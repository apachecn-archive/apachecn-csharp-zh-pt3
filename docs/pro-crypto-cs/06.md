# 六、安全编程指南

## 介绍

当软件应用有漏洞时，对应用开发者来说意味着高成本。一些组织为每个安全事件支付超过 50 万美元。用于消除软件应用中的漏洞的工作应该集中在安全编程上，避免在生产阶段部署任何漏洞。

编写安全的源代码是一项艰巨的任务。理解正在编写的代码的含义并有一个需要检查的东西的清单是非常重要的。该清单将帮助开发人员针对众所周知的安全问题快速验证他们的代码。通常，验证是由安全团队完成的，而不是软件开发人员或工程师。软件开发人员不能客观地对待他们自己的代码。

清单的想法应该从以下想法开始:验证将处理其域外数据的源代码，并考虑用户输入、网络通信、二进制文件的处理、从数据库管理系统或服务器接收输出等等。

当我们使用一个软件应用时(不管这个应用是桌面应用、web 应用还是移动应用)，认为这个应用是安全的，因为它是由一个知名公司开发的，这只是一个神话。不要相信这种想法。依赖这种想法的公司最终会在安全事故、维护、咨询和审计会议上花费大量的预算。

软件应用有两种工作环境，在每种环境中它的行为是不同的。在一个公司中处于分析和开发过程中的软件应用代表了它的信任圈(至少，大多数公司都是这样想的，并且他们乐于认为他们的基础设施非常能够抵御安全攻击)。软件应用在信任圈中的行为代表了开发和测试应用的最关键环境。没有一个开发人员、IT 安全官员或软件分析师会黑掉自己的代码。为此，一些公司，如微软，曾经有软件开发测试工程师(sdet)，他们的任务是破解或试图破解由软件开发工程师(SDE)编写的代码。这个环境是舒适的。一旦应用离开舒适区，进入真实环境，问题就开始出现了。信任边界很难同时也很容易被划定，并且在舒适区和真实区之间创建一个界限。这不是一项容易完成的任务，尤其是如果这些应用运行在虚拟化基础架构、云或大数据环境中。

在舒适区中，恶意的最终用户代表安全威胁。恶意终端用户将攻击软件应用的机密性和/或完整性。其中一个有趣的方法和概念是*软件混淆* *。*

## 安全编程清单

在本节中，我们将讨论并提出一个安全的编码清单(也可以将其视为一个过程)。表 [6-1](#Tab1) 显示了这种清单的一个例子，它可以根据你的需要进行开发。该清单包含了用 C# 编写代码时可以检查的项目的最小示例，无论它是在 Windows 还是 Linux 操作系统上。开发人员经常使用的一种做法是隐藏警告，这是没有好处的。

表 6-1

安全编程清单示例

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"> <col class="tcol5 align-left"></colgroup> 
| 

编号#

 | 

要检查的项目

 | 

描述

 | 

是/否

 | 

笔记

 |
| --- | --- | --- | --- | --- |
| one | ***编译器警告*** |   |   |
| 确保 GCC 编译器将输出，并为接收针对下列项目列出的潜在错误的通知设置了一个标志。对于更多的标志及其定义和操作，建议遵循编译器选项来请求或抑制警告部分[ [1](#Par38) ]。如果要实现复杂的加密算法和安全方案，这将非常有用。 |   |   |
| Two | ***处理字符串时分配足够的内存作为缓冲内存。**T3】* |   |   |
| 检查以下函数，查看当复制过程完成直到满足 NULL 时，目标缓冲区是否有上限。为了避免这种情况，建议在将数据复制到目标缓冲区之前，为其分配足够的内存空间。 |   |   |
| three | ***检查系统安全的直接破坏。**T3】* |   |   |
| 检查不可信的输入会直接破坏应用的安全性。通过这一步，您将保护应用免受恶意用户和攻击者使用元字符试图利用程序的攻击。 |   |   |
| four | ***检查参数大小是否错误并得到意外结果。**T3】* |   |   |
| 当编写复杂的程序时，比如第 2 章 [2](02.html) 中清单 2-9 中 SHA-256 的实现，给一个参数分配错误的大小或者进行错误的算术运算会导致严重的缺陷，应该立即提供修复。确保在目标端为参数分配的大小相同。作为最佳实践，尤其是在实现加密算法时，最好使用类型的返回大小。保持类型安全，不要造成溢出。 |   |   |
| five | 检查是否分配了过多的内存。 |   |   |
| 分配过多的内存和外部参数代表了一定部分的大小。这意味着处理一个错误的内存分配，你将经历*拒绝服务*的结果。为了避免这种情况发生，最好遵循以下标准。 |   |   |
| six | ***避免投错。**T3】* |   |   |
| 避免像下面这样编码。编译器会认为内存分配会返回一个`int`，这是完全不正确的。它会产生一个漏洞，很容易被黑客利用。 |   |   |
| seven | ***避免变量参数表。**T3】* |   |   |
| 当您实现基于字符串的安全方案时，您可能会遇到一种新类型的问题，安全分析师或有道德的黑客在执行测试时喜欢玩这种问题。有道德的黑客通常用来检查不可信数据的一个简单测试是检查函数是否允许变量作为参数或自变量的列表，如`Console.WriteLine()`或`MessageBox.Show()`。不可信数据(由有道德的黑客创建)直接用作字符串格式，而不是参数。对于任何类似的情况，请遵循以下逻辑。 |   |   |
| eight | ***同文件操作*** |   |   |
| 在加密操作期间处理文件时，使用`mkstemp().` |   |   |
| nine | ***文件权限*** |   |   |
| 不是每个人都有能力读写文件。为了避免给文件分配错误的权限，要养成使用`FileIOPermission`类的习惯。 |   |   |
| Ten | **避免使用代码访问安全(CAS)** |   |   |
| CAS 使用主程序运行过程中可以利用的资源。这种资源的例子是 XML 文件、数据库、图像、设置和配置文件等。因为不建议使用 CAS，所以它在中不受支持。网芯， .NET 5 或更高版本。一般来说，高于 7.0 的 C# 版本不支持 CAS。 |   |   |
| Eleven | 避免使用部分可信的代码。 |   |   |
| 这些程序集代表了应用中的一个脆弱点，它们很容易被利用和覆盖，以便访问函数和方法的核心以及主代码。 |   |   |
| Twelve | *避免使用* `AllowPartiallyTrustedCaller` *属性。* |   |   |
| 从……开始 .NET Framework 4 中，新的安全规则影响了`AllowPartiallyTrustedCallersAttribute`属性的行为。从……开始 .NET Core，不再支持部分受信任的代码。建议使用. NET 4 库，并坚持使用 .NET 4 安全模型，并在需要的地方使用适当的`SecurityCritical, SecuritySafeCritical`和`Security Transparent`属性。 |   |   |
| Thirteen | *避免使用 .NET 远程处理。* |   |   |
|  .NET Remoting 是一种技术，它使得一个被称为*远程对象*的对象可以跨不同的远程边界使用，这些边界基于不同的应用域(AppDomain)、进程或在网络内或通过网络连接的不同计算机。由于这一事实，进程或计算机(网络)可被利用，对象(远程对象)可被覆盖，以便恶意访问应用和应用的资源。这种情况出现在[ [21](#Par58) ]中。 |   |   |
| *14* | 避免使用 DCOM(分布式组件对象模型)。 |   |   |
| DCOM 代表一种编程结构，它允许计算机通过网络在另一台计算机上执行程序，就像程序在本地运行一样。通过中间人攻击，攻击者可以控制通信信道，并攻击应用与其计算机之间的通信。 |   |   |
| *15* | 避免使用二进制格式化程序。 |   |   |
| `BinaryFormatter`类型从 .NET Framework 是非常危险的，在数据处理完成时不推荐使用。应用应该立即停止使用`BinaryFormatter`，即使开发人员认为他们正在处理的数据是可信的。的确，`BinaryFormatter`是不安全的，但某些方面可以变得安全。不过还是建议完全避免[ [20](#Par57) ]。 |   |   |

在后面的部分中，我们将讨论应用于加密算法开发过程的最重要的规则。每条规则在指南中都有很好的解释。

## 证书编码标准

CERT 编码标准只为 ISO/IEC 14882-2014 标准定义的 C++编程语言版本开发，但是一些编码标准可以成功地用于其他编程语言，如 C#、Java 或 Python。

编码标准组织得非常好，它遵循以下结构:标识符、不符合的代码示例和符合的解决方案、异常、风险评估、自动检测、相关漏洞和相关指南[ [7](#Par44) ]。

在接下来的部分中，我们将检查结构的每一项，并解释主要目标和目的。

### 标识符

每个标识符有三个部分:

*   三个字母的助记符，表示标准中的部分。

*   介于 00 和 99 之间的两位数字的数值。

*   与之关联的语言，用后缀(-CPP，-C，-J，-PL)表示。
    *   –CPP:SEI CERT c# 编码标准[ [7](#Par44)

    *   –C:SEI CERT C 编码标准[ [8](#Par45)

    *   –J:SEI CERT Oracle Java 编码标准[ [9](#Par46) ]

    *   –PL:SEI CERT Perl 编码标准[ [10](#Par47) ]

三个字母的助记符用于对相关编码实践进行分组，并指出相关编码属于哪个类别。

### 不兼容的代码示例和兼容的解决方案

不合规代码的例子显示了违反准则的代码。记住这些只是例子，这一点非常重要。示例中所有外观的移除过程并不意味着我们正在分析的代码符合 SEI CERT 标准。

### 规则的例外

例外具有信息性，不要求遵循。任何规则都可以有一组例外情况，这些例外情况详细说明了在哪些情况下不必遵循指南来确保软件的安全性、可靠性。

与任何类型的异常一样，编程语言并不重要，原理是一样的。有必要格外注意异常，捕捉任何可能的异常，并从中吸取教训。不要忽视他们。不要认为一种编程语言是完美的，它没有任何漏洞或某些可被利用的门。

### 风险评估

对于 CERT C++编码标准中的每个指南，都有一个指定的风险评估部分。风险评估部分的目的是向软件开发人员提供不遵守或不处理特定规则或建议的潜在后果。风险评估看起来像一个指标，其主要目的是帮助软件应用和复杂项目的补救过程。

每个规则和建议都有一个*优先级。*为了分配一个优先级，建议了解一下 IEC 60812 [ [11](#Par48) ]。使用一个以三种分析类型为特征的指标来评估和分配优先级:故障模式、影响和关键程度。每个规则还将有一个值，该值被分配在 1 到 3 之间，例如严重性、可能性和补救成本(参见表 [6-2](#Tab2) )。

表 6-2

为每个规则[ [7](#Par44) ]赋值

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"> <col class="tcol4 align-left"></colgroup> 
| 

严重性–如果忽略该规则，会有什么后果？

 |
| --- |
| 

价值

 | 

意义

 | 

不同漏洞的示例

 |
| --- | --- | --- |
| one | 低的 | 拒绝服务攻击，意外终止 |
| Two | 中等 | 违反数据完整性，无意泄露信息 |
| three | 高的 | 运行随机代码 |
| **可能性–**从统计角度来说，通过避免和忽略规则规范而在代码中引入缺陷，从而导致可能被恶意用户利用的漏洞的可能性有多大？ |
| **值** | **定义** |
| one | 不太可能的 |
| Two | 很可能的事 |
| three | 可能的 |
| **补救成本–**遵守规则的成本是多少？ |
| **值** | **定义** | **检测** | **校正** |
| one | 高的 | 指南 | 指南 |
| Two | 中等 | 自动的 | 指南 |
| three | 低的 | 自动的 | 自动的 |

对于每条规则，这些值会相乘。表 [6-3](#Tab3) 中的指标为您提供了一种方法，可用于确定应用中规则的优先级。值从 1 到 27。在所有 27 个值中，只有 10 个不同的值出现，并且在大多数情况下是可用的:1、2、3、4、6、8、9、12、18 和 27。表 [6-3](#Tab3) 显示了优先级和级别的可能解释和含义。

表 6-3

级别和优先级[ [7](#Par44)

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

水平

 | 

优先

 | 

可能的解释

 |
| --- | --- | --- |
| 腰神经 2 | 12, 18, 27 | 严重程度高，可能修复成本低 |
| L2 | 6, 8, 9 | 中等严重性，便携式，中等修复成本 |
| L3 | 1, 2, 3, 4 | 严重性低，不太可能，维修费用高 |

### 自动检测

规则和建议包含描述自动检测过程的部分。上述部分提供了多套工具，可用作自动诊断违规的分析器。安全编程验证套件[ [12](#Par49) ]可用于测试分析仪提供违反 ISO/IEC TS 17961:2013[[14](#Par51)]规定的规则的诊断信息的能力，这与 SEI CERT C 编码标准[ [13](#Par50) ]的规则相关。

### 相关指南

根据标准，当开发软件应用时，这个部分有一个特殊的槽。它还包含链接、技术规范和指南集，如*“信息技术-编程语言、其环境和系统软件接口-C 安全编程规则[*[14](#Par51)*”；信息技术-编程语言-通过语言选择和使用避免编程语言漏洞的指南[*[15](#Par52)*]；MISRA C# 2008:在关键系统中使用 C# 语言的指南[*[16](#Par53)*]；*和 *CWE IDs 在米特里的常见弱点枚举(CWE) [* [17](#Par54) *]”*[18](#Par55)

## 规则

在接下来的几节中，我们将给出一个主要规则的简要概述，这些规则非常适用于使用 C# 实现加密算法和安全方案。尤其是有了新版本的 it，最好了解以下规则。请注意，我们将只研究 10 条规则中的 6 条。指南[ [19](#Par56) ]中提供了所有解释和示例。

对于某些规则，也有一些来自 C 编程语言的规则适用于 C#。以下规则可用于表 [6-1](#Tab1) 中说明的程序。

任何信息安全官、安全分析师、道德黑客等的职责。就是通过设计这样一个清单来改进代码。此外，开发人员在开发关键的加密算法时，也可以使用该清单作为指南。建议对算法中非常脆弱的部分进行代码审查，并确保尽可能遵守规则(规则 01、规则 02、规则 03、规则 05、规则 06 和规则 07)。

遵循这些规则将使您作为安全分析师或有道德的黑客对安全机制(加密算法、安全协议、安全方案和其他加密原语)的正确实施以及常见漏洞的消除有一定程度的信任。参见表 [6-4](#Tab4) 至 [6-9](#Tab9) 。

表 6-9

规则 07–输入/输出[ [19](#Par56)

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

规则

 | 

在 C# 中应用

 | 

标题

 |
| --- | --- | --- |
| 导线 50-CPP | Y | 在没有插入定位调用的情况下，不要交替输入和输出文件流。 |
| 导线 51-CPP | Y | 不再需要文件时将其关闭。 |
| 电线 30-C | Y | 从格式字符串中排除用户输入。 |
| 32-C 导线 | Y | 不要在仅适用于文件的设备上执行操作。 |
| 34-C 导线 | Y | 区分从文件中读取的字符和 EOF 或 WEOF。 |
| 线 38-C | 普通 | 不要复制文件对象。 |
| 电线 39-C | Y | 在没有插入刷新或定位调用的情况下，不要从流中交替输入和输出。 |
| 42-C 导线 | Y | 不再需要文件时将其关闭。 |
| 电线 44-C | 普通 | 仅使用从`fgetpos()`返回的`fsetpos()`值。 |
| 导线 45-C | 普通 | 访问文件时避免 TOCTOU 竞争条件。 |
| 导线 46-C | Y | 不要访问关闭的文件。 |
| 导线 47-C | Y | 使用有效的格式字符串。 |

表 6-8

规则 06–内存管理[ [19](#Par56)

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

规则

 | 

在 C# 中应用

 | 

标题

 |
| --- | --- | --- |
| MEM50-CPP | Y | 不要访问释放的内存。 |
| MEM51-CPP | Y | 正确释放动态分配的资源。 |
| MEM52-CPP | Y | 检测和处理内存分配错误。 |
| MEM53-CPP | Y | 手动管理对象生存期时，显式构造和析构对象。 |
| MEM54-CPP | Y | 为新的放置提供正确对齐的指针，以提供足够的存储容量。 |
| MEM55-CPP | Y | 遵守替换动态存储管理要求。 |
| MEM56-CPP | Y | 不要将已经拥有的指针值存储在不相关的智能指针中。 |
| MEM57-CPP | Y | 避免对过度对齐的类型使用默认运算符`new`。 |
| MEM30-C | Y | 不要访问释放的内存。 |
| MEM31-C | Y | 不再需要时释放动态分配的内存。 |
| MEM34-C | Y | 仅动态分配空闲内存。 |
| MEM35-C | Y | 为对象分配足够的内存。 |
| MEM36-C | 普通 | 不要通过调用`realloc()`来修改对象的对齐。 |

表 6-7

规则 05–字符和字符串[ [19](#Par56)

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

规则

 | 

在 C# 中应用

 | 

标题

 |
| --- | --- | --- |
| STR50-CPP | Y | 确保字符串存储有足够的空间来存储字符数据和空终止符。 |
| STR52-CPP | 普通 | 使用有效的引用、指针和迭代器来引用`basic_string`的元素。 |
| STR53-CPP | Y | 范围检查元素访问。 |
| STR30-C | Y | 不要试图修改字符串文字。 |
| STR31-C | Y | 确保字符串存储有足够的空间来存储字符数据和空终止符。 |
| STR32-C | Y | 不要将非空字符序列传递给需要字符串的库函数。 |
| STR34-C | Y | 在转换为更大的整数之前，将字符转换为无符号字符。 |
| STR37-C | Y | 字符处理函数的参数必须可以表示为无符号字符。 |
| STR38-C | Y | 不要混淆窄和宽的字符串和函数。 |

表 6-6

规则 03–整数[ [19](#Par56)

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

规则

 | 

在 C# 中应用

 | 

标题

 |
| --- | --- | --- |
| INT50-CPP | Y | 不要强制转换为超出范围的枚举值。 |
| INT30-C | Y | 确保无符号整数运算不换行。 |
| INT31-C | Y | 确保整数转换不会导致数据丢失或被误解。 |
| INT32-C | Y | 确保对有符号整数的操作不会导致溢出。 |
| INT33-C | Y | 确保除法和余数运算不会导致被零除的错误。 |
| INT34-C | Y | 不要将表达式移位负数位数或大于或等于操作数中存在的位数。 |
| INT35-C | Y | 不要用不匹配的语言链接调用函数。 |

表 6-5

规则 02–表达式[ [19](#Par56)

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

规则

 | 

在 C# 中应用

 | 

标题

 |
| --- | --- | --- |
| EXP50-CPP | Y | 不要依赖于副作用的评估顺序。 |
| EXP51-CPP | Y | 不要通过不正确类型的指针删除数组。 |
| EXP52-CPP | Y | 不要依赖未赋值操作数的副作用。 |
| EXP53-CPP | Y | 不要读取未初始化的内存。 |
| EXP54-CPP | Y | 不要访问超出其生存期的对象。 |
| EXP56-CPP | Y | 不要用不匹配的语言链接调用函数。 |
| EXP57-CPP | Y | 不要强制转换或删除指向不完整类的指针。 |
| EXP60-CPP | Y | 不要跨越执行边界传递非标准布局类型的对象。 |
| EXP61-CPP | Y | lambda 对象不能比它的任何引用捕获对象活得长。 |
| EXP62-CPP | Y | 不要访问对象表示中不属于对象值表示的位。 |
| EXP63-CPP | Y | 不要依赖移出对象的值。 |

表 6-4

规则 01–声明和初始化[ [19](#Par56)

<colgroup><col class="tcol1 align-left"> <col class="tcol2 align-left"> <col class="tcol3 align-left"></colgroup> 
| 

规则

 | 

在 C# 中应用

 | 

标题

 |
| --- | --- | --- |
| DCL51-CPP | Y | 不要声明或定义保留标识符。 |
| DCL52-CPP | Y | 永远不要用 const 或 volatile 限定引用类型。 |
| DCL53-CPP | Y | 不要写语法不明确的声明。 |
| DCL54-CPP | Y | 重载分配和解除分配在同一范围内成对运行。 |
| DCL55-CPP | Y | 在跨越信任边界传递类对象时避免信息泄漏。 |
| DCL56-CPP | Y | 避免静态对象初始化期间的循环。 |
| DCL57-CPP | Y | 不要让异常从析构函数或释放函数中逃脱。 |
| DCL58-CPP | Y | 不要修改标准名称空间。 |
| DCL59-CPP | Y | 不要在头文件中定义未命名的命名空间。 |
| DCL60-CPP | Y | 遵守一个定义规则。 |
| DCL30-C | Y | 声明具有适当存储期限的对象。 |
| DCL39-C | Y | 在跨信任边界传递结构时避免信息泄漏。 |
| DCL40-C | Y | 不要创建同一函数或对象的不兼容声明。 |

### 规则 01。声明和初始化(DCL)

### 规则 02。表达式(表达式)

### 规则 03。整数(INT)

### 规则 05。字符和字符串(STR)

### 规则 06。内存管理(MEM)

### 规则 07。输入/输出

## 结论

在本章中，你学习了*规则*和*建议*。您踏上了在开发加密算法和安全方案的过程中需要考虑的最重要的安全方面的旅程。

理解*规则*和*建议*之间的区别非常重要。一般的想法是，与建议相比，规则必须遵循特定数量的标准，而建议代表了改进代码质量的建议。

你已经获得了大量的知识。在本章结束时，您现在能够执行源代码的安全性分析，创建安全的编码清单，筛选对您的应用至关重要的方面，并指导开发人员在实现加密算法和编写相关源代码时如何进行。

## 文献学

1.  请求或禁止警告的 GCC 选项。网上有: [`https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html#Warning-Options`](https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html%2523Warning-Options) 。

2.  HXprox_*，libHX–把事情做好。网上有: [`http://libhx.sourceforge.net/`](http://libhx.sourceforge.net/) 。

3.  [ISO/IEC TR 24772:2013] ISO/IEC。*信息技术——编程语言——通过语言选择和使用避免编程语言漏洞的指南*。TR 24772-2013。ISO。2013 年 3 月。

4.  [ISO/IEC TS 17961:2012]ISO/IEC TS 17961。*信息技术——编程语言及其环境和系统软件接口——C 安全编程规则*。ISO。2012.

5.  [ISO/IEC 14882-2014]ISO/IEC 14882-2014。*编程语言— C#，第四版。* 2014 年。

6.  鲍尔曼，2016 年。 *SEI CERT C# 编码标准(2016 版)* 435。

7.  SEI CERT C# 编码标准:网上有:[`https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046682`](https://wiki.sei.cmu.edu/confluence/pages/viewpage.action%253FpageId%253D88046682)(4 . 9 . 20 访问)。

8.  编码标准。在线可用:[`https://wiki.sei.cmu.edu/confluence/display/c`](https://wiki.sei.cmu.edu/confluence/display/c)(4 . 9 . 20 访问)。

9.  Oracle Java 编码标准。在线可用:[`https://wiki.sei.cmu.edu/confluence/display/java`](https://wiki.sei.cmu.edu/confluence/display/java)(4 . 9 . 20 访问)。

10.  CERT Perl 编码标准。在线可用:[`https://wiki.sei.cmu.edu/confluence/display/perl`](https://wiki.sei.cmu.edu/confluence/display/perl)(4 . 9 . 20 访问)。

11.  [IEC 60812 2006]国际电工委员会。*系统可靠性分析技术——故障模式和影响分析程序(FMEA)* ，第二版。(IEC 60812)。瑞士日内瓦:国际电工委员会，2006 年。

12.  安全编程验证套件。网上有: [`https://github.com/SEI-CERT/scvs`](https://github.com/SEI-CERT/scvs) 。

13.  SEI CERT C 编码标准:*开发安全、可靠、可靠系统的规则(2016 版)*，n.d. 534。

14.  [ISO/IEC TS 17961:2012]ISO/IEC TS 17961。*信息技术——编程语言及其环境和系统软件接口——C 安全编程规则*。ISO。2012.

15.  [ISO/IEC TR 24772:2013] ISO/IEC。*信息技术——编程语言——通过语言选择和使用避免编程语言漏洞的指南*。TR 24772-2013。ISO。2013 年 3 月。

16.  [米斯拉 2008]米斯拉有限公司。 *MISRA C# 2008 在关键系统中使用 C# 语言的指南*。ISBN 978-906400-03-3(平装本)；ISBN 978-906400-04-0 (PDF)。2008 年 6 月。

17.  斜接。*常见弱点列举，1.8 版*。2010 年 2 月。网上有: [`http://cwe.mitre.org/`](http://cwe.mitre.org/) 。

18.  "这个编码标准是如何组织的."网上有: [`https://wiki.sei.cmu.edu/confluence/display/cplusplus/How+this+Coding+Standard+Is+Organized`](https://wiki.sei.cmu.edu/confluence/display/cplusplus/How+this+Coding+Standard+Is+Organized) 。

19.  “规则。”网上有: [`https://wiki.sei.cmu.edu/confluence/pages/viewpage.action?pageId=88046322`](https://wiki.sei.cmu.edu/confluence/pages/viewpage.action%253FpageId%253D88046322) 。

20.  BinaryFormatter 类。网上有: [`https://docs.microsoft.com/en-us/dotnet/standard/serialization/binaryformatter-security-guide`](https://docs.microsoft.com/en-us/dotnet/standard/serialization/binaryformatter-security-guide) 。

21.  “寻找和开发 .NET Remoting over HTTP，使用反序列化。网上有: [`www.nccgroup.com/uk/about-us/newsroom-and-events/blogs/2019/march/finding-and-exploiting-.net-remoting-over-http-using-deserialisation/`](http://www.nccgroup.com/uk/about-us/newsroom-and-events/blogs/2019/march/finding-and-exploiting-.net-remoting-over-http-using-deserialisation/) 。