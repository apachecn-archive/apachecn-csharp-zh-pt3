# 三十、常见问题解答

本章是本书所有章节的“问答”部分的子集。这些问题中有许多没有在具体的章节中讨论，因为相关的模式还没有涉及到。除了下面的问答，我强烈推荐你浏览本书的所有“问答”部分，以便更好地理解这些模式。

**30.1 你最喜欢哪个** **的设计模式** **？**

这取决于许多因素，如背景、情况、需求、制约因素等等。如果你知道所有的模式，你会有更多的选择。

30.2 开发人员为什么要使用设计模式？

一个常见的答案是，它们是现实软件开发中重复出现的软件设计问题的可重用解决方案。但是我之前提到过(比如在第 [28 章](28.html)的问答环节)，你需要分析各方面的情况，比如在你实现一个模式之前，问题的上下文和意图。

30.3 命令模式和纪念模式有什么区别？

命令模式存储所有的动作，但是记忆模式只在请求时保存状态。此外，命令模式可以支持每个动作的撤销操作，但是 Memento 模式不需要这样。我强烈建议你访问第 [19 章](19.html)的问答 19.4，清楚地了解其中的区别。

**30.4 门面模式和建造者模式有什么区别？**

Facade 模式旨在使代码的特定部分更易于使用。它从开发者那里抽象出细节。

构建器模式将对象的构造与其表示分离开来。在第 [3](03.html) 章中，导演调用了同样的方法，`Construct() in`演示 1 和`ConstructCar()`演示 2，来创造不同类型的车辆。换句话说，您可以使用相同的构造过程来创建多种类型。

**30.5 构建者模式和策略模式有什么区别？它们有相似的 UML 表示。**

首先，你必须检查意图。构建者模式属于创造模式的范畴，而策略模式属于行为模式的范畴。他们关注的领域不同。当你考虑构建器模式时，你可以使用相同的构建过程来创建不同的类型，当你使用策略模式时，你可以在运行时自由选择算法。

**30.6 命令模式和** **解释器模式** **有什么区别？**

在命令模式中，命令是对象。在解释器模式中，命令是句子。在解释器模式中，您可以制定自己的评估规则并构建语法树。对于一个简单的语法来说，这很好，但是当你的语法很复杂的时候，就很难实现了。这是因为建立一个解释器的成本对你来说是一个大问题。

**30.7 责任链模式和观察者模式有什么区别？**

对于 Observer 模式，所有注册用户都被并行通知或收到请求(主题的更改)。对于责任链模式，您可能不会到达链的末端，因此所有用户不需要处理相同的场景。位于链开始的某个用户可以更早地处理请求。建议你参考问答 14.4。

30.8 责任链模式和装饰者模式的区别是什么？

它们一点也不一样，但你可能认为它们的结构相似。像 FAQ 30.7 一样，在责任链模式中，通常只有一个类处理一个请求，但是在装饰模式中，所有的类都处理一个请求。您必须记住，装饰器只在添加和删除责任的上下文中有效。如果您可以将装饰模式与单一责任原则结合起来，那么您就可以在运行时添加(或删除)单一责任。

**30.9****调停者模式** **和** **观察者模式** **有什么区别？**

GoF 说，“这是相互竞争的模式。它们之间的区别在于，观察者通过引入观察者和主体对象来分发通信，而中介对象封装了其他对象之间的通信。”

这里我建议你考虑一下第 21 章中的中介模式的例子。在演示 2 中，我解释了如果发送者在线，他可以接收发送给目标接收者的消息。我描述了如何限制一个局外人并提高安全性。但是在观察者模式中，主体/广播者通常不关心其观察者的状态。它只是广播消息。

GoF 的书告诉我们，在制作可重用的观察者和主体时，你可能比制作可重用的中介者面临更少的挑战，但是关于交流的流程，中介者比观察者得分更高。

**30.10****单胎班** **和** **静态班** **你更喜欢哪个？**

看情况。首先，您可以创建单例类的对象，这对于静态类是不可能的。因此，继承和多态的概念可以用单例类来实现。此外，一些开发人员认为在现实世界的应用中模仿静态类(例如，考虑单元测试场景)是具有挑战性的。

**30.11 如何区分** **代理** **和** **适配器** **？**

代理在与它们的主体相似的接口上工作。适配器在不同的接口上工作(对于它们所适配的对象)。

代理和装饰者有什么不同？

有不同类型的代理，它们因实现而异。因此，这些实现中的一些可能接近装饰者。例如，保护代理可以像装饰器一样实现。但是你必须记住，装饰者专注于增加责任，而代理者专注于控制对对象的访问。

30.13 中介与门面有何不同？

总的来说，两者都简化了复杂的系统。在中介模式中，中介和内部子系统之间存在双向连接。相反，在 Facade 模式中，您通常提供单向连接(子系统不知道 Facade)。

30.14 享元模式和国家模式之间有什么联系吗？

GoF 书提到 Flyweight 模式可以帮助您决定何时以及如何共享状态对象。

**30.15****简单工厂** **、** **工厂方法** **、** **抽象工厂设计模式** **有什么相似之处？**

所有这些都封装了对象创建，这意味着您要对抽象(接口)而不是具体的类进行编码。简单地说，每个工厂都通过减少对具体类的依赖来促进松散耦合。

简单工厂、工厂方法和抽象工厂设计模式之间有什么区别？

这是你在各种工作面试中可能会面临的一个重要问题。首先参考第 [5](05.html) 章中的问答 5.3，如果需要，遍历第 [4](04.html) 和 [5](05.html) 章中的所有问答环节。

如何区分****和** **工厂方法模式** **？****

 **单例模式确保您每次都能获得一个唯一的实例。它还限制创建其他实例。

但是工厂方法模式并没有说你只能得到一个唯一的实例。通常，这种模式会根据您的需要创建任意多的实例，并且这些实例不一定是唯一的。这些新类型化的实例可以实现一个公共基类。(请记住，根据 GoF 定义，工厂方法让一个类将实例化推迟到子类。)

**30.18****模板方法模式** **与策略模式有何不同？**

在策略模式中，您可以使用委托来改变整个算法。另一方面，使用 Template Method 模式，您只改变了使用继承的算法中的某些步骤，但是算法的整体流程是不变的。

**30.19 如何区分** **访客模式** **和策略模式？**

在策略模式中，每个子类使用不同的算法来解决一个共同的问题。但是在访问者设计模式中，每个访问者子类可以提供彼此不同的功能。

30.20 空对象和代理有什么不同？

一般来说，代理在某个时间点作用于真实对象，它们也可能提供一些行为。但是空对象不做任何这样的操作。

如何区分解释者模式和访问者模式？

使用解释器模式，您可以将简单的语法表示为一个对象结构，但是在访问者模式中，您可以定义一些想要在对象结构上使用的特定操作。除此之外，解释器可以直接访问所需的属性，但是在访问者模式中，您需要特殊的功能(类似于观察者)来访问它们。

**30.22 如何区分** **Flyweight 模式** **和** **对象池模式** **？**

我没有在本书中讨论对象池模式。但是如果你已经知道对象池模式，你会注意到在 Flyweight 模式中，flyweights 可以有内部和外部状态。因此，如果一个 flyweight 有两种状态，那么它的状态是分开的，客户端需要将一部分状态传递给它。此外，通常，客户端不会更改固有状态，因为它是共享的。

对象池不存储外部状态的任何部分；所有状态信息都存储/封装在池化对象中。此外，客户端可以更改池化对象的状态。

30.23 库或框架与设计模式有何相似和不同之处？

它们不是设计模式。它们提供了可以直接在应用中使用的实现。但是他们可以在那些实现中使用模式的概念。

**30.24 什么是** **回调法** **？**

它是一种在您执行一些特定操作后可以调用的方法。您将经常在异步编程中看到这种方法的使用，当您不知道前一个操作的确切完成时间，但希望在前一个任务结束后开始某个特定任务时，这种方法会很有用。你应该参考第 27 章中的演示 7 来更好地理解它。**