# 十七、附录一：基本编程概念

以下信息是为编程新手和需要一些基本编程概念入门的读者准备的。如果您已经用另一种语言编程，那么本附录中的概念对您来说可能并不陌生。但是，您应该简要地回顾一下这些资料，以便熟悉 C# 语法。

使用变量和数据类型

编程语言中的变量存储的值可以在程序执行时改变。例如，如果您想计算用户尝试登录应用的次数，您可以使用一个变量来跟踪尝试次数。变量是存储值的内存位置。使用该变量，您的程序可以读取或更改存储在内存中的值。但是，在程序中使用变量之前，必须声明它。当你声明一个变量时，编译器也需要知道什么样的数据将被存储在内存位置。比如会是数字还是字母？如果变量将存储数字，那么一个数字可以有多大？变量是存储小数还是只存储整数？您可以通过给变量分配一个 数据类型来回答这些问题。例如，登录计数器只需要保存正整数。下面的代码演示了如何在 C# 中用整数数据类型声明名为`counter`的变量:

```cs
int counter;
```

指定数据类型被称为 *强类型*。强类型导致更有效的内存管理、更快的执行和编译器类型检查，所有这些都减少了运行时错误。运行时错误是程序运行时可能发生的错误，在您构建应用时，编译器不会捕捉到这些错误。例如，由于在计算中使用了错误的数据类型，可能会出现不正确的舍入。

一旦声明了变量，就需要在单独的语句中或者在声明语句本身中给它赋一个初始值。例如，下面的代码:

```cs
int counter = 1;
```

相当于这样:

```cs
int counter;
counter = 1;
```

了解基本数据类型

C# 支持基本数据类型，如数字、字符和日期类型。

整数数据类型

整数数据类型仅表示整数。[表 A-1](#Tab1) 总结了 C# 中使用的整型数据类型。

[表 A-1](#_Tab1) 整数数据类型

| **数据类型** | **存储大小** | **取值范围** |
| --- | --- | --- |
| `Byte`T3】 | 8 位 | 0 到 255 |
| `Short`T3】 | 16 位 | –32768 到 32767 |
| `Integer`T3】 | 32 位 | –2147483648 至 2147483647 |
| `Long`T3】 | 64 位 | -9，223，372，036，854，775，808 至 9，223，372，036，854，775，807 |

显然，在为变量选择数据类型时，内存大小很重要。一个不太明显的考虑是编译器处理数据类型的容易程度。编译器对整数 执行算术运算比其他类型更有效。通常，最好使用整数作为计数器变量，即使一个字节 或短类型可以轻松管理达到的最大值。

非整数数据类型

如果变量将存储包含小数部分 的数字，那么您必须使用非整数数据类型。C# 支持[表 A-2](#Tab2) 中列出的非整数数据类型。

[表 A-2。](#_Tab2)非整数数据类型

| **数据类型** | **存储大小** | **取值范围** |
| --- | --- | --- |
| `Single`T3】 | 32 位 | 负值为–3.4028235 e+38 到–1.401298 e–45；正值为 1.401298 e–45 到 3.4028235E+38 |
| `Double`T3】 | 64 位 | 1.79769313486231570E+308 到–4.94065645841246544 e–324 为负值；正值为 4.94065645841246544 e–324 到 1.79769313486231570E+308 |
| `Decimal`T3】 | 128 位 | 0 到+/-79，228，162，514，264，337，593，543，950，335，不带小数点；0 到+/-7.9228162514264337593543950335，小数点右边有 28 位 |

与单个 或双 数据类型相比，十进制数据类型包含更多的有效数字，并且不受舍入误差的影响。十进制数据类型通常用于需要更高精度的金融或科学计算。

字符数据类型

字符数据类型用于保存人类语言中使用的字符的变量。例如，字符数据类型保存字母(如“a”)或用于显示和打印的数字(如“2 个苹果”)C# 中的字符数据类型是基于 Unicode 的，Unicode 定义了一个字符集，可以表示从英语到阿拉伯语和中文普通话等各种语言中的字符。C# 支持两种字符数据类型:`char`和`string`。`char`数据类型保存单个(16 位)Unicode 字符值，如`a`或`B`。字符串数据类型包含一系列 Unicode 字符。它的范围从 0 到大约 20 亿个字符。

布尔数据类型

布尔数据类型包含一个 16 位值，该值被解释为 true 或 false。它用于只能是两个值之一的变量，例如是或否，或开或关。

日期数据类型

日期以 64 位整数保存，其中每个增量代表从公历开始(1/1/0001 12:00`a.m`)经过的一段时间。).

对象数据类型

object 数据类型是一个 32 位地址，指向另一种数据类型的内存位置。当变量引用的实际数据类型直到运行时才能确定时，通常使用它来声明变量。尽管 object 数据类型可以是引用其他数据类型的总称，但就性能而言，它是最低效的数据类型，除非绝对必要，否则应该避免使用。

可空的 类型

默认情况下，不能为布尔值、整数和 double 数据类型等值类型分配空值。当从数据结构中检索数据时，比如一个允许空值的数据库，这可能会成为问题。当声明一个可能被赋值为 null 的值类型变量时，通过将问号(？)在类型名之后，像这样:

```cs
double salary = null; // Not allowed.
double? salary = null; // allowed.
```

介绍复合 数据类型

组合基本数据类型可以创建复合数据类型。结构、数组和类是复合数据类型的例子。

构筑物

当您想要组织和处理不需要类方法和构造函数开销的信息时，结构数据类型非常有用。它非常适合表示轻量级对象，如点或矩形的坐标。structure 类型的单个变量可以存储这样的信息。你用关键字`struct`声明一个结构。例如，下面的代码创建了一个名为`Point`的结构来存储二维表面中点的坐标:

```cs
public struct Point
{
  public int _x, _y;

  public Point(int x, int y)
  {
  _x = x;
  _y = y;
  }
}
```

一旦定义了结构，就可以声明结构类型的变量并创建该类型的新实例，如下所示:

```cs
Point p1 = new Point(10,20);
```

数组

数组通常用于组织和处理相同数据类型的组；例如，您可能需要处理一组名称，因此您可以通过在变量名后紧跟方括号(`[]`)来声明数组数据类型，如下所示:

```cs
string[] name;
```

`new`操作符用于创建数组，并将其元素初始化为默认值。因为数组的元素由从零开始的索引引用，所以下面的数组包含五个元素:

```cs
string[] name = new string[4];
```

要在声明数组时初始化数组元素，可以使用花括号(`{}`)列出值。因为可以推断出数组的大小，所以不必声明它。

```cs
string[] name = {"Bob","Bill","Jane","Judy"};
```

C# 支持多维数组。声明数组时，用逗号分隔维度的大小。以下声明创建一个五行四列的二维整数数组:

```cs
string[,] name = new string[4,3];
```

要在声明二维数组时初始化该数组的元素，可以在花括号中使用花括号来列出数组元素。

```cs
int[,] intArray = {{1,2}, {3,4}, {5,6}, {7,8}};
```

您可以使用数组名称后跟括号中元素的索引来访问数组元素。第一个元素的索引编号从 0 开始。例如，`name[2]`引用先前声明的 names 数组的第三个元素，其值为`Jane`。

类类类

在面向对象的编程语言中，类被广泛使用。本书的大部分内容是关于它们的创建和使用。至此，可以说类为对象定义了一个复杂的数据类型。它们包含关于对象应该如何行为的信息，包括其名称、方法、属性和事件。那个 .NET Framework 包含许多您可以使用的预定义类。您也可以创建自己的类类型定义。定义为类类型的变量包含一个指向对象内存位置的地址指针。下面的代码声明了在 .NET 框架:

```cs
StringBuilder sb = new StringBuilder();
```

查看文字、常量和枚举

尽管变量值在程序执行过程中会发生变化，但文字和常量包含不变的数据项。

文字

文字是隐式分配了数据类型的固定值，通常用于初始化变量。以下代码使用文字将`2`的值与整数值相加:

```cs
Count = Count + 2;
```

通过检查文本，编译器将数据类型分配给文本。没有十进制值的数值被指定为整数数据类型；具有十进制值的数据被指定为双精度数据类型。关键字`true`和`false`被指定为布尔数据类型。如果文字包含在引号中，则它被指定为字符串数据类型。在下面的代码行中，两个字符串文字被组合并赋给一个字符串变量:

```cs
FullName = "Bob" + "Smith";
```

通过向文本追加一个类型字符，可以覆盖文本的默认数据类型赋值。例如，`12.25`的值将被分配双精度数据类型，而`12.25f`的值将导致编译器为其分配单数据类型。

常数

很多时候，您必须在代码中重复使用同一个常量值。例如，一系列几何计算可能需要使用圆周率的值。不用在你的代码中重复文字 3.14，你可以通过使用一个声明的常量来使你的代码更可读和可维护。使用关键字`const`声明一个常量，后跟数据类型和常量名称:

```cs
const Single pi = 3.14159265358979323846;
```

常量在声明时被赋值，这个值不能被修改或重新赋值。

枚举

您经常需要将变量值赋给几个相关的预定义常量之一。在这些情况下，您可以创建枚举类型来对值进行分组。枚举将一组整数常量与可在代码中使用的名称相关联。例如，下面的代码创建了一个类型为`Manager`的`enum`，用于定义三个相关的管理器常量，它们的名称分别为`DeptManager`、`GeneralManager`和`AssistantManager`，值分别为`0`、`1`和`2`:

```cs
 enum Manager
 {
  DeptManager,
  GeneralManager,
  AssistantManager,
 }
```

可以声明一个`enum`类型的变量，并将其设置为一个`enum`常量。

```cs
Manager managerLevel = Manager.DeptManager;
```

![image](img/sq.jpg) **注**此 .NET Framework 提供了各种内部常数和枚举，旨在使您的编码更加直观和易读。例如，`StringAlignment`枚举指定文本字符串相对于其布局矩形的对齐方式。

探索变量范围

变量的两个重要方面是它的范围和生存期。变量的作用域指的是如何从其他代码中访问该变量。变量的生存期是变量有效并可供使用的时间段。变量的作用域和生存期由声明变量的位置和用于声明变量的访问修饰符决定。

块级范围

代码块是一组分组的代码语句。代码块的例子包括以`if` - `else`、`do` - `loop`或`for` - `next`语句组织的代码。块级范围是变量可以拥有的最窄范围。在代码块中声明的变量只能在声明它的代码块中使用。在下面的代码中，变量`blockCount`只能从 if 块内部访问。任何访问块外变量的尝试都会产生编译器错误。

```cs
if (icount > 10)
{
  int blockCount;
  blockCount = icount;
}
```

程序范围

过程是可以从其他代码中调用和执行的代码块。C# 支持两种类型的过程:方法和属性。在代码块外但在过程内声明的变量具有过程级范围。具有过程范围的变量可以由同一过程中的代码访问。在下面的代码中，计数器`iCount`是用过程范围声明的，可以从`Counter`方法的过程块中的任何地方引用:

```cs
void Counter()
{
  int iCount = 0;
  do
  {
  iCount = iCount + 2;
  }
  while (iCount < 10);
}
```

过程范围变量的生存期限于过程执行的持续时间。

模块范围

具有模块范围的变量可用于类或结构中的任何代码。为了具有模块范围，变量在类或结构的一般声明部分(在任何过程块之外)声明。为了限制声明它的模块的可访问性，可以使用`private`访问修饰符关键字。在下面的代码中，`iCount`变量可以被类中定义的两个过程访问:

```cs
public class Class1
{
  private int _iCount;
  public void IncrementCount()
  {
  int iCount = 0;
  do
  {
  iCount = iCount + 2;
  }
  while (iCount < 10);
  }
  public void ReadCount()
  {
  Console.WriteLine(_iCount.ToString());
  }
}
```

用模块范围声明的变量的生存期与声明该变量的类或结构的对象实例的生存期相同。

![image](img/sq.jpg) **注**关于范围的进一步讨论，见第 6 章[。](06.html)

了解数据类型转换

在程序执行过程中，很多时候都必须将一个值从一种数据类型转换为另一种数据类型。数据类型之间的转换过程称为*转换*或*转换*。

隐式转换

C# 编译器会自动为您执行一些数据类型转换。对于数值类型，当要存储的值可以放入变量而不被截断或舍入时，可以进行隐式转换。例如，在下面的代码中，整数数据类型被隐式转换为 long 数据类型:

```cs
int i1 = 373737373;
long l1 = i1;
l1 *= l1;
```

显式转换

显式转换被称为*强制转换*。若要执行强制转换，请在要转换的值或变量前面的括号中指定要强制转换的类型。以下代码使用强制转换将 double 类型`n1`显式转换为 integer 类型:

```cs
double n1 = 3.73737373;
int i1 = (int)n1;
```

扩大和缩小转换

当要转换的数据类型可以容纳原始数据类型中包含的所有可能值时，就会发生扩大转换 。例如，整数数据类型可以转换为双精度数据类型，而不会有任何数据丢失或溢出。当数字被截断时，就会发生数据丢失。例如，如果将 2.54 转换为整数数据类型，它将被截断为 2。当数字太大而不适合新的数据类型时，就会发生溢出。例如，如果将数字 50000 转换为 short 数据类型，则超出了 short 数据类型的最大容量，从而导致溢出错误。另一方面，收缩转换 发生在被转换的数据类型不能容纳原始数据类型中可以包含的所有值时。例如，当 double 数据类型的值转换为 short 数据类型时，原始值中包含的任何十进制值都将丢失。此外，如果原始值超过短数据类型的限制，将会发生运行时异常。在代码中实现收缩转换时，应该特别小心地捕捉这些情况。

使用运算符

运算符是一个代码符号，它告诉编译器对一个值执行运算。运算可以是算术、比较或逻辑。

算术运算符

算术运算符对数值类型执行数学操作。[表 A-3](#Tab3) 列出了 C# 中常用的算术运算符。

[表 A-3。](#_Tab3)算术运算符

| **操作员** | **描述** |
| --- | --- |
| `=` | 分配 |
| `*` | 增加 |
| `/` | 分开 |
| `+` | 添加 |
| `-` | 减法 |

下面的代码将整数数据类型的值递增 1:

```cs
Count = Count + 1;
```

C# 还支持将赋值和操作结合起来的速记赋值操作符。以下代码等效于前面的代码:

```cs
Count += 1;
```

如果你要增加 1，你也可以使用简写赋值`++`。以下代码等效于前面的代码:

```cs
Count ++;
```

比较运算符

比较运算符比较两个值，并返回布尔值`true`或`false`。[表 A-4](#Tab4) 列出了 C# 中常用的比较运算符。

[表 A-4。](#_Tab4)比较运算符

| **操作员** | **描述** |
| --- | --- |
| `<` | 不到 |
| `<=` | 小于或等于 |
| `>` | 大于 |
| `>=` | 大于或等于 |
| `==` | 等于 |
| `!=` | 不等于 |

您可以在条件语句中使用比较运算符来决定何时执行代码块。在显示消息之前，下面的`if`块检查无效登录尝试的次数是否大于三次:

```cs
if (_loginAttempts > 3)
{
  Messagebox.Show("Invalid login.");
}
```

逻辑运算符

逻辑运算符组合条件运算符的结果。三种最常用的逻辑运算符是 AND、OR 和 NOT 运算符。 AND 运算符(`&&`)组合两个表达式，如果两个表达式都为真，则返回`true`。 OR 运算符(`||`)组合两个表达式，如果其中一个为真，则返回`true`。 NOT 运算符(`!`)切换比较结果:值`true`返回`false`，值`false`返回`true`。以下代码在运行方法之前检查登录用户是部门经理还是助理经理:

```cs
if (currentUserLevel == Manager.AssistantManager ||
  currentUserLevel == Manager.DeptManager)
{
  ReadLog();
}
```

三进制运算符

三元运算符计算布尔表达式，并根据表达式的结果返回两个值之一。下面显示了三元运算符的语法:

```cs
condition ? first_expression : second_expression;
```

如果条件评估为 true，则返回第一个表达式的结果。如果条件评估为 false，则返回第二个表达式的结果。下面的代码检查 x 的值是否为零。如果是，则返回 0；如果不是，它将 y 除以 x 并返回结果。

```cs
return x == 0.0 ? 0 : y/x;
```

介绍决策结构

决策结构允许根据条件语句的评估有条件地执行代码块。`if`语句评估一个布尔表达式，如果结果为真，则执行代码块。`switch`语句检查同一个表达式的几个不同值，并根据结果有条件地执行一个代码块。

如果语句

若要在条件为真时执行代码块，请使用以下结构:

```cs
if (condition1)
{
  //code
}
```

若要在条件为真时执行代码块，在条件为假时执行替代代码块，请添加一个 else 块。

```cs
if (condition1)
{
  //code
}
else
{
  //code
}
```

如果第一个评估为`false`，要测试附加条件，添加一个`else` - `if`模块:

```cs
if (condition1)
{
  //code
}
else if (condition2)
{
  //code
}
else
{
  //code
}
```

一条`if`语句可以有多个-`else`-`if`块。如果条件评估为`true`，则执行相应的代码语句，之后执行跳转到语句的末尾。如果条件评估为`false`，则检查下一个 else-if 条件。else 块是可选的，但是如果包含，它必须是最后一个。`else`模块没有条件检查，仅当所有其他条件检查评估为`false`时才执行。下面的代码演示了如何使用`if`语句来评估一系列条件。它检查绩效评级以确定使用何种奖金，并检查员工是否是经理以确定最低奖金。

```cs
if (performance ==1)
{
  bonus = salary * 0.1;
}
else if (performance == 2)
{
  bonus = salary * 0.08;
}
else if (employeeLevel == Manager.DeptManager)
{
  bonus = salary * 0.05;
}
else
{
  bonus = salary * 0.03;
}
```

切换报表

虽然`switch`语句类似于`if` - `else`语句，但它用于测试一系列值的单个表达式。`switch`语句的结构如下:

```cs
switch (expression)
{
case 1:
  Console.WriteLine("Case 1");
  break;
case 2:
  Console.WriteLine("Case 2");
  break;
default:
  Console.WriteLine("Default case");
  break;
}
```

一个`switch`语句可以有多个`case`块。如果测试表达式的值与`case`表达式匹配，那么`case`块中的代码语句就会执行。在`case`块执行之后，您需要一个`break`语句来绕过其余的 case 语句。如果测试表达式与`case`表达式不匹配，执行跳转到下一个`case`块。`default`块没有表达式。如果没有执行其他 case 块，它就会执行。`default`块是可选的，但如果使用，它必须是最后一个。以下示例使用`switch`来评估绩效评级，以设置适当的奖金率:

```cs
switch(performance)
{
  case 1:
  bonus = salary * 0.1;
  break;
  case 2:
  bonus = salary * 0.08;
  break;
  case 3:
  bonus = salary * 0.03;
  break;
  default:
  bonus = salary * 0.01;
  break;
 }
```

使用循环结构

循环结构重复一段代码，直到满足一个条件。C# 支持以下循环结构。

而声明

当布尔表达式保持不变时，`while`语句重复执行代码。表达式在循环开始时计算。下面的代码执行，直到一个有效的登录变量评估为`true`:

```cs
while (validLogin == false)
{
  //code statements...
}
```

Do-While 语句

`do` - `while`循环类似于`while`循环，只是表达式是在循环结束时计算的。以下代码将循环运行，直到达到最大登录尝试次数:

```cs
do
{
  //code statements...
}
while (iCount < maxLoginAttempts);
```

对于声明

一条`for`语句根据存储在计数器中的值在一个代码块中循环特定的次数。当您知道循环在设计时需要执行的次数时，For 语句是更好的选择。在`for`语句后面的括号中，初始化一个计数器，定义求值表达式，并定义计数器的增量。

```cs
for (int i = 0; i < 10; i++)
{
  //Code statements...
}
```

对于每一个语句

`for` - `each`语句循环遍历集合中每一项的代码。一个*集合* 是一组有序的条目；例如，放置在 Windows 窗体上的控件被组织到一个控件集合中。要使用`for` - `each`语句，首先声明集合中包含的条目类型的变量。此变量设置为集合中的当前项。下面的`for` - `each`语句遍历雇员列表集合中的雇员:

```cs
foreach (Employee e in employeeList)
{
  //Code statements
}
```

如果需要有条件地退出循环代码块，可以使用`break`语句。下面的代码显示了如何跳出`for` - `each`循环:

```cs
foreach (Employee e in employeeList)
{
  //Code statements
  if (e.Name == "Bob")
  {
  break;
  }
}
```

介绍方法

方法是可以从其他代码中调用和执行的代码块。将应用分解成离散的逻辑代码块极大地增强了代码的维护和重用。C# 支持返回值的方法和不返回值的方法。当您声明一个方法时，您为该方法指定一个访问修饰符、一个返回类型和一个名称。下面的代码声明了一个没有返回类型(由关键字指定)的方法，用于记录事件日志的登录:

```cs
public void RecordLogin(string userName)
{
  EventLog appLog = new EventLog();
  appLog.Source = "OSO App";
  appLog.WriteEntry(userName + " has logged in.");
}
```

您可以使用参数列表来声明方法，该列表定义了调用方法时必须传递给该方法的参数。以下代码定义了一个封装奖金分配的方法。调用代码将一个整数类型的值传递给该方法，并接收一个`double`类型的值。

```cs
public double GetBonusRate(int performanceRating)
{
  double bonusRate;
  switch (performanceRating)
  {
  case 1:
  bonusRate = 0.1;
  break;
  case 2:
  bonusRate = 0.08;
  break;
  case 3:
  bonusRate = 0.03;
  break;
  default:
  bonusRate = 0.01;
  break;
  }
  return bonusRate;
  }
```

下面的代码演示了如何调用方法:

```cs
double salary;
int performance = 0;
double bonus = 0;
// Get salary and performance data from data base...
bonus = GetBonusRate(performance) * salary;
```

如果该方法的访问修饰符是私有的，则只能从同一类中的代码访问它。如果该方法需要被其他类中的代码访问，那么使用`public`访问修饰符。

本附录中的信息旨在帮助您快速了解一些基本的编程概念。您现在应该更熟悉 C# 语法，并准备通过阅读本书的其余部分来扩展和构建这些概念。