# 18.理解 CIL 和动态程序集的作用

当你建造一个全尺寸的。NET 应用程序，鉴于其固有的生产力和易用性，您肯定会使用 C#(或类似的托管语言，如 Visual Basic)。然而，正如你在第一章中所学的，托管编译器的作用是将`*.cs`代码文件翻译成 CIL 代码、类型元数据和汇编指令清单。事实证明，CIL 是一个成熟的。NET 编程语言，有自己的语法、语义和编译器(`ilasm.exe`)。

在这一章中，你将参观。NET 的母语。在这里你将理解 CIL 指令、CIL 属性和 CIL 操作码之间的区别。然后，您将了解. NET 程序集和各种 CIL 编程工具的往返工程的作用。本章的剩余部分将带你了解使用 CIL 语法定义命名空间、类型和成员的基本知识。本章将以对`System.Reflection.Emit`名称空间的角色的检查结束，并检查如何在运行时动态地构造一个汇编(用 CIL 指令)。

当然，很少有程序员需要在日常工作中使用原始的 CIL 代码。因此，本章一开始，我将分析为什么要了解这个底层的语法和语义。网络语言可能值得你花时间。

## 学习 CIL 语法的动机

CIL 语是美国人真正的母语。NET 平台。当您使用您选择的托管语言(C#、VB、F#等)生成. NET 程序集时。)，相关的编译器将你的源代码翻译成 CIL。像任何编程语言一样，CIL 提供了许多结构化和以实现为中心的标记。鉴于 CIL 只是另一个。NET 编程语言，所以构建您的。NET 程序集直接使用 CIL 和 CIL 编译器(`ilasm.exe`)。NET 框架 SDK。

现在虽然这是事实，很少(如果有的话！)程序员会选择构建一个完整的。NET 应用程序直接与 CIL，CIL 仍然是一个极其有趣的智力追求。简单地说，你对 CIL 的语法理解得越多，你就越有能力进入高级领域。网络开发。通过一些具体的例子，了解 CIL 教的个人能够做到以下几点:

*   拆卸现有的。NET 程序集，编辑 CIL 代码，并将更新后的代码库重新编译为修改后的。NET 二进制。例如，在某些情况下，您可能需要修改 CIL 来与一些高级 COM 功能进行互操作。
*   使用`System.Reflection.Emit`名称空间构建动态程序集。这个 API 允许您在内存中生成一个。NET 程序集，它可以选择性地保存到磁盘上。对于需要动态生成程序集的工具构建者来说，这是一种非常有用的技术。
*   理解高级管理语言不支持但在 CIL 级别存在的 cts 方面。可以肯定的是，CIL 是唯一的。NET 语言，允许您访问 CTS 的各个方面。例如，使用原始 CIL，您可以定义全局级别的成员和字段(这在 C#中是不允许的)。

同样，非常清楚的是，如果你选择不关心 CIL 代码的细节，你仍然绝对能够掌握 C#和。NET 基础类库。在许多方面，CIL 的知识类似于 C ++程序员对汇编语言的理解。那些知道底层“goo”的来龙去脉的人能够为手头的任务创建相当高级的解决方案，并对底层编程(和运行时)环境有更深的理解。所以，如果你准备好迎接挑战，让我们开始研究 CIL 的细节。

Note

理解这一章并不打算是 CIL 语法和语义的全面处理。如果您需要对该主题进行全面检查，我推荐您从 ECMA 国际网站( [`www.ecma-international.org`](http://www.ecma-international.org/) )下载官方的 ECMA 规范(ecma-335.pdf)。

## 检查 CIL 指令、属性和操作码

当你开始研究像 CIL 这样的低级语言时，你肯定会为熟悉的概念找到新的(通常听起来吓人的)名称。例如，在文本的这一点上，如果向您显示以下一组项目

`{new, public, this, base, get, set, explicit, unsafe, enum, operator, partial}`

您肯定会认为它们是 C#语言的关键字(这是正确的)。但是，如果您更仔细地观察这个集合的成员，您可能会发现虽然每个条目确实是一个 C#关键字，但是它具有完全不同的语义。例如，`enum`关键字定义了一个`System.Enum`派生的类型，而`this`和`base`关键字允许你分别引用当前对象或对象的父类。`unsafe`关键字用于建立一个不能被 CLR 直接监控的代码块，而`operator`关键字允许你构建一个隐藏的(特别命名的)方法，当你应用一个特定的 C#操作符(比如加号)时，这个方法将被调用。

与 C#这样的高级语言形成鲜明对比的是，CIL 本身并不只是简单地定义一组通用的关键字。相反，CIL 编译器所理解的标记集根据语义被细分为以下三大类:

*   cil 指令
*   CIL 属性
*   CIL 操作码

每一类 CIL 令牌都使用特定的语法来表示，并且这些令牌被组合起来以构建有效的。NET 程序集。

### CIL 指令的作用

首先，有一组众所周知的 CIL 标记，用于描述. NET 程序集的整体结构。这些令牌称为指令。CIL 指令用于通知 CIL 编译器如何定义将填充程序集的命名空间、类型和成员。

指令在语法上使用单个点(`.`)前缀(例如`.namespace`、`.class`、`.publickeytoken`、`.method`、`.assembly`等)来表示。).因此，如果您的`*.il`文件(包含 CIL 代码的文件的传统扩展名)有一个`.namespace`指令和三个`.class`指令，CIL 编译器将生成一个定义单个。NET 命名空间包含三个。NET 类类型。

### CIL 属性的作用

在许多情况下，CIL 指令本身的描述性不足以完全表达给定的定义。NET 类型或类型成员。鉴于这一事实，许多 CIL 指令可以进一步指定各种 CIL 属性，以限定指令应该如何处理。例如，`.class`指令可以用`public`属性(建立类型可见性)、`extends`属性(显式指定类型的基类)和`implements`属性(列出该类型支持的接口集)来修饰。

Note

不要混淆. NET 属性和 CIL 属性，这是两个非常不同的概念。

### CIL 操作码的作用

一旦使用各种指令和相关属性按照 CIL 定义了. NET 程序集、命名空间和类型集，剩下的最后一项任务就是提供类型的实现逻辑。这是操作码或简单操作码的工作。在其他低级语言的传统中，许多 CIL 操作码往往是神秘的，对于我们这些普通人来说完全无法发音。例如，如果你需要将一个`string`变量加载到内存中，你不会使用一个友好的操作码`LoadString`，而是使用`ldstr`。

现在，公平地说，一些 CIL 操作码确实非常自然地映射到它们的 C#对应物(例如，`box`、`unbox`、`throw`和`sizeof`)。正如您将看到的，CIL 的操作码总是在成员的实现范围内使用，并且不像 CIL 指令，它们从不带有点前缀。

### CIL 操作码/CIL 助记符的区别

如前所述，操作码如`ldstr`用于实现给定类型的成员。然而，实际上，像`ldstr`这样的标记是实际二进制 CIL 操作码的 CIL 助记符。为了阐明区别，假设您已经用 C#编写了以下方法:

`static int Add(int x, int y)`

`{`

`return x + y;`

`}`

两个数相加的行为用 CIL 操作码`0X58`来表示。类似地，用操作码`0X59`来表示减去两个数字，并且使用`0X73`操作码来实现在托管堆上分配新对象的动作。鉴于这一现实，请理解由 JIT 编译器处理的“CIL 代码”实际上只不过是二进制数据块。

谢天谢地，对于 CIL 的每一个二进制操作码，都有相应的助记符。例如，可以使用`add`助记符而不是`0X58`、`sub`而不是`0X59`、`newobj`而不是`0X73`。考虑到操作码/助记符的区别，CIL 反编译器如`ildasm.exe`将汇编的二进制操作码翻译成相应的 CIL 助记符。例如，这里是`ildasm.exe`为之前的 C# `Add()`方法提供的 CIL(根据您的版本，您的确切输出可能会有所不同。净):

`.method private hidebysig static int32 Add(int32 x,`

`int32 y) cil managed`

`{`

`// Code size 9 (0x9)`

`.maxstack 2`

`.locals init ([0] int32 CS$1$0000)`

`IL_0000: nop`

`IL_0001: ldarg.0`

`IL_0002: ldarg.1`

`IL_0003: add`

`IL_0004: stloc.0`

`IL_0005: br.s IL_0007`

`IL_0007: ldloc.0`

`IL_0008: ret`

`}`

除非你在建造一些非常低级的。NET 软件(如定制的托管编译器)，您将永远不需要关心自己的文字数字二进制操作码的 CIL。实际上，当。NET 程序员谈到“CIL 操作码”，他们指的是一组友好的字符串标记助记符(正如我在本文中所做的，并将在本章的剩余部分中做的)，而不是底层的数值。

## 推进和弹出:CIL 基于堆栈的本质

更高级的。网络语言(如 C#)试图尽可能隐藏低级的 CIL 垃圾。的一方面。NET 开发中隐藏得特别好的一点是，CIL 是一种基于堆栈的编程语言。回想一下对集合名称空间的检查(参见[第 9 章](09.html)),`Stack<T>`类可以用来将一个值压入堆栈，也可以从堆栈中弹出最上面的值以供使用。当然，CIL 开发人员不会使用类型为`Stack<T>`的对象来加载和卸载要评估的值；然而，同样的推动和弹出的心态仍然适用。

从形式上讲，用来保存一组待评估值的实体被称为虚拟执行堆栈。正如您将看到的，CIL 提供了许多操作码，用于将一个值推送到堆栈上；这个过程称为装载。此外，CIL 还定义了许多额外的操作码，这些操作码通过存储过程将栈顶的值转移到内存中(比如一个局部变量)。

在 CIL 的世界里，不可能直接访问一个数据点，包括本地定义的变量、传入的方法参数或某种类型的字段数据。相反，您需要显式地将该项加载到堆栈中，然后弹出它以备后用(记住这一点，因为它将有助于解释为什么给定的 CIL 代码块看起来有点多余)。

Note

回想一下，CIL 不是直接执行的，而是按需编译的。在编译 CIL 代码的过程中，许多实现冗余被优化掉了。此外，如果为当前项目启用代码优化选项(使用 Visual Studio 项目属性窗口的“生成”选项卡)，编译器还将移除各种 CIL 冗余。

为了理解 CIL 如何利用基于堆栈的处理模型，考虑一个简单的 C#方法`PrintMessage()`，它没有参数，返回`void`。在这个方法的实现中，您只需将一个本地字符串变量的值打印到标准输出流中，如下所示:

`public void PrintMessage()`

`{`

`string myMessage = "Hello.";`

`Console.WriteLine(myMessage);`

`}`

如果您要研究 C#编译器如何根据 CIL 来翻译这个方法，您首先会发现`PrintMessage()`方法使用`.locals`指令为局部变量定义了一个存储槽。然后使用`ldstr`(加载字符串)和`stloc.0`操作码(可以理解为“将当前值存储在存储槽零的局部变量中”)加载并存储局部字符串。

然后，使用`ldloc.0`(“在索引 0 处加载本地参数”)操作码将该值(同样在索引 0 处)加载到内存中，以供`System.Console.WriteLine()`方法调用(使用`call`操作码指定)使用。最后，函数通过`ret`操作码返回。下面是`PrintMessage()`方法的(带注释的)CIL 代码(注意，为了简洁起见，我已经从清单中删除了`nop`操作码):

`.method public hidebysig instance void PrintMessage() cil managed`

`{`

`.maxstack 1`

`// Define a local string variable (at index 0).`

`.locals init ([0] string myMessage)`

`// Load a string onto the stack with the value "Hello."`

`ldstr " Hello."`

`// Store string value on the stack in the local variable.`

`stloc.0`

`// Load the value at index 0.`

`ldloc.0`

`// Call method with current value.`

`call void [mscorlib]System.Console::WriteLine(string)`

`ret`

`}`

Note

如您所见，CIL 支持使用双斜线语法的代码注释(以及/*...*/语法，就此而言)。和 C#一样，CIL 编译器完全忽略代码注释。

现在您已经有了 CIL 指令、属性和操作码的基础，让我们看看 CIL 编程的实际应用，从往返工程的主题开始。

## 了解往返工程

你知道如何使用`ildasm.exe`来查看 C#编译器生成的 CIL 代码(参见[第 1 章](01.html))。然而，您可能不知道的是，`ildasm.exe`允许您将加载到`ildasm.exe`的程序集中包含的 CIL 转储到外部文件。一旦你有了 CIL 代码，你就可以使用 CIL 编译器`ilasm.exe`自由地编辑和重新编译代码库。

从形式上来说，这种技术被称为往返工程，它在某些情况下很有用，例如:

*   您需要修改不再有源代码的程序集。
*   你正在和一个不完美的人一起工作。NET 语言编译器发出了无效的(或完全不正确的)CIL 代码，并且您想要修改代码库。
*   您正在构建一个 COM 互用性库，并希望解决在转换过程中丢失的一些 COM IDL 属性(如 COM `[helpstring]`属性)。

为了说明往返过程，首先使用简单的文本编辑器(如记事本)创建一个新的 C#代码文件(`HelloProgram.cs`)，并定义以下类类型(如果需要，您可以使用 Visual Studio 创建一个新的控制台应用程序项目。但是，一定要删除`AssemblyInfo.cs`文件，以减少生成的 CIL 代码的数量)。

`// A simple C# console app.`

`using System;`

`// Note that we are not wrapping our class in a namespace,`

`// to help simplify the generated CIL code.`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("Hello CIL code!");`

`Console.ReadLine();`

`}`

`}`

将您的文件保存到一个方便的位置(例如，`C:\RoundTrip`)并使用`csc.exe`编译您的程序，如下所示:

`csc HelloProgram.cs`

现在，用`ildasm.exe`打开`HelloProgram.exe`，使用文件➤转储菜单选项，将原始 CIL 代码保存到一个新的`*.il`文件(`HelloProgram.il`)中，该文件位于包含已编译程序集的同一文件夹中(结果对话框的所有默认值都可以)。

Note

`ildasm.exe`在将汇编的内容转储到文件时也会生成一个`*.res`文件。在本章中，这些资源文件可以被忽略(和删除),因为您不会用到它们。该文件包含一些低级别的 CLR 安全信息(以及其他信息)。

现在您可以使用您选择的文本编辑器查看`HelloProgram.il`。下面是(稍微重新格式化和注释的)结果:

`// Referenced assemblies.`

`.assembly extern mscorlib`

`{`

`.publickeytoken = (B7 7A 5C 56 19 34 E0 89 )`

`.ver 4:0:0:0`

`}`

`// Our assembly.`

`.assembly HelloProgram`

`{`

`/**** TargetFrameworkAttribute data removed for clarity! ****/`

`.hash algorithm 0x00008004`

`.ver 0:0:0:0`

`}`

`.module HelloProgram.exe`

`.imagebase 0x00400000`

`.file alignment 0x00000200`

`.stackreserve 0x00100000`

`.subsystem 0x0003`

`.corflags 0x00000003`

`// Definition of Program class.`

`.class private auto ansi beforefieldinit Program`

`extends [mscorlib]System.Object`

`{`

`.method private hidebysig static void Main(string[] args) cil managed`

`{`

`// Marks this method as the entry point of the`

`// executable.`

`.entrypoint`

`.maxstack 8`

`IL_0000: nop`

`IL_0001: ldstr "Hello CIL code!"`

`IL_0006: call void [mscorlib]System.Console::WriteLine(string)`

`IL_000b: nop`

`IL_000c: call string [mscorlib]System.Console::ReadLine()`

`IL_0011: pop`

`IL_0012: ret`

`}`

`// The` `default constructor.`

`.method public hidebysig specialname rtspecialname`

`instance void .ctor() cil managed`

`{`

`.maxstack 8`

`IL_0000: ldarg.0`

`IL_0001: call instance void [mscorlib]System.Object::.ctor()`

`IL_0006: ret`

`}`

`}`

首先，请注意,`*.il`文件是通过声明每个外部引用的程序集来打开的，当前程序集是针对该程序集编译的。在这里，您可以看到为始终存在的`mscorlib.dll`设置的单个`.assembly extern`令牌。当然，如果你的类库使用了其他引用程序集中的类型，你会发现额外的`.assembly extern`指令。

接下来，您找到了您的`HelloProgram.exe`程序集的正式定义，它被赋予了一个默认版本的`0.0.0.0`(假设您没有使用`[AssemblyVersion]`属性指定一个值)。使用各种 CIL 指令(如`.module`、`.imagebase`等)进一步描述该程序集。

在记录外部引用的程序集并定义当前程序集后，您会发现一个`Program`类型的定义。请注意，`.class`指令有各种属性(其中许多实际上是可选的),如这里所示的`extends`,它标记了该类型的基类:

`.class private auto ansi beforefieldinit Program`

`extends [mscorlib]System.Object`

`{ ... }`

大部分 CIL 代码代表了类的默认构造函数和`Main()`方法的实现，这两者都是用`.method`指令定义的(部分)。一旦使用正确的指令和属性定义了成员，就可以使用各种操作码来实现它们。

了解这一点非常重要。NET 类型(比如`System.Console`)在 CIL，你总是需要使用类型的完全限定名。此外，类型的完全限定名必须始终以定义程序集的友好名称为前缀(在方括号中)。考虑下面的`Main()`的 CIL 实现:

`.method private hidebysig static void Main(string[] args) cil managed`

`{`

`.entrypoint`

`.maxstack 8`

`IL_0000: nop`

`IL_0001: ldstr "Hello CIL code!"`

`IL_0006: call void [mscorlib]System.Console::WriteLine(string)`

`IL_000b: nop`

`IL_000c: call string [mscorlib]System.Console::ReadLine()`

`IL_0011: pop`

`IL_0012: ret`

`}`

根据 CIL 代码，默认构造函数的实现使用了另一个“以加载为中心”的指令(`ldarg.0`)。在这种情况下，加载到堆栈上的值不是您指定的自定义变量，而是当前的对象引用(稍后将详细介绍)。还要注意，默认构造函数显式调用基类构造函数，如下所示(在本例中，它是您的好朋友`System.Object`):

`.method public hidebysig specialname rtspecialname`

`instance void .ctor() cil managed`

`{`

`.maxstack 8`

`IL_0000: ldarg.0`

`IL_0001: call instance void [mscorlib]System.Object::.ctor()`

`IL_0006: ret`

`}`

### CIL 代码标签的作用

您肯定已经注意到的一件事是，每一行实现代码都带有一个形式为`IL_XXX:`的前缀(例如，`IL_0000:`、`IL_0001:`等等)。这些标记称为代码标签，可以按照您选择的任何方式命名(前提是它们在同一个成员范围内不重复)。当您使用`ildasm.exe`将一个程序集转储到文件时，它将自动生成遵循`IL_XXX:`命名约定的代码标签。但是，您可以更改它们以反映更具描述性的标记。这里有一个例子:

`.method private hidebysig static void Main(string[] args) cil managed`

`{`

`.entrypoint`

`.maxstack 8`

`Nothing_1: nop`

`Load_String: ldstr "Hello CIL code!"`

`PrintToConsole: call void [mscorlib]System.Console::WriteLine(string)`

`Nothing_2: nop`

`WaitFor_KeyPress: call string [mscorlib]System.Console::ReadLine()`

`RemoveValueFromStack: pop`

`Leave_Function: ret`

`}`

事实是，大多数代码标签是完全可选的。代码标签唯一真正必需的时候是在你编写使用各种分支或循环结构的 CIL 代码的时候，因为你可以通过这些代码标签指定逻辑流向哪里。对于当前示例，您可以完全删除这些自动生成的标签，而不会产生不良影响，如下所示:

`.method private hidebysig static void Main(string[] args) cil managed`

`{`

`.entrypoint`

`.maxstack 8`

`nop`

`ldstr "Hello CIL code!"`

`call void [mscorlib]System.Console::WriteLine(string)`

`nop`

`call string [mscorlib]System.Console::ReadLine()`

`pop`

`ret`

`}`

### 与 CIL 互动:修改一个*。il 文件

现在您已经对基本的 CIL 文件是如何组成的有了更好的理解，让我们完成往返实验。这里的目标是更新现有`*.il`文件中的 CIL，如下所示:

Add a reference to the `System.Windows.Forms.dll` assembly.   Load a local string within `Main()`.   Call the `System.Windows.Forms.MessageBox.Show()` method using the local string variable as an argument.  

第一步是添加一个新的`.assembly`指令(用`extern`属性限定),指定您的程序集需要`System.Windows.Forms.dll`程序集。为此，在外部引用`mscorlib`之后，用以下逻辑更新`*.il`文件:

`.assembly extern System.Windows.Forms`

`{`

`.publickeytoken = (B7 7A 5C 56 19 34 E0 89)`

`.ver 4:0:0:0`

`}`

请注意，分配给`.ver`指令的值可能会因。NET 平台，您已经安装在您的开发机器。在这里，您可以看到使用了版本 4.0.0.0 的`System.Windows.Forms.dll`,它的公钥标记为 B77A5C561934E089。如果你打开 GAC(见[第 14 章](14.html)并找到你的`System.Windows.Forms.dll`程序集版本，你可以简单地复制正确的版本和公钥标记值。

接下来，您需要改变`Main()`方法的当前实现。在`*.il`文件中找到这个方法，并删除当前的实现代码(`.maxstack`和`.entrypoint`指令应该保持不变)，如下所示:

`.method private hidebysig static void Main(string[] args) cil managed`

`{`

`.entrypoint`

`.maxstack 8`

`// ToDo: Write new CIL code!`

`}`

同样，这里的目标是推一个新的`string`到堆栈上，并调用`MessageBox.Show()`方法(而不是`Console.WriteLine()`方法)。回想一下，当指定外部类型的名称时，必须使用该类型的完全限定名(与程序集的友好名称结合使用)。还要注意，就 CIL 而言，每个方法调用都记录了完全限定的返回类型。记住这些事情，更新`Main()`方法如下:

`.method private hidebysig static void Main(string[] args) cil managed`

`{`

`.entrypoint`

`.maxstack 8`

`ldstr "CIL is way cool"`

`call valuetype [System.Windows.Forms]`

`System.Windows.Forms.DialogResult`

`[System.Windows.Forms]`

`System.Windows.Forms.MessageBox::Show(string)`

`pop`

`ret`

`}`

实际上，您已经更新了 CIL 代码，以对应下面的 C#类定义:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`System.Windows.Forms.MessageBox.Show("CIL is way cool");`

`}`

`}`

### 使用 ilasm.exe 编译 CIL 代码

假设您已经保存了这个修改过的`*.il`文件，您可以编译一个新的。NET 汇编使用`ilasm.` `exe` (CIL 编译器)实用程序。虽然 CIL 编译器有许多命令行选项(通过指定`-?`选项可以看到所有选项)，但表 [18-1](#Tab1) 显示了感兴趣的核心标志。

表 18-1。

Common ilasm.exe Command-Line Flags

<colgroup><col> <col></colgroup> 
| 旗 | 生命的意义 |
| --- | --- |
| `/debug` | 包括调试信息(如局部变量和参数名，以及行号)。 |
| `/dll` | 生成一个`*.dll`文件作为输出。 |
| `/exe` | 生成一个`*.exe`文件作为输出。这是默认设置，可以省略。 |
| `/key` | 使用给定的`*.snk`文件编译具有强名称的程序集。 |
| `/output` | 指定输出文件名和扩展名。如果不使用`/output`标志，结果文件名(减去文件扩展名)与第一个源文件的名称相同。 |

将更新后的`HelloProgram.il`文件编译成新的。NET `*.exe`，您可以在开发人员命令提示符下发出以下命令:

`ilasm /exe HelloProgram.il /output=NewAssembly.exe`

假设一切顺利，您将看到如下所示的报告:

`Microsoft (R) .NET Framework IL Assembler. Version 4.0.30319.33440`

`Copyright (c) Microsoft Corporation. All rights reserved.`

`Assembling ’HelloProgram.il’ to EXE --> ’NewAssembly.exe’`

`Source file is UTF-8`

`Assembled method Program::Main`

`Assembled method Program::.ctor`

`Creating PE file`

`Emitting classes:`

`Class 1: Program`

`Emitting fields and methods:`

`Global`

`Class 1 Methods: 2;`

`Emitting events and properties:`

`Global`

`Class 1`

`Writing PE file`

`Operation completed successfully`

此时，您可以运行您的新应用程序了。果然，您将看到一个消息框显示您的消息，而不是在控制台窗口中显示消息。虽然这个简单示例的输出并不那么壮观，但它确实展示了编程在 CIL 往返中的一个实际应用。

### peverify.exe 的角色

当您使用 CIL 代码生成或修改程序集时，验证编译的二进制映像是格式良好的总是明智的。NET 图像使用`peverify.exe`命令行工具，就像这样:

`peverify NewAssembly.exe`

此工具将检查指定程序集中的所有操作码是否为有效的 CIL 代码。例如，就 CIL 代码而言，在退出函数之前，计算堆栈必须始终为空。如果您忘记弹出任何剩余的值，`ilasm.exe`编译器仍然会生成一个编译后的程序集(假设编译器只关心语法)。另一方面，`peverify.exe`关注的是语义。如果你忘记在退出一个给定的函数之前清空堆栈，`peverify.exe`会在你尝试运行你的代码库之前让你知道。

Source Code

往返示例包含在 [`Chapter 18`](18.html) 子目录中。

## 了解 CIL 指令和属性

既然您已经看到了如何使用`ildasm.exe`和`ilasm.exe`来执行往返，那么您可以开始检查 CIL 本身的语法和语义了。接下来的几节将带您完成创作包含一组类型的自定义名称空间的过程。然而，为了简单起见，这些类型不会包含其成员的任何实现逻辑。在理解了如何创建空类型之后，就可以将注意力转向使用 CIL 操作码定义“真实”成员的过程了。

### 在 CIL 指定外部引用的程序集

使用您选择的编辑器创建一个名为`CILTypes.il`的新文件。CIL 项目要求的第一项任务是列出当前程序集使用的外部程序集。对于这个例子，您将只使用在`mscorlib.dll`中找到的类型。为此，将使用`external`属性来限定`.assembly`指令。当你引用一个强命名的程序集时，比如`mscorlib.dll`，你会想要指定`.publickeytoken`和`.ver`指令，就像这样:

`.assembly extern mscorlib`

`{`

`.publickeytoken = (B7 7A 5C 56 19 34 E0 89 )`

`.ver 4:0:0:0`

`}`

Note

严格地说，您不需要显式地引用`mscorlib.dll`作为外部引用，因为`ilasm.exe`会自动这样做。然而，对于每个外部的。你的 CIL 项目需要. NET 库，你将需要作者一个类似的`.assembly extern`指令。

### 定义 CIL 的当前程序集

下一步是使用`.assembly`指令定义您感兴趣的程序集。在最简单的层次上，可以通过指定二进制文件的友好名称来定义程序集，如下所示:

`// Our assembly.`

`.assembly CILTypes { }`

虽然这确实定义了一个新的。NET 程序集，通常会在程序集声明的范围内放置附加指令。对于本例，使用`.ver`指令更新您的程序集定义以包含版本号 1.0.0.0(注意每个数字标识符由冒号分隔，而不是以 C#为中心的点符号)，如下所示:

`// Our assembly.`

`.assembly CILTypes`

`{`

`.ver 1:0:0:0`

`}`

鉴于`CILTypes`汇编是一个单文件汇编(见[第 14 章](14.html)，你将使用下面的单个`.module`指令完成汇编定义，它标记了你的。`CILTypes.dll`净二进制:

`.assembly CILTypes`

`{`

`.ver 1:0:0:0`

`}`

`// The module of our single-file assembly.`

`.module CILTypes.dll`

除了`.assembly`和`.module`之外，CIL 指令进一步限定了的整体结构。您正在编写的. NET 二进制文件。表 [18-2](#Tab2) 列出了一些更常见的汇编级指令。

表 18-2。

Additional Assembly-Centric Directives

<colgroup><col> <col></colgroup> 
| 管理的 | 生命的意义 |
| --- | --- |
| `.mresources` | 如果您的程序集使用内部资源(如位图或字符串表)，此指令用于标识包含要嵌入的资源的文件的名称。 |
| `.subsystem` | 这个 CIL 指令用于建立程序集希望在其中执行的首选用户界面。例如，`2`的值表示程序集应该在 GUI 应用程序中运行，而`3`的值表示控制台可执行程序。 |

### 在 CIL 中定义名称空间

既然已经定义了程序集的外观(以及所需的外部引用)，就可以使用`.namespace`指令创建一个. NET 命名空间(`MyNamespace`)，如下所示:

`// Our assembly has a single namespace.`

`.namespace MyNamespace {}`

像 C#一样，CIL 命名空间定义可以嵌套在更多的命名空间中。这里不需要定义根命名空间；然而，为了便于讨论，假设您想要创建以下名为`MyCompany`的根名称空间:

`.namespace MyCompany`

`{`

`.namespace MyNamespace {}`

`}`

像 C#一样，CIL 允许您定义嵌套的名称空间，如下所示:

`// Defining a nested namespace.`

`.namespace MyCompany.MyNamespace {}`

### 在 CIL 定义分类类型

空的名称空间不是很有趣，所以现在让我们看看使用 CIL 定义类类型的过程。毫不奇怪，`.class`指令被用来定义一个新的类。但是，这个简单的指令可以用许多附加属性来修饰，以进一步限定类型的性质。举例来说，向名为`MyBaseClass`的名称空间添加一个公共类。和 C#一样，如果你不指定一个显式基类，你的类型将自动从`System.Object`派生。

`.namespace MyNamespace`

`{`

`// System.Object base class assumed.`

`.class public MyBaseClass {}`

`}`

当您构建一个从除了`System.Object`之外的任何类派生的类类型时，您使用`extends`属性。每当您需要引用在同一程序集中定义的类型时，CIL 要求您也使用完全限定名(但是，如果基类型在同一程序集中，您可以省略程序集的友好名称前缀)。因此，以下扩展`MyBaseClass`的尝试会导致编译器错误:

`// This will not compile!`

`.namespace MyNamespace`

`{`

`.class public MyBaseClass {}`

`.class public MyDerivedClass`

`extends MyBaseClass {}`

`}`

为了正确定义`MyDerivedClass`的父类，您必须指定`MyBaseClass`的全名，如下所示:

`// Better!`

`.namespace MyNamespace`

`{`

`.class public MyBaseClass {}`

`.class public MyDerivedClass`

`extends MyNamespace.MyBaseClass {}`

`}`

除了`public`和`extends`属性之外，CIL 类定义可能会采用许多额外的限定符来控制类型的可见性、字段布局等等。表 [18-3](#Tab3) 说明了一些(但不是全部)可能与`.class`指令结合使用的属性。

表 18-3。

Various Attributes Used in Conjunction with the `.class` Directive

<colgroup><col> <col></colgroup> 
| 属性 | 生命的意义 |
| --- | --- |
| `public`、`private`、`nested assembly`、`nested famandassem`、`nested family`、`nested famorassem`、`nested public`、`nested private` | CIL 定义了各种属性，用于指定给定类型的可见性。正如你所看到的，除了 C#提供的，原始 CIL 还提供了许多其他的可能性。如有兴趣，请参考 ECMA 335 了解详情。 |
| `abstract`，`sealed` | 这两个属性可以附加到一个`.class`指令上，分别定义一个抽象类或密封类。 |
| `auto`、`sequential`、`explicit` | 这些属性用于指示 CLR 如何在内存中布置字段数据。对于类类型，默认布局标志(`auto`)是合适的。如果您需要使用 P/Invoke 来调用非托管 C 代码，更改此默认值会很有帮助。 |
| `extends`，`implements` | 这些属性允许你定义一个类型的基类(通过`extends`)或者实现一个类型的接口(通过`implements`)。 |

### 在 CIL 中定义和实现接口

看起来很奇怪，接口类型在 CIL 是用`.class`指令定义的。然而，当`.class`指令用`interface`属性修饰时，该类型被实现为 CTS 接口类型。一旦定义了一个接口，就可以使用 CIL `implements`属性将它绑定到一个类或结构类型，如下所示:

`.namespace MyNamespace`

`{`

`// An interface definition.`

`.class public interface IMyInterface {}`

`// A simple base class.`

`.class public MyBaseClass {}`

`// MyDerivedClass now implements IMyInterface,`

`// and extends MyBaseClass.`

`.class public MyDerivedClass`

`extends MyNamespace.MyBaseClass`

`implements MyNamespace.IMyInterface {}`

`}`

Note

`extends`子句必须在`implements`子句之前。同样，`implements`子句可以包含逗号分隔的接口列表。

正如你在第 9 章中回忆的那样，接口可以作为其他接口类型的基础接口来构建接口层次结构。然而，与您的想法相反，`extends`属性不能用于从接口 b 派生接口 A。`extends`属性仅用于限定类型的基类。当您想要扩展一个接口时，您将再次使用`implements`属性。这里有一个例子:

`// Extending interfaces in terms of CIL.`

`.class public interface IMyInterface {}`

`.class public interface IMyOtherInterface`

`implements MyNamespace.IMyInterface {}`

### 定义 CIL 的结构

如果类型扩展了`System.ValueType`，则`.class`指令可用于定义 CTS 结构。同样，`.class`指令必须用`sealed`属性限定(因为结构永远不能成为其他值类型的基础结构)。如果你试图不这样做，`ilasm.exe`将发布一个编译错误。

`// A structure definition is always sealed.`

`.class public sealed MyStruct`

`extends [mscorlib]System.ValueType{}`

请注意，CIL 提供了一种定义结构类型的简写符号。如果您使用`value`属性，新类型将自动从`[mscorlib]System.ValueType`派生类型。因此，您可以将`MyStruct`定义如下:

`// Shorthand notation for declaring a structure.`

`.class public sealed value MyStruct{}`

### 在 CIL 定义枚举

。NET 枚举(正如您回忆的那样)派生自`System.Enum`，它是一个`System.ValueType`(因此也必须是密封的)。当你想用 CIL 定义一个枚举时，只需扩展`[mscorlib]System.Enum`，就像这样:

`// An enum.`

`.class public sealed MyEnum`

`extends [mscorlib]System.Enum{}`

像结构定义一样，枚举可以用简写符号使用`enum`属性来定义。这里有一个例子:

`// Enum shorthand.`

`.class public sealed enum MyEnum{}`

稍后您将看到如何指定枚举的名称-值对。

Note

另一个基本原则。NET 类型的委托也有特定的 CIL 表示形式。详见[第 10 章](10.html)。

### 在 CIL 定义仿制药

泛型类型在 CIL 语法中也有特定的表示。回想一下第 9 章中的内容，一个给定的泛型类型或泛型成员可能有一个或多个类型参数。例如，`List<T>`类型只有一个类型参数，而`Dictionary<TKey, TValue>`有两个。就 CIL 而言，类型参数的数量是使用一个向后倾斜的单引号(```)来指定的，后跟一个表示类型参数数量的数值。像 C#一样，类型参数的实际值被放在尖括号内。

Note

在大多数键盘上，您可以在 Tab 键上方的键上(以及 1 键的左侧)找到`字符。

例如，假设您想要创建一个`List<T>`变量，其中`T`的类型是`System.Int32`。在 C#中，您应该键入以下内容:

`void SomeMethod()`

`{`

`List<int> myInts = new List<int>();`

`}`

在 CIL，您将编写以下代码(它可能出现在任何 CIL 方法范围内):

`// In C#: List<int> myInts = new List<int>();`

`newobj instance void class [mscorlib]`

`System.Collections.Generic.List`1<int32>::.ctor()`

注意，这个泛型类被定义为`List`1<int32>`，因为`List<T>`只有一个类型参数。然而，如果你需要定义一个`Dictionary<string, int>`类型，你可以这样做:

`// In C#: Dictionary<string, int> d = new Dictionary<string, int>();`

`newobj instance void class [mscorlib]`

`System.Collections.Generic.Dictionary`2<string,int32>::.ctor()`

作为另一个示例，如果您有一个使用另一个泛型类型作为类型参数的泛型类型，您将编写如下所示的 CIL 代码:

`// In C#: List<List<int>> myInts = new List<List<int>>();`

`newobj instance void class [mscorlib]`

`System.Collections.Generic.List`1<class`

`[mscorlib]System.Collections.Generic.List`1<int32>>::.ctor()`

### 编译 CILTypes.il 文件

即使您还没有向您定义的类型添加任何成员或实现代码，您也能够将这个`*.il`文件编译成一个. NET DLL 程序集(您必须这样做，因为您还没有指定一个`Main()`方法)。打开命令提示符，向`ilasm.exe`输入以下命令:

`ilasm /dll CilTypes.il`

这样做之后，现在可以将编译后的程序集打开到`ildasm.exe`中来验证每个类型的创建。确认了程序集的内容后，对其运行`peverify.exe`,如下所示:

`peverify CilTypes.dll`

请注意，如果您的所有类型都完全为空，那么您会收到错误。以下是部分输出:

`Microsoft (R) .NET Framework PE Verifier. Version 4.0.30319.33440`

`Copyright (c) Microsoft Corporation. All rights reserved.`

`[MD]: Error: Value class has neither fields nor size parameter. [token:0x02000005]`

`[MD]: Error: Enum has no instance field. [token:0x02000006]`

`...`

要理解如何用内容填充类型，首先需要研究 CIL 的基本数据类型。

## 。NET 基类库、C#和 CIL 数据类型映射

表 [18-4](#Tab4) 说明了. NET 基类类型如何映射到相应的 C#关键字，以及每个 C#关键字如何映射到原始 CIL。同样，表 [18-4](#Tab4) 记录了用于每种 CIL 类型的简写常数符号。正如你马上会看到的，这些常量经常被许多 CIL 操作码引用。

表 18-4。

Mapping .NET Base Class Types to C# Keywords, and C# Keywords to CIL

<colgroup><col> <col> <col> <col></colgroup> 
| 。NET 基类类型 | C#关键字 | CIL 代表 | CIL 常量符号 |
| --- | --- | --- | --- |
| `System.SByte` | `sbyte` | `int8` | `I1` |
| `System.Byte` | `byte` | `unsigned int8` | `U1` |
| `System.Int16` | `short` | `int16` | `I2` |
| `System.UInt16` | `ushort` | `unsigned int16` | `U2` |
| `System.Int32` | `int` | `int32` | `I4` |
| `System.UInt32` | `uint` | `unsigned int32` | `U4` |
| `System.Int64` | `long` | `int64` | `I8` |
| `System.UInt64` | `ulong` | `unsigned int64` | `U8` |
| `System.Char` | `char` | `char` | `CHAR` |
| `System.Single` | `float` | `float32` | `R4` |
| `System.Double` | `double` | `float64` | `R8` |
| `System.Boolean` | `bool` | `bool` | `BOOLEAN` |
| `System.String` | `string` | `string` | 不适用的 |
| `System.Object` | `object` | `object` | 不适用的 |
| `System.Void` | `void` | `void` | `VOID` |

Note

`System.IntPtr`和`System.UIntPtr`类型映射到本机`int`和本机`unsigned int`(知道这一点很好，因为许多 COM 互操作性和 P/Invoke 场景广泛使用这些)。

## 在 CIL 中定义类型成员

正如你已经知道的。NET 类型可以支持各种成员。枚举有一些名称-值对。结构和类可能有构造函数、字段、方法、属性、静态成员等等。在本书的前 17 章中，您已经看到了前面提到的项目的部分 CIL 定义，但是，这里还是快速回顾一下各种成员如何映射到 CIL 原语。

### 定义 CIL 的字段数据

枚举、结构和类都可以支持字段数据。在每种情况下，都将使用`.field`指令。例如，让我们给骨架`MyEnum`枚举注入一些活力，并定义以下三个名称-值对(注意这些值是在括号内指定的):

`.class public sealed enum MyEnum`

`{`

`.field public static literal valuetype`

`MyNamespace.MyEnum A = int32(0)`

`.field public static literal valuetype`

`MyNamespace.MyEnum B = int32(1)`

`.field public static literal valuetype`

`MyNamespace.MyEnum C = int32(2)`

`}`

使用`static`和`literal`属性限定. NET `System.Enum`派生类型范围内的字段。正如您所猜测的，这些属性将字段数据设置为可从类型本身访问的固定值(例如，`MyEnum.A`)。

Note

分配给枚举值的值也可以是带有`0x`前缀的十六进制值。

当然，当您想要在类或结构中定义一个字段数据点时，您并不局限于一个公共静态文本数据点。例如，您可以更新`MyBaseClass`来支持两点私有的、实例级的字段数据，设置为默认值:

`.class public MyBaseClass`

`{`

`.field private string stringField = "hello!"`

`.field private int32 intField = int32(42)`

`}`

与 C#一样，类字段数据将自动初始化为适当的默认值。如果您希望允许对象用户在创建私有字段数据的每个点时提供自定义值，您(当然)需要创建自定义构造函数。

### 在 CIL 中定义类型构造函数

CTS 支持实例级和类级(静态)构造函数。根据 CIL，实例级构造函数使用`.ctor`标记表示，而静态级构造函数通过`.cctor`(类构造函数)表示。这两个 CIL 令牌都必须使用`rtspecialname`(返回类型特殊名称)和`specialname`属性来限定。简而言之，这些属性用于标识一个特定的 CIL 令牌，该令牌可以由给定的。NET 语言。例如，在 C#中，构造函数不定义返回类型；然而，就 CIL 而言，构造函数的返回值确实是`void`。

`.class public MyBaseClass`

`{`

`.field private string stringField`

`.field private int32 intField`

`.method public hidebysig specialname rtspecialname`

`instance void .ctor(string s, int32 i) cil managed`

`{`

`// TODO: Add implementation code...`

`}`

`}`

注意，`.ctor`指令已经用`instance`属性限定了(因为它不是一个静态构造函数)。`cil managed`属性表示该方法的范围包含 CIL 代码，而不是非托管代码，这些代码可能会在平台调用请求期间使用。

### 在 CIL 定义属性

属性和方法也有特定的 CIL 表示。举例来说，如果`MyBaseClass`被更新以支持名为`TheString`的公共属性，您将编写以下 CIL(再次注意`specialname`属性的使用):

`.class public MyBaseClass`

`{`

`...`

`.method public hidebysig specialname`

`instance string get_TheString() cil managed`

`{`

`// TODO: Add implementation code...`

`}`

`.method public hidebysig specialname`

`instance void set_TheString(string ’value’) cil managed`

`{`

`// TODO: Add implementation code...`

`}`

`.property instance string TheString()`

`{`

`.get instance string`

`MyNamespace.MyBaseClass::get_TheString()`

`.set instance void`

`MyNamespace.MyBaseClass::set_TheString(string)`

`}`

`}`

根据 CIL，一个属性映射到一对带有前缀`get_`和`set_`的方法。`.property`指令利用相关的`.get`和`.set`指令将属性语法映射到正确的“专门命名的”方法。

Note

请注意，属性的`set`方法的传入参数放在单引号中，单引号表示在方法范围内赋值运算符右侧使用的标记的名称。

### 定义成员参数

简而言之，在 CIL 中指定参数(或多或少)与在 C#中相同。例如，每个参数都是通过指定其数据类型，后跟参数名称来定义的。此外，像 C#一样，CIL 提供了一种定义输入、输出和按引用传递参数的方法。同样，CIL 允许你定义一个参数数组实参(又名 C# `params`关键字)，以及可选的参数。

为了说明在原始 CIL 中定义参数的过程，假设您想要构建一个方法，该方法采用一个`int32`(按值)、一个`int32`(按引用)、一个`[mscorlib]System.Collection.ArrayList`和一个单一输出参数(类型为`int32`)。就 C#而言，此方法类似于以下内容:

`public static void MyMethod(int inputInt,`

`ref int refInt, ArrayList ar, out int outputInt)`

`{`

`outputInt = 0; // Just to satisfy the C# compiler...`

`}`

如果您将这个方法映射到 CIL 术语中，您会发现 C#引用参数用一个&符号(`&`)标记，其后缀是参数的基础数据类型(`int32&`)。

输出参数也使用`&`后缀，但是它们使用 CIL `[out]`标记进一步限定。还要注意，如果参数是引用类型(在本例中是`[mscorlib]System.Collections.ArrayList`类型)，那么`class`标记将作为数据类型的前缀(不要与`.class`指令混淆！).

`.method public hidebysig static void MyMethod(int32 inputInt,`

`int32& refInt,`

`class [mscorlib]System.Collections.ArrayList ar,`

`[out] int32& outputInt) cil managed`

`{`

`...`

`}`

## 检查 CIL 操作码

你将在本章研究的 CIL 代码的最后一个方面与各种操作码(操作码)的作用有关。回想一下，操作码只是一个 CIL 令牌，用于为给定成员构建实现逻辑。完整的 CIL 操作码集(相当大)可以分为以下几大类:

*   控制程序流程的操作码
*   计算表达式的操作码
*   访问内存值的操作码(通过参数、局部变量等。)

为了通过 CIL 提供对成员实现世界的一些洞察，表 [18-5](#Tab5) 定义了一些更有用的操作码，这些操作码与成员实现逻辑直接相关，按相关功能分组。

表 18-5。

Various Implementation-Specific CIL Opcodes

<colgroup><col> <col></colgroup> 
| 操作码 | 生命的意义 |
| --- | --- |
| `add`、`sub`、`mul`、`div`、`rem` | 这些 CIL 操作码允许你加、减、乘、除两个值(`rem`返回除法运算的余数)。 |
| `and`、`or`、`not`、`xor` | 这些 CIL 操作码允许您对两个值执行逐位运算。 |
| `ceq`、`cgt`、`clt` | 这些 CIL 操作码允许你以不同的方式比较堆栈上的两个值。这里有一个例子: |
|   | `ceq`:比较是否相等 |
|   | `cgt`:比较大于 |
|   | `clt`:比较小于 |
| `box`，`unbox` | 这些 CIL 操作码用于在引用类型和值类型之间进行转换。 |
| `ret` | 这个 CIL 操作码用于退出一个方法并向调用者返回值(如果需要的话)。 |
| `beq`、`bgt`、`ble`、`blt`、`switch` | 这些 CIL 操作码(以及许多其他相关操作码)用于控制方法内的分支逻辑。这里有一个例子: |
|   | `beq`:如果相等，则断开代码标签 |
|   | `bgt`:如果大于，则断开代码标签 |
|   | `ble`:如果小于或等于，则中断到代码标签 |
|   | `blt`:如果小于，则中断到代码标签 |
|   | 所有以分支为中心的操作码都要求您指定一个 CIL 代码标签，以便在测试结果为真时跳转到该标签。 |
| `call` | 这个 CIL 操作码用于调用给定类型的成员。 |
| `newarr`，`newobj` | 这些 CIL 操作码允许你分配一个新的数组或新的对象类型到内存中。 |

下一大类 CIL 操作码(其子集如表 [18-6](#Tab6) 所示)用于将参数加载(推送)到虚拟执行堆栈上。请注意这些特定于加载的操作码是如何使用`ld` (load)前缀的。

表 18-6。

The Primary Stack-Centric Opcodes of CIL

<colgroup><col> <col></colgroup> 
| 操作码 | 生命的意义 |
| --- | --- |
| `ldarg`(变化多端) | 将方法的参数加载到堆栈上。除了一般的`ldarg`(它与标识参数的给定索引一起工作)，还有许多其他的变化。 |
|   | 例如，`ldarg`带有数字后缀(`ldarg_0`)的操作码硬编码加载哪个参数。同样，`ldarg`操作码的变体允许您使用表 [18-4](#Tab4) ( `ldarg_I4`，对于`int32`)中所示的 CIL 常数符号硬编码数据类型，以及数据类型和值(`ldarg_I4_5`，用值`5`加载`int32`)。 |
| `ldc`(变化多端) | 将常数值加载到堆栈上。 |
| `ldfld`(变化多端) | 将实例级字段的值加载到堆栈上。 |
| `ldloc`(变化多端) | 将局部变量的值加载到堆栈上。 |
| `ldobj` | 获取由基于堆的对象收集的所有值，并将它们放在堆栈上。 |
| `ldstr` | 将字符串值加载到堆栈上。 |

除了加载特定的操作码集，CIL 提供了许多操作码，显式弹出栈顶值。如本章前几个例子所示，从堆栈中弹出一个值通常涉及到将该值存储到临时本地存储中以备将来使用(如即将到来的方法调用的参数)。鉴于此，请注意有多少从虚拟执行堆栈中弹出当前值的操作码带有`st`(存储)前缀。表 [18-7](#Tab7) 击中亮点。

表 18-7。

Various Pop-Centric Opcodes

<colgroup><col> <col></colgroup> 
| 操作码 | 生命的意义 |
| --- | --- |
| `pop` | 移除当前位于计算堆栈顶部的值，但不存储该值 |
| `starg` | 将堆栈顶部的值存储到指定索引处的方法参数中 |
| `stloc`(变化多端) | 从计算堆栈顶部弹出当前值，并将其存储在指定索引处的局部变量列表中 |
| `stobj` | 将指定类型的值从计算堆栈复制到提供的内存地址中 |
| `stsfld` | 用计算堆栈中的值替换静态字段的值 |

请注意，各种 CIL 操作码将隐式地从堆栈中弹出值来执行手头的任务。例如，如果您试图使用`sub`操作码减去两个数字，应该清楚的是`sub`必须弹出下两个可用值才能执行计算。一旦计算完成，值(surprise，surprise)的结果再次被压入堆栈。

### 那个。maxstack 指令

当您使用原始 CIL 编写方法实现时，您需要注意一个名为`.maxstack`的特殊指令。顾名思义，`.maxstack`建立了在方法执行期间的任何给定时间可以被推到堆栈上的变量的最大数量。好消息是，`.maxstack`指令有一个默认值(`8`，对于您可能正在创作的绝大多数方法来说，这应该是安全的。但是，如果您想显式地定义，您可以手动计算堆栈上局部变量的数量，并显式地定义该值，如下所示:

`.method public hidebysig instance void`

`Speak() cil managed`

`{`

`// During the scope of this method, exactly`

`// 1 value (the string literal) is on the stack.`

`.maxstack 1`

`ldstr "Hello there..."`

`call void [mscorlib]System.Console::WriteLine(string)`

`ret`

`}`

### 在 CIL 声明局部变量

让我们先看看如何声明一个局部变量。假设您想在 CIL 构建一个名为`MyLocalVariables()`的方法，该方法不带参数并返回`void`。在这个方法中，您想要定义三个类型为`System.String`、`System.Int32`和`System.Object`的局部变量。在 C#中，此成员将如下所示(回想一下，局部作用域的变量不接收默认值，应该在进一步使用之前设置为初始状态):

`public static void MyLocalVariables()`

`{`

`string myStr = "CIL code is fun!";`

`int myInt = 33;`

`object myObj = new object();`

`}`

如果您要在 CIL 直接构建`MyLocalVariables()`，您可以编写以下代码:

`.method public hidebysig static void`

`MyLocalVariables() cil managed`

`{`

`.maxstack 8`

`// Define three local variables.`

`.locals init ([0] string myStr, [1] int32 myInt, [2] object myObj)`

`// Load a string onto the virtual execution stack.`

`ldstr "CIL code is fun!"`

`// Pop off current value and store in local variable [0].`

`stloc.0`

`// Load a constant of type "i4"`

`// (shorthand for int32) set to the value 33.`

`ldc.i4 33`

`// Pop off current value and store in local variable [1].`

`stloc.1`

`// Create a new object and place on stack.`

`newobj instance void [mscorlib]System.Object::.ctor()`

`// Pop off current value and store in local variable [2].`

`stloc.2`

`ret`

`}`

如您所见，在原始 CIL 中分配局部变量的第一步是使用`.locals`指令，它与`init`属性成对出现。在相关括号的范围内，您的目标是将一个给定的数字索引与每个变量相关联(在这里被视为`[0]`、`[1]`和`[2]`)。正如您所看到的，每个索引由它的数据类型和一个可选的变量名来标识。定义局部变量后，将值加载到堆栈上(使用各种以加载为中心的操作码)并将值存储在局部变量中(使用各种以存储为中心的操作码)。

### 将参数映射到 CIL 的本地变量

您已经看到了如何使用`.locals init`指令在原始 CIL 中声明局部变量；但是，您还没有看到如何将传入的参数映射到本地方法。考虑下面的静态 C#方法:

`public static int Add(int a, int b)`

`{`

`return a + b;`

`}`

就 CIL 而言，这种看似无辜的方法有很多话要说。首先，必须使用`ldarg`(加载参数)操作码将传入的参数(`a`和`b`)推送到虚拟执行堆栈上。接下来，`add`操作码将用于从堆栈中弹出接下来的两个值，找到总和并将值再次存储在堆栈中。最后，这个总和被弹出堆栈，并通过`ret`操作码返回给调用者。如果你使用`ildasm.exe`反汇编这个 C#方法，你会发现`csc.exe`注入了许多额外的标记，但是 CIL 代码的关键非常简单。

`.method public hidebysig static int32 Add(int32 a,`

`int32 b) cil managed`

`{`

`.maxstack 2`

`ldarg.0 // Load "a" onto the stack.`

`ldarg.1 // Load "b" onto the stack.`

`add     // Add both values.`

`ret`

`}`

### 隐藏此引用

注意，假定虚拟执行堆栈从位置 0 开始索引，那么两个传入参数(`a`和`b`)在 CIL 代码中使用它们的索引位置(索引 0 和索引 1)来引用。

在检查或创作 CIL 代码时要注意的一点是，每个接受传入参数的非静态方法都会自动接收一个隐式附加参数，该参数是对当前对象的引用(想想 C# `this`关键字)。鉴于此，如果`Add()`方法被定义为非静态的，就像这样:

`// No longer static!`

`public int Add(int a, int b)`

`{`

`return a + b;`

`}`

使用`ldarg.1`和`ldarg.2`加载传入的`a`和`b`参数(而不是预期的`ldarg.0`和`ldarg.1`操作码)。同样，原因是槽 0 实际上包含隐式的`this`引用。考虑下面的伪代码:

`// This is JUST pseudo-code!`

`.method public hidebysig static int32 AddTwoIntParams(`

`MyClass_HiddenThisPointer this, int32 a, int32 b) cil managed`

`{`

`ldarg.0 // Load MyClass_HiddenThisPointer onto the stack.`

`ldarg.1 // Load "a" onto the stack.`

`ldarg.2 // Load "b" onto the stack.`

`...`

`}`

### 在 CIL 中表示迭代构造

C#编程语言中的迭代结构使用`for`、`foreach`、`while`和`do`关键字来表示，其中每一个关键字在 CIL 中都有特定的表示。考虑下面这个经典的`for`循环:

`public static void CountToTen()`

`{`

`for(int i = 0; i < 10; i++)`

`;`

`}`

现在，您可能还记得，`br`操作码(`br`、`blt`等等)用于在满足某些条件时控制流程中断。在本例中，您已经设置了一个条件，当本地变量`i`等于或大于值 10 时，`for`循环应该中断。每次通过时，值 1 被加到`i`，此时再次评估测试条件。

还记得当您使用任何 CIL 分支操作码时，您将需要定义一个特定的代码标签(或两个)来标记当条件确实为真时跳转到的位置。考虑到这几点，思考下面通过`ildasm.exe`生成的(扩充的)CIL 代码(包括自动生成的代码标签):

`.method public hidebysig static void CountToTen() cil managed`

`{`

`.maxstack 2`

`.locals init ([0] int32 i) // Init the local integer "i".`

`IL_0000: ldc.i4.0          // Load this value onto the stack.`

`IL_0001: stloc.0           // Store this value at index "0".`

`IL_0002: br.s IL_0008      // Jump to IL_0008.`

`IL_0004: ldloc.0           // Load value of variable at index 0.`

`IL_0005: ldc.i4.1          // Load the value "1" on the stack.`

`IL_0006: add               // Add current value on the stack at index 0.`

`IL_0007: stloc.0`

`IL_0008: ldloc.0           // Load value at index "0".`

`IL_0009: ldc.i4.s 10       // Load value of "10" onto the stack.`

`IL_000b: blt.s IL_0004     // Less than? If so, jump back to IL_0004`

`IL_000d: ret`

`}`

简而言之，这段 CIL 代码从定义局部变量`int32`并将其加载到堆栈开始。此时，您在代码标签`IL_0008`和`IL_0004`之间来回跳转，每次将`i`的值增加 1，并测试`i`是否仍然小于值 10。如果是，则退出该方法。

Source Code

CilTypes 示例包含在 [`Chapter 18`](18.html) 子目录中。

## 用 CIL 构建. NET 程序集

既然您已经浏览了 raw CIL 的语法和语义，是时候巩固您当前的理解了，只需使用`ilasm.exe`和您选择的文本编辑器构建一个. NET 应用程序。具体来说，您的应用程序将由一个私有部署的、包含两个类类型定义的单文件`*.dll`和一个与这些类型交互的基于控制台的`*.exe`组成。

### 建设 CILCars.dll

首要任务是构建供客户端使用的`*.dll`。打开一个文本编辑器，创建一个名为`CILCars.il`的新`*.il`文件。这个单文件程序集将使用两个外部。NET 程序集。首先更新您的代码文件，如下所示:

`// Reference mscorlib.dll and`

`// System.Windows.Forms.dll.`

`.assembly extern mscorlib`

`{`

`.publickeytoken = (B7 7A 5C 56 19 34 E0 89 )`

`.ver 4:0:0:0`

`}`

`.assembly extern System.Windows.Forms`

`{`

`.publickeytoken = (B7 7A 5C 56 19 34 E0 89 )`

`.ver 4:0:0:0`

`}`

`// Define the single-file assembly.`

`.assembly CILCars`

`{`

`.hash algorithm 0x00008004`

`.ver 1:0:0:0`

`}`

`.module CILCars.dll`

这个程序集将包含两个类类型。第一种类型`CILCar`，定义了两个字段数据点(为了简单起见，本例中为 public)和一个自定义构造函数。第二种类型`CILCarInfo`，定义了一个名为`Display()`的静态方法，该方法将`CILCar`作为参数并返回`void`。这两种类型都在`CILCars`名称空间中。就 CIL 而言，`CILCar`可以实现如下:

`// Implementation of CILCars.CILCar type.`

`.namespace CILCars`

`{`

`.class public auto ansi beforefieldinit CILCar`

`extends [mscorlib]System.Object`

`{`

`// The field data of the CILCar.`

`.field public string petName`

`.field public int32 currSpeed`

`// The custom constructor simply allows the caller`

`// to assign the field data.`

`.method public hidebysig specialname rtspecialname`

`instance void .ctor(int32 c, string p) cil managed`

`{`

`.maxstack 8`

`// Load first arg onto the stack and call base class ctor.`

`ldarg.0 // "this" object, not the int32!`

`call instance void [mscorlib]System.Object::.ctor()`

`// Now load first and second args onto the stack.`

`ldarg.0 // "this" object`

`ldarg.1 // int32 arg`

`// Store topmost stack (int 32) member in currSpeed field.`

`stfld int32 CILCars.CILCar::currSpeed`

`// Load string arg and store in petName field.`

`ldarg.0 // "this" object`

`ldarg.2 // string arg`

`stfld string CILCars.CILCar::petName`

`ret`

`}`

`}`

`}`

请记住，任何非静态成员的真正的第一个参数是当前对象引用，CIL 的第一个块只是加载对象引用并调用基类构造函数。接下来，将传入的构造函数参数推送到堆栈上，并使用`stfld`(存储在字段中)操作码将它们存储到类型的字段数据中。

现在让我们实现这个名称空间中的第二种类型:`CILCarInfo`。类型的肉在静态的`Display()`方法中找到。简而言之，该方法的作用是获取传入的`CILCar`参数，提取其字段数据的值，并将其显示在 Windows 窗体消息框中。下面是`CILCarInfo`(应该在`CILCars`名称空间中定义)的完整实现，分析如下:

`.class public auto ansi beforefieldinit CILCarInfo`

`extends [mscorlib]System.Object`

`{`

`.method public hidebysig static void`

`Display(class CILCars.CILCar c) cil managed`

`{`

`.maxstack 8`

`// We need a local string variable.`

`.locals init ([0] string caption)`

`// Load string and the incoming CILCar onto the stack.`

`ldstr "{0}’s speed is:"`

`ldarg.0`

`// Now place the value of the CILCar’s petName on the`

`// stack and call the static String.Format() method.`

`ldfld string CILCars.CILCar::petName`

`call string [mscorlib]System.String::Format(string, object)`

`stloc.0`

`// Now load the value of the currSpeed field and get its string`

`// representation (note call to ToString()).`

`ldarg.0`

`ldflda int32 CILCars.CILCar::currSpeed`

`call instance string [mscorlib]System.Int32::ToString()`

`ldloc.0`

`// Now call the MessageBox.Show() method with loaded values.`

`call valuetype [System.Windows.Forms]`

`System.Windows.Forms.DialogResult`

`[System.Windows.Forms]`

`System.Windows.Forms.MessageBox::Show(string, string)`

`pop`

`ret`

`}`

`}`

尽管 CIL 代码的数量比你在`CILCar`的实现中看到的要多一点，但事情仍然相当简单。首先，假设您正在定义一个静态方法，您不必关心隐藏对象引用(因此，`ldarg.0`操作码确实加载了传入的`CILCar`参数)。

该方法首先将一个字符串(`"{0}’s speed is"`)加载到堆栈上，然后是`CILCar`参数。这两个值就位后，您加载`petName`字段的值并调用静态的`System.String.Format()`方法，用`CILCar`的昵称替换花括号占位符。

当处理`currSpeed`字段时，发生相同的一般过程，但是注意，您使用了`ldflda`操作码，它将参数地址加载到堆栈上。此时，您调用`System.Int32.ToString()`将该地址的值转换为字符串类型。最后，在两个字符串都根据需要格式化之后，您调用`MessageBox.Show()`方法。

此时，您可以通过以下命令使用`ilasm.exe`编译新的`*.dll`:

`ilasm /dll CILCars.il`

并使用`peverify.exe`验证包含的 CIL，如下所示:

`peverify CILCars.dll`

### 建设 CILCarClient.exe

现在，您可以用一个`Main()`方法构建一个简单的`*.exe`程序集，它将执行以下操作:

*   制作一个`CILCar`对象
*   将对象传递给静态的`CILCarInfo.Display()`方法

创建一个名为`CarClient.il`的新文件，并定义对`mscorlib.dll`和`CILCars.dll`的外部引用(不要忘记放置一个副本。NET 程序集在客户端的应用程序目录中！).接下来，定义一个操纵`CILCars.dll`组件的单一类型(`Program`)。下面是完整的代码:

`// External assembly refs.`

`.assembly extern mscorlib`

`{`

`.publickeytoken = (B7 7A 5C 56 19 34 E0 89)`

`.ver 4:0:0:0`

`}`

`.assembly extern CILCars`

`{`

`.ver 1:0:0:0`

`}`

`// Our executable assembly.`

`.assembly CarClient`

`{`

`.hash algorithm 0x00008004`

`.ver 1:0:0:0`

`}`

`.module CarClient.exe`

`// Implementation of Program type.`

`.namespace CarClient`

`{`

`.class private auto ansi beforefieldinit Program`

`extends [mscorlib]System.Object`

`{`

`.method private hidebysig static void`

`Main(string[] args) cil managed`

`{`

`// Marks the entry point of the *.exe.`

`.entrypoint`

`.maxstack 8`

`// Declare a local CILCar variable and push`

`// values onto the stack for ctor call.`

`.locals init ([0] class`

`[CILCars]CILCars.CILCar myCilCar)`

`ldc.i4 55`

`ldstr "Junior"`

`// Make new CilCar; store and load reference.`

`newobj instance void`

`[CILCars]CILCars.CILCar::.ctor(int32, string)`

`stloc.0`

`ldloc.0`

`// Call Display() and pass in topmost value on stack.`

`call void [CILCars]`

`CILCars.CILCarInfo::Display(`

`class [CILCars]CILCars.CILCar)`

`ret`

`}`

`}`

`}`

需要指出的一个操作码是`.entrypoint`。回想一下本章前面的讨论，这个操作码用于标记`*.exe`的哪个方法作为模块的入口点。事实上，鉴于`.entrypoint`是 CLR 识别要执行的初始方法的方式，这个方法可以被称为任何东西，尽管这里您使用的是标准方法名`Main()`。在`Main()`方法中找到的 CIL 代码的剩余部分是你基本的基于堆栈的值的推送和弹出。

但是，请注意，`CILCar`对象的创建涉及到`newobj`操作码的使用。与此相关，回想一下，当您想使用原始 CIL 调用类型的成员时，您使用双冒号语法，并且一如既往地使用类型的完全限定名。这样，你可以用`ilasm.exe`编译你的新文件，用`peverify.exe`验证你的汇编，并执行你的程序。在命令提示符下发出以下命令:

`ilasm CarClient.il`

`peverify CarClient.exe`

`CarClient.exe`

Source Code

CilCars 示例包含在 [`Chapter 18`](18.html) 子目录中。

## 了解动态程序集

可以肯定的是，建造一个综合体的过程。在 CIL 使用. NET 应用程序将是一件非常愉快的事情。一方面，CIL 是一种极具表现力的编程语言，它允许你与 cts 允许的所有编程结构进行交互。另一方面，创作原始 CIL 是单调乏味、容易出错和痛苦的。诚然，知识就是力量，但你可能真的想知道记住 CIL 语法法则有多重要。答案是，“看情况。”可以肯定的是，你的大部分。NET 编程工作不需要您查看、编辑或创作 CIL 代码。然而，有了 CIL 初级读本，你现在可以研究动态程序集的世界(相对于静态程序集)和`System.Reflection.Emit`名称空间的角色了。

你可能有的第一个问题是，“静态和动态程序集之间到底有什么区别？”根据定义，静态程序集是。NET 二进制文件直接从磁盘存储中加载，这意味着当 CLR 请求它们时，它们位于硬盘上的某个物理文件中(或者在多文件程序集的情况下可能是一组文件)。正如你可能猜到的，每次你编译你的 C#源代码，你都会得到一个静态汇编。

另一方面，动态程序集是使用由`System.Reflection.Emit`名称空间提供的类型在内存中动态创建的。`System.Reflection.Emit`名称空间使得在运行时创建一个程序集及其模块、类型定义和 CIL 实现逻辑成为可能。完成之后，您就可以将内存中的二进制文件保存到磁盘上了。这当然会产生一个新的静态程序集。可以肯定的是，使用`System.Reflection.Emit`命名空间构建动态程序集的过程确实需要对 CIL 操作码的本质有一定程度的理解。

尽管创建动态程序集是一项相当高级(且不常见)的编程任务，但它们在各种情况下都很有用。这里有一个例子:

*   您正在构建一个需要根据用户输入按需生成程序集的. NET 编程工具。
*   您正在构建一个程序，该程序需要根据获得的元数据动态生成远程类型的代理。
*   您希望加载静态程序集并将新类型动态插入二进制映像。

话虽如此，我们还是来看看`System.Reflection.Emit`内的类型。

### 探索系统。Reflection.Emit 命名空间

创建一个动态程序集需要你对 CIL 操作码有一些熟悉，但是`System.Reflection.Emit`命名空间的类型尽可能地隐藏了 CIL 的复杂性。例如，与其直接指定必要的 CIL 指令和属性来定义类类型，不如直接使用`TypeBuilder`类。同样，如果您想定义一个新的实例级构造函数，您不需要发出`specialname`、`rtspecialname`或`.ctor`标记；相反，你可以使用`ConstructorBuilder`。表 [18-8](#Tab8) 记录了`System.Reflection.Emit`名称空间的关键成员。

表 18-8。

Select Members of the System.Reflection.Emit Namespace

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `AssemblyBuilder` | 用于在运行时创建一个装配(`*.dll`或`*.exe`)。`*.exe` s 必须调用`ModuleBuilder.SetEntryPoint()`方法来设置作为模块入口点的方法。如果没有指定入口点，将会生成一个`*.dll`。 |
| `ModuleBuilder` | 用于定义当前程序集中的模块集。 |
| `EnumBuilder` | 用于创建. NET 枚举类型。 |
| `TypeBuilder` | 可用于在运行时在模块内创建类、接口、结构和委托。 |
| `MethodBuilder LocalBuilder PropertyBuilder FieldBuilder ConstructorBuilder CustomAttributeBuilder ParameterBuilder EventBuilder` | 用于在运行时创建类型成员(如方法、局部变量、属性、构造函数和特性)。 |
| `ILGenerator` | 向给定的类型成员发出 CIL 操作码。 |
| `OpCodes` | 提供了许多映射到 CIL 操作码的字段。该类型与`System.Reflection.Emit.ILGenerator`的各种成员一起使用。 |

一般来说，`System.Reflection.Emit`名称空间的类型允许您在动态程序集的构造过程中以编程方式表示原始 CIL 标记。您将在下面的示例中看到许多这样的成员；然而，`ILGenerator`型值得一试。

### 系统的作用。Reflection.Emit.ILGenerator

顾名思义，`ILGenerator`类型的作用是将 CIL 操作码注入给定的类型成员。但是，您不能直接创建`ILGenerator`对象，因为这种类型没有公共构造函数；相反，您通过调用以构建者为中心的类型的特定方法(例如`MethodBuilder`和`ConstructorBuilder`类型)来接收一个`ILGenerator`类型。这里有一个例子:

`// Obtain an ILGenerator from a ConstructorBuilder`

`// object named "myCtorBuilder".`

`ConstructorBuilder myCtorBuilder =`

`new ConstructorBuilder(/* ...various args... */);`

`ILGenerator myCILGen = myCtorBuilder.GetILGenerator();`

一旦你手中有了一个`ILGenerator`，你就可以用任何方法发出原始的 CIL 操作码。表 [18-9](#Tab9) 记录了`ILGenerator`的一些(但不是全部)方法。

表 18-9。

Various Methods of `ILGenerator`

<colgroup><col> <col></colgroup> 
| 方法 | 生命的意义 |
| --- | --- |
| `BeginCatchBlock()` | 开始一个`catch`块 |
| `BeginExceptionBlock()` | 开始异常的异常范围 |
| `BeginFinallyBlock()` | 开始一个`finally`块 |
| `BeginScope()` | 开始词法范围 |
| `DeclareLocal()` | 声明一个局部变量 |
| `DefineLabel()` | 声明一个新标签 |
| `Emit()` | 被重载多次，以允许您发出 CIL 操作码 |
| `EmitCall()` | 将一个`call`或`callvirt`操作码推入 CIL 流 |
| `EmitWriteLine()` | 用不同类型的值发出对`Console.WriteLine()`的调用 |
| `EndExceptionBlock()` | 结束异常块 |
| `EndScope()` | 结束词法范围 |
| `ThrowException()` | 发出引发异常的指令 |
| `UsingNamespace()` | 指定用于计算当前活动词法范围的局部变量和监视器的命名空间 |

`ILGenerator`的关键方法是`Emit()`，它与`System.Reflection.Emit.OpCodes`类类型一起工作。正如本章前面提到的，这种类型公开了大量映射到原始 CIL 操作码的只读字段。所有这些成员都记录在联机帮助中，您将在接下来的页面中看到各种示例。

### 发出动态程序集

为了说明在运行时定义. NET 程序集的过程，让我们来看一下创建名为`MyAssembly.` `dll`的单文件动态程序集的过程。在这个模块中有一个名为`HelloWorld`的类。`HelloWorld`类支持一个默认的构造函数和一个自定义的构造函数，用来为`string`类型的私有成员变量(`theMessage`)赋值。此外，`HelloWorld`支持一个名为`SayHello()`的公共实例方法，它向标准 I/O 流打印问候，还支持另一个名为`GetMsg()`的实例方法，它返回内部私有字符串。实际上，您将通过编程生成以下类类型:

`// This class will be created at runtime`

`// using System.Reflection.Emit.`

`public class HelloWorld`

`{`

`private string theMessage;`

`HelloWorld() {}`

`HelloWorld(string s) {theMessage = s;}`

`public string GetMsg() {return theMessage;}`

`public void SayHello()`

`{`

`System.Console.WriteLine("Hello from the HelloWorld class!");`

`}`

`}`

假设您已经创建了一个名为 DynamicAsmBuilder 的新 Visual Studio 控制台应用程序项目，并且导入了`System.Reflection`、`System.Reflection.Emit`和`System.Threading`名称空间。在`Program`类中定义名为`CreateMyAsm()`的静态方法。这个单一方法负责以下内容:

*   定义动态程序集的特征(名称、版本等。)
*   实现`HelloClass`类型
*   将内存中的程序集保存到物理文件中

还要注意的是，`CreateMyAsm()`方法将一个`System.AppDomain`类型作为单个参数，这个参数将被用来访问与当前应用程序域相关的`AssemblyBuilder`类型(参见[第 17 章](17.html)。NET 应用程序域)。下面是完整的代码，并附有分析:

`// The caller sends in an AppDomain type.`

`public static void CreateMyAsm(AppDomain curAppDomain)`

`{`

`// Establish general assembly characteristics.`

`AssemblyName assemblyName = new AssemblyName();`

`assemblyName.Name = "MyAssembly";`

`assemblyName.Version = new Version("1.0.0.0");`

`// Create new assembly within the current AppDomain.`

`AssemblyBuilder assembly =`

`curAppDomain.DefineDynamicAssembly(assemblyName,`

`AssemblyBuilderAccess.Save);`

`// Given that we are building a single-file`

`// assembly, the name of the module is the same as the assembly.`

`ModuleBuilder module =`

`assembly.DefineDynamicModule("MyAssembly", "MyAssembly.dll");`

`// Define a public class named "HelloWorld".`

`TypeBuilder helloWorldClass = module.DefineType("MyAssembly.HelloWorld",`

`TypeAttributes.Public);`

`// Define a private String member variable named "theMessage".`

`FieldBuilder msgField =`

`helloWorldClass.DefineField("theMessage", Type.GetType("System.String"),`

`FieldAttributes.Private);`

`// Create the custom ctor.`

`Type[] constructorArgs = new Type[1];`

`constructorArgs[0] = typeof(string);`

`ConstructorBuilder constructor =`

`helloWorldClass.DefineConstructor(MethodAttributes.Public,`

`CallingConventions.Standard,`

`constructorArgs);`

`ILGenerator constructorIL = constructor.GetILGenerator();`

`constructorIL.Emit(OpCodes.Ldarg_0);`

`Type objectClass = typeof(object);`

`ConstructorInfo superConstructor =`

`objectClass.GetConstructor(new Type[0]);`

`constructorIL.Emit(OpCodes.Call, superConstructor);`

`constructorIL.Emit(OpCodes.Ldarg_0);`

`constructorIL.Emit(OpCodes.Ldarg_1);`

`constructorIL.Emit(OpCodes.Stfld, msgField);`

`constructorIL.Emit(OpCodes.Ret);`

`// Create the default ctor.`

`helloWorldClass.DefineDefaultConstructor(MethodAttributes.Public);`

`// Now create the GetMsg() method.`

`MethodBuilder getMsgMethod =`

`helloWorldClass.DefineMethod("GetMsg", MethodAttributes.Public,`

`typeof(string), null);`

`ILGenerator methodIL = getMsgMethod.GetILGenerator();`

`methodIL.Emit(OpCodes.Ldarg_0);`

`methodIL.Emit(OpCodes.Ldfld, msgField);`

`methodIL.Emit(OpCodes.Ret);`

`// Create the SayHello method.`

`MethodBuilder sayHiMethod =`

`helloWorldClass.DefineMethod("SayHello",`

`MethodAttributes.Public, null, null);`

`methodIL = sayHiMethod.GetILGenerator();`

`methodIL.EmitWriteLine("Hello from the HelloWorld class!");`

`methodIL.Emit(OpCodes.Ret);`

`// "Bake" the class HelloWorld.`

`// (Baking is the formal term for emitting the type.)`

`helloWorldClass.CreateType();`

`// (Optionally) save the assembly to file.`

`assembly.Save("MyAssembly.dll");`

`}`

### 发射组件和模块组

方法体首先使用`AssemblyName`和`Version`类型(在`System.Reflection`命名空间中定义)建立关于程序集的最小特征集。接下来，您通过实例级的`AppDomain.DefineDynamicAssembly()`方法获得一个`AssemblyBuilder`类型(回想一下调用者将把一个`AppDomain`引用传递给`CreateMyAsm()`方法)，就像这样:

`// Establish general assembly characteristics`

`// and gain access to the AssemblyBuilder type.`

`public static void CreateMyAsm(AppDomain curAppDomain)`

`{`

`AssemblyName assemblyName = new AssemblyName();`

`assemblyName.Name = "MyAssembly";`

`assemblyName.Version = new Version("1.0.0.0");`

`// Create new assembly within the current AppDomain.`

`AssemblyBuilder assembly =`

`curAppDomain.DefineDynamicAssembly(assemblyName,`

`AssemblyBuilderAccess.Save);`

`...`

`}`

可以看到，在调用`AppDomain.DefineDynamicAssembly()`时，必须指定要定义的程序集的访问模式，最常用的值如表 [18-10](#Tab10) 所示。

表 18-10。

Common Values of the AssemblyBuilderAccess Enumeration

<colgroup><col> <col></colgroup> 
| 价值 | 生命的意义 |
| --- | --- |
| `ReflectionOnly` | 表示动态程序集只能被反射 |
| `Run` | 表示动态程序集可以在内存中执行，但不能保存到磁盘上 |
| `RunAndSave` | 表示动态程序集可以在内存中执行并保存到磁盘 |
| `Save` | 表示动态程序集可以保存到磁盘，但不能在内存中执行 |

下一个任务是为新的程序集定义模块集。假设程序集是一个单文件单元，您只需要定义一个模块。如果您要使用`DefineDynamicModule()`方法构建一个多文件程序集，您将指定一个可选的第二个参数来表示给定模块的名称(例如，`myMod.dotnetmodule`)。但是，当创建单文件程序集时，模块的名称将与程序集本身的名称相同。在任何情况下，一旦`DefineDynamicModule()`方法返回，就会为您提供一个有效的`ModuleBuilder`类型的引用。

`// The single-file assembly.`

`ModuleBuilder module =`

`assembly.DefineDynamicModule("MyAssembly", "MyAssembly.dll");`

### ModuleBuilder 类型的作用

`ModuleBuilder`是动态程序集开发过程中使用的键类型。如您所料，`ModuleBuilder`支持许多成员，这些成员允许您定义给定模块中包含的类型集(类、接口、结构等)。)以及嵌入式资源集(字符串表、图像等)。)包含在内。表 [18-11](#Tab11) 描述了一些以创造为中心的方法。(请注意，每个方法都将向您返回一个相关的类型，该类型表示您想要构造的类型。)

表 18-11。

Select Members of the `ModuleBuilder` Type

<colgroup><col> <col></colgroup> 
| 方法 | 生命的意义 |
| --- | --- |
| `DefineEnum()` | 用于发出. NET 枚举定义 |
| `DefineResource()` | 定义要存储在此模块中的托管嵌入式资源 |
| `DefineType()` | 构造一个`TypeBuilder`，它允许您定义值类型、接口和类类型(包括委托) |

需要注意的`ModuleBuilder`类的关键成员是`DefineType()`。除了指定类型的名称(通过一个简单的字符串)，您还将使用`System.Reflection.TypeAttributes`枚举来描述类型本身的格式。表 [18-12](#Tab12) 列出了`TypeAttributes`枚举的一些(但不是全部)关键成员。

表 18-12。

Select Members of the `TypeAttributes` Enumeration

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `Abstract` | 指定该类型是抽象的 |
| `Class` | 指定该类型是类 |
| `Interface` | 指定该类型是接口 |
| `NestedAssembly` | 指定该类嵌套有程序集可见性，因此只能由其程序集中的方法访问 |
| `NestedFamANDAssem` | 指定该类嵌套有程序集和族可见性，因此只能由位于其族和程序集的交集中的方法访问 |
| `NestedFamily` | 指定该类是用族可见性嵌套的，因此只能由它自己的类型和任何子类型中的方法访问 |
| `NestedFamORAssem` | 指定该类是用族或程序集可见性嵌套的，因此只能由位于其族和程序集的联合中的方法访问 |
| `NestedPrivate` | 指定该类嵌套有私有可见性 |
| `NestedPublic` | 指定该类嵌套有公共可见性 |
| `NotPublic` | 指定该类不是公共的 |
| `Public` | 指定该类是公共的 |
| `Sealed` | 指定该类是具体的，不能扩展 |
| `Serializable` | 指定该类可以序列化 |

### 发出 HelloClass 类型和字符串成员变量

现在您已经对`ModuleBuilder.CreateType()`方法的作用有了更好的理解，让我们看看如何发出公共`HelloWorld`类类型和私有字符串变量。

`// Define a public class named "MyAssembly.HelloWorld".`

`TypeBuilder helloWorldClass = module.DefineType("MyAssembly.HelloWorld",`

`TypeAttributes.Public);`

`// Define a private String member variable named "theMessage".`

`FieldBuilder msgField =`

`helloWorldClass.DefineField("theMessage",`

`Type.GetType("System.String"),`

`FieldAttributes.Private);`

注意`TypeBuilder.DefineField()`方法如何提供对`FieldBuilder`类型的访问。`TypeBuilder`类还定义了提供对其他“构建器”类型访问的其他方法。例如，`DefineConstructor()`返回一个`ConstructorBuilder`，`DefineProperty()`返回一个`PropertyBuilder`，以此类推。

### 发出构造函数

如前所述，`TypeBuilder.DefineConstructor()`方法可以用来为当前类型定义一个构造函数。然而，当实现`HelloClass`的构造函数时，您需要将原始的 CIL 代码注入构造函数体，它负责将传入的参数分配给内部私有字符串。为了获得一个`ILGenerator`类型，您从您引用的相应“构建器”类型(在本例中是`ConstructorBuilder`类型)中调用`GetILGenerator()`方法。

`ILGenerator`类的`Emit()`方法是负责将 CIL 放入成员实现的实体。`Emit()`本身经常使用`OpCodes`类类型，它使用只读字段公开 CIL 的操作码集。例如，`OpCodes.Ret`表示方法调用的返回，`OpCodes.Stfld`对成员变量赋值，`OpCodes.` `Call`用于调用给定的方法(在本例中，是基类构造函数)。也就是说，思考下面的构造函数逻辑:

`// Create the` `custom constructor taking`

`// a single System.String argument.`

`Type[] constructorArgs = new Type[1];`

`constructorArgs[0] = typeof(string);`

`ConstructorBuilder constructor =`

`helloWorldClass.DefineConstructor(MethodAttributes.Public,`

`CallingConventions.Standard, constructorArgs);`

`// Now emit the necessary CIL into the ctor.`

`ILGenerator constructorIL = constructor.GetILGenerator();`

`constructorIL.Emit(OpCodes.Ldarg_0);`

`Type objectClass = typeof(object);`

`ConstructorInfo superConstructor = objectClass.GetConstructor(new Type[0]);`

`constructorIL.Emit(OpCodes.Call, superConstructor); // Call base class ctor.`

`// Load the object’s "this" pointer on the stack.`

`constructorIL.Emit(OpCodes.Ldarg_0);`

`// Load incoming argument on virtual stack and store in msgField.`

`constructorIL.Emit(OpCodes.Ldarg_1);`

`constructorIL.Emit(OpCodes.Stfld, msgField); // Assign msgField.`

`constructorIL.Emit(OpCodes.Ret);             // Return.`

现在，如您所知，一旦您为类型定义了自定义构造函数，默认构造函数就会被自动移除。要重新定义无参数构造函数，只需调用`TypeBuilder`类型的`DefineDefaultConstructor()`方法，如下所示:

`// Reinsert the default ctor.`

`helloWorldClass.DefineDefaultConstructor(MethodAttributes.Public);`

这个调用发出了用于定义默认构造函数的标准 CIL 代码。

`.method public hidebysig specialname rtspecialname`

`instance void .ctor() cil managed`

`{`

`.maxstack 1`

`ldarg.0`

`call instance void [mscorlib]System.Object::.ctor()`

`ret`

`}`

### 发出 SayHello()方法

最后但同样重要的是，让我们检查一下发出`SayHello()`方法的过程。第一个任务是从`helloWorldClass`变量中获取一个`MethodBuilder`类型。这样做之后，定义方法并获得底层的`ILGenerator`来注入 CIL 指令，如下所示:

`// Create the SayHello method.`

`MethodBuilder sayHiMethod =`

`helloWorldClass.DefineMethod("SayHello",`

`MethodAttributes.Public, null, null);`

`methodIL = sayHiMethod.GetILGenerator();`

`// Write a line to the Console.`

`methodIL.EmitWriteLine("Hello from the HelloWorld class!");`

`methodIL.Emit(OpCodes.Ret);`

在这里，您已经建立了一个公共方法(`MethodAttributes.Public`)，它不接受任何参数，也不返回任何内容(由包含在`DefineMethod()`调用中的空条目标记)。也注意到了`EmitWriteLine()`的称呼。这个`ILGenerator`类的助手成员自动地向标准输出写了一行，最大限度地减少了麻烦。

### 使用动态生成的程序集

既然已经有了创建和保存程序集的逻辑，那么所需要的就是一个类来触发逻辑。回到原点，假设您当前的项目定义了第二个名为`AsmReader`的类。`Main()`中的逻辑通过`Thread.GetDomain()`方法获得当前的 AppDomain，该方法将用于托管您将动态创建的程序集。一旦有了引用，就可以调用`CreateMyAsm()`方法。

让事情变得更有趣一点，在对`CreateMyAsm()`的调用返回后，你将练习一些后期绑定(参见[第 15 章](15.html))来将你新创建的程序集加载到内存中，并与`HelloWorld`类的成员进行交互。更新您的`Main()`方法如下:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** The Amazing Dynamic Assembly Builder App *****");`

`// Get the application domain for the current thread.`

`AppDomain curAppDomain = Thread.GetDomain();`

`// Create the dynamic assembly using our helper f(x).`

`CreateMyAsm(curAppDomain);`

`Console.WriteLine("-> Finished creating MyAssembly.dll.");`

`// Now load the new assembly from file.`

`Console.WriteLine("-> Loading MyAssembly.dll from file.");`

`Assembly a = Assembly.Load("MyAssembly");`

`// Get the HelloWorld type.`

`Type hello = a.GetType("MyAssembly.HelloWorld");`

`// Create HelloWorld object and call the correct ctor.`

`Console.Write("-> Enter message to pass HelloWorld class: ");`

`string msg = Console.ReadLine();`

`object[] ctorArgs = new object[1];`

`ctorArgs[0] = msg;`

`object obj = Activator.CreateInstance(hello, ctorArgs);`

`// Call SayHello and show returned string.`

`Console.WriteLine("-> Calling SayHello() via late binding.");`

`MethodInfo mi = hello.GetMethod("SayHello");`

`mi.Invoke(obj, null);`

`// Invoke method.`

`mi = hello.GetMethod("GetMsg");`

`Console.WriteLine(mi.Invoke(obj, null));`

`}`

实际上，您刚刚创建了一个能够创建和执行的. NET 程序集。NET 程序集！这就结束了对 CIL 和动态程序集的作用的研究。我希望这一章加深了你对。NET 类型系统，CIL 的语法和语义，以及 C#编译器如何在编译时处理你的代码。

Source Code

DynamicAsmBuilder 项目包含在 [`Chapter 18`](18.html) 子目录中。

## 摘要

本章概述了 CIL 的语法和语义。与 C#等更高级别的托管语言不同，CIL 不仅定义了一组关键字，还提供了指令(用于定义程序集及其类型的结构)、属性(进一步限定给定的指令)和操作码(用于实现类型成员)。

向您介绍了一些以 CIL 为中心的编程工具，并学习了如何使用往返工程用新的 CIL 指令改变. NET 程序集的内容。此后，您花时间学习了如何建立当前(和引用的)程序集、命名空间、类型和成员。最后，我用一个简单的例子来构建一个. NET 代码库和可执行文件，这个例子只使用了 CIL、命令行工具和一些额外的工作。

最后，您初步了解了创建动态程序集的过程。使用`System.Reflection.Emit`名称空间，可以在运行时在内存中定义一个. NET 程序集。正如您亲眼所见，使用这个特定的 API 需要您详细了解 CIL 代码的语义。虽然构建动态程序集的需求对于大多数人来说肯定不是一项常见的任务。NET 应用程序，对于那些需要构建支持工具和其他编程实用程序的人来说，它会很有用。