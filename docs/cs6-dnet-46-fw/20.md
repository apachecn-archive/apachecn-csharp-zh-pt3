# 20.文件 I/O 和对象序列化

当您创建桌面应用程序时，在用户会话之间保存信息的能力是很常见的。本章从。NET 框架。首要任务是探索在`System.IO`名称空间中定义的核心类型，并学习如何以编程方式修改机器的目录和文件结构。下一个任务是探索读取和写入基于字符、基于二进制、基于字符串和基于内存的数据存储的各种方法。

在您学习了如何使用核心 I/O 类型操作文件和目录之后，您将研究对象序列化的相关主题。您可以使用对象序列化将对象的状态持久化并检索到任何从`System.IO.Stream`派生的类型。当您希望使用各种远程处理技术(如 Windows Communication Foundation)将对象复制到远程计算机时，序列化对象的能力至关重要。然而，序列化本身非常有用，很可能会在您的许多。NET 应用程序(分布式或非分布式)。

Note

为了确保您可以运行本章中的每个示例，请以管理权限启动 Visual Studio(只需右击 VS 图标并选择“以管理员身份运行”)。如果不这样做，在访问计算机文件系统时可能会遇到运行时安全异常。

## 探索系统。IO 命名空间

在...的框架内。NET 中，`System.IO`命名空间是基类库中专门用于基于文件(和基于内存)的输入和输出(I/O)服务的区域。像任何名称空间一样，`System.IO`定义了一组类、接口、枚举、结构和委托，其中大部分可以在`mscorlib.dll`中找到。除了包含在`mscorlib.dll`中的类型之外，`System.dll`程序集还定义了`System.IO`名称空间的其他成员。请注意，所有 Visual Studio 项目都会自动设置对这两个程序集的引用。

`System.IO`名称空间中的许多类型侧重于物理目录和文件的编程操作。但是，其他类型支持从字符串缓冲区以及原始内存位置读取数据和向其中写入数据。表 [20-1](#Tab1) 概述了核心(非抽象)类，提供了`System.IO`中功能的路线图。

表 20-1。

Key Members of the System.IO Namespace

<colgroup><col> <col></colgroup> 
| 非抽象 I/O 类类型 | 生命的意义 |
| --- | --- |
| `BinaryReader BinaryWriter` | 这些类允许您以二进制值的形式存储和检索原始数据类型(整数、布尔值、字符串等等)。 |
| `BufferedStream` | 此类为字节流提供临时存储，您可以在以后提交给存储。 |
| `Directory DirectoryInfo` | 您可以使用这些类来操作机器的目录结构。`Directory`类型使用静态成员公开功能，而`DirectoryInfo`类型从有效的对象引用公开类似的功能。 |
| `DriveInfo` | 该类提供关于给定机器使用的驱动器的详细信息。 |
| `File FileInfo` | 您使用这些类来操作机器的一组文件。`File`类型使用静态成员公开功能，而`FileInfo`类型从有效的对象引用公开类似的功能。 |
| `FileStream` | 这个类为您提供了随机文件访问(例如，搜索功能),数据以字节流的形式表示。 |
| `FileSystemWatcher` | 这个类允许你监视指定目录中外部文件的修改。 |
| `MemoryStream` | 该类提供对存储在内存中而不是物理文件中的流数据的随机访问。 |
| `Path` | 这个类以平台无关的方式对包含文件或目录路径信息的`System.String`类型执行操作。 |
| `StreamWriter StreamReader` | 您可以使用这些类将文本信息存储到(或从)文件中检索。这些类型不支持随机文件访问。 |
| `StringWriter StringReader` | 像`StreamReader` / `StreamWriter`类一样，这些类也处理文本信息。然而，底层存储是一个字符串缓冲区，而不是一个物理文件。 |

除了这些具体的类类型之外，`System.IO`还定义了许多枚举，以及一组抽象类(例如，`Stream`、`TextReader`和`TextWriter`，它们为所有后代定义了一个共享的多态接口。在这一章中，你将会读到许多这种类型的内容。

## 目录(信息)和文件(信息)类型

提供四个类，允许你操作单个文件，以及与机器的目录结构交互。前两种类型，`Directory`和`File`，使用各种静态成员公开创建、删除、复制和移动操作。密切相关的`FileInfo`和`DirectoryInfo`类型公开了与实例级方法相似的功能(因此，必须用`new`关键字分配它们)。在图 [20-1](#Fig1) 中，`Directory`和`File`类直接扩展`System.Object`，而`DirectoryInfo`和`FileInfo`派生自抽象的`FileSystemInfo`类型。

![A978-1-4842-1332-2_20_Fig1_HTML.jpg](img/A978-1-4842-1332-2_20_Fig1_HTML.jpg)

图 20-1。

The `File`- and `Directory`-centric types

`FileInfo`和`DirectoryInfo`通常是获得文件或目录的完整细节(例如，创建时间或读/写能力)的更好选择，因为它们的成员倾向于返回强类型对象。相反，`Directory`和`File`类成员倾向于返回简单的字符串值，而不是强类型对象。然而，这只是一个指导方针；在许多情况下，你可以使用`File` / `FileInfo`或`Directory` / `DirectoryInfo`完成同样的工作。

### 抽象 FileSystemInfo 基类

`DirectoryInfo`和`FileInfo`类型从抽象的`FileSystemInfo`基类接收许多行为。在大多数情况下，您使用`FileSystemInfo`类的成员来发现关于给定文件或目录的一般特征(比如创建时间、各种属性等等)。表 [20-2](#Tab2) 列出了一些感兴趣的核心属性。

表 20-2。

FileSystemInfo Properties

<colgroup><col> <col></colgroup> 
| 财产 | 生命的意义 |
| --- | --- |
| `Attributes` | 获取或设置与当前文件关联的属性，这些属性由`FileAttributes`枚举表示(例如，文件或目录是只读的、加密的、隐藏的还是压缩的？). |
| `CreationTime` | 获取或设置当前文件或目录的创建时间。 |
| `Exists` | 确定给定的文件或目录是否存在。 |
| `Extension` | 检索文件的扩展名。 |
| `FullName` | 获取目录或文件的完整路径。 |
| `LastAccessTime` | 获取或设置上次访问当前文件或目录的时间。 |
| `LastWriteTime` | 获取或设置上次写入当前文件或目录的时间。 |
| `Name` | 获取当前文件或目录的名称。 |

`FileSystemInfo`也定义了`Delete()`方法。这是通过派生类型从硬盘上删除给定的文件或目录来实现的。此外，您可以在获取属性信息之前调用`Refresh()`,以确保关于当前文件(或目录)的统计信息没有过时。

## 使用 DirectoryInfo 类型

您将研究的第一个可创建的以 I/O 为中心的类型是`DirectoryInfo`类。该类包含一组用于创建、移动、删除和枚举目录和子目录的成员。除了其基类(`FileSystemInfo`)提供的功能外，`DirectoryInfo`还提供表 [20-3](#Tab3) 中详细列出的关键成员。

表 20-3。

Key Members of the DirectoryInfo Type

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `Create()` `CreateSubdirectory()` | 给定路径名后，创建一个目录(或一组子目录) |
| `Delete()` | 删除目录及其所有内容 |
| `GetDirectories()` | 返回代表当前目录中所有子目录的`DirectoryInfo`对象数组 |
| `GetFiles()` | 检索代表给定目录中一组文件的一组`FileInfo`对象 |
| `MoveTo()` | 将目录及其内容移动到新路径 |
| `Parent` | 检索了此目录的父目录 |
| `Root` | 获取路径的根部分 |

通过指定一个特定的目录路径作为构造函数参数，开始使用`DirectoryInfo`类型。如果您想要访问当前工作目录(执行应用程序的目录)，请使用点(`.`)符号。以下是一些例子:

`// Bind to the current working directory.`

`DirectoryInfo dir1 = new DirectoryInfo(".");`

`// Bind to C:\Windows,`

`// using a verbatim string.`

`DirectoryInfo dir2 = new DirectoryInfo(@"C:\Windows");`

在第二个例子中，假设传递给构造函数(`C:\Windows`)的路径已经存在于物理机器上。然而，如果您试图与一个不存在的目录交互，就会抛出一个`System.IO.DirectoryNotFoundException`。因此，如果您指定了一个尚未创建的目录，您需要在继续之前调用`Create()`方法，如下所示:

`// Bind to a nonexistent directory, then create it.`

`DirectoryInfo dir3 = new DirectoryInfo(@"C:\MyCode\Testing");`

`dir3.Create();`

在创建了一个`DirectoryInfo`对象之后，您可以使用从`FileSystemInfo`继承的任何属性来研究底层目录内容。要看到这一点，创建一个名为 DirectoryApp 的新控制台应用程序项目，并更新您的 C#文件以导入`System.IO`。用以下新的静态方法更新您的`Program`类，该方法创建一个映射到`C:\Windows`的新的`DirectoryInfo`对象(如果需要，调整您的路径)，它显示了一些有趣的统计数据:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Directory(Info) *****\n");`

`ShowWindowsDirectoryInfo();`

`Console.ReadLine();`

`}`

`static void ShowWindowsDirectoryInfo()`

`{`

`// Dump directory information.`

`DirectoryInfo dir = new DirectoryInfo(@"C:\Windows");`

`Console.WriteLine("***** Directory Info *****");`

`Console.WriteLine("FullName: {0}", dir.FullName);`

`Console.WriteLine("Name: {0}", dir.Name);`

`Console.WriteLine("Parent: {0}", dir.Parent);`

`Console.WriteLine("Creation: {0}", dir.CreationTime);`

`Console.WriteLine("Attributes: {0}", dir.Attributes);`

`Console.WriteLine("Root: {0}", dir.Root);`

`Console.WriteLine("**************************\n");`

`}`

`}`

虽然您的输出可能有所不同，但您应该会看到类似于以下内容的内容:

`***** Fun with Directory(Info) *****`

`***** Directory Info *****`

`FullName: C:\Windows`

`Name: Windows`

`Parent:`

`Creation: 10/10/2015 10:22:32 PM`

`Attributes: Directory`

`Root: C:\`

`**************************`

### 枚举 DirectoryInfo 类型的文件

除了获得现有目录的基本细节，您还可以扩展当前示例，使用一些`DirectoryInfo`类型的方法。首先，您可以利用`GetFiles()`方法获得位于`C:\Windows\Web\Wallpaper`目录中的所有`*.jpg`文件的信息。

Note

如果你的机器没有`C:\Windows\Web\Wallpaper`目录，修改这个代码来读取你的机器上的目录的文件(例如，从`C:\Windows`目录中读取所有的`*.bmp`文件)。

`GetFiles()`方法返回一个由`FileInfo`对象组成的数组，每个对象公开一个特定文件的细节(你将在本章后面了解到`FileInfo`类型的全部细节)。假设您有下面的`Program`类的静态方法，您从`Main()`调用它:

`static void DisplayImageFiles()`

`{`

`DirectoryInfo dir = new DirectoryInfo(@"C:\Windows\Web\Wallpaper");`

`// Get all files with a *.jpg extension.`

`FileInfo[] imageFiles = dir.GetFiles("*.jpg", SearchOption.AllDirectories);`

`// How many were found?`

`Console.WriteLine("Found {0} *.jpg files\n", imageFiles.Length);`

`// Now print out info for each file.`

`foreach (FileInfo f in imageFiles)`

`{`

`Console.WriteLine("***************************");`

`Console.WriteLine("File name: {0}", f.Name);`

`Console.WriteLine("File size: {0}", f.Length);`

`Console.WriteLine("Creation: {0}", f.CreationTime);`

`Console.WriteLine("Attributes: {0}", f.Attributes);`

`Console.WriteLine("***************************\n");`

`}`

`}`

注意，当您调用`GetFiles()`时，您指定了一个搜索选项；这样做是为了在根目录的所有子目录中查找。运行应用程序后，您将看到所有符合搜索模式的文件的列表。

### 创建 DirectoryInfo 类型的子目录

您可以使用`DirectoryInfo.CreateSubdirectory()`方法以编程方式扩展目录结构。此方法可以在一次函数调用中创建一个子目录以及多个嵌套子目录。这个方法演示了如何做到这一点，用一些自定义子目录扩展了`C:`驱动器的目录结构:

`static void ModifyAppDirectory()`

`{`

`DirectoryInfo dir = new DirectoryInfo(@"C:\");`

`// Create \MyFolder off application directory.`

`dir.CreateSubdirectory("MyFolder");`

`// Create \MyFolder2\Data off application directory.`

`dir.CreateSubdirectory(@"MyFolder2\Data");`

`}`

您不需要捕获`CreateSubdirectory()`方法的返回值，但是您应该知道，表示新创建的项目的`DirectoryInfo`对象在成功执行时被传递回来。考虑对前面方法的以下更新。请注意`DirectoryInfo`的构造函数中的点符号，它让您可以访问应用程序的安装点。

`static void ModifyAppDirectory()`

`{`

`DirectoryInfo dir = new DirectoryInfo(".");`

`// Create \MyFolder off initial directory.`

`dir.CreateSubdirectory("MyFolder");`

`// Capture returned DirectoryInfo object.`

`DirectoryInfo myDataFolder = dir.CreateSubdirectory(@"MyFolder2\Data");`

`// Prints path to ..\MyFolder2\Data.`

`Console.WriteLine("New Folder is: {0}", myDataFolder);`

`}`

如果你从`Main()`内调用这个方法，并使用 Windows 资源管理器检查你的 Windows 目录，你会看到新的子目录存在并被考虑(见图 [20-2](#Fig2) )。

![A978-1-4842-1332-2_20_Fig2_HTML.jpg](img/A978-1-4842-1332-2_20_Fig2_HTML.jpg)

图 20-2。

Creating subdirectories

## 使用目录类型

你已经看到了`DirectoryInfo`型的作用；现在你已经准备好学习`Directory`类型了。在很大程度上，`Directory`的静态成员模仿了由`DirectoryInfo`定义的实例级成员所提供的功能。然而，回想一下，`Directory`的成员通常返回字符串数据，而不是强类型的`FileInfo` / `DirectoryInfo`对象。

现在让我们看看`Directory`类型的一些功能；这个最后的帮助器函数显示映射到当前计算机的所有驱动器的名称(使用`Directory.GetLogicalDrives()`方法),并使用静态的`Directory.Delete()`方法删除之前创建的`\MyFolder`和`\MyFolder2\Data`子目录。

`static void FunWithDirectoryType()`

`{`

`// List all drives on current computer.`

`string[] drives = Directory.GetLogicalDrives();`

`Console.WriteLine("Here are your drives:");`

`foreach (string s in drives)`

`Console.WriteLine("--> {0} ", s);`

`// Delete what was created.`

`Console.WriteLine("Press Enter to delete directories");`

`Console.ReadLine();`

`try`

`{`

`Directory.Delete(@"C:\MyFolder");`

`// The second parameter specifies whether you`

`// wish to destroy any subdirectories.`

`Directory.Delete(@"C:\MyFolder2", true);`

`}`

`catch (IOException e)`

`{`

`Console.WriteLine(e.Message);`

`}`

`}`

Source Code

您可以在 [`Chapter 20`](20.html) 子目录中找到 DirectoryApp 项目。

## 使用 DriveInfo 类类型

`System.IO`名称空间提供了一个名为`DriveInfo`的类。像`Directory.GetLogicalDrives()`一样，静态`DriveInfo.GetDrives()`方法允许您发现机器驱动器的名称。然而，与`Directory.GetLogicalDrives()`不同的是，`DriveInfo`提供了许多其他细节(例如，驱动器类型、可用空间和卷标)。考虑在名为 DriveInfoApp 的新控制台应用程序项目中定义的以下`Program`类(不要忘记导入`System.IO`):

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with DriveInfo *****\n");`

`// Get info regarding all drives.`

`DriveInfo[] myDrives = DriveInfo.GetDrives();`

`// Now print drive stats.`

`foreach(DriveInfo d in myDrives)`

`{`

`Console.WriteLine("Name: {0}", d.Name);`

`Console.WriteLine("Type: {0}", d.DriveType);`

`// Check to see whether the drive is mounted.`

`if(d.IsReady)`

`{`

`Console.WriteLine("Free space: {0}", d.TotalFreeSpace);`

`Console.WriteLine("Format: {0}", d.DriveFormat);`

`Console.WriteLine("Label: {0}", d.VolumeLabel);`

`}`

`Console.WriteLine();`

`}`

`Console.ReadLine();`

`}`

`}`

以下是一些可能的输出:

`***** Fun with DriveInfo *****`

`Name: C:\`

`Type: Fixed`

`Free space: 791699763200`

`Format: NTFS`

`Label: Windows10_OS`

`Name: D:\`

`Type: Fixed`

`Free space: 23804067840`

`Format: NTFS`

`Label: LENOVO`

`Press any key to continue . . .`

至此，您已经研究了`Directory`、`DirectoryInfo`和`DriveInfo`类的一些核心行为。接下来，您将学习如何创建、打开、关闭和销毁填充给定目录的文件。

Source Code

你可以在 [`Chapter 20`](20.html) 子目录中找到 DriveInfoApp 项目。

## 使用 FileInfo 类

如前面的`DirectoryApp`示例所示，`FileInfo`类允许您获取硬盘上现有文件的详细信息(例如，创建时间、大小和文件属性),并帮助创建、复制、移动和销毁文件。除了由`FileSystemInfo`继承的功能集，你可以找到一些`FileInfo`类特有的核心成员，你可以在表 [20-4](#Tab4) 中看到描述。

表 20-4。

FileInfo Core Members

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `AppendText()` | 创建一个向文件追加文本的`StreamWriter`对象(稍后描述) |
| `CopyTo()` | 将现有文件复制到新文件中 |
| `Create()` | 创建一个新文件并返回一个`FileStream`对象(稍后描述)来与新创建的文件交互 |
| `CreateText()` | 创建一个写新文本文件的`StreamWriter`对象 |
| `Delete()` | 删除绑定了`FileInfo`实例的文件 |
| `Directory` | 获取父目录的实例 |
| `DirectoryName` | 获取父目录的完整路径 |
| `Length` | 获取当前文件的大小 |
| `MoveTo()` | 将指定文件移动到新位置，并提供指定新文件名的选项 |
| `Name` | 获取文件的名称 |
| `Open()` | 以各种读/写和共享权限打开文件 |
| `OpenRead()` | 创建一个只读的`FileStream`对象 |
| `OpenText()` | 创建一个从现有文本文件中读取的`StreamReader`对象(稍后描述) |
| `OpenWrite()` | 创建一个只写的`FileStream`对象 |

请注意，`FileInfo`类的大多数方法都返回一个特定的以 I/O 为中心的对象(例如，`FileStream`和`StreamWriter`)，该对象允许您开始以各种格式向相关文件读写数据。您将很快了解这些类型；然而，在您看到一个工作示例之前，您会发现检查使用`FileInfo`类类型获得文件句柄的各种方法是有帮助的。

### 文件信息。Create()方法

创建文件句柄的一种方法是使用`FileInfo.Create()`方法，如下所示:

`static void Main(string[] args)`

`{`

`// Make a new file on the C drive.`

`FileInfo f = new FileInfo(@"C:\Test.dat");`

`FileStream fs = f.Create();`

`// Use the FileStream object...`

`// Close down file stream.`

`fs.Close();`

`}`

注意，`FileInfo.Create()`方法返回了一个`FileStream`对象，该对象公开了对底层文件的同步和异步写/读操作(稍后会有更多细节)。注意由`FileInfo.Create()`返回的`FileStream`对象授予所有用户完全的读/写权限。

还要注意，在使用完当前的`FileStream`对象后，必须确保关闭句柄来释放底层的非托管流资源。鉴于`FileStream`实现了`IDisposable`，你可以使用 C# `using`作用域让编译器生成拆卸逻辑(详见[第 8 章](08.html))，如下所示:

`static void Main(string[] args)`

`{`

`// Defining a using scope for file I/O`

`// types is ideal.`

`FileInfo f = new FileInfo(@"C:\Test.dat");`

`using (FileStream fs = f.Create())`

`{`

`// Use the FileStream object...`

`}`

`}`

### 文件信息。Open()方法

您可以使用`FileInfo.Open()`方法打开现有文件，也可以创建比使用`FileInfo.Create()`更精确的新文件。这是可行的，因为`Open()`通常采用几个参数来限定如何迭代您想要操作的文件。一旦对`Open()`的调用完成，就会返回一个`FileStream`对象。考虑以下逻辑:

`static void Main(string[] args)`

`{`

`// Make a new file via FileInfo.Open().`

`FileInfo f2 = new FileInfo(@"C:\Test2.dat");`

`using(FileStream fs2 = f2.Open(FileMode.OpenOrCreate,`

`FileAccess.ReadWrite, FileShare.None))`

`{`

`// Use the FileStream object...`

`}`

`}`

这个版本的重载`Open()`方法需要三个参数。`Open()`方法的第一个参数指定了 I/O 请求的一般风格(例如，创建一个新文件，打开一个现有文件，并追加到一个文件中)，这可以使用`FileMode`枚举来指定(详细信息请参见表 [20-5](#Tab5) ，如下所示:

表 20-5。

Members of the FileMode Enumeration

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `CreateNew` | 通知操作系统创建一个新文件。如果它已经存在，抛出一个`IOException`。 |
| `Create` | 通知操作系统创建一个新文件。如果它已经存在，它将被覆盖。 |
| `Open` | 打开现有文件。如果文件不存在，抛出一个`FileNotFoundException`。 |
| `OpenOrCreate` | 如果文件存在，则打开该文件；否则，将创建一个新文件。 |
| `Truncate` | 打开一个现有文件并将文件截断为 0 字节大小。 |
| `Append` | 打开一个文件，移动到文件末尾，并开始写操作(只能对只写流使用此标志)。如果文件不存在，将创建一个新文件。 |

`public enum FileMode`

`{`

`CreateNew,`

`Create,`

`Open,`

`OpenOrCreate,`

`Truncate,`

`Append`

`}`

使用`Open()`方法的第二个参数，一个来自`FileAccess`枚举的值，来确定底层流的读/写行为，如下所示:

`public enum FileAccess`

`{`

`Read,`

`Write,`

`ReadWrite`

`}`

最后，`Open()`方法的第三个参数`FileShare`指定如何在其他文件处理程序之间共享文件。以下是核心名称:

`public enum FileShare`

`{`

`Delete,`

`Inheritable,`

`None,`

`Read,`

`ReadWrite,`

`Write`

`}`

### 文件信息。OpenRead()和 FileInfo。OpenWrite()方法

`FileInfo.Open()`方法允许您以灵活的方式获得文件句柄，但是`FileInfo`类也提供了名为`OpenRead()`和`OpenWrite()`的成员。正如您所想象的，这些方法返回一个正确配置的只读或只写的`FileStream`对象，而不需要提供各种枚举值。与`FileInfo.Create()`和`FileInfo.Open()`一样，`OpenRead()`和`OpenWrite()`返回一个`FileStream`对象(注意，下面的代码假设您的`C:`驱动器上有名为`Test3.dat`和`Test4.dat`的文件):

`static void Main(string[] args)`

`{`

`// Get a FileStream object with read-only permissions.`

`FileInfo f3 = new FileInfo(@"C:\Test3.dat");`

`using(FileStream readOnlyStream = f3.OpenRead())`

`{`

`// Use the FileStream object...`

`}`

`// Now get a FileStream object with write-only permissions.`

`FileInfo f4 = new FileInfo(@"C:\Test4.dat");`

`using(FileStream writeOnlyStream = f4.OpenWrite())`

`{`

`// Use the FileStream object...`

`}`

`}`

### 文件信息。OpenText()方法

`FileInfo`类型的另一个开中心成员是`OpenText()`。与`Create()`、`Open()`、`OpenRead()`或`OpenWrite()`不同，`OpenText()`方法返回`StreamReader`类型的实例，而不是`FileStream`类型的实例。假设您在`C:`驱动器上有一个名为`boot.ini`的文件，下面的代码片段让您可以访问它的内容:

`static void Main(string[] args)`

`{`

`// Get a StreamReader object.`

`FileInfo f5 = new FileInfo(@"C:\boot.ini");`

`using(StreamReader sreader = f5.OpenText())`

`{`

`// Use the StreamReader object...`

`}`

`}`

很快您就会看到，`StreamReader`类型提供了一种从底层文件读取字符数据的方法。

### 文件信息。CreateText()和 FileInfo。AppendText()方法

此时最后两个感兴趣的`FileInfo`方法是`CreateText()`和`AppendText()`。两者都返回一个`StreamWriter`对象，如下所示:

`static void Main(string[] args)`

`{`

`FileInfo f6 = new FileInfo(@"C:\Test6.txt");`

`using(StreamWriter swriter = f6.CreateText())`

`{`

`// Use the StreamWriter object...`

`}`

`FileInfo f7 = new FileInfo(@"C:\FinalTest.txt");`

`using(StreamWriter swriterAppend = f7.AppendText())`

`{`

`// Use the StreamWriter object...`

`}`

`}`

正如您可能猜到的，`StreamWriter`类型提供了一种将字符数据写入底层文件的方法。

## 使用文件类型

`File`类型使用几个静态成员来提供与`FileInfo`类型几乎相同的功能。像`FileInfo`、`File`供给`AppendText()`、`Create()`、`CreateText()`、`Open()`、`OpenRead()`、`OpenWrite()`、`OpenText()`的方法。在许多情况下，您可以互换使用`File`和`FileInfo`类型。要看到这一点，您可以通过使用`File`类型来简化前面的每个`FileStream`示例，如下所示:

`static void Main(string[] args)`

`{`

`// Obtain FileStream object via File.Create().`

`using(FileStream fs = File.Create(@"C:\Test.dat"))`

`{}`

`// Obtain FileStream object via File.Open().`

`using(FileStream fs2 = File.Open(@"C:\Test2.dat",`

`FileMode.OpenOrCreate,`

`FileAccess.ReadWrite, FileShare.None))`

`{}`

`// Get a FileStream object with read-only permissions.`

`using(FileStream readOnlyStream = File.OpenRead(@"Test3.dat"))`

`{}`

`// Get a FileStream object with write-only permissions.`

`using(FileStream writeOnlyStream = File.OpenWrite(@"Test4.dat"))`

`{}`

`// Get a StreamReader object.`

`using(StreamReader sreader = File.OpenText(@"C:\boot.ini"))`

`{}`

`// Get some StreamWriters.`

`using(StreamWriter swriter = File.CreateText(@"C:\Test6.txt"))`

`{}`

`using(StreamWriter swriterAppend = File.AppendText(@"C:\FinalTest.txt"))`

`{}`

`}`

### 其他以文件为中心的成员

`File`类型还支持一些成员，如表 [20-6](#Tab6) 所示，可以大大简化读写文本数据的过程。

表 20-6。

Methods of the File Type

<colgroup><col> <col></colgroup> 
| 方法 | 生命的意义 |
| --- | --- |
| `ReadAllBytes()` | 打开指定的文件，以字节数组的形式返回二进制数据，然后关闭文件 |
| `ReadAllLines()` | 打开指定的文件，以字符串数组的形式返回字符数据，然后关闭文件 |
| `ReadAllText()` | 打开指定文件，返回字符数据作为`System.String`，然后关闭文件 |
| `WriteAllBytes()` | 打开指定的文件，写出字节数组，然后关闭文件 |
| `WriteAllLines()` | 打开指定文件，写出字符串数组，然后关闭文件 |
| `WriteAllText()` | 打开指定文件，写入指定字符串中的字符数据，然后关闭该文件 |

您可以使用这些`File`类型的方法，只用几行代码就可以读写成批的数据。更好的是，这些成员中的每一个都会自动关闭底层文件句柄。例如，下面的控制台程序(名为 SimpleFileIO)将字符串数据持久化到`C:`驱动器上的一个新文件中(并将它读入内存中)，而不会产生任何麻烦(这个例子假设您已经导入了`System.IO`):

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Simple I/O with the File Type *****\n");`

`string[] myTasks = {`

`"Fix bathroom sink", "Call Dave",`

`"Call Mom and Dad", "Play Xbox One"};`

`// Write out all data to file on C drive.`

`File.WriteAllLines(@"C:\tasks.txt", myTasks);`

`// Read it all back and print out.`

`foreach (string task in File.ReadAllLines(@"C:\tasks.txt"))`

`{`

`Console.WriteLine("TODO: {0}", task);`

`}`

`Console.ReadLine();`

`}`

`}`

这里的教训是，当你想快速获得一个文件句柄时，`File`类型将为你节省一些击键。然而，首先创建一个`FileInfo`对象的一个好处是，您可以使用抽象的`FileSystemInfo`基类的成员来研究文件。

Source Code

您可以在 [`Chapter 20`](20.html) 子目录中找到 SimpleFileIO 项目。

## 抽象流类

至此，您已经看到了许多获取`FileStream`、`StreamReader`和`StreamWriter`对象的方法，但是您还没有使用这些类型从文件中读取数据或将数据写入文件。要理解如何做到这一点，您需要熟悉流的概念。在 I/O 操作的世界中，流表示在源和目的地之间流动的数据块。流提供了一种与字节序列进行交互的通用方式，无论哪种设备(例如文件、网络连接或打印机)存储或显示相关的字节。

抽象`System.IO.Stream`类定义了几个成员，这些成员为与存储介质(例如，底层文件或存储位置)的同步和异步交互提供支持。

Note

流的概念不限于文件 I/O。NET 库提供了对网络、内存位置和其他以流为中心的抽象的流访问。

同样，`Stream`后代将数据表示为原始字节流；因此，直接处理原始流是相当神秘的。有些`Stream`派生的类型支持 seeking，seeking 是指获取并调整流中当前位置的过程。表 [20-7](#Tab7) 通过描述`Stream`类的核心成员来帮助你理解它所提供的功能。

表 20-7。

Abstract Stream Members

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `CanRead``CanWrite`T2】 | 确定当前流是否支持读取、查找和/或写入。 |
| `Close()` | 关闭当前流并释放与当前流关联的任何资源(如套接字和文件句柄)。在内部，这个方法是`Dispose()`方法的别名；因此，关闭流在功能上等同于释放流。 |
| `Flush()` | 用缓冲区的当前状态更新底层数据源或储存库，然后清除缓冲区。如果流没有实现缓冲区，则此方法不执行任何操作。 |
| `Length` | 以字节为单位返回流的长度。 |
| `Position` | 确定当前流中的位置。 |
| `Read()  ReadByte() ReadAsync()` | 从当前流中读取一个字节序列(或单个字节),并将流中的当前位置提升所读取的字节数。 |
| `Seek()` | 设置当前流中的位置。 |
| `SetLength()` | 设置当前流的长度。 |
| `Write()` `WriteByte() WrriteAsync()` | 将一个字节序列(或单个字节)写入当前流，并按写入的字节数提升流中的当前位置。 |

### 使用文件流

`FileStream`类以适合基于文件的流的方式为抽象`Stream`成员提供了一个实现。这是一条相当原始的河流；它只能读取或写入单个字节或字节数组。然而，你并不经常需要与`FileStream`类型的成员直接交互。相反，您可能会使用各种流包装器，这使得处理文本数据或。网络类型。尽管如此，您会发现尝试一下`FileStream`类型的同步读/写功能是很有帮助的。

假设您有一个名为 FileStreamApp 的新控制台应用程序项目(并验证`System.IO`和`System.Text`已导入到您的初始 C#代码文件中)。你的目标是写一个简单的文本信息到一个名为`myMessage.dat`的新文件中。然而，鉴于`FileStream`只能对原始字节进行操作，您需要将`System.String`类型编码到相应的字节数组中。幸运的是，`System.Text`名称空间定义了一个名为`Encoding`的类型，它提供了将字符串编码和解码为字节数组的成员(查看。NET Framework SDK 文档，了解关于`Encoding`类型的更多详细信息)。

一旦编码完成，字节数组就用`FileStream.Write()`方法保存到文件中。要将字节读回内存，必须重置流的内部位置(使用`Position`属性)并调用`ReadByte()`方法。最后，向控制台显示原始字节数组和解码后的字符串。下面是完整的`Main()`方法:

`// Don’t forget to import the System.Text and System.IO namespaces.`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with FileStreams *****\n");`

`// Obtain a FileStream object.`

`using(FileStream fStream = File.Open(@"C:\myMessage.dat",`

`FileMode.Create))`

`{`

`// Encode a string as an array of bytes.`

`string msg = "Hello!";`

`byte[] msgAsByteArray = Encoding.Default.GetBytes(msg);`

`// Write byte[] to file.`

`fStream.Write(msgAsByteArray, 0, msgAsByteArray.Length);`

`// Reset internal position of stream.`

`fStream.Position = 0;`

`// Read the types from file and display to console.`

`Console.Write("Your message as an array of bytes: ");`

`byte[] bytesFromFile = new byte[msgAsByteArray.Length];`

`for (int i = 0; i < msgAsByteArray.Length; i++)`

`{`

`bytesFromFile[i] = (byte)fStream.ReadByte();`

`Console.Write(bytesFromFile[i]);`

`}`

`// Display decoded messages.`

`Console.Write("\nDecoded Message: ");`

`Console.WriteLine(Encoding.Default.GetString(bytesFromFile));`

`}`

`Console.ReadLine();`

`}`

这个例子用数据填充文件，但是它也强调了直接使用`FileStream`类型的主要缺点:它要求对原始字节进行操作。其他`Stream`派生的类型以类似的方式操作。例如，如果你想将一个字节序列写入内存区域，你可以分配一个`MemoryStream`。同样，如果您想通过网络连接推送一个字节数组，您可以使用`NetworkStream`类(在`System.Net.Sockets`名称空间中)。

如前所述，`System.IO`名称空间提供了几个读取器和写入器类型，封装了使用`Stream`派生类型的细节。

Source Code

你可以在 [`Chapter 20`](20.html) 子目录中找到 FileStreamApp 项目。

## 使用 streamwriter 和 streamreader

当您需要读取或写入基于字符的数据(例如字符串)时，`StreamWriter`和`StreamReader`类非常有用。默认情况下，这两种类型都使用 Unicode 字符；然而，您可以通过提供一个正确配置的`System.Text.Encoding`对象引用来改变这一点。为了简单起见，假设默认的 Unicode 编码符合要求。

`StreamReader`从一个名为`TextReader`的抽象类型派生而来，相关的`StringReader`类型也是如此(本章稍后讨论)。`TextReader`基类为这些后代中的每一个提供了一组有限的功能；具体来说，它提供了读取和查看字符流的能力。

`StreamWriter`类型(以及`StringWriter`，你将在本章后面研究)来自一个名为`TextWriter`的抽象基类。此类定义允许派生类型将文本数据写入给定字符流的成员。

为了帮助你理解`StreamWriter`和`StringWriter`类的核心编写能力，表 [20-8](#Tab8) 描述了抽象`TextWriter`基类的核心成员。

表 20-8。

Core Members of TextWriter

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `Close()` | 此方法关闭编写器并释放所有关联的资源。在这个过程中，缓冲区被自动刷新(同样，这个成员在功能上等同于调用`Dispose()`方法)。 |
| `Flush()` | 此方法清除当前编写器的所有缓冲区，并将所有缓冲的数据写入基础设备；但是，它不会关闭编写器。 |
| `NewLine` | 此属性指示派生的 writer 类的换行符常量。Windows 操作系统的默认行结束符是回车，后面跟一个换行符(`\r\n`)。 |
| `Write() WriteAsync()` | 这个重载方法将数据写入文本流，而不使用换行符常量。 |
| `WriteLine() WriteLineAsync()` | 这个重载的方法用一个换行符常量将数据写入文本流。 |

Note

最后两个`TextWriter`类的成员可能你看起来很熟悉。如果您还记得，`System.Console`类型有`Write()`和`WriteLine()`成员，它们将文本数据推送到标准输出设备。实际上，`Console.In`属性包装了一个`TextReader`，而`Console.Out`属性包装了一个`TextWriter`。

派生的`StreamWriter`类为`Write()`、`Close()`和`Flush()`方法提供了适当的实现，并定义了额外的`AutoFlush`属性。当设置为`true`时，该属性强制`StreamWriter`在每次执行写操作时刷新所有数据。请注意，通过将`AutoFlush`设置为`false`，您可以获得更好的性能，前提是当您使用`StreamWriter`完成写入时，您总是调用`Close()`。

### 写入文本文件

要查看运行中的`StreamWriter`类型，创建一个名为 StreamWriterReaderApp 的新控制台应用程序项目并导入`System.IO`。下面的`Main()`方法使用`File.CreateText()`方法在当前执行文件夹中创建一个名为`reminders.txt`的新文件。使用获得的`StreamWriter`对象，您可以向新文件添加一些文本数据。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with StreamWriter / StreamReader *****\n");`

`// Get a StreamWriter and write string data.`

`using(StreamWriter writer = File.CreateText("reminders.txt"))`

`{`

`writer.WriteLine("Don’t forget Mother’s Day this year...");`

`writer.WriteLine("Don’t forget Father’s Day this year...");`

`writer.WriteLine("Don’t forget these numbers:");`

`for(int i = 0; i < 10; i++)`

`writer.Write(i + " ");`

`// Insert a new line.`

`writer.Write(writer.NewLine);`

`}`

`Console.WriteLine("Created file and wrote some thoughts...");`

`Console.ReadLine();`

`}`

运行这个程序后，你可以检查这个新文件的内容(见图 [20-3](#Fig3) )。您将在当前应用程序的`bin\Debug`文件夹下找到这个文件，因为您在调用`CreateText()`时没有指定绝对路径。

![A978-1-4842-1332-2_20_Fig3_HTML.jpg](img/A978-1-4842-1332-2_20_Fig3_HTML.jpg)

图 20-3。

The contents of your *.txt file

### 从文本文件中读取

接下来，您将学习通过使用相应的`StreamReader`类型以编程方式从文件中读取数据。回想一下，这个类源自抽象`TextReader`，它提供了表 [20-9](#Tab9) 中描述的功能。

表 20-9。

TextReader Core Members

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `Peek()` | 返回下一个可用字符(用整数表示)，而不实际改变读取器的位置。值`-1`表示您位于流的末尾。 |
| `Read() ReadAsync()` | 从输入流中读取数据。 |
| `ReadBlock()` `ReadBlockAsync()` | 从当前流中读取指定的最大字符数，并将数据写入缓冲区，从指定的索引处开始。 |
| `ReadLine() ReadLineAsync()` | 从当前流中读取一行字符，并将数据作为字符串返回(`null`字符串表示 e of)。 |
| `ReadToEnd() ReadToEndAsync()` | 读取从当前位置到流尾的所有字符，并将它们作为单个字符串返回。 |

如果您现在扩展当前的示例应用程序以使用一个`StreamReader`，您可以从`reminders.txt`文件中读入文本数据，如下所示:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with StreamWriter / StreamReader *****\n");`

`...`

`// Now read data from file.`

`Console.WriteLine("Here are your thoughts:\n");`

`using(StreamReader sr = File.OpenText("reminders.txt"))`

`{`

`string input = null;`

`while ((input = sr.ReadLine()) != null)`

`{`

`Console.WriteLine (input);`

`}`

`}`

`Console.ReadLine();`

`}`

运行程序后，你会看到`reminders.txt`中的字符数据显示到控制台上。

### 直接创建 StreamWriter/StreamReader 类型

使用`System.IO`中的类型的一个令人困惑的方面是，您经常可以使用不同的方法获得相同的结果。例如，您已经看到，您可以使用`CreateText()`方法获得带有`File`或`FileInfo`类型的`StreamWriter`。碰巧你可以用另一种方式处理`StreamWriter`和`StreamReader` s:直接创建它们。例如，您可以对当前应用程序进行如下改进:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with StreamWriter / StreamReader *****\n");`

`// Get a StreamWriter and write string data.`

`using(StreamWriter writer = new StreamWriter("reminders.txt"))`

`{`

`...`

`}`

`// Now read data from file.`

`using(StreamReader sr = new StreamReader("reminders.txt"))`

`{`

`...`

`}`

`}`

虽然看到这么多看似相同的文件 I/O 方法会让人有点困惑，但请记住，最终结果是更大的灵活性。无论如何，现在您已经准备好检查`StringWriter`和`StringReader`类的作用，因为您已经看到了如何使用`StreamWriter`和`StreamReader`类型将字符数据移入和移出给定的文件。

Source Code

您可以在 [`Chapter 20`](20.html) 子目录中找到 StreamWriterReaderApp 项目。

## 使用 StringWriters 和 StringReaders

您可以使用`StringWriter`和`StringReader`类型将文本信息视为内存中的字符流。当您想要将基于字符的信息追加到底层缓冲区时，这可能会很有帮助。下面的控制台应用程序项目(名为 StringReaderWriterApp)说明了这一点，它将一个字符串数据块写入一个`StringWriter`对象，而不是本地硬盘上的一个文件(不要忘记导入`System.IO`):

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with StringWriter / StringReader *****\n");`

`// Create a StringWriter and emit character data to memory.`

`using(StringWriter strWriter = new StringWriter())`

`{`

`strWriter.WriteLine("Don’t forget Mother’s Day this year...");`

`// Get a copy of the contents (stored in a string) and dump`

`// to console.`

`Console.WriteLine("Contents of StringWriter:\n{0}", strWriter);`

`}`

`Console.ReadLine();`

`}`

`StringWriter`和`StreamWriter`都来源于同一个基类(`TextWriter`)，所以编写逻辑大致相同。然而，考虑到`StringWriter`的性质，你也应该知道这个类允许你使用下面的`GetStringBuilder()`方法来提取一个`System.Text.StringBuilder`对象:

`using (StringWriter strWriter = new StringWriter())`

`{`

`strWriter.WriteLine("Don’t forget Mother’s Day this year...");`

`Console.WriteLine("Contents of StringWriter:\n{0}", strWriter);`

`// Get the internal StringBuilder.`

`StringBuilder sb = strWriter.GetStringBuilder();`

`sb.Insert(0, "Hey!! ");`

`Console.WriteLine("-> {0}", sb.ToString());`

`sb.Remove(0, "Hey!! ".Length);`

`Console.WriteLine("-> {0}", sb.ToString());`

`}`

当您想从字符数据流中读取数据时，您可以使用相应的`StringReader`类型，它(正如您所期望的)的功能与相关的`StreamReader`类相同。事实上，`StringReader`类只不过覆盖了继承的成员，从字符数据块中读取，而不是从文件中读取，如下所示:

`using (StringWriter strWriter = new StringWriter())`

`{`

`strWriter.WriteLine("Don’t forget Mother’s Day this year...");`

`Console.WriteLine("Contents of StringWriter:\n{0}", strWriter);`

`// Read data from the StringWriter.`

`using (StringReader strReader = new StringReader(strWriter.ToString()))`

`{`

`string input = null;`

`while ((input = strReader.ReadLine()) != null)`

`{`

`Console.WriteLine(input);`

`}`

`}`

`}`

Source Code

你可以在 [`Chapter 20`](20.html) 子目录中找到 StringReaderWriterApp。

## 使用 binarywriter 和 binaryreader

您将在本节中检查的最后一组写入器/读取器是`BinaryReader`和`BinaryWriter`。两者都直接来源于`System.Object`。这些类型允许您以紧凑的二进制格式读写基础流中的离散数据类型。`BinaryWriter`类定义了一个高度重载的`Write()`方法，将数据类型放入底层流中。除了`Write()`成员之外，`BinaryWriter`还提供了额外的成员，允许您获取或设置`Stream`派生的类型；它还支持对数据的随机访问(见表 [20-10](#Tab10) )。

表 20-10。

BinaryWriter Core Members

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `BaseStream` | 这个只读属性提供对与`BinaryWriter`对象一起使用的基础流的访问。 |
| `Close()` | 此方法关闭二进制流。 |
| `Flush()` | 此方法刷新二进制流。 |
| `Seek()` | 此方法设置当前流中的位置。 |
| `Write()` | 此方法将一个值写入当前流。 |

`BinaryReader`类用表 [20-11](#Tab11) 中描述的成员补充了`BinaryWriter`提供的功能。

表 20-11。

BinaryReader Core Members

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `BaseStream` | 这个只读属性提供对与`BinaryReader`对象一起使用的基础流的访问。 |
| `Close()` | 此方法关闭二进制读取器。 |
| `PeekChar()` | 此方法返回下一个可用字符，而不提升在流中的位置。 |
| `Read()` | 此方法读取一组给定的字节或字符，并将它们存储在传入数组中。 |
| `ReadXXXX()` | `BinaryReader`类定义了许多从流中获取下一个类型的读取方法(例如，`ReadBoolean()`、`ReadByte()`和`ReadInt32()`)。 |

以下示例(名为 BinaryWriterReader 的控制台应用程序项目)将许多数据类型写入新的`*.dat`文件:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Binary Writers / Readers *****\n");`

`// Open a binary writer for a file.`

`FileInfo f = new FileInfo("BinFile.dat");`

`using(BinaryWriter bw = new BinaryWriter(f.OpenWrite()))`

`{`

`// Print out the type of BaseStream.`

`// (System.IO.FileStream in this case).`

`Console.WriteLine("Base stream is: {0}", bw.BaseStream);`

`// Create some data to save in the file.`

`double aDouble = 1234.67;`

`int anInt = 34567;`

`string aString = "A, B, C";`

`// Write the data.`

`bw.Write(aDouble);`

`bw.Write(anInt);`

`bw.Write(aString);`

`}`

`Console.WriteLine("Done!");`

`Console.ReadLine();`

`}`

注意从`FileInfo.OpenWrite()`返回的`FileStream`对象是如何传递给`BinaryWriter`类型的构造函数的。使用这种技术可以很容易地在写出数据之前在流中分层。请注意，`BinaryWriter`的构造函数接受任何从`Stream`派生的类型(例如，`FileStream`、`MemoryStream`或`BufferedStream`)。因此，将二进制数据写入内存就像提供一个有效的`MemoryStream`对象一样简单。

为了从`BinFile.dat`文件中读取数据，`BinaryReader`类型提供了许多选项。在这里，您调用各种以读取为中心的成员从文件流中提取每个数据块:

`static void Main(string[] args)`

`{`

`...`

`FileInfo f = new FileInfo("BinFile.dat");`

`...`

`// Read the binary data from the stream.`

`using(BinaryReader br = new BinaryReader(f.OpenRead()))`

`{`

`Console.WriteLine(br.ReadDouble());`

`Console.WriteLine(br.ReadInt32());`

`Console.WriteLine(br.ReadString());`

`}`

`Console.ReadLine();`

`}`

Source Code

您可以在 [`Chapter 20`](20.html) 子目录中找到 BinaryWriterReader 应用程序。

## 以编程方式监视文件

现在您已经更好地掌握了各种阅读器和编写器的使用，您将看到`FileSystemWatcher`类的作用。当您希望以编程方式监控(或“监视”)系统上的文件时，这种类型非常有用。具体来说，您可以指示`FileSystemWatcher`类型监视由`System.IO.NotifyFilters`枚举指定的任何动作的文件(这些成员中有许多是不言自明的，但是您仍然应该检查。NET Framework 4.6 SDK 文档了解更多详细信息)。

`public enum NotifyFilters`

`{`

`Attributes, CreationTime,`

`DirectoryName, FileName,`

`LastAccess, LastWrite,`

`Security, Size`

`}`

要开始使用`FileSystemWatcher`类型，您需要设置`Path`属性来指定包含您想要监控的文件的目录的名称(和位置),以及定义您想要监控的文件的文件扩展名的`Filter`属性。

此时，您可以选择处理`Changed`、`Created`和`Deleted`事件，所有这些事件都与`FileSystemEventHandler`委托协同工作。此委托可以调用与以下模式匹配的任何方法:

`// The FileSystemEventHandler delegate must point`

`// to methods matching the following signature.`

`void MyNotificationHandler(object source, FileSystemEventArgs e)`

您还可以使用`RenamedEventHandler`委托类型来处理`Renamed`事件，这可以调用匹配以下签名的方法:

`// The RenamedEventHandler delegate must point`

`// to methods matching the following signature.`

`void MyRenamedHandler(object source, RenamedEventArgs e)`

虽然您可以使用传统的委托/事件语法来处理每个事件，但是您当然也可以使用 lambda 表达式语法(如果您感兴趣，这个项目的可下载代码使用 lambda 语法)。

接下来，我们来看看看一个文件的过程。假设您已经在您的`C:`驱动器上创建了一个名为`MyFolder`的新目录，其中包含各种`*.txt`文件(您可以随意命名)。以下控制台应用程序项目(名为 MyDirectoryWatcher)监视`MyFolder`目录中的`*.txt`文件，并在创建、删除、修改或重命名文件时打印消息:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** The Amazing File Watcher App *****\n");`

`// Establish the path to the directory to watch.`

`FileSystemWatcher watcher = new FileSystemWatcher();`

`try`

`{`

`watcher.Path = @"C:\MyFolder";`

`}`

`catch(ArgumentException ex)`

`{`

`Console.WriteLine(ex.Message);`

`return;`

`}`

`// Set up the things to be on the lookout for.`

`watcher.NotifyFilter = NotifyFilters.LastAccess`

`| NotifyFilters.LastWrite`

`| NotifyFilters.FileName`

`| NotifyFilters.DirectoryName;`

`// Only watch text files.`

`watcher.Filter = "*.txt";`

`// Add event handlers.`

`watcher.Changed += new FileSystemEventHandler(OnChanged);`

`watcher.Created += new FileSystemEventHandler(OnChanged);`

`watcher.Deleted += new FileSystemEventHandler(OnChanged);`

`watcher.Renamed += new RenamedEventHandler(OnRenamed);`

`// Begin watching the directory.`

`watcher.EnableRaisingEvents = true;`

`// Wait for the user to quit the program.`

`Console.WriteLine(@"Press ’q’ to quit app.");`

`while(Console.Read()!=’q’)`

`;`

`}`

以下两个事件处理程序只是打印当前的文件修改:

`static void OnChanged(object source, FileSystemEventArgs e)`

`{`

`// Specify what is done when a file is changed, created, or deleted.`

`Console.WriteLine("File: {0} {1}!", e.FullPath, e.ChangeType);`

`}`

`static void OnRenamed(object source, RenamedEventArgs e)`

`{`

`// Specify what is done when a file is renamed.`

`Console.WriteLine("File: {0} renamed to {1}", e.OldFullPath, e.FullPath);`

`}`

若要测试该程序，请运行该应用程序并打开 Windows 资源管理器。尝试重命名文件，创建一个`*.txt`文件，删除一个`*.txt`文件，等等。您将在您的`MyFolder`中看到关于文本文件状态的各种信息，如下例所示:

`***** The Amazing File Watcher App *****`

`Press ’q’ to quit app.`

`File: C:\MyFolder\New Text Document.txt Created!`

`File: C:\MyFolder\New Text Document.txt renamed to C:\MyFolder\Hello.txt`

`File: C:\MyFolder\Hello.txt Changed!`

`File: C:\MyFolder\Hello.txt Changed!`

`File: C:\MyFolder\Hello.txt Deleted!`

Source Code

您可以在 [`Chapter 20`](20.html) 子目录中找到 MyDirectoryWatcher 应用程序。

这就结束了本章对。NET 平台。虽然您肯定会在许多应用程序中使用这些技术，但是您也可能会发现对象序列化服务可以极大地简化您持久存储大量数据的方式。

## 了解对象序列化

术语序列化描述了将对象的状态持久化(并且可能转移)到流(例如，文件流和内存流)中的过程。持久化的数据序列包含了重构(或反序列化)对象状态以备后用所需的所有必要信息。使用这项技术可以轻松保存大量数据(各种格式)。在许多情况下，使用序列化服务保存应用程序数据会比使用在`System.IO`名称空间中找到的读取器/写入器产生更少的代码。

例如，假设您想要创建一个基于 GUI 的桌面应用程序，为最终用户提供一种保存他们的首选项(例如，窗口颜色和字体大小)的方法。为此，您可以定义一个名为`UserPrefs`的类，它封装了大约 20 条字段数据。现在，如果您要使用一个`System.IO.BinaryWriter`类型，您将需要手动保存`UserPrefs`对象的每个字段。同样，如果您要将数据从文件加载回内存，您将需要使用一个`System.IO.BinaryReader`并(再次)手动读入每个值来重新配置一个新的`UserPrefs`对象。

这都是可行的，但是您可以通过用`[Serializable]`属性标记`UserPrefs`类来节省大量时间，如下所示:

`[Serializable]`

`public class UserPrefs`

`{`

`public string WindowColor;`

`public int FontSize;`

`}`

这样做意味着只需几行代码就可以持久保存对象的整个状态。暂时不要纠结于细节，考虑下面的`Main()`方法:

`static void Main(string[] args)`

`{`

`UserPrefs userData= new UserPrefs();`

`userData.WindowColor = "Yellow";`

`userData.FontSize = 50;`

`// The BinaryFormatter persists state data in a binary format.`

`// You would need to import System.Runtime.Serialization.Formatters.Binary`

`// to gain access to BinaryFormatter.`

`BinaryFormatter binFormat = new BinaryFormatter();`

`// Store object in a local file.`

`using(Stream fStream = new FileStream("user.dat",`

`FileMode.Create, FileAccess.Write, FileShare.None))`

`{`

`binFormat.Serialize(fStream, userData);`

`}`

`Console.ReadLine();`

`}`

。NET 对象序列化使得持久化对象变得容易；然而，幕后使用的流程相当复杂。例如，当对象被持久保存到流中时，所有相关联的数据(例如，基类数据和所包含的对象)也被自动序列化。因此，如果您试图持久化一个派生类，继承链上的所有数据都会随之而来。正如您将看到的，您使用一个对象图来表示一组相互关联的对象。

。NET 序列化服务还允许您以各种格式保存对象图。前面的代码示例使用了`BinaryFormatter`类型；因此，`UserPrefs`对象的状态以紧凑的二进制格式保存。您还可以使用其他类型将对象图持久化为 SOAP 或 XML 格式。当您需要确保持久化的对象能够跨操作系统、语言和体系结构很好地传播时，这些格式非常有用。

Note

WCF 倾向于使用一种稍微不同的机制来序列化 WCF 服务操作的对象；它使用了`[DataContract]`和`[DataMember]`属性。你会在[第 25 章](25.html)中了解更多。

最后，要明白您可以将一个对象图持久化到任何从`System.IO.Stream`派生的类型中。在前面的例子中，您使用了`FileStream`类型将一个`UserPrefs`对象持久化到一个本地文件中。但是，如果您想将一个对象存储到内存的特定区域，您可以使用一个`MemoryStream`类型来代替。重要的是数据序列正确地表示了图形中对象的状态。

### 对象图的作用

如前所述，CLR 将考虑所有相关的对象，以确保在对象被序列化时数据被正确地持久化。这组相关对象被称为对象图。对象图提供了一种简单的方法来记录一组项目如何相互引用。请注意，对象图并不表示 OOP 是-a 或具有-a 关系。相反，您可以将对象图中的箭头理解为“需要”或“依赖”

对象图中的每个对象都被赋予一个唯一的数值。请记住，分配给对象图中成员的数字是任意的，对外界没有实际意义。

一旦给所有对象分配了一个数值，对象图就可以记录每个对象的依赖集。

例如，假设您已经创建了一组为一些汽车建模的类(当然)。你有一个名为`Car`的基类，它有-a `Radio`。另一个名为`JamesBondCar`的类扩展了`Car`的基本类型。图 [20-4](#Fig4) 显示了一个模拟这些关系的可能的对象图。

![A978-1-4842-1332-2_20_Fig4_HTML.gif](img/A978-1-4842-1332-2_20_Fig4_HTML.gif)

图 20-4。

A simple object graph

阅读对象图时，在连接箭头时可以使用短语“依赖于”或“指”。因此，在图 [20-4](#Fig4) 中，你可以看到`Car`指的是`Radio`类(给定 has-a 关系)。`JamesBondCar`指的是`Car`(给定 is-a 关系)，以及`Radio`(它继承了这个受保护的成员变量)。

当然，CLR 不会在内存中绘制图片来表示相关对象的图形。相反，图 [20-4](#Fig4) 中记录的关系是由一个数学公式表示的，看起来像这样:

`[Car 3, ref 2], [Radio 2], [JamesBondCar 1, ref 3, ref 2]`

如果您解析这个公式，您可以看到对象 3(`Car`)依赖于对象 2(`Radio`)。对象 2，`Radio`，是一只孤独的狼，不需要任何人。最后，对象 1(`JamesBondCar`)依赖于对象 3，也依赖于对象 2。在任何情况下，当你序列化或者反序列化一个`JamesBondCar`的实例时，对象图确保`Radio`和`Car`类型也参与到这个过程中。

序列化过程的美妙之处在于，表示对象之间关系的图形是在幕后自动建立的。然而，正如你将在本章后面看到的，通过使用属性和接口定制序列化过程，你可以更多地参与给定对象图的构造。

Note

严格地说，`XmlSerializer`类型(在本章后面描述)不使用对象图持久化状态；但是，此类型仍然以可预测的方式序列化和反序列化相关对象。

## 为序列化配置对象

使对象对可用。NET 序列化服务，您需要做的就是用`[Serializable]`属性修饰每个相关的类(或结构)。如果您确定给定的类型有一些成员数据不应该(或者可能不能)参与序列化方案，那么您可以用`[NonSerialized]`属性标记这样的字段。如果您希望减少持久化数据的大小，并且在可序列化类中有不需要记住的成员变量(例如，固定值、随机值和瞬态数据)，这可能会很有帮助。

### 定义可序列化类型

首先，创建一个名为 SimpleSerialize 的新控制台应用程序项目。插入一个名为`Radio`的新类，该类已被标记为`[Serializable]`，不包括已被标记为`[NonSerialized]`的单个成员变量(`radioID`)，因此不会被持久化到指定的数据流中。

`[Serializable]`

`public class Radio`

`{`

`public bool hasTweeters;`

`public bool hasSubWoofers;`

`public double[] stationPresets;`

`[NonSerialized]`

`public string radioID = "XF-552RR6";`

`}`

接下来，插入两个额外的类类型来表示`JamesBondCar`和`Car`类，这两个类也被标记为`[Serializable]`，并定义了以下字段数据:

`[Serializable]`

`public class Car`

`{`

`public Radio theRadio = new Radio();`

`public bool isHatchBack;`

`}`

`[Serializable]`

`public class JamesBondCar : Car`

`{`

`public bool canFly;`

`public bool canSubmerge;`

`}`

请注意，您不能从父类继承`[Serializable]`属性。因此，如果你从一个标记为`[Serializable]`的类型中派生出一个类，那么子类也必须被标记为`[Serializable]`，否则它就不能被持久化。事实上，对象图中的所有对象都必须标记有`[Serializable]`属性。如果您试图使用`BinaryFormatter`或`SoapFormatter`来序列化一个不可序列化的对象，您将在运行时收到一个`SerializationException`。

### 公共字段、私有字段和公共属性

请注意，在每个类中，您都将字段数据定义为 public 这有助于简化示例。当然，从面向对象的角度来看，使用公共属性公开私有数据会更好。此外，为了简单起见，这个示例没有在这些类型上定义任何自定义构造函数；因此，所有未分配的字段数据将获得预期的默认值。

抛开 OO 设计原则不谈，您可能想知道各种格式化程序如何期望定义一个类型的字段数据，以便将其序列化为一个流。答案是视情况而定。如果您使用`BinaryFormatter`或`SoapFormatter`持久化一个对象的状态，那绝对没有区别。这些类型被编程为序列化某个类型的所有可序列化字段，而不管它们是公共字段、私有字段还是通过公共属性公开的私有字段。但是，回想一下，如果您不想将数据点持久化到对象图中，您可以有选择地将公共或私有字段标记为`[NonSerialized]`，就像您对`Radio`类型的字符串字段所做的那样。

然而，如果你使用`XmlSerializer`类型，情况就完全不同了。此类型将只序列化公共属性公开的公共数据字段或私有数据。未从属性中公开的私有数据将被忽略。例如，考虑以下可序列化的`Person`类型:

`[Serializable]`

`public class Person`

`{`

`// A public field.`

`public bool isAlive = true;`

`// A private field.`

`private int personAge = 21;`

`// Public property/private data.`

`private string fName = string.Empty;`

`public string FirstName`

`{`

`get { return fName; }`

`set { fName = value; }`

`}`

`}`

如果您用`BinaryFormatter`或`SoapFormatter`处理上述内容，您会发现`isAlive`、`personAge`和`fName`字段被保存到选定的流中。然而，`XmlSerializer`不会保存`personAge`的值，因为这段私有数据没有被公共类型属性封装。如果您想用`XmlSerializer`持久化这个人的年龄，您需要公开定义这个字段，或者使用一个公共属性封装私有成员。

## 选择序列化格式化程序

将类型配置为参与。通过应用必要的属性，下一步是选择在持久化对象状态时应该使用的格式(二进制、SOAP 或 XML)。每种可能性都由以下类别表示:

*   `BinaryFormatter`
*   `SoapFormatter`
*   `XmlSerializer`

`BinaryFormatter`类型使用紧凑的二进制格式将对象的状态序列化为一个流。这个类型是在属于`mscorlib.dll`的`System.Runtime.Serialization.Formatters.Binary`名称空间中定义的。如果你想获得对这种类型的访问，你可以指定下面的 C# `using`指令:

`// Gain access to the BinaryFormatter in mscorlib.dll.`

`using System.Runtime.Serialization.Formatters.Binary;`

`SoapFormatter`类型将对象的状态保存为 SOAP 消息(与基于 SOAP 的 web 服务之间传递消息的标准 XML 格式)。这个类型是在`System.Runtime.Serialization.Formatters.Soap`名称空间中定义的，这个名称空间是在一个单独的程序集中定义的。因此，要将对象图格式化为 SOAP 消息，您必须首先使用 Visual Studio 添加引用对话框设置对`System.Runtime.Serialization.Formatters.Soap.dll`的引用，然后指定以下 C# `using`指令:

`// Must reference System.Runtime.Serialization.Formatters.Soap.dll.`

`using System.Runtime.Serialization.Formatters.Soap;`

最后，如果希望将对象树作为 XML 文档持久化，可以使用`XmlSerializer`类型。要使用这种类型，您需要指定您使用的是`System.Xml.Serialization`名称空间，并设置对程序集`System.Xml.dll`的引用。幸运的是，所有 Visual Studio 项目模板都会自动引用`System.Xml.dll`；因此，您需要做的就是使用以下命名空间:

`// Defined within System.Xml.dll.`

`using System.Xml.Serialization;`

### IFormatter 和 IRemotingFormatter 接口

无论您选择使用哪种格式化程序，请注意它们都是直接从`System.Object`派生的，因此它们不共享来自以序列化为中心的基类的一组公共成员。然而，`BinaryFormatter`和`SoapFormatter`类型通过实现`I` `Formatter`和`IRemotingFormatter`接口支持公共成员(看起来可能很奇怪，`XmlSerializer`两者都没有实现)。

`System.Runtime.Serialization.IFormatter`定义了核心的`Serialize()`和`De` `serialize()`方法，它们完成了将对象图形移入和移出特定流的繁重工作。除了这些成员，`IFormatter`还定义了实现类型在幕后使用的以下几个属性:

`public interface IFormatter`

`{`

`SerializationBinder Binder { get; set; }`

`StreamingContext Context { get; set; }`

`ISurrogateSelector SurrogateSelector { get; set; }`

`object Deserialize(Stream serializationStream);`

`void Serialize(Stream serializationStream, object graph);`

`}`

`System.Runtime.Remoting.Messaging.IRemotingFormatter`接口(由。NET remoting 层)将`Serialize()`和`Deserialize()`成员重载成一种更适合分布式持久性的方式。注意`IRemotingFormatter`是从更通用的`IFormatter`接口派生出来的。

`public interface IRemotingFormatter : IFormatter`

`{`

`object Deserialize(Stream serializationStream, HeaderHandler handler);`

`void Serialize(Stream serializationStream, object graph, Header[] headers);`

`}`

尽管对于大多数序列化工作，您可能不需要直接与这些接口进行交互，但是请记住，基于接口的多态性允许您使用`IFormatter`引用来保存`BinaryFormatter`或`SoapFormatter`的实例。因此，如果您想要构建一个可以使用这些类之一序列化对象图的方法，您可以编写以下代码:

`static void SerializeObjectGraph(IFormatter itfFormat,`

`Stream destStream, object graph)`

`{`

`itfFormat.Serialize(destStream, graph);`

`}`

### 格式化程序之间的类型保真度

三种格式化程序之间最明显的区别是对象图如何持久化到流中(二进制、SOAP 或 XML)。您还应该注意一些更微妙的区别，特别是格式化程序如何处理类型保真度。当您使用`BinaryFormatter`类型时，它不仅会保存对象图中对象的字段数据，还会保存每个类型的完全限定名和定义程序集的全名(名称、版本、公钥标记和文化)。这些额外的数据点使`BinaryFormatter`成为您跨机器边界按值传输对象(例如，作为完整副本)的理想选择。以网络为中心的应用。

`SoapFormatter`通过使用 XML 名称空间来保存原始程序集的踪迹。例如，回想一下本章前面的`Person`类型。如果这种类型作为 SOAP 消息持久化，您会发现`Person`的开始元素由生成的`xmlns`限定。考虑这个部分定义，特别注意`a1` XML 名称空间:

`<a1:Person id="ref-1" xmlns:a1=`

`"`[`http://schemas.microsoft.com/clr/nsassem/SimpleSerialize/MyApp%2C%20`T3】](http://schemas.microsoft.com/clr/nsassem/SimpleSerialize/MyApp%2C%20)

`Version%3D1.0.0.0%2C%20Culture%3Dneutral%2C%20PublicKeyToken%3Dnull">`

`<isAlive>true</isAlive>`

`<personAge>21</personAge>`

`<fName id="ref-3">Mel</fName>`

`</a1:Person>`

然而，`XmlSerializer`并不试图保持完整的类型保真度；因此，它不记录类型的完全限定名或原始程序集。乍一看，这似乎是一种限制，但是 XML 序列化是由 classic 使用的。NET web 服务，可以从任何平台上的客户端调用它(不仅仅是。NET)。这意味着完全序列化是没有意义的。NET 类型元数据。下面是`Person`类型的一种可能的 XML 表示:

`<?xml version="1.0"?>`

`<Person xmlns:xsi="`[`http://www.w3.org/2001/XMLSchema-instance`](http://www.w3.org/2001/XMLSchema-instance)T2】

`xmlns:xsd="`[`http://www.w3.org/2001/XMLSchema`](http://www.w3.org/2001/XMLSchema)T2】

`<isAlive>true</isAlive>`

`<PersonAge>21</PersonAge>`

`<FirstName>Frank</FirstName>`

`</Person>`

如果您希望以任何操作系统(例如，Windows、Mac OS X 和各种 Linux 发行版)、应用程序框架(例如，NET、Java Enterprise Edition 和 COM)或编程语言，您不希望保持完整的类型保真度，因为您不能假定所有可能的接收者都能理解。特定于 NET 的数据类型。鉴于此，`SoapFormatter`和`XmlSerializer`是理想的选择，当您需要确保对象持久化树尽可能广泛的范围时。

## 使用 BinaryFormatter 序列化对象

您可以使用`BinaryFormatter`类型来说明将`JamesBondCar`的一个实例持久化到一个物理文件是多么容易。同样，需要注意的`BinaryFormatter`类型的两个关键方法是`Serialize()`和`Deserialize()`。

*   `Serialize()`:将对象图作为字节序列保存到指定的流中
*   `Deserialize()`:将持久化的字节序列转换成对象图

假设您已经创建了一个`JamesBondCar`的实例，修改了一些状态数据，并希望将您的间谍手机保存到一个`*.dat`文件中。首先创建`*.dat`文件本身。您可以通过创建`System.IO.FileStream`类型的实例来实现这一点。此时，您可以创建一个`BinaryFormatter`的实例，并传入`FileStream`和对象图来持久化。考虑以下`Main()`方法:

`// Be sure to import the System.Runtime.Serialization.Formatters.Binary`

`// and System.IO namespaces.`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Object Serialization *****\n");`

`// Make a JamesBondCar and set state.`

`JamesBondCar jbc = new JamesBondCar();`

`jbc.canFly = true;`

`jbc.canSubmerge = false;`

`jbc.theRadio.stationPresets = new double[]{89.3, 105.1, 97.1};`

`jbc.theRadio.hasTweeters = true;`

`// Now save the car to a specific file in a binary format.`

`SaveAsBinaryFormat(jbc, "CarData.dat");`

`Console.ReadLine();`

`}`

像这样实现`SaveAsBinaryFormat()`方法:

`static void SaveAsBinaryFormat(object objGraph, string fileName)`

`{`

`// Save object to a file named CarData.dat in binary.`

`BinaryFormatter binFormat = new BinaryFormatter();`

`using(Stream fStream = new FileStream(fileName,`

`FileMode.Create, FileAccess.Write, FileShare.None))`

`{`

`binFormat.Serialize(fStream, objGraph);`

`}`

`Console.WriteLine("=> Saved car in binary format!");`

`}`

`BinaryFormatter.Serialize()`方法是负责组成对象图并将字节序列移动到某个`Stream`派生类型的成员。在这种情况下，流恰好是一个物理文件。您还可以将您的对象类型序列化为任何从`Stream`派生的类型，比如内存位置或网络流。

运行程序后，您可以通过导航到当前项目的`\bin\Debug`文件夹来查看代表`JamesBondCar`实例的`CarData.dat`文件的内容。图 [20-5](#Fig5) 显示了在 Visual Studio 中打开的这个文件。

![A978-1-4842-1332-2_20_Fig5_HTML.jpg](img/A978-1-4842-1332-2_20_Fig5_HTML.jpg)

图 20-5。

JamesBondCar serialized using a BinaryFormatter

### 使用 BinaryFormatter 反序列化对象

现在假设您想从二进制文件中将持久化的`JamesBondCar`读回到一个对象变量中。以编程方式打开`CarData.dat`(用`File.OpenRead()`方法)后，可以调用`BinaryFormatter`的`Deserialize()`方法。请注意，`Deserialize()`返回一个通用的`System.Object`类型，因此您需要进行显式强制转换，如下所示:

`static void LoadFromBinaryFile(string fileName)`

`{`

`BinaryFormatter binFormat = new BinaryFormatter();`

`// Read the JamesBondCar from the binary file.`

`using(Stream fStream = File.OpenRead(fileName))`

`{`

`JamesBondCar carFromDisk =`

`(JamesBondCar)binFormat.Deserialize(fStream);`

`Console.WriteLine("Can this car fly? : {0}", carFromDisk.canFly);`

`}`

`}`

注意，当您调用`Deserialize()`时，您传递了代表持久化对象图位置的`Stream`派生类型。一旦您将对象转换回正确的类型，您将发现从您保存该对象时起，状态数据就被保留了下来。

## 使用 SoapFormatter 序列化对象

您下一个选择的格式化程序是`SoapFormatter`类型，它将数据序列化到适当的 SOAP 信封中。简而言之，简单对象访问协议(SOAP)定义了一个标准过程，在这个过程中，您可以以平台和操作系统中立的方式调用方法。

假设您已经添加了对`System.Runtime.Serialization.Formatters.Soap.dll`程序集的引用(并导入了`System.Runtime.Serialization.Formatters.Soap`名称空间)，您可以简单地通过用`SoapFormatter`替换每次出现的`BinaryFormatter`来将`JamesBondCar`作为 SOAP 消息保存和检索。考虑下面的`Program`类的新方法，它以 SOAP 格式将一个对象序列化为一个本地文件:

`// Be sure to import System.Runtime.Serialization.Formatters.Soap`

`// and reference System.Runtime.Serialization.Formatters.Soap.dll.`

`static void SaveAsSoapFormat (object objGraph, string fileName)`

`{`

`// Save object to a file named CarData.soap in SOAP format.`

`SoapFormatter soapFormat = new SoapFormatter();`

`using(Stream fStream = new FileStream(fileName,`

`FileMode.Create, FileAccess.Write, FileShare.None))`

`{`

`soapFormat.Serialize(fStream, objGraph);`

`}`

`Console.WriteLine("=> Saved car in SOAP format!");`

`}`

和以前一样，您使用`Serialize()`和`Deserialize()`将对象图移入和移出流。如果您从`Main()`调用这个方法并运行应用程序，您可以打开生成的`*.soap`文件。在这里，您可以使用`#` `ref`标记来定位标记当前`JamesBondCar`的有状态值的 XML 元素，以及图中对象之间的关系(参见图 [20-6](#Fig6) )。

![A978-1-4842-1332-2_20_Fig6_HTML.jpg](img/A978-1-4842-1332-2_20_Fig6_HTML.jpg)

图 20-6。

JamesBondCar serialized using a SoapFormatter

## 使用 XmlSerializer 序列化对象

除了 SOAP 和二进制格式化程序之外，`System.Xml.dll`程序集还提供了第三个格式化程序，`System.Xml.Serialization.XmlSerializer`。您可以使用该格式化程序将给定对象的公共状态保存为纯 XML，而不是包装在 SOAP 消息中的 XML 数据。使用这种类型与使用`SoapFormatter`或`BinaryFormatter`类型略有不同。考虑下面的代码，它假设您已经导入了`System.Xml.Serialization`名称空间:

`static void SaveAsXmlFormat(object objGraph, string fileName)`

`{`

`// Save object to a file named CarData.xml in XML format.`

`XmlSerializer xmlFormat = new XmlSerializer(typeof(JamesBondCar));`

`using(Stream fStream = new FileStream(fileName,`

`FileMode.Create, FileAccess.Write, FileShare.None))`

`{`

`xmlFormat.Serialize(fStream, objGraph);`

`}`

`Console.WriteLine("=> Saved car in XML format!");`

`}`

关键的区别在于,`XmlSerializer`类型要求您指定表示您想要序列化的类的类型信息。如果您要查看新生成的 XML 文件(假设您从`Main()`中调用这个新方法)，您会发现如下所示的 XML 数据:

`<?xml version="1.0"?>`

`<JamesBondCar xmlns:xsi="`[`http://www.w3.org/2001/XMLSchema-instance`](http://www.w3.org/2001/XMLSchema-instance)T2】

`xmlns:xsd="`[`http://www.w3.org/2001/XMLSchema`](http://www.w3.org/2001/XMLSchema)T2】

`<theRadio>`

`<hasTweeters>true</hasTweeters>`

`<hasSubWoofers>false</hasSubWoofers>`

`<stationPresets>`

`<double>89.3</double>`

`<double>105.1</double>`

`<double>97.1</double>`

`</stationPresets>`

`<radioID>XF-552RR6</radioID>`

`</theRadio>`

`<isHatchBack>false</isHatchBack>`

`<canFly>true</canFly>`

`<canSubmerge>false</canSubmerge>`

`</JamesBondCar>`

Note

`XmlSerializer`要求对象图中的所有序列化类型都支持一个默认的构造函数(所以如果定义了自定义构造函数，一定要把它添加回来)。如果不是这样，您将在运行时收到一个`InvalidOperationException`。

### 控制生成的 XML 数据

如果您有 XML 技术方面的背景，您会知道确保 XML 文档中的数据符合一组确定数据有效性的规则通常是至关重要的。理解有效的 XML 文档与 XML 元素的语法无关(例如，所有的开始元素必须有一个结束元素)。相反，有效文档符合商定的格式规则(例如，字段`X`必须表示为属性而不是子元素)，这些规则通常由 XML 模式或文档类型定义(DTD)文件定义。

默认情况下，`XmlSerializer`将所有公共字段/属性序列化为 XML 元素，而不是 XML 属性。如果您想控制`XmlSerializer`如何生成结果 XML 文档，您可以用任意数量的附加。来自`System.Xml.Serialization`命名空间的. NET 属性。表 [20-12](#Tab12) 记录了。NET 属性，这些属性影响 XML 数据如何编码为流。

表 20-12。

Select Attributes of the System.Xml.Serialization Namespace

<colgroup><col> <col></colgroup> 
| 。网络属性 | 生命的意义 |
| --- | --- |
| `[XmlAttribute]` | 你可以用这个。NET 属性告诉`XmlSerializer`将数据序列化为 XML 属性(而不是子元素)。 |
| `[XmlElement]` | 该字段或属性将被序列化为您选择的 XML 元素。 |
| `[XmlEnum]` | 此属性提供枚举成员的元素名称。 |
| `[XmlRoot]` | 该属性控制如何构造根元素(名称空间和元素名称)。 |
| `[XmlText]` | 属性或字段将被序列化为 XML 文本(即根元素的开始标记和结束标记之间的内容)。 |
| `[XmlType]` | 该属性提供 XML 类型的名称和命名空间。 |

这个简单的例子说明了当前如何将`JamesBondCar`的字段数据持久化为 XML:

`<?xml version="1.0" encoding="utf-8"?>`

`<JamesBondCar xmlns:xsi="`[`http://www.w3.org/2001/XMLSchema-instance`](http://www.w3.org/2001/XMLSchema-instance)T2】

`xmlns:xsd="`[`http://www.w3.org/2001/XMLSchema`](http://www.w3.org/2001/XMLSchema)T2】

`...`

`<canFly>true</canFly>`

`<canSubmerge>false</canSubmerge>`

`</JamesBondCar>`

如果您想要指定一个自定义的 XML 名称空间来限定`JamesBondCar`并将`canFly`和`canSubmerge`值编码为 XML 属性，您可以通过修改 C#对`JamesBondCar`的定义来实现，如下所示:

`[Serializable, XmlRoot(Namespace = "`[`http://www.MyCompany.com`](http://www.mycompany.com/)T2】

`public class JamesBondCar : Car`

`{`

`[XmlAttribute]`

`public bool canFly;`

`[XmlAttribute]`

`public bool canSubmerge;`

`}`

这产生了下面的 XML 文档(注意开始的`<JamesBondCar>`元素):

`<?xml version="1.0"""?>`

`<JamesBondCar xmlns:xsi="`[`http://www.w3.org/2001/XMLSchema-instance`](http://www.w3.org/2001/XMLSchema-instance)T2】

`xmlns:xsd="`[`http://www.w3.org/2001/XMLSchema`](http://www.w3.org/2001/XMLSchema)T2】

`canFly="true" canSubmerge="false"`

`xmlns="`[`http://www.MyCompany.com`](http://www.mycompany.com/)T2】

`...`

`</JamesBondCar>`

当然，您可以使用许多其他方法。NET 属性来控制`XmlSerializer`如何生成结果 XML 文档。要了解完整的细节，请在。NET Framework 4.6 SDK 文档。

## 序列化对象集合

既然您已经看到了如何将单个对象持久化到流中，那么您就可以研究如何保存一组对象了。您可能已经注意到了，`IFormatter`接口的`Serialize()`方法没有提供指定任意数量的对象作为输入的方法(只有一个`System.Object`)。与此相关的是，`Deserialize()`的返回值也是单个的`System.Object`(同样的基本限制也适用于`XmlSerializer`)。

`public interface IFormatter`

`{`

`...`

`object Deserialize(Stream serializationStream);`

`void Serialize(Stream serializationStream, object graph);`

`}`

回想一下，`System.Object`代表一个完整的对象树。考虑到这一点，如果你传入一个被标记为`[Serializable]`并包含其他`[Serializable]`对象的对象，那么整个对象集将被保存在一个方法调用中。幸运的是，您在`System.Collections`和`System.Collections.Generic`名称空间中找到的大多数类型已经被标记为`[Serializable]`。因此，如果您想持久化一组对象，只需将所需的对象集添加到容器中(比如一个普通数组、`ArrayList`或`List<T>`)并将对象序列化到您选择的流中。

现在假设您想用一个两个参数的构造函数更新`JamesBondCar`类，这样您就可以设置一些状态数据(注意，您根据`XmlSerializer`的要求添加回默认的构造函数)。

`[Serializable,`

`XmlRoot(Namespace = "`[`http://www.MyCompany.com`](http://www.mycompany.com/)T2】

`public class JamesBondCar : Car`

`{`

`public JamesBondCar(bool skyWorthy, bool seaWorthy)`

`{`

`canFly = skyWorthy;`

`canSubmerge = seaWorthy;`

`}`

`// The XmlSerializer demands a default constructor!`

`public JamesBondCar(){}`

`...`

`}`

有了这个，你现在可以持久化任意数量的`JamesBondCar`。

`static void SaveListOfCars()`

`{`

`// Now persist a List<T> of JamesBondCars.`

`List<JamesBondCar> myCars = new List<JamesBondCar>();`

`myCars.Add(new JamesBondCar(true, true));`

`myCars.Add(new JamesBondCar(true, false));`

`myCars.Add(new JamesBondCar(false, true));`

`myCars.Add(new JamesBondCar(false, false));`

`using(Stream fStream = new FileStream("CarCollection.xml",`

`FileMode.Create, FileAccess.Write, FileShare.None))`

`{`

`XmlSerializer xmlFormat = new XmlSerializer(typeof(List<JamesBondCar>));`

`xmlFormat.Serialize(fStream, myCars);`

`}`

`Console.WriteLine("=> Saved list of cars!");`

`}`

这里使用了`XmlSerializer`，所以需要为根对象中的每个子对象指定类型信息(本例中为`List<JamesBondCar>`)。然而，如果您使用`BinaryFormatter`或`SoapFormatter`类型，逻辑会更简单，如下所示:

`static void SaveListOfCarsAsBinary()`

`{`

`// Save ArrayList object (myCars) as binary.`

`List<JamesBondCar> myCars = new List<JamesBondCar>();`

`BinaryFormatter binFormat = new BinaryFormatter();`

`using(Stream fStream = new FileStream("AllMyCars.dat",`

`FileMode.Create, FileAccess.Write, FileShare.None))`

`{`

`binFormat.Serialize(fStream, myCars);`

`}`

`Console.WriteLine("=> Saved list of cars in binary!");`

`}`

Source Code

SimpleSerialize 应用程序包含在 [`Chapter 20`](20.html) 子目录中。

## 定制 Soap/二进制序列化过程

在大多数情况下，由。NET 平台正是你所需要的。只需将`[Serializable]`属性应用到您的相关类型，并将对象树传递给您选择的格式化程序进行处理。但是，在某些情况下，您可能希望在序列化过程中更多地参与树的构造和处理。例如，您可能有一个业务规则，规定所有字段数据必须使用特定格式持久化，或者您可能需要向流中添加不直接映射到持久化对象中的字段的附加数据位(例如，时间戳和唯一标识符)。

当您想更多地参与对象序列化过程时，`System.Runtime.Serialization`名称空间提供了几种类型来允许您这样做。表 [20-13](#Tab13) 描述了一些你应该知道的核心类型。

表 20-13。

System.Runtime.Serialization Namespace Core Types

<colgroup><col> <col></colgroup> 
| 类型 | 生命的意义 |
| --- | --- |
| `ISerializable` | 您可以在一个`[Serializable]`类型上实现这个接口来控制它的序列化和反序列化。 |
| `ObjectIDGenerator` | 此类型为对象图中的成员生成 id。 |
| `[OnDeserialized]` | 此属性允许您指定一个在对象被反序列化后立即调用的方法。 |
| `[OnDeserializing]` | 此属性允许您指定将在反序列化过程之前调用的方法。 |
| `[OnSerialized]` | 此属性允许您指定一个在对象序列化后立即调用的方法。 |
| `[OnSerializing]` | 此属性允许您指定一个将在序列化过程之前调用的方法。 |
| `[OptionalField]` | 此属性允许您在指定流中可能缺少的类型上定义一个字段。 |
| `[SerializationInfo]` | 本质上，这个类是一个属性包，它维护在序列化过程中表示对象状态的名称-值对。 |

### 更深入地了解对象序列化

在研究定制序列化过程的各种方法之前，您会发现更深入地了解幕后发生的事情会很有帮助。当`BinaryFormatter`序列化一个对象图时，它负责将以下信息传输到指定的流中:

*   图形中对象的完全限定名(例如，`MyApp.JamesBondCar`)
*   定义对象图的集合名称(如`MyApp.exe`)
*   包含由对象图中的成员维护的所有有状态数据的`SerializationInfo`类的实例

在反序列化过程中，`BinaryFormatter`使用从底层流中提取的信息，使用相同的信息构建对象的相同副本。`SoapFormatter`采用了非常相似的流程。

Note

回想一下,`XmlSerializer`没有保存类型的完全限定名或定义程序集的名称；这种行为有助于尽可能保持对象的移动状态。这种类型只关心持久公开的公共数据。

除了将所需数据移入和移出流之外，格式化程序还分析对象图中的成员，以获得以下基础结构:

*   进行检查以确定对象是否标记有`[Serializable]`属性。如果对象不是，抛出一个`SerializationException`。
*   如果对象被标记为`[Serializable]`，则进行检查以确定该对象是否实现了`ISerializable`接口。如果是这样的话，`GetObjectData()`就叫做物上。
*   如果对象没有实现`ISerializable`，则使用默认的序列化过程，序列化所有没有标记为`[NonSerialized]`的字段。

除了确定类型是否支持`ISerializable`，格式化程序还负责发现相关类型是否支持已经用`[OnSerializing]`、`[OnSerialized]`、`[OnDeserializing]`或`[OnDeserialized]`属性修饰的成员。稍后您将检查这些属性的作用，但是首先您需要看看`ISerializable`的作用。

### 使用 ISerializable 自定义序列化

标记为`[Serializable]`的对象可以选择实现`ISerializable`接口。这样做可以让您“参与”序列化过程，并执行任何前数据或后数据格式化。

`ISerializable`接口非常简单，因为它只定义了一个方法`GetObjectData()`。

`// When you wish to tweak the serialization process,`

`// implement ISerializable.`

`public interface ISerializable`

`{`

`void GetObjectData(SerializationInfo info,`

`StreamingContext context);`

`}`

在序列化过程中，给定的格式化程序会自动调用`GetObjectData()`方法。该方法的实现用一系列名称-值对填充传入的`SerializationInfo`参数，这些名称-值对(通常)映射到被持久化的对象的字段数据。`SerializationInfo`在重载的`AddValue()`方法上定义了许多变体，以及一小部分允许类型获取和设置类型名称、定义程序集和成员数的属性。以下是部分快照:

`public sealed class SerializationInfo`

`{`

`public SerializationInfo(Type type, IFormatterConverter converter);`

`public string AssemblyName { get; set; }`

`public string FullTypeName { get; set; }`

`public int MemberCount { get; }`

`public void AddValue(string name, short value);`

`public void AddValue(string name, ushort value);`

`public void AddValue(string name, int value);`

`...`

`}`

实现`ISerializable`接口的类型还必须定义一个采用以下签名的特殊构造函数:

`// You must supply a custom constructor with this signature`

`// to allow the runtime engine to set the state of your object.`

`[Serializable]`

`class SomeClass : ISerializable`

`{`

`protected SomeClass (SerializationInfo si, StreamingContext ctx) {...}`

`...`

`}`

请注意，此构造函数的可见性被设置为 protected。这是允许的，因为格式化程序将可以访问该成员，而不管其可见性如何。这些特殊的构造函数往往被标记为 protected(或者 private ),以确保普通的对象用户永远无法以这种方式创建对象。这个构造函数的第一个参数是一个`SerializationInfo`类型的实例(您之前已经见过了)。

这个特殊构造函数的第二个参数是一个`StreamingContext`类型，它包含关于位来源的信息。`StreamingContext`中信息最丰富的成员是`State`属性，它代表来自`StreamingContextStates`枚举的一个值。此枚举的值表示当前流的基本组成。

除非您打算实现一些低级自定义远程处理服务，否则很少需要直接处理此枚举。然而，这里是`StreamingContextStates`枚举的可能名称(参考。NET Framework 4.6 SDK 文档以了解完整的详细信息):

`public enum StreamingContextStates`

`{`

`CrossProcess,`

`CrossMachine,`

`File,`

`Persistence,`

`Remoting,`

`Other,`

`Clone,`

`CrossAppDomain,`

`All`

`}`

现在让我们看看如何使用`ISerializable`定制序列化过程。假设您有一个新的控制台应用程序项目(名为 CustomSerialization ),它定义了一个包含两点`string`数据的类类型。还假设您必须确保`string`对象全部以大写形式序列化到流中，并以小写形式从流中反序列化。为了说明这些规则，您可以像这样实现`ISerializable`(确保导入`System.Runtime.Serialization`名称空间):

`[Serializable]`

`class StringData : ISerializable`

`{`

`private string dataItemOne = "First data block";`

`private string dataItemTwo= "More data";`

`public StringData(){}`

`protected StringData(SerializationInfo si, StreamingContext ctx)`

`{`

`// Rehydrate member variables from stream.`

`dataItemOne = si.GetString("First_Item").ToLower();`

`dataItemTwo = si.GetString("dataItemTwo").ToLower();`

`}`

`void ISerializable.GetObjectData(SerializationInfo info, StreamingContext ctx)`

`{`

`// Fill up the SerializationInfo object with the formatted data.`

`info.AddValue("First_Item", dataItemOne.ToUpper());`

`info.AddValue("dataItemTwo", dataItemTwo.ToUpper());`

`}`

`}`

注意，当您用`GetObjectData()`方法填充`SerializationInfo`类型时，您不需要将数据点命名为与类型的内部成员变量相同。如果您需要进一步将类型的数据从持久化格式中分离出来，这显然会很有帮助。但是，请注意，您将需要使用在`GetObjectData()`中分配的相同名称从特殊的、受保护的构造函数中获取值。

为了测试您的定制，假设您想要使用一个`SoapFormatter`持久化一个`MyStringData`实例(因此相应地更新您的程序集引用和导入)，如下所示:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Custom Serialization *****");`

`// Recall that this type implements ISerializable.`

`StringData myData = new StringData();`

`// Save to a local file in SOAP format.`

`SoapFormatter soapFormat = new SoapFormatter();`

`using(Stream fStream = new FileStream("MyData.soap",`

`FileMode.Create, FileAccess.Write, FileShare.None))`

`{`

`soapFormat.Serialize(fStream, myData);`

`}`

`Console.ReadLine();`

`}`

当您查看生成的`*.soap`文件时，您将会看到字符串字段以大写形式保存，如下所示:

`<SOAP-ENV:Envelope xmlns:xsi="`[`http://www.w3.org/2001/XMLSchema-instance`](http://www.w3.org/2001/XMLSchema-instance)T2】

`xmlns:xsd="`[`http://www.w3.org/2001/XMLSchema`](http://www.w3.org/2001/XMLSchema)T2】

`xmlns:SOAP-ENC="`[`http://schemas.xmlsoap.org/soap/encoding/`](http://schemas.xmlsoap.org/soap/encoding/)T2】

`xmlns:SOAP-ENV="`[`http://schemas.xmlsoap.org/soap/envelope/`](http://schemas.xmlsoap.org/soap/envelope/)T2】

`xmlns:clr="`[`http://schemas.microsoft.com/soap/encoding/clr/1.0`](http://schemas.microsoft.com/soap/encoding/clr/1.0)T2】

`SOAP-ENV:encodingStyle="`[`http://schemas.xmlsoap.org/soap/encoding/`](http://schemas.xmlsoap.org/soap/encoding/)T2】

`<SOAP-ENV:Body>`

`<a1:StringData id="ref-1" ...>`

`<First_Item id="ref-3">FIRST DATA BLOCK</First_Item>`

`<dataItemTwo id="ref-4">MORE DATA</dataItemTwo>`

`</a1:StringData>`

`</SOAP-ENV:Body>`

`</SOAP-ENV:Envelope>`

### 使用属性自定义序列化

虽然实现`ISerializable`接口是定制序列化过程的一种方式，但是定制序列化过程的首选方式是定义具有任何新的以序列化为中心的属性的方法:`[OnSerializing]`、`[OnSerialized]`、`[OnDeserializing]`或`[OnDeserialized]`。使用这些属性没有实现`ISerializable`麻烦，因为您不需要手动与传入的`SerializationInfo`参数交互。相反，当格式化程序对类型进行操作时，您可以直接修改状态数据。

Note

您可以在`System.Runtime.Serialization`名称空间中找到这些序列化属性。

当您定义用这些属性修饰的方法时，您必须定义这些方法，以便它们接收一个`StreamingContext`参数并且不返回任何东西(否则，您将收到一个运行时异常)。请注意，您不需要考虑每个以序列化为中心的属性，您可以简单地处理想要拦截的序列化阶段。下面的片段说明了这一点。这里，一个新的`[Serializable]`类型具有与`StringData`相同的需求，但是这次您使用了`[OnSerializing]`和`[OnDeserialized]`属性:

`[Serializable]`

`class MoreData`

`{`

`private string dataItemOne = "First data block";`

`private string dataItemTwo= "More data";`

`[OnSerializing]`

`private void OnSerializing(StreamingContext context)`

`{`

`// Called during the serialization process.`

`dataItemOne = dataItemOne.ToUpper();`

`dataItemTwo = dataItemTwo.ToUpper();`

`}`

`[OnDeserialized]`

`private void OnDeserialized(StreamingContext context)`

`{`

`// Called when the deserialization process is complete.`

`dataItemOne = dataItemOne.ToLower();`

`dataItemTwo = dataItemTwo.ToLower();`

`}`

`}`

如果您要序列化这个新类型，您会再次发现数据已经被持久化为大写，并被反序列化为小写。

Source Code

您可以在 [`Chapter 20`](20.html) 子目录中找到 CustomSerialization 项目。

有了这个例子，您对对象序列化服务的核心细节的探索就完成了，包括定制这个过程的各种方法。正如您所看到的，序列化和反序列化过程使得持久化大量数据变得容易，并且比使用各种各样的`System.IO`名称空间的读取器/写入器类更省力。

## 摘要

你在本章开始时研究了`Directory(Info)`和`File(Info)`类型的使用。正如您所了解的，这些类允许您操作硬盘上的物理文件或目录。接下来，您研究了许多从抽象的`Stream`类派生的类。假定`Stream`派生的类型在原始字节流上操作，`System.IO`命名空间提供了许多读取器/写入器类型(例如`StreamWriter`、`StringWriter`和`BinaryWriter`)，从而简化了这个过程。在这个过程中，您还了解了由`DriveType`提供的功能，学习了如何使用`FileSystemWatcher`类型来监控文件，并了解了如何以异步方式与流进行交互。

本章还向您介绍了对象序列化服务的主题。如您所见。NET 平台使用对象图来说明您希望保留到流中的相关对象的完整集合。只要对象图中的每个成员都标有`[Serializable]`属性，数据就会使用您选择的格式(二进制或 SOAP)持久化。

您还了解了使用两种可能的方法定制现成的序列化过程是可能的。首先，您学习了如何实现`ISerializable`接口(并支持一个特殊的私有构造函数)，这使您能够更多地参与格式化程序如何持久存储所提供的数据。第二，你学到了一套。NET 属性来简化自定义序列化的过程。您所需要做的就是对接受`StreamingContext`参数的成员应用`[OnSerializing]`、`[OnSerialized]`、`[OnDeserializing]`或`[OnDeserialized]`属性，格式化程序将相应地调用它们。