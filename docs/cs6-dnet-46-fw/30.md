# 30.通知、命令、验证和 MVVM

本章将通过向您介绍可观察模式和 WPF 内置的通知系统来结束您对 WPF 编程模型的研究。您还将扩展您的命令和验证知识。这三项是在 WPF 实现模型-视图-视图模型(MVVM)模式的基础。

第一部分包括可观察模型和可观察集合。当类和集合分别实现`INotifyPropertyChanged`和`INotifyCollectionChanged`时，绑定管理器将 UI 中的值与绑定的数据保持同步。让 UI 中的数据准确地描述数据的当前状态可以自动显著改善用户体验，并减少在旧技术(如 WinForms)中实现相同结果所需的手动编码。

在可观察模式的基础上，您将研究向应用程序中添加验证的机制。验证是任何应用程序的重要组成部分——不仅让用户知道出了问题，也让他们知道出了什么问题。为了通知用户错误是什么，您还将学习如何将验证合并到视图标记中。

接下来，你将更深入地研究 WPF 命令系统，创建自定义命令来封装程序逻辑，就像你在第 27 章中对内置命令所做的一样。创建定制命令有几个优点，包括(但不限于)支持代码重用、逻辑封装和更干净的代码。

最后，您将了解模型-视图-视图模型(MVVM)模式，以及所有这些材料如何组合在一起支持该模式。图 [30-1](#Fig1) 显示了您将在本章中构建的应用程序。

![A978-1-4842-1332-2_30_Fig1_HTML.jpg](A978-1-4842-1332-2_30_Fig1_HTML.jpg)

图 30-1。

Fun with MVVM!

## 介绍模型-视图-视图模型

在深入研究 WPF 中的通知、验证和命令之前，最好理解本章的最终目标，即模式-视图-视图模型模式(MVVM)。

MVVM 源自马丁·福勒的表示模型模式，它利用了本章中讨论的 XAML 特有的能力，使你的 WPF 开发更快更干净。名称本身描述了模式的主要组成部分:模型、视图、视图模型。

### 模型

模型是数据的对象表示。在本章的示例中，模型是`Inventory`类。这并不意味着实际的数据存储(如 SQL Server)，而是表示存储在持久层中的数据的类。

模型通常有内置的验证(你将在本章后面的验证部分看到)并且被配置为可观察的，这也将在本章后面讨论。

### 视角

视图是应用程序的 UI，它被设计成非常轻量级的。想想免下车餐馆的菜单板。该板显示菜单项和价格，并且它有一个机制，以便用户可以与后端系统通信。然而，该板没有内置任何智能，除非它与餐厅本身隔离，在这种情况下，它可能会有一个光传感器，如果天黑了，它会打开灯。

应该怀着同样的目标发展 MVVM 观点。任何智能都应该内置到应用程序的其他地方。代码隐藏文件中的唯一代码(例如`MainWindow.xaml.cs`)应该与操作 UI 直接相关。它不应该基于业务规则或任何需要保留以备将来使用的东西。虽然这不是 MVVM 的目标，但代码隐藏中很少的代码(如果有的话)是一个令人愉快的副作用。

### 视图模型

在 WPF 和其他 XAML 技术中，视图模型有两个用途:

*   ViewModel 为视图所需的所有数据提供了一站式服务。这并不意味着 ViewModel 负责获取实际数据；相反，它调用相关的代码(比如 EF 存储库)将所有的数据集中到容易访问的地方。因此，在我的代码中，窗口和视图模型之间通常存在一对一的关联，但是存在架构上的差异，您的收获可能会有所不同。
*   第二项工作是充当视图的控制器。就像菜单板一样，ViewModel 接受用户的指示，并调用代码来确保采取正确的操作。该代码通常是命令的形式。

### 贫血模型或视图模型

在 WPF 的早期，当开发人员还在研究如何最好地实现 MVVM 模式时，就在哪里实现诸如验证和可观察模式之类的项目进行了重要的(有时甚至是激烈的)讨论。一个阵营(贫血模型阵营)认为，所有这些都应该在视图模型中，因为将这些功能添加到模型中打破了关注点的分离。另一个阵营(缺乏活力的 ViewModel 阵营)认为应该全部放在模型中，因为这样可以减少代码的重复。

真正的答案当然是视情况而定。当`INotifyPropertyChanged`、`IDataErrorInfo`和`INotifyDataErrorInfo`在`model`类上实现时，这确保了相关代码接近代码的目标(正如你将在本章中看到的)，并且对于每个模型只实现一次。也就是说，有时候你的`ViewModel`类本身也需要被开发成可观察的。在一天结束时，您需要确定什么是最有意义的，而不会使您的代码过于复杂或牺牲 MVVM 的好处。

Note

有多种 MVVM 框架可用于 WPF，如 MVVMLite、Caliburn。Micro 和 Prism(尽管 Prism 不仅仅是一个 MVVM 框架)。每个框架都有其优点和(在某种程度上)缺点。本章讨论 MVVM 模式和 WPF 支持实现该模式的特性。读者朋友们，我让你们来研究不同的框架，并选择最符合你们应用需求的框架。

## WPF 约束通知系统

WinForms 绑定系统的一个显著缺点是缺少通知。如果数据源中的数据发生变化，用户界面不会自动更新。相反，开发人员需要在控件从数据源重新加载数据之前调用控件上的`Refresh`。这可能导致对`Refresh`的调用比实际需要的多，因为大多数开发人员希望确保 UI 和数据不会不同步。虽然包含太多并不是一个重大的性能问题，但是如果您没有包含足够多，用户的体验可能会受到负面影响。

内置于基于 XAML 的应用程序中的绑定系统纠正了这个问题，它使您能够将数据对象挂钩到通知系统中。挂钩到这个系统的类和集合被称为可观察模型和可观察集合，或者统称为可观察。每当一个属性的值在一个可观察的模型上发生变化，或者集合在一个可观察的集合上发生变化(例如，项目被添加、删除或重新排序)，它们就会引发一个事件(或者是`NotifyPropertyChanged`或者是`NotifyCollectionChanged`)。绑定框架自动侦听这些事件的发生，并在它们触发时更新绑定的控件。更好的是，作为开发人员，您可以控制哪些属性会引发通知。听起来很完美，对吧？你很快就会看到，它并不完美。如果您全部手动完成，那么为可观察模型设置这一点需要相当多的代码。幸运的是，有一个开源框架使它变得更简单，您很快就会看到这一点。

### 可观察模型和集合

在本节中，您将创建一个使用可观察模型和集合的应用程序。首先，创建一个名为`Notifications`的新 WPF 应用程序。该表单将是一个主详细信息表单，允许用户使用`ComboBox`选择特定的汽车，然后该汽车的详细信息将显示在下面的`TextBoxes`中。将`MainWindow.xaml`更新为以下标记:

`<Window x:Class="Notifications.MainWindow"`

`ExternalRef"> http://schemas.microsoft.com/winfx/2006/xaml/presentation` `"`

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`xmlns:d="`[`http://schemas.microsoft.com/expression/blend/2008`](http://schemas.microsoft.com/expression/blend/2008)T2】

`xmlns:mc="`[`http://schemas.openxmlformats.org/markup-compatibility/2006`](http://schemas.openxmlformats.org/markup-compatibility/2006)T2】

`xmlns:local="clr-namespace:Notifications"`

`mc:Ignorable="d"`

`Title="Fun with Notifications!" Height="225" Width="325"`

`WindowStartupLocation="CenterOwner">`

`<Grid IsSharedSizeScope="True" Margin="5,0,5,5">`

`<Grid.RowDefinitions>`

`<RowDefinition Height="Auto"/>`

`<RowDefinition Height="Auto"/>`

`</Grid.RowDefinitions>`

`<Grid Grid.Row="0">`

`<Grid.ColumnDefinitions>`

`<ColumnDefinition Width="Auto" SharedSizeGroup="CarLabels"/>`

`<ColumnDefinition Width="*"/>`

`</Grid.ColumnDefinitions>`

`<Label Grid.Column="0" Content="Vehicle"/>`

`<ComboBox Name="cboCars"  Grid.Column="1" DisplayMemberPath="PetName" />`

`</Grid>`

`<Grid Grid.Row="1">`

`<Grid.ColumnDefinitions>`

`<ColumnDefinition Width="Auto" SharedSizeGroup="CarLabels"/>`

`<ColumnDefinition Width="*"/>`

`</Grid.ColumnDefinitions>`

`<Grid.RowDefinitions>`

`<RowDefinition Height="Auto"/>`

`<RowDefinition Height="Auto"/>`

`<RowDefinition Height="Auto"/>`

`<RowDefinition Height="Auto"/>`

`</Grid.RowDefinitions>`

`<Label Grid.Column="0" Grid.Row="0" Content="Make"/>`

`<TextBox Grid.Column="1" Grid.Row="0" />`

`<Label Grid.Column="0" Grid.Row="1" Content="Color"/>`

`<TextBox Grid.Column="1" Grid.Row="1" />`

`<Label Grid.Column="0" Grid.Row="2" Content="Pet Name"/>`

`<TextBox Grid.Column="1" Grid.Row="2" />`

`<StackPanel Grid.Column="0" Grid.ColumnSpan="2" Grid.Row="3"`

`HorizontalAlignment="Right" Orientation="Horizontal" Margin="0,5,0,5">`

`<Button x:Name="btnAddCar" Content="Add Car" Margin="5,0,5,0" Padding="4, 2" />`

`<Button x:Name="btnChangeColor" Content="Change Color" Margin="5,0,5,0"`

`Padding="4, 2"/>`

`</StackPanel>`

`</Grid>`

`</Grid>`

`</Window>`

您的窗口将类似于图 [30-2](#Fig2) 。

![A978-1-4842-1332-2_30_Fig2_HTML.jpg](A978-1-4842-1332-2_30_Fig2_HTML.jpg)

图 30-2。

Master Detail window displaying inventory details

接下来，在解决方案资源管理器中右键单击项目名称，选择添加名为`Models`的➤新文件夹，并在这个新文件夹中创建一个名为`Inventory`的类。这里列出了初始类:

`public class Inventory`

`{`

`public int CarId { get; set; }`

`public string Make { get; set; }`

`public string Color { get; set; }`

`public string PetName { get; set; }`

`}`

### 添加绑定和数据

下一步是为控件添加绑定语句。为此，向保存文本框和标签的`Grid`添加一个`DataContext`。将`DataContext`设置为`ComboBox`的`SelectedItem`属性。将保存细节控制的`Grid`更新为以下内容:

`<Grid Grid.Row="1" DataContext="{Binding ElementName=cboCars, Path=SelectedItem}">`

提醒一下，如果没有指定的话，控件将在元素树中向上导航一个`DataContext`。这使您能够在`TextBox` es 中指定绑定的路径。将适当的文本属性和相关绑定添加到`TextBox` es 中，如下所示:

`<TextBox Grid.Column="1" Grid.Row="0" Text="{Binding Path=Make}" />`

`<TextBox Grid.Column="1" Grid.Row="1" Text="{Binding Path=Color}" />`

`<TextBox Grid.Column="1" Grid.Row="2" Text="{Binding Path=PetName}" />`

最后，将数据添加到`ComboBox`中。在`MainWindow.xaml.cs`中，创建一个新的`Inventory`记录列表，并将`ComboBox`的`ItemsSource`设置到列表中。还要为`Notifications.Models`名称空间添加`using`语句。

`using Notifications.Models;`

`public class MainWindow : Window`

`{`

`readonly IList<Inventory> _cars;`

`public MainWindow()`

`{`

`InitializeComponent();`

`_cars = new List<Inventory>`

`{`

`new Inventory {CarId=1,Color="Blue",Make="Chevy",PetName="Kit" },`

`new Inventory {CarId=2,Color="Red",Make="Ford",PetName="Red Rider" },`

`};`

`cboCars.ItemsSource = _cars;`

`}`

`}`

运行应用程序。您将看到车辆选择器有两辆车可供选择。选择其中之一，文本框将自动填充车辆的详细信息，如图 [30-3](#Fig3) 所示。更改其中一辆车的颜色，选择另一辆车，然后返回到您编辑的车辆。你会看到新的颜色确实仍然附着在车辆上。这没什么了不起的。在前面的例子中，您已经看到了 XAML 数据绑定的强大功能。

![A978-1-4842-1332-2_30_Fig3_HTML.jpg](A978-1-4842-1332-2_30_Fig3_HTML.jpg)

图 30-3。

The window with data

### 以编程方式更改车辆数据

虽然前面的示例按预期工作，但如果数据以编程方式更改，UI 将不会反映这些更改，除非您对应用程序进行编程以刷新数据。为了演示这一点，为`btnChangeColor`按钮添加一个事件处理程序，如下所示:

`<Button x:Name="btnAddCar" Content="Add Car" Margin="5,0,5,0" Padding="4, 2" Click="btnAddCar_Click"/>`

为`btnChangeColor_Click`事件创建(或让 Visual Studio 为您创建)事件处理程序，如下所示:

`private void btnChangeColor_Click(object sender, RoutedEventArgs e)`

`{`

`}`

在事件处理程序中，使用`ComboBox`的`SelectedItem`属性从汽车列表中定位所选记录。如果找到匹配，将颜色更改为粉红色。代码如下所示:

`private void btnChangeColor_Click(object sender, RoutedEventArgs e)`

`{`

`var car = _cars.FirstOrDefault(x => x.CarId == ((Inventory)cboCars.SelectedItem)?.CarId);`

`if (car != null)`

`{`

`car.Color = "Pink";`

`}`

`}`

运行应用程序，选择一辆车，然后单击“改变颜色”按钮。没有明显的变化。选择另一辆车，然后回到最初选择的车。现在您将看到更新后的值。这对用户来说不是很好的体验！

现在给`btnAddCar`按钮添加一个事件处理程序，如下所示:

`<Button x:Name="btnAddCar" Content="Add Car" Margin="5,0,5,0" Padding="4,2" Click="btnAddCar_Click"/>`

为`btnAddCar_Click`事件处理程序添加事件处理程序(或者让 Visual Studio 为您创建)，如下所示:

`private void btnAddCar_Click(object sender, RoutedEventArgs e)`

`{`

`}`

在`btnAddCar_Click`事件处理程序中，向`Inventory`列表添加一条新记录。

`private void btnAddCar_Click(object sender, RoutedEventArgs e)`

`{`

`var maxCount = _cars?.Max(x => x.CarId) ?? 0;`

`_cars?.Add(new Inventory { CarId=++maxCount,Color="Yellow",Make="VW",PetName="Birdie"});`

`}`

运行应用程序，单击 Add Car 按钮，并检查组合框的内容。尽管您知道列表中有三辆汽车，但只显示了两辆！

为了纠正这两个问题，您将使用可观察的模型和可观察的集合。这些变化将在下一节中介绍。

### 可观测模型

通过在您的`Inventory`模型类上实现`INotifyPropertyChanged`接口，解决了您的模型属性上的数据更改和不在 UI 中显示的问题。`INotifyPropertyChanged`接口只公开了一个事件:T3。只要类实现了`INotifyPropertyChanged`接口，XAML 绑定引擎就会监听每个绑定属性的这个事件。界面如下所示:

`public interface INotifyPropertyChanged`

`{`

`event PropertyChangedEventHandler PropertyChanged;`

`}`

`PropertyChanged`事件接受一个对象引用和一个`PropertyChangedEventArgs`类的新实例，如下所示:

`PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("Model"));`

第一个参数是引发事件的对象实例。`PropertyChangedEventArgs`构造函数接受一个字符串，该字符串表示属性已被更改，需要更新。当引发事件时，绑定引擎会在该实例上查找绑定到命名属性的任何控件。如果将`string.Empty`传递给`PropertyChangedEventArgs`，那么实例的所有绑定属性都会更新。

通过在 setter 中为您想要自动更新的属性引发`PropertyChanged`事件，您可以控制哪些属性被列入自动更新。这通常是模型类的所有属性，但是您可以根据应用程序的需求选择省略某些属性。一种常见的模式是创建一个帮助器方法(通常名为`OnPropertyChanged)`)来代表属性引发事件，而不是在 setter 中为每个登记的属性直接引发事件，通常是在模型的基类中。

在的版本中。在 4.5 之前的. NET 版本中，您必须将属性的字符串名称传递给助手方法。如果你的类的属性名改变了，你必须记住更新传入 helper 方法的字符串，否则更新将不起作用。开始于。NET 4.5，可以利用`[CallerMemberName]`属性。该属性将调用您的帮助器方法的方法(您的属性 setter)的名称分配给`propertyName`参数。向`Inventory`类添加一个方法(名为`OnPropertyChanged)`，并像这样提升`PropertyChangedEvent`:

`internal void OnPropertyChanged([CallerMemberName] string propertyName = "")`

`{`

`PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));`

`}`

接下来，更新`Inventory`类中的每个自动属性，使其拥有一个完整的 getter 和 setter 以及一个支持字段。当值改变时，调用`OnPropertyChanged`帮助器方法。下面是更新后的`CarId`属性:

`private int _carId;`

`public int CarId`

`{`

`get { return _carId; }`

`set`

`{`

`if (value == _carId) return;`

`_carId = value;`

`OnPropertyChanged();`

`}`

`}`

对`Inventory`类进行了一些修改，包括实现`INotifyPropertyChanged`事件，引发`PropertyChanged`事件，以及将所有自动属性转换为带有支持字段的显式属性。下面列出了更新后的类:

`using System.ComponentModel;`

`using System.Runtime.CompilerServices;`

`namespace Notifications.Models`

`{`

`public class Inventory : INotifyPropertyChanged`

`{`

`private int _carId;`

`public int CarId`

`{`

`get { return _carId; }`

`set`

`{`

`if (value == _carId) return;`

`_carId = value;`

`OnPropertyChanged();`

`}`

`}`

`private string _make;`

`public string Make`

`{`

`get { return _make; }`

`set`

`{`

`if (value == _make) return;`

`_make = value;`

`OnPropertyChanged();`

`}`

`}`

`private string _color;`

`public string Color`

`{`

`get { return _color; }`

`set`

`{`

`if (value == _color) return;`

`_color = value;`

`OnPropertyChanged();`

`}`

`}`

`private string _petName;`

`public string PetName`

`{`

`get { return _petName; }`

`set`

`{`

`if (value == _petName) return;`

`_petName = value;`

`OnPropertyChanged();`

`}`

`}`

`public event PropertyChangedEventHandler PropertyChanged;`

`internal void OnPropertyChanged([CallerMemberName] string propertyName = "")`

`{`

`PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));`

`}`

`}`

`}`

再次运行应用程序。选择一辆车并点击“改变颜色”按钮。您将立即看到 UI 中显示的更改。第一个问题解决！

#### 使用名称 of

C# 6 中的一个新特性是`nameof`操作符，它提供了传递给`nameof`方法的项目的字符串名称。您可以在 setters 中调用`OnPropertyChanged`，就像这样:

`private string _color;`

`public string Color`

`{`

`get { return _color; }`

`set`

`{`

`if (value == _color) return;`

`_color = value;`

`OnPropertyChanged(nameof(Color));`

`}`

`}`

注意，当您使用`nameof`方法时，您不必从`OnPropertyChanged`中移除`CallerMemberName`属性(尽管这变得没有必要)。最后，是使用`nameof`方法还是`CallerMemberName`属性，这取决于个人的选择。

### 可观察的集合

下一个要解决的问题是当集合的内容改变时更新 UI。这是通过实现`INotifyCollectionChanged`接口来完成的。像`INotifyPropertyChanged`接口一样，这个接口公开了一个事件，即`CollectionChanged`事件。与`INotifyPropertyChanged`事件不同，手工实现这个接口不仅仅是调用 setter 中的一个方法。您需要创建一个完整的`List`实现，并在列表发生变化时引发`CollectionChanged`事件。

`CollectionChanged`事件接受一个参数，即`CollectionChangedEventArgs`的一个新实例。根据操作，`CollectionChangedEventArgs`在其构造函数中接受一个或多个参数。第一个参数总是`NotifyCollectionChangedAction enum`值之一，它通知绑定引擎列表发生了什么变化。`NotifyCollectionChangedAction enum`的值如表 [30-1](#Tab1) 所示。

表 30-1。

NotifyCollectionChangedAction enum Values

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `Add` | 一个或多个时间被添加到集合中。 |
| `Move` | 集合中移动了一个或多个项目。 |
| `Remove` | 从集合中移除了一个或多个项目。 |
| `Replace` | 集合中的一个或多个项目被替换。 |
| `Reset` | 变化如此之大，以至于最好的选择是重新开始，重新绑定与该集合相关的所有内容。 |

`NotifyCollectionChangedEventArgs`的构造函数的选项根据所宣布的动作而变化。表 [30-2](#Tab2) 列出了发送给构造函数的操作和附加参数。

表 30-2。

NotifyCollectionChangedEventArgs Constructor Options

<colgroup><col> <col></colgroup> 
| 操作 | 附加参数 |
| --- | --- |
| `Reset` | 没有人 |
| `Add (single)` | 要添加的项目，[可选]添加位置的索引 |
| `Add (List)` | 要添加的项目，[可选]添加位置的索引 |
| `Remove (single)` | 要删除的项目，[可选]要删除的项目的索引 |
| `Remove (List)` | 要移除的项目，[可选]移除位置的开始索引 |
| `Move (Single)` | 要移动的项目、原始索引、目标索引 |
| `Move (List)` | 要移动的项目、起始原始索引、目标索引 |
| `Replace (single)` | 要添加的项目，要删除的项目，[可选]变更索引 |
| `Replace (List)` | 要添加的项目，要删除的项目，[可选]变更的起始索引 |

这里有许多不同的玩法。下一节展示了适用于运行中的`IList<T>`的选项。

#### 建筑自定义列表

要查看这样的例子，在您的`Models`目录中创建一个新类，并将该类命名为`InventoryList`。实现`IList<Inventory>`和`INotifyCollectionChanged`接口，当它们被切断时，会产生下面的代码:

`public class InventoryList : IList<Inventory>, INotifyCollectionChanged`

`{`

`public IEnumerator<Inventory> GetEnumerator()`

`{`

`throw new System.NotImplementedException();`

`}`

`IEnumerator IEnumerable.GetEnumerator()`

`{`

`return GetEnumerator();`

`}`

`public void Add(Inventory item)`

`{`

`throw new System.NotImplementedException();`

`}`

`public void Clear()`

`{`

`throw new System.NotImplementedException();`

`}`

`public bool Contains(Inventory item)`

`{`

`throw new System.NotImplementedException();`

`}`

`public void CopyTo(Inventory[] array, int arrayIndex)`

`{`

`throw new System.NotImplementedException();`

`}`

`public bool Remove(Inventory item)`

`{`

`throw new System.NotImplementedException();`

`}`

`public int Count { get; }`

`public bool IsReadOnly { get; }`

`public int IndexOf(Inventory item)`

`{`

`throw new System.NotImplementedException();`

`}`

`public void Insert(int index, Inventory item)`

`{`

`throw new System.NotImplementedException();`

`}`

`public void RemoveAt(int index)`

`{`

`throw new System.NotImplementedException();`

`}`

`public Inventory this[int index]`

`{`

`get { throw new System.NotImplementedException(); }`

`set { throw new System.NotImplementedException(); }`

`}`

`public event NotifyCollectionChangedEventHandler CollectionChanged;`

`}`

开始更新这个类，为`CollectionChanged`事件添加一个名为`OnCollectionChanged`的助手方法。在这个方法中，如果`CollectionChanged`不为空，就调用它，就像这样:

`public event OnCollectionChangedEventHandler CollectionChanged;`

`private void OnCollectionChanged(NotifyCollectionChangedEventArgs args)`

`{`

`CollectionChanged?.Invoke(this, args);`

`}`

接下来，添加一个名为 _ `inventories`、类型为`IList<Inventory>`的私有字段，以及一个新的构造函数，该构造函数采用一个`IList<Inventory>`并初始化该字段，如下所示:

`private readonly IList<Inventory> _inventories;`

`public InventoryList(IList<Inventory> inventories)`

`{`

`_inventories = inventories;`

`}`

接下来，为 list 添加一些管道方法。这些方法不会改变列表的状态，但是对于实现`IList<T>`是必要的，如下所示:

`public IEnumerator<Inventory> GetEnumerator() => _inventories.GetEnumerator();`

`IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();`

`public bool Contains(Inventory item) => _inventories.Contains(item);`

`public void CopyTo(Inventory[] array, int arrayIndex)`

`{`

`_inventories.CopyTo(array, arrayIndex);`

`}`

`public int Count => _inventories.Count;`

`public bool IsReadOnly => _inventories.IsReadOnly;`

`public int IndexOf(Inventory item) => _inventories.IndexOf(item);`

第一种清除方法是`Add`方法。将项目添加到`_inventories`列表中，并调用`OnCollectionChanged`方法，传入`NotificationCollectionChangedAction.Add`值和要添加的新项目。更新后的代码如下所示:

`public void Add(Inventory item)`

`{`

`_inventories.Add(item);`

`OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, item));`

`}`

`Insert`方法在指定的索引处添加一条记录。在该方法中，将项目插入到`_inventories`列表的正确索引处。然后调用`OnCollectionChanged`方法，传入`NotificationCollectionChangedAction.Add`值、要添加的新项和变更的索引。更新后的代码如下所示:

`public void Insert(int index, Inventory item)`

`{`

`_inventories.Insert(index, item);`

`OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Add, item, index));`

`}`

要执行用索引器替换的方法，请在`OnCollectionChanged`调用中传入`NotifyCollectionChangedAction.Replace`值和更新的项:

`public Inventory this[int index]`

`{`

`get { return _inventories?[index]; }`

`set`

`{`

`_inventories[index] = value;`

`OnCollectionChanged(new NotifyCollectionChangedEventArgs(`

`NotifyCollectionChangedAction.Replace, _inventories[index]));`

`}`

`}`

接下来，更新`Remove`方法。从`_inventories`列表中移除项目，并调用`OnCollectionChanged`方法，传入`NotificationCollectionChangedAction.Remove`值和要移除的项目。更新后的代码如下所示:

`public bool Remove(Inventory item)`

`{`

`var removed = _inventories.Remove(item);`

`if (removed)`

`{`

`OnCollectionChanged(new NotifyCollectionChangedEventArgs(`

`NotifyCollectionChangedAction.Remove, item));`

`}`

`return removed;`

`}`

接下来，更新`RemoveAt`方法。在`IList<T>`接口上的`RemoveAt`方法只接受一个索引，并且没有一个版本的`NotifyCollectionEventArgs`构造函数只接受一个索引。因此，在从列表中删除它之前，您需要首先从`_inventories`列表中获得正确对象的引用。接下来，使用提供的索引值从`_inventories`列表中删除该项目。最后，调用`OnCollectionChanged`方法，传入`NotificationCollectionChangedAction.Remove`值、要移除的项目和索引。

Note

如果您没有获得对正确对象的引用，您必须将`NotifyCollectionChangedEventArgs.Reset`传递给事件，这可能会影响性能，因为它会刷新 UI 中绑定到该列表的所有内容。

更新后的代码如下所示:

`public void RemoveAt(int index)`

`{`

`var itm = _inventories[index];`

`_inventories.RemoveAt(index);`

`OnCollectionChanged(new NotifyCollectionChangedEventArgs(`

`NotifyCollectionChangedAction.Remove,itm,index));`

`}`

最后，更新`Clear`方法。因为这完全改变了列表，所以传入`NotifyCollectionChangedAction.Reset`，如下所示:

`public void Clear()`

`{`

`_inventories.Clear();`

`OnCollectionChanged(new NotifyCollectionChangedEventArgs(NotifyCollectionChangedAction.Reset));`

`}`

既然您已经创建了一个也实现了`INotifyCollectionChanged`的自定义`IList<Inventory>`，那么是时候在您的应用程序中使用它了。打开`MainForm.xaml.cs`，将`_cars`变量的类型改为`InventoryList`，并更新构造函数创建一个新的`InventoryList`，如下:

`private readonly InventoryList _cars;`

`public MainWindow()`

`{`

`InitializeComponent();`

`_cars = new InventoryList(new List<Inventory>`

`{`

`//IsChanged must be last in the list`

`new Inventory {CarId=1,Color="Blue",Make="Chevy",PetName="Kit", IsChanged = false},`

`new Inventory {CarId=2,Color="Red",Make="Ford",PetName="Red Rider", IsChanged = false },`

`});`

`cboCars.ItemsSource = _cars;`

`}`

运行应用程序，单击 Add Car 按钮，验证组合框中的汽车数量确实增加了。现在，通过在 Change Color 按钮后添加一个新按钮来测试删除记录。将新按钮命名为`btnRemoveCar`，设置内容为“移除汽车”，设置`Click`事件为`btnRemoveCar_Click`，如下:

`<Button x:Name="btnRemoveCar" Content="Remove Car" Margin="5,0,5,0" Padding="4,2" Click="btnRemoveCar_Click"/>`

创建事件处理程序(或者让 Visual Studio 为您创建)，并添加一个调用来从`_cars`列表中删除第一条记录。代码如下所示:

`private void btnRemoveCar_Click(object sender, RoutedEventArgs e)`

`{`

`_cars.RemoveAt(0);`

`}`

运行应用程序，单击 Remove Car 按钮，并验证组合框中的汽车数量确实减少了。集合改变和不更新 UI 的问题确实得到了解决，但是需要编写大量的代码。

#### 使用可观察集合

幸运的是，有一种比创建自己的收藏更简单的方法。`ObservableCollection<T>`类实现了`INotifyCollectionChanged`、`INotifyPropertyChanged`和`Collection<T>,`，它是框架的一部分。没有额外的工作！为了演示这一点，为`System.Collections.ObjectModel`添加一个`using`语句，然后将`_cars`的私有字段和`MainWindow.xaml.cs`中的构造函数更新如下:

`readonly ObservableCollection<Inventory> _cars;`

`public MainWindow()`

`{`

`InitializeComponent();`

`_cars = new ObservableCollection<Inventory>`

`{`

`new Inventory {CarId=1,Color="Blue",Make="Chevy",PetName="Kit" },`

`new Inventory {CarId=2,Color="Red",Make="Ford",PetName="Red Rider" },`

`};`

`cboCars.ItemsSource = _cars;`

`}`

再次运行应用程序，然后单击添加汽车和移除汽车按钮。您将看到新记录适当地出现(和消失)。

#### 实现脏标志

可观测模型的另一个优点是跟踪状态变化。虽然像 Entity Framework 这样的一些对象关系映射器(ORMS)提供了一些基本的状态跟踪，但是对于可观察模型，脏跟踪(当一个或多个对象的值发生变化时进行跟踪)是微不足道的。将名为`IsChanged`的 bool 属性添加到`Inventory`类中。确保像调用`Inventory`类中的其他属性一样调用`OnPropertyChanged`。

`private bool _isChanged;`

`public bool IsChanged {`

`get { return _isChanged;}`

`set`

`{`

`if (value == _isChanged) return;`

`_isChanged = value;`

`OnPropertyChanged();`

`}`

`}`

打开`MainWindows.xaml`，在包含细节`TextBox` es 的`Grid`中增加一个额外的`RowDefinition`。这里显示的是`Grid`的开始:

`<Grid Grid.Row="1" DataContext="{Binding ElementName=cboCars, Path=SelectedItem}">`

`<Grid.ColumnDefinitions>`

`<ColumnDefinition Width="Auto" SharedSizeGroup="CarLabels"/>`

`<ColumnDefinition Width="*"/>`

`</Grid.ColumnDefinitions>`

`<Grid.RowDefinitions>`

`<RowDefinition Height="Auto"/>`

`<RowDefinition Height="Auto"/>`

`<RowDefinition Height="Auto"/>`

`<RowDefinition Height="Auto"/>`

`<RowDefinition Height="Auto"/>`

`</Grid.RowDefinitions>`

在那个`Grid`的末尾，添加一个`Label`和一个`CheckBox`，然后将`CheckBox`绑定到`IsChanged`属性，如下所示:

`<Label Grid.Column="0" Grid.Row="4" Content="Is Changed"/>`

`<CheckBox Grid.Column="1" Grid.Row="4" VerticalAlignment="Center"`

`Margin="10,0,0,0" IsEnabled="False" IsChecked="{Binding Path=IsChanged}" />`

每当另一个属性改变时，您需要将`IsChanged`属性设置为`true`。做这件事的最好地方是在`OnPropertyChanged`帮助器方法中，因为它在属性改变时被调用。你还需要确保当`IsChanged`改变时，你没有将`IsChanged`设置为`true`，否则你将遇到堆栈溢出异常！打开`Inventory.cs`并将`OnPropertyChanged`方法更新为以下内容(使用之前讨论的`nameof`方法):

`protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = "")`

`{`

`if (propertyName != nameof(IsChanged))`

`{`

`IsChanged = true;`

`}`

`PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));`

`}`

如果你现在运行这个应用程序，你会看到每一条记录都显示为已更改，即使你没有更改任何东西！这是因为对象创建会设置属性值，设置任何值都会调用`OnPropertyChanged`。这将设置对象的`IsChanged`属性。要纠正这一点，将`IsChanged`属性设置为`false`，作为对象初始化代码中的最后一个属性。打开`MainWindow.xaml.cs`,修改代码创建如下列表:

`_cars = new ObservableCollection<Inventory>`

`{`

`//IsChanged must be last in the list`

`new Inventory {CarId=1,Color="Blue",Make="Chevy",PetName="Kit", IsChanged = false},`

`new Inventory {CarId=2,Color="Red",Make="Ford",PetName="Red Rider", IsChanged = false },`

`};`

再次运行应用程序，选择一辆车，然后单击“更改颜色”按钮。你会看到复选框和新颜色一起被选中，如图 [30-4](#Fig4) 所示。

![A978-1-4842-1332-2_30_Fig4_HTML.jpg](A978-1-4842-1332-2_30_Fig4_HTML.jpg)

图 30-4。

Showing the IsDirty flag

#### 通过 UI 交互更新源代码

您可能会注意到，如果在用户界面中键入文本,“已更改”复选框实际上不会被选中，直到您退出正在编辑的控件。这是由于`TextBox`绑定上的`UpdateSourceTrigger`属性。`UpdateSourceTrigger`决定了什么事件(比如改变值、跳转等等)。)使用户界面更新基础数据。有四种选择，如表 [30-3](#Tab3) 所示。

表 30-3。

UpdateSourceTrigger Values

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `Default` | 设置为控件的默认值(如`TextBoxes`设置为`LostFocus`)。 |
| `Explicit` | 仅在调用`UpdateSource`方法时更新源对象。 |
| `LostFocus` | 当控件失去焦点时更新。默认为`TextBoxes`。 |
| `PropertyChanged` | 属性一改变就更新。默认为`CheckBoxes`。 |

`TextBoxes`的默认值是`LostFocus`。通过将颜色`TextBox`的绑定更新为以下 XAML，将其更改为`PropertyChanged`:

`<TextBox Grid.Column="1" Grid.Row="1"`

`Text="{Binding Path=Color, UpdateSourceTrigger=PropertyChanged}" />`

现在，当您运行应用程序并开始在颜色文本框中键入内容时，更改复选框会立即被选中。你可能会问为什么默认设置为`TextBox` es 的`LostFocus`。每次引发`PropertyChanged`事件时，都会触发对模型的任何验证(将在下一节中介绍)。对于`TextBox`，这可能会导致错误持续闪烁，直到用户输入正确的值。例如，如果验证规则不允许在一个`TextBox`中少于五个字符，错误将在每次击键时显示，直到用户输入五个或更多。在这些情况下，最好等待用户退出`TextBox`(在完成对文本的更改之后)来触发`PropertyChanged`事件。

#### 最后一句话

使用`INotifyPropertyChanged`和`INotifyCollectionChanged`通过保持数据和 UI 同步来改善你的应用程序的用户体验。虽然这两个接口都不复杂，但它们确实需要更新您的代码。幸运的是，微软已经包含了`ObservableCollection`类来处理创建可观察集合的所有管道。不幸的是，您必须自己为可观察的模型提供所有的管道。虽然这不是一个困难的任务，但这意味着您需要接触模型中的每个 setter。如果您使用 ORM(类似于实体框架)从现有的数据库中创建您的模型，这可能会有问题，因为当您重新生成您的模型类时，您的模型将被覆盖。幸运的是，有一个开源库可以解决这个问题，你将在本章后面用到它。

Source Code

通知项目可以在 [`Chapter 30`](30.html) 子目录中找到。

## 确认

既然您已经实现了`INotifyPropertyChanged`并且正在使用`ObservableCollection`，那么是时候为您的应用程序添加验证了。应用程序需要验证用户输入，并在输入的数据不正确时向用户提供反馈。本节涵盖了现代 WPF 应用程序最常见的验证机制，但这些仍然只是 WPF 内置功能的一部分。

Note

有关 WPF 所有验证方法的完整解释，请参见 Matthew McDonald 的 C# 4.5 版本的 Pro WPF，可从位于 [`www.apress.com/9781430243656`](http://www.apress.com/9781430243656) 的网站获取。

当数据绑定试图更新数据源时，会发生验证。除了内置验证(如属性设置器中的异常)之外，您还可以创建自定义验证规则。如果任何验证规则(内置的或定制的)失败，后面讨论的`Validation`类就会发挥作用。

### 更新验证示例的样本

对于验证示例，您可以继续在同一个项目中工作。更新`MainWindow.xaml`以添加一个额外的行来包含`CarId`属性的`Label`和`TextBox`。最好的方法是打开窗口的设计器，用鼠标添加另一行。确保选择文档轮廓中底部的`Grid`，并将鼠标悬停在它的左侧。在显示黄线的地方点击鼠标(图 [30-5](#Fig5) )。

![A978-1-4842-1332-2_30_Fig5_HTML.jpg](A978-1-4842-1332-2_30_Fig5_HTML.jpg)

图 30-5。

Adding a new Grid row with the designer

这将在`Grid`中创建一个新行，并将较高行中每个元素的行号增加 1。您将不得不清理标记，并删除设计者插入的边距和其他值，但是这是在`Grid`早期添加新行的最简单的方法。在新行中，添加一个内容设置为“Id”的`Label`和一个绑定到`CarId`属性的`TextBox`。新控件的标记如下所示:

`<Label Grid.Column="0" Grid.Row="0" Content="Id"/>`

`<TextBox Grid.Column="1" Grid.Row="0" Text="{Binding Path=CarId}" />`

当您运行应用程序并选择记录时，Id 文本框会自动填充主键值(如预期的那样)。更新后的窗口应该如图 [30-6](#Fig6) 所示。

![A978-1-4842-1332-2_30_Fig6_HTML.jpg](A978-1-4842-1332-2_30_Fig6_HTML.jpg)

图 30-6。

Updated to show CardId

既然您已经更新了核心应用程序，那么是时候在 WPF 探索验证了。

### 验证类

在向项目添加验证之前，理解`Validation`类很重要。该类是验证框架的一部分，它提供了可用于显示验证结果的方法和附加属性。在处理验证错误时，`Validation`类有三个常用的主要属性(如表 [30-4](#Tab4) 所示)。在本章这一节的其余部分，您将使用其中的每一项。

表 30-4。

Key Members of the `Validation` Class

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `HasError` | 附加的属性，指示验证规则在过程中的某个地方失败 |
| `Errors` | 所有活动`ValidationError`对象的集合 |
| `ErrorTemplate` | 当`HasError`设置为 true 时，变得可见并修饰绑定元素的控制模板 |

### 验证选项

如前所述，XAML 技术公司有几种将验证逻辑整合到应用程序中的机制。在接下来的小节中，您将研究三种最常用的验证选择。

#### 异常时通知

虽然不应该使用异常来实施业务逻辑，但是异常可能并且确实会发生，并且应该适当地处理它们。如果代码中没有处理它们，用户应该会收到问题的视觉反馈。与 WinForms 相比，WPF 的一个变化是，绑定异常(默认情况下)不会显示给用户，而是被“吞掉”作为开发人员，您必须选择显示错误。

要测试这一点，运行应用程序，从组合框中选择一条记录，并清除`Id`值。回想一下您之前添加的`CarId`属性的定义，它被定义为一个`int`(不是一个`nullable int`)，因此需要一个数值。当您跳出 Id 字段时，绑定框架会向`CarId`属性发送一个空字符串，由于空字符串不能转换为`int`，setter 中会抛出一个异常。但是，没有任何提示给用户，因为您还没有选择显示异常。

这样做很容易；您需要做的就是将`ValidatesOnExceptions = true`添加到绑定语句中。更新`MainWindow.xaml`中的绑定语句以包含`ValidatesOnExceptions = true`，如下所示:

`<TextBox Grid.Column="1" Grid.Row="0"`

`Text="{Binding Path=CarId, ValidatesOnExceptions=True}" />`

`<TextBox Grid.Column="1" Grid.Row="1"`

`Text="{Binding Path=Make, ValidatesOnExceptions=True}" />`

`<TextBox Grid.Column="1" Grid.Row="2"`

`Text="{Binding Path=Color, ValidatesOnExceptions=True}" />`

`<TextBox Grid.Column="1" Grid.Row="3"`

`Text="{Binding Path=PetName, ValidatesOnExceptions=True}" />`

再次运行应用程序，选择一辆车，并再次清除 Id 文本框。当您从 Id 文本框中退出时，它会被一个红色的框包围。由于您已经更新了绑定语句以验证异常，错误由一个修饰 Id 文本框的红色框显示(如图 [30-7](#Fig7) 所示)。

![A978-1-4842-1332-2_30_Fig7_HTML.jpg](A978-1-4842-1332-2_30_Fig7_HTML.jpg)

图 30-7。

The default error template

红框是`Validation`对象的`ErrorTemplate`属性，充当绑定控件的装饰器。虽然默认的外观和感觉显示确实有错误，但没有任何迹象表明是什么错误。好消息是`ErrorTemplate`是完全可定制的，你将在本章后面看到。

#### IDataErrorInfo

`IDataErrorInfo`接口为您向模型类添加验证提供了一种机制。由于您将接口直接添加到您的模型类中，并且验证代码被放置在您的模型类中(或者在分部类中)，这有助于减少项目中重复的验证代码。例如，在 WinForms 中，验证通常在 UI 本身中完成，这意味着使用`Inventory`类的每个表单(在本例中)都必须添加相同的验证代码。如果规则改变了，这些表格都必须更新。事实上，实现可以在一个单独的文件中作为一个分部类，防止你的代码在从一个现有的数据库中逆向工程你的模型时被覆盖(如[第 23 章](23.html)所示)。

如下所示的`IDataErrorInfo`接口包含两个属性，一个索引器和一个名为`Error`的字符串属性。注意，WPF 绑定引擎不使用`Error`属性。

`public interface IDataErrorInfo`

`{`

`string this[string columnName] { get; }`

`string Error { get; }`

`}`

您将很快添加`Inventory`分部类，但是首先您需要更新`Inventory.cs`类并将其标记为分部类。接下来，将另一个名为`InventoryPartial.cs`的类添加到`Models`目录中。重命名该类`Inventory`，确保该类标记为`partial`，并添加`IDataErrorInfo`接口。最后，实现接口的 API。初始代码如下所示:

`public partial class Inventory : IDataErrorInfo`

`{`

`public string this[string columnName]`

`{`

`get { return string.Empty; }`

`}`

`public string Error { get; }`

`}`

每次在对象上引发`PropertyChanged`事件时，都会调用索引器。事件的属性名被用作索引器中的`columnName`参数。如果索引器返回`string.Empty`，那么框架假设所有的验证都通过了，并且不存在错误情况。如果索引器返回除`string.Empty`之外的任何内容，则认为该对象实例的属性上存在错误，并且绑定到该属性(以及该类的特定实例)的每个控件都被认为有错误。一个警告是，如果在绑定语句中`ValidatesOnDataErrors`被设置为`true`，控件将只登记`Validation`类。如果不是这样(就像上一个例子中 setter 中的异常一样)，验证错误将被忽略，并且用户不会得到通知。如果`ValidatesOnDataErrors`被设置为 true，则`Validation`对象的`HasError`属性被设置为 true，并且`ErrorTemplate`装饰器被激活。

接下来，您将向`InventoryPartial.cs`中的索引器添加一些简单的验证逻辑。验证规则很简单:

*   如果`Make`等于 ModelT，则设置误差等于“太老”。
*   如果`Make`等于 Chevy，而`Color`等于 Pink，则将误差设置为$“{ Make }的不要进来{Color}”。

首先为每个属性添加一个 switch 语句。为了避免在 case 语句中使用神奇的字符串，您将再次使用`nameof`方法。如果代码没有通过 switch 语句，则返回`string.Empty`。代码如下所示:

`public string this[string columnName]`

`{`

`get`

`{`

`switch (columnName)`

`{`

`case nameof(CarId):`

`break;`

`case nameof(Make):`

`break;`

`case nameof(Color):`

`break;`

`case nameof(PetName):`

`break;`

`}`

`return string.Empty;`

`}`

`}`

接下来，添加验证规则。在适当的 case 语句中，根据上面列出的规则添加对属性值的检查。在`Make`属性的 case 语句中，首先检查以确保值不是 ModelT。如果是，则返回错误。如果通过，下一行将调用一个 helper 方法，如果违反了第二条规则，则返回一个错误，否则返回`string.Empty`。在`Color`属性的 case 语句中，也调用 helper 方法。代码如下:

`public string this[string columnName]`

`{`

`get`

`{`

`switch (columnName)`

`{`

`case nameof(CarId):`

`break;`

`case nameof(Make):`

`if (Make == "ModelT")`

`{`

`return "Too Old";`

`}`

`return CheckMakeAndColor();`

`case nameof(Color):`

`return CheckMakeAndColor();`

`case nameof(PetName):`

`break;`

`}`

`return string.Empty;`

`}`

`}`

`internal string CheckMakeAndColor()`

`{`

`if (Make == "Chevy" && Color == "Pink")`

`{`

`return $"{Make}’s don’t come in {Color}";`

`//AddError(nameof(Color), $"{Make}’s don’t come in {Color}");`

`//hasError = true;`

`}`

`return string.Empty;`

`}`

最后一步，更新`Binding`语句以包含`ValidatesOnDataErrors = true`，如以下代码所示:

`<TextBox Grid.Column="1" Grid.Row="0"`

`Text="{Binding Path=CarId, ValidatesOnExceptions=True, ValidatesOnDataErrors=True}" />`

`<TextBox Grid.Column="1" Grid.Row="1"`

`Text="{Binding Path=Make, ValidatesOnExceptions=True, ValidatesOnDataErrors=True}" />`

`<TextBox Grid.Column="1" Grid.Row="2"`

`Text="{Binding Path=Color, ValidatesOnExceptions=True, ValidatesOnDataErrors=True}" />`

`<TextBox Grid.Column="1" Grid.Row="3"`

`Text="{Binding Path=PetName, ValidatesOnExceptions=True, ValidatesOnDataErrors=True}" />`

运行应用程序，选择红色骑手车辆(福特)，并将品牌更改为 ModelT。一旦您跳出该字段，就会出现红色的错误装饰。现在从下拉列表中选择 Kit(Chevy ),并单击 Change Color 按钮将颜色更改为粉红色。红色错误装饰立即出现在颜色字段中，但不会出现在生成文本框中。现在，将品牌更改为 Ford，跳出文本框，注意红色装饰符没有消失！

这是因为索引器仅在属性的`PropertyChanged`事件被触发时运行。正如在“通知”一节中所讨论的，当源对象的属性改变时，`PropertyChanged`事件被触发，这或者通过代码(比如单击改变颜色按钮)或者通过用户交互(时间通过`UpdateSourceTrigger`控制)来实现。当您改变颜色时，`Make`属性没有改变，所以事件没有为`Make`属性触发。因为事件没有触发，索引器没有被调用，所以对`Make`属性的验证没有运行。

有两种方法可以解决这个问题。第一个是通过传入`string.Empty`而不是字段名来更改`PropertyChangedEventArgs`以更新每个绑定属性。如前所述，这会导致绑定引擎更新该实例上的每个属性。将`OnPropertyChanged`方法更新为:

`protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = "")`

`{`

`if (propertyName != nameof(IsChanged))`

`{`

`IsChanged = true;`

`}`

`//PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));`

`PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(string.Empty));`

`}`

现在，当您运行相同的测试时，您会看到当 Make 和 Color 文本框中的一个被更新时，它们都用错误模板进行了修饰。那么，为什么不总是以这种方式引发事件呢？很大程度上是性能问题。刷新对象的每个属性可能会降低性能。当然，不测试是无法知道的，你的里程可能(很可能)会有所不同。

另一个解决方案是当一个字段发生变化时，为其他依赖字段引发`PropertyChanged`事件。使用这种机制的缺点是，您(或其他支持您的应用程序的开发人员)必须知道在`InventoryPartial.cs`类中，`Make`和`Color`属性通过验证代码相关联。为了实现这一更改，在`Make`和`Color`的设置器中添加以下对`OnPropertyChanged`方法的调用:

`private string _make;`

`public string Make`

`{`

`get { return _make; }`

`set`

`{`

`if (value == _make) return;`

`_make = value;`

`OnPropertyChanged(nameof(Make);`

`OnPropertyChanged(nameof(Color));`

`}`

`}`

`private string _color;`

`public string Color`

`{`

`get { return _color; }`

`set`

`{`

`if (value == _color) return;`

`_color = value;`

`OnPropertyChanged(nameof(Color));`

`OnPropertyChanged(nameof(Make));`

`}`

`}`

再次运行应用程序，选择一辆雪佛兰，然后单击“更改颜色”按钮。现在，Make 和 Color 都获得了错误装饰器。将品牌更改为 Chevy 以外的品牌，当您按 tab 键离开“品牌”文本框时，两个文本框的装饰都将被删除。

#### INotifyDataErrorInfo

中引入的`INotifyDataErrorInfo`接口。NET 4.5，构建在`IDataErrorInfo`接口上，并增加了额外的验证功能。当然，随着额外的功率而来的是额外的工作！与您必须特别选择的先前的验证技术相比，这是一个巨大的转变，`ValidatesOnNotifyDataErrors`绑定属性默认为`true`，因此将该属性添加到您的绑定语句是可选的。

`INotifyDataErrorInfo`接口非常小，但是占用了大量的管道代码，您很快就会看到。界面如下所示:

`public interface INotifyDataErrorInfo`

`{`

`bool HasErrors { get; }`

`event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;`

`IEnumerable GetErrors(string propertyName);`

`}`

绑定引擎使用`HasErrors`属性来确定作为绑定源的任何实例属性上是否有任何错误。如果使用 null 或空字符串调用`GetErrors`方法的`propertyName`参数，它将返回实例中存在的所有错误。如果一个`propertyName`被传递到方法中，那么只返回特定属性的错误。`ErrorsChanged`事件(类似于`PropertyChanged`和`CollectionChanged`事件)通知绑定引擎更新 UI。

##### 实现支持代码

要实现这一点，需要大量的管道代码。好消息是，所有这些代码都可以下推到一个基本模型类中，并且只需要编写一次。从用`INotifyDataErrorInfo`替换`IDataErrorInfo`到`InventoryPartial.cs`类开始(你可以将`IDataErrorInfo`的代码留在类中；不会碍事)。

添加接口成员后，添加一个私有变量来保存任何错误。代码的当前状态如下所示:

`private readonly Dictionary<string,List<string>> _errors =   new Dictionary<string, List<string>>();`

`public IEnumerable GetErrors(string propertyName)`

`{`

`throw new NotImplementedException();`

`}`

`public bool HasErrors`

`{`

`get`

`{`

`throw new NotImplementedException();`

`}`

`}`

`public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;`

如果字典中有任何错误，`HasErrors`属性应该返回`true`。这很容易实现，如下所示:

`public bool HasErrors => _errors.Count != 0;`

接下来，创建一个 helper 方法来引发`ErrorsChanged`事件(就像引发`PropertyChanged`事件一样),如下所示:

`private void OnErrorsChanged(string propertyName)`

`{`

`ErrorsChanged?.Invoke(this, new DataErrorsChangedEventArgs(propertyName));`

`}`

如果参数为空，那么`GetErrors`方法应该返回字典中的所有错误。如果传入一个有效的`propertyName`，它将返回为该属性找到的任何错误。如果参数不匹配(或者属性没有任何错误)，那么该方法将返回 null。

`public IEnumerable GetErrors(string propertyName)`

`{`

`if (string.IsNullOrEmpty(propertyName))`

`{`

`return _errors.Values;`

`}`

`return _errors.ContainsKey(propertyName) ? _errors[propertyName] : null;`

`}`

最后一组助手将为属性添加一个或多个错误，或者清除属性的所有错误。每当字典发生变化时，记得调用`OnErrorsChanged` helper 方法:

`protected void ClearErrors(string propertyName = "")`

`{`

`_errors.Remove(propertyName);`

`OnErrorsChanged(propertyName);`

`}`

`private void AddError(string propertyName, string error)`

`{`

`AddErrors(propertyName,new List<string> {error});`

`}`

`private void AddErrors(string propertyName, IList<string> errors)`

`{`

`var changed = false;`

`if (!_errors.ContainsKey(propertyName))`

`{`

`_errors.Add(propertyName, new List<string>());`

`changed = true;`

`}`

`errors.ToList().ForEach(x =>`

`{`

`if (_errors[propertyName].Contains(x)) return;`

`_errors[propertyName].Add(x);`

`changed = true;`

`});`

`if (changed)`

`{`

`OnErrorsChanged(propertyName);`

`}`

`}`

绑定引擎监听`ErrorsChanged`事件，如果绑定语句的错误集合发生变化，它将更新 UI。这就消除了调用`PropertyChanged`或`CollectionChanged`来更新带有错误条件的 UI 的需要，就像您在实现`IDataErrorInfo`时所做的那样。这意味着不再需要额外的调用来提高`Make`和`Color`设置器中的`PropertyChanged`(以确保当其他属性改变时显示错误)。当然，您仍然需要为 UI 提高`PropertyChanged`和`CollectionChanged`来响应数据变化，而不仅仅是错误变化。删除`Make`和`Color`设置器中对`OnPropertyChanged`的额外调用，如下所示:

`private string _make;`

`public string Make`

`{`

`get { return _make; }`

`set`

`{`

`if (value == _make) return;`

`_make = value;`

`OnPropertyChanged(nameof(Make);`

`}`

`}`

`private string _color;`

`public string Color`

`{`

`get { return _color; }`

`set`

`{`

`if (value == _color) return;`

`_color = value;`

`OnPropertyChanged(nameof(Color));`

`}`

`}`

##### 使用 INotifyDataErrorInfo 进行验证

既然您已经准备好了所有的支持代码，是时候使用`INotifyDataErrorInfo`将验证添加回您的应用程序中了。即使您已经实现了支持`INotifyDataErrorInfo`的代码，您仍然需要确定何时何地检查错误并将错误添加到错误列表中。检查错误的一个地方是属性设置器，如下例所示，简化为只检查 ModelT 验证:

`public string Make`

`{`

`get { return _make; }`

`set`

`{`

`if (value == _make) return;`

`_make = value;`

`if (Make == "ModelT")`

`{`

`AddError(nameof(Make), "Too Old");`

`}`

`else`

`{`

`ClearErrors(nameof(Make));`

`}`

`OnPropertyChanged(nameof(Make));`

`//OnPropertyChanged(nameof(Color));`

`}`

`}`

这种方法的一个问题是，如果您从现有的数据库中更新您的模型，该类将被覆盖，导致您丢失所有的验证代码。即使您使用代码优先的方法来生成和更新您的数据库，您仍然混淆了模型代码和验证代码，使您的代码更难支持。

在上一节中，您看到了可以将`IDataErrorInfo`添加到分部类中，这意味着您不必更新 setters。这清理了您的模型代码，只留下在 setters 中调用 raise `PropertyChanged`。结合`IDataErrorInfo`和`INotifyDataErrorInfo`为您提供了来自`INotifyDataErrorInfo`的额外验证特性，以及`IDataErrorInfo`提供的与设置器的分离。

将`IDataErrorInfo`接口添加回`InventoryPartial.cs`中的`Inventory`类。

`public partial class Inventory : IDataErrorInfo, INotifyDataErrorInfo`

使用`IDataErrorInfo`的目的不是运行验证，而是确保每次在对象上引发`PropertyChanged`时，利用`INOtifyDataErrorInfo`的验证代码都会被调用。因为没有使用`IDataErrorInfo`进行验证，所以总是返回`string.Empty`，因为`ErrorsChanged`事件现在负责在出现错误时通知绑定引擎。将索引器和`CheckMakeAndColor`帮助器方法更新为以下代码:

`public string this[string columnName]`

`{`

`get`

`{`

`bool hasError = false;`

`switch (columnName)`

`{`

`case nameof(CarId):`

`break;`

`case nameof(Make):`

`hasError = CheckMakeAndColor();`

`if (Make == "ModelT")`

`{`

`AddError(nameof(Make),"Too Old");`

`hasError = true;`

`}`

`if (!hasError) ClearErrors(nameof(Make));`

`break;`

`case nameof(Color):`

`hasError = CheckMakeAndColor();`

`if (!hasError) ClearErrors(nameof(Color));`

`break;`

`case nameof(PetName):`

`break;`

`}`

`return string.Empty;`

`}`

`}`

`internal bool CheckMakeAndColor()`

`{`

`if (Make == "Chevy" && Color == "Pink")`

`{`

`//return $"{Make}’s don’t come in {Color}";`

`AddError(nameof(Make), $"{Make}’s don’t come in {Color}");`

`AddError(nameof(Color), $"{Make}’s don’t come in {Color}");`

`return true;`

`}`

`return false;`

`}`

运行应用程序，选择雪佛兰，并改变颜色为粉红色。除了品牌和型号文本框周围的红色装饰符之外，您还会看到整个网格周围的红色框装饰符，其中包含库存详细信息字段(如图 [30-8](#Fig8) 所示)。这是使用`INotifyDataErrorInfo`的另一个好处。提醒一下，数据上下文被设置为 ComboBox 中的选定项。这将为`Grid`及其所有子控件设置数据源。当引发`PropertyChange`时，数据上下文调用`GetErrors`方法检查对象实例上是否有错误，如果有，激活`Validation`类。

![A978-1-4842-1332-2_30_Fig8_HTML.jpg](A978-1-4842-1332-2_30_Fig8_HTML.jpg)

图 30-8。

The updated error adorner

##### 显示所有错误

`Validation`类的`Errors`属性返回特定对象的所有验证错误。该属性返回一个`ValidationError`对象列表，每个`ValidationError`对象都有一个`ErrorContent`属性，其中包含每个属性的错误消息列表。因为您想要显示的实际错误消息在这个列表中，所以您需要在保存了`ListBox`的`ListBox`上创建一个`DataTemplate`。听起来有点递归，但是一旦看到就有道理了。

首先向`Grid`添加另一行，并将`Window`的`Height`增加到 300。在最后一行添加一个`ListBox`，将`ListBox`的`ItemsSource`绑定到`Grid`，路径使用`Validation.Errors`，如下:

`<ListBox Grid.Row="6" Grid.Column="0" Grid.ColumnSpan="2"`

`ItemsSource="{Binding ElementName=testGrid, Path=(Validation.Errors)}">`

`</ListBox>`

添加一个`DataTemplate`，在`DataTemplate`中添加一个绑定到`ErrorContent`属性的`ListBox`。在这种情况下，每个`ListBoxItem`的数据上下文是一个`ValidationError`对象，所以不需要设置数据上下文，只需要设置路径。将绑定路径设置为`ErrorContent`，如下所示:

`<ListBox.ItemTemplate>`

`<DataTemplate>`

`<ListBox ItemsSource="{Binding Path=ErrorContent}"/>`

`</DataTemplate>`

`</ListBox.ItemTemplate>`

最终的标记如下所示:

`<ListBox Grid.Row="6" Grid.Column="0" Grid.ColumnSpan="2"`

`ItemsSource="{Binding ElementName=testGrid, Path=(Validation.Errors)}">`

`<ListBox.ItemTemplate>`

`<DataTemplate>`

`<ListBox ItemsSource="{Binding Path=ErrorContent}"/>`

`</DataTemplate>`

`</ListBox.ItemTemplate>`

`</ListBox>`

运行应用程序，选择雪佛兰，并设置颜色为粉红色。您将看到图 [30-9](#Fig9) 中显示的错误。

![A978-1-4842-1332-2_30_Fig9_HTML.jpg](A978-1-4842-1332-2_30_Fig9_HTML.jpg)

图 30-9。

Showing the errors collection

##### 将支持代码移动到基类

正如您可能注意到的，现在在`InventoryPartial.cs`类中有很多代码。因为这个例子只有一个模型类，这并不可怕。但是，当您将模型添加到实际的应用程序中时，您不希望必须将所有的管道添加到您的模型的每个分部类中。最好的做法是将所有支持代码下推到一个基类。你现在就去做。

向名为`EntityBase.cs`的`Models`文件夹添加一个新的类文件。为`System.Collections`和`System.ComponentModel`增加`using` s。将该类公开，并添加`INotifyDataErrorInfor`接口，如下所示:

`using System;`

`using System.Collections;`

`using System.Collections.Generic;`

`using System.ComponentModel;`

`using System.Linq;`

`namespace Validations.Models`

`{`

`public class EntityBase : INotifyDataErrorInfo`

`}`

将所有与`INofityDataErrorInfo`相关的代码从`InventoryPartial.cs`移到新的类中。任何私有方法都需要受到保护。更新后的代码如下所示:

`public class EntityBase : INotifyDataErrorInfo`

`{`

`//INotifyDataErrorInfo`

`protected readonly Dictionary<string, List<string>> _errors = new Dictionary<string, List<string>>();`

`protected void ClearErrors(string propertyName = "")`

`{`

`_errors.Remove(propertyName);`

`OnErrorsChanged(propertyName);`

`}`

`protected void AddError(string propertyName, string error)`

`{`

`AddErrors(propertyName, new List<string> { error });`

`}`

`protected void AddErrors(string propertyName, IList<string> errors)`

`{`

`var changed = false;`

`if (!_errors.ContainsKey(propertyName))`

`{`

`_errors.Add(propertyName, new List<string>());`

`changed = true;`

`}`

`errors.ToList().ForEach(x =>`

`{`

`if (_errors[propertyName].Contains(x)) return;`

`_errors[propertyName].Add(x);`

`changed = true;`

`});`

`if (changed)`

`{`

`OnErrorsChanged(propertyName);`

`}`

`}`

`public IEnumerable GetErrors(string propertyName)`

`{`

`if (string.IsNullOrEmpty(propertyName))`

`{`

`return _errors.Values;`

`}`

`return _errors.ContainsKey(propertyName) ? _errors[propertyName] : null;`

`}`

`public bool HasErrors => _errors.Count != 0;`

`public event EventHandler<DataErrorsChangedEventArgs> ErrorsChanged;`

`protected void OnErrorsChanged(string propertyName)`

`{`

`ErrorsChanged?.Invoke(this, new DataErrorsChangedEventArgs(propertyName));`

`}`

`}`

接下来，从`InventoryPartial.cs`类中移除`INotifyDataErrorInfo`接口，并添加`EntityBase`作为基类，如下所示:

`public partial class Inventory : EntityBase, IDataErrorInfo`

`{`

`//removed for brevity`

`}`

现在，您创建的任何额外的模型类都将继承所有的`INotifyDataErrorInfo`管道代码。你可以将更多的东西下推到基类中，最明显的是`INotifyPropertyChanged`代码，但是你将在本章的后面做。

## 使用数据注释

正如你在第 23 章中了解到的，EF 大量使用数据注释。WPF 也可以利用这些来进行 UI 验证。让我们给`Inventory`模型添加一些数据注释。

### 添加数据注释

给`System.ComponentModel.DataAnnotations`添加一个项目引用，然后打开`Inventory.cs`，给`System.ComponentModel.DataAnnotations`添加一个`using`。将`[Required]`属性添加到`CarId`、`Make`和`Color`属性，并将`[StringLength(50)]`添加到`Make`、`Color`和`PetName`。`Required`属性添加了一个验证规则，即属性不能为空(当然，这对`CarId`属性来说是多余的，因为它不是`nullable int`)。`StringLength`属性增加了一个属性不能超过 30 个字符的验证规则。此处显示了代码的简略视图:

`[Required]`

`public int CarId`

`[Required, StringLength(50)]`

`public string Make`

`[Required, StringLength(50)]`

`public string Color`

`[StringLength(50)]`

`public string PetName`

### 检查基于数据注释的验证错误

既然已经添加了额外的验证规则，那么需要将它们添加到验证过程中。与 ASP.NET MVC 和 ASP.NET Web Forms(两者都可以基于数据注释自动检查模型的验证错误)不同，在 WPF，你必须以编程方式检查基于数据注释的验证错误。

在添加代码来检查验证错误之前，有几个对象需要讨论。首先是`ValidationContext`。这为使用`Validator`类检查类的验证错误提供了一个上下文。`Validator`类允许您在`ValidationContext`中检查对象的基于属性的错误。

打开`EntityBase.cs`，为`System.ComponentModel.DataAnnotations`增加一个`using`。接下来，创建一个名为`GetErrorsFromAnnotations`的新方法。此方法是泛型的，采用字符串属性名和 T 类型的值作为参数，并返回字符串数组。确保该方法被标记为受保护。签名如下所示:

`protected string[] GetErrorsFromAnnotations<T>(string propertyName, T value)`

在该方法中，创建一个`List<ValidationResult>`变量来保存验证检查的结果。接下来，创建一个作用域为传递给方法的属性名的`ValidationContext`。当你准备好这两个项目后，调用`Validate.TryValidateProperty`，它会返回一个`bool`。如果一切都通过(关于数据注释验证)，它返回`true`。如果不是，它返回`false`，并用错误填充`List<ValidationResult>`。完整的代码如下所示:

`protected string[] GetErrorsFromAnnotations<T>(string propertyName, T value)`

`{`

`var results = new List<ValidationResult>();`

`var vc = new ValidationContext(this, null, null) { MemberName = propertyName };`

`var isValid = Validator.TryValidateProperty(value, vc, results);`

`return (isValid)?null:Array.ConvertAll(results.ToArray(), o => o.ErrorMessage);`

`}`

现在，您可以更新索引器方法，根据数据注释检查任何错误。如果发现任何错误，将它们添加到支持`INotifyDataErrorInfo`的错误集合中。更新后的索引器代码如下所示:

`public string this[string columnName]`

`{`

`get`

`{`

`string[] errors = null;`

`bool hasError = false;`

`switch (columnName)`

`{`

`case nameof(CarId):`

`errors = GetErrorsFromAnnotations(nameof(CarId), CarId);`

`break;`

`case nameof(Make):`

`hasError = CheckMakeAndColor();`

`if (Make == "ModelT")`

`{`

`AddError(nameof(Make), "Too Old");`

`hasError = true;`

`}`

`errors = GetErrorsFromAnnotations(nameof(Make), Make);`

`break;`

`case nameof(Color):`

`hasError = CheckMakeAndColor();`

`errors = GetErrorsFromAnnotations(nameof(Color), Color);`

`break;`

`case nameof(PetName):`

`errors = GetErrorsFromAnnotations(nameof(PetName), PetName);`

`break;`

`}`

`if (errors != null && errors.Length != 0)`

`{`

`AddErrors(columnName, errors);`

`hasError = true;`

`}`

`if (!hasError) ClearErrors(columnName);`

`return string.Empty;`

`}`

`}`

运行应用程序，选择其中一辆车，并为该车型添加超过 50 个字符的文本。当您退出时，`StringLength`数据注释通过`GetErrorsFromAnnotations`方法报告一个验证错误。这些错误由`INotifyDataErrorInfo`报告，并导致错误模板装饰器出现，`ListBox`显示消息(如图 [30-10](#Fig10) )。

![A978-1-4842-1332-2_30_Fig10_HTML.jpg](A978-1-4842-1332-2_30_Fig10_HTML.jpg)

图 30-10。

Validating the required Data Annotation

### 自定义错误模板

最后一个主题是更新`ErrorTemplate`,以便控件显示关于数据错误的更有意义的信息。正如你在第 29 章中学到的，控件可以通过它们的控件模板来定制。正如你在本章前面所学的,`Validation`类有一个`ErrorTemplate`,用于修饰有绑定错误的控件。

首先在目标类型为`TextBox`的`MainWindow.xaml`的 Windows 资源部分添加一个新样式，如下所示:

`<Window.Resources>`

`<Style TargetType="{x:Type TextBox}">`

`</Style>`

`</Window.Resources>`

接下来，在样式上添加一个触发器，在`Validation.HasError`设置为`true`时设置属性。要设置的属性和值有`Background` ( `Pink`)、`Foreground` ( `Black`)、`Tooltip`到`ErrorContent`。`Background`和`Foreground`设置器并不新鲜，但是`ToolTip`需要一些解释。绑定指向作为数据源执行该样式的`TextBox`。该路径是`Validation.Errors`集合的第一个`ErrorContent`值。标记如下所示:

`<Style TargetType="{x:Type TextBox}">`

`<Style.Triggers>`

`<Trigger Property="Validation.HasError" Value="true">`

`<Setter Property="Background" Value="Pink" />`

`<Setter Property="Foreground" Value="Black" />`

`<Setter Property="ToolTip"`

`Value="{Binding RelativeSource={RelativeSource Self},`

`Path=(Validation.Errors)[0].ErrorContent}"/>`

`</Trigger>`

`</Style.Triggers>`

`</Style>`

接下来，您将更新`Validation`类的`ErrorTemplate`以显示一个红色感叹号，并为感叹号设置`ToolTips`。在刚刚创建的样式中，在`Style.Triggers`结束标记之后立即放置一个 setter。您将创建一个控制模板，它由一个`TextBlock`(显示感叹号)和一个`BorderBrush`组成，包围包含错误的`TextBox`。在 XAML 有一个特殊的标签，这个标签是用名为`AdornedElementPlaceholder`的`ErrorTemplate`来装饰的。通过向该控件添加名称，可以访问与该控件相关联的错误。在这个例子中，您想要访问`Validation.Errors`属性，这样您就可以获得`ErrorContent`(就像您在`Style.Trigger`中所做的那样)。以下是 setter 的完整标记:

`<Setter Property="Validation.ErrorTemplate">`

`<Setter.Value>`

`<ControlTemplate>`

`<DockPanel LastChildFill="True">`

`<TextBlock Foreground="Red" FontSize="20" Text="!"`

`ToolTip="{Binding ElementName=controlWithError,`

`Path=AdornedElement.(Validation.Errors)[0].ErrorContent}"/>`

`<Border BorderBrush="Red" BorderThickness="1">`

`<AdornedElementPlaceholder Name="controlWithError" />`

`</Border>`

`</DockPanel>`

`</ControlTemplate>`

`</Setter.Value>`

`</Setter>`

运行应用程序，并创建一个错误条件。结果将类似于图 [30-11](#Fig11) 。

![A978-1-4842-1332-2_30_Fig11_HTML.jpg](A978-1-4842-1332-2_30_Fig11_HTML.jpg)

图 30-11。

Showing a custom ErrorTemplate Source Code

验证项目可以在 [`Chapter 30`](30.html) 子目录中找到。

## 创建自定义命令

正如你在第 27 章中学到的，命令是 WPF 不可或缺的一部分。命令可以挂接到 WPF 控件(比如`Buttons`和`MenuItems`)来处理用户事件，比如点击。不是直接创建事件处理程序，而是在事件触发时执行命令的`Execute`方法。`CanExecute`方法用于根据您的自定义代码启用或禁用控件。除了你在第 27 章中使用的内置命令之外，你可以通过实现`ICommand`接口来创建你自己的定制命令。通过使用命令而不是事件处理程序，您获得了封装应用程序代码以及基于业务逻辑自动启用和禁用控件的好处。

### 实现 ICommand 接口

作为对第 27 章的快速回顾，这里列出了`ICommand`界面:

`public interface ICommand`

`{`

`event EventHandler CanExecuteChanged;`

`bool CanExecute(object parameter);`

`void Execute(object parameter);`

`}`

现在您将创建一个命令来改变一个`Inventory`对象的颜色。首先在解决方案资源管理器中右键单击项目名称，并创建一个名为`Cmds`的新文件夹。添加一个名为`ChangeColorCommand.cs`的新类。将`ICommand`接口添加到类中，实现成员，并为`Validations.Models`添加一个`using`。您的代码应该如下所示:

`public class ChangeColorCommand : ICommand`

`{`

`public bool CanExecute(object parameter)`

`{`

`throw new NotImplementedException();`

`}`

`public void Execute(object parameter)`

`{`

`throw new NotImplementedException();`

`}`

`public event EventHandler CanExecuteChanged;`

`}`

传递给`CanExecute`和`Execute`方法的参数是通过绑定语句上设置的`CommandParameter`属性从 UI 发送的。您将在本节的后面进行更改。现在，您只需要知道，在这个例子中，对象应该是类型`Inventory`。如果对象为空或者不是一个`Inventory`对象，那么`CanExecute`方法必须返回`false`，任何绑定到命令的控件都被禁用。如果它不为空，并且是一个`Inventory`对象，那么该方法必须返回`true`，并且任何绑定到该命令的控件都被启用。将`CanExecute`方法更新如下:

`public override bool CanExecute(object parameter) => (parameter as Inventory) != null;`

`Execute`方法的参数与`CanExecute`方法的参数完全相同。只有当用户单击绑定到命令的控件时，`Execute`方法才会触发，并且只有当`CanExecute`方法返回`true`时，用户才能单击控件。该类型属于类型`object`，因此您仍然需要将参数转换为`Inventory`对象。铸造参数后，改变汽车的颜色为粉红色。将`Execute`方法更新如下:

`public override void Execute(object parameter)`

`{`

`((Inventory)parameter).Color="Pink";`

`}`

### 更新 MainWindow.xaml.cs

下一个变化是创建这个类的一个实例，`Button`可以访问它。现在，您将把它放在`MainWindow`的代码隐藏文件中(在本章的后面，您将把它移到一个`ViewModel`)。打开`MainWindow.xaml.cs`并删除 Change Color 按钮的 click 事件处理程序，因为您将用您的命令实现替换这个功能。

接下来，添加一个名为`ChangeColorCmd`的公共属性，类型为`ICommand`，带有一个支持字段。在属性的表达式体中，返回支持属性(如果支持字段为空，确保实例化一个新的`ChangeColorCommand`实例)。

`private ICommand _changeColorCommand = null;`

`public ICommand ChangeColorCmd => _changeColorCommand ?? (_changeColorCommand = new ChangeColorCommand());`

### 更新 MainWindow.xaml

正如你在《T4》第 27 章中看到的，WPF 的可点击控件(比如`Buttons`)有一个`Command`属性，允许你给控件分配一个命令对象。一旦命令对象被连接到一个控件，`CanExecute`方法确定控件是否被启用，点击事件被附加到`Execute`方法。

首先，将代码隐藏中实例化的命令连接到`btnChangeColor`按钮。因为命令的属性在`MainWindow`类上，所以使用`RelativeSourceMode`绑定语法来访问包含`Button`的窗口，如下所示:

`Command="{Binding Path=ChangeColorCmd,`

`RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"`

`Button`仍然需要发送一个`Inventory`对象作为`CanExecute`和`Execute`方法的参数。可点击控件上还有一个名为`CommandParameter`的属性。您将此设置为`cboCars ComboBox`的`SelectedItem`，如下所示:

`CommandParameter="{Binding ElementName=cboCars, Path=SelectedItem}"`

按钮的完整标记如下所示:

`<Button x:Name="btnhangeColor" Content="Change Color" Margin="5,0,5,0" Padding="4,2"`

`Command="{Binding Path=ChangeColorCmd,`

`RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"`

`CommandParameter="{Binding ElementName=cboCars, Path=SelectedItem}"/>`

### 将命令附加到 CommandManager

如果您现在运行应用程序，您会看到当窗口首次加载时，更改颜色按钮未启用。这是我们所期望的，因为组合框的`SelectedItem`为空。因为这是传递给`CanExectue`和`Execute`方法的值，所以该控件被禁用。如果您从组合框中选择一条记录，您会期望按钮被激活，因为`SelectedItem`属性不再为空。但是，您会看到该按钮仍然处于禁用状态。

这是因为`CanExecute`方法在窗口第一次加载时触发，然后在命令管理器指示它触发时触发。每个命令类都必须选择加入命令管理器。这是通过`CanExecuteChanged`事件完成的，简单到只需将下面的代码添加到您的`ChangeColorCommand.cs`类中:

`public event EventHandler CanExecuteChanged`

`{`

`add { CommandManager.RequerySuggested += value; }`

`remove { CommandManager.RequerySuggested -= value; }`

`}`

#### 创建 commandbars 类

您构建的每个自定义命令中都需要包含这些代码，因此最好创建一个抽象基类来保存它。在`Cmds`文件夹中新建一个名为`CommandBase`的类，将类设置为抽象，添加`ICommand`接口，实现接口。为`System.Windows.Input`名称空间添加一个`using`，并将`Execute`和`CanExecute`方法改为 abstract。最后，加入你刚刚写的`CanExecuteChanged`。下面列出了完整的实现:

`public abstract class CommandBase : ICommand`

`{`

`public abstract void Execute(object parameter);`

`public abstract bool CanExecute(object parameter);`

`public event EventHandler CanExecuteChanged`

`{`

`add { CommandManager.RequerySuggested += value; }`

`remove { CommandManager.RequerySuggested -= value; }`

`}`

`}`

#### 更新 ChangeColorCommand 类

打开`ChangeColorCommand.cs`，添加`CommandBase`作为基类。删除`CanExecuteChanged`代码，并为`CanExecute`和`Execute`方法添加覆盖，如下所示:

`internal class ChangeColorCommand : CommandBase`

`{`

`public override void Execute(object parameter)`

`{`

`((Inventory)parameter).Color="Pink";`

`}`

`public override bool CanExecute(object parameter) =>`

`(parameter as Inventory) != null;`

`}`

### 测试应用程序

运行应用程序。你会看到改变颜色命令没有被激活，如图 [30-12](#Fig12) 所示，因为没有选择车辆。

![A978-1-4842-1332-2_30_Fig12_HTML.jpg](A978-1-4842-1332-2_30_Fig12_HTML.jpg)

图 30-12。

A window with nothing selected

现在，选择一辆车，按钮将被激活，如图 [30-13](#Fig13) 所示。

![A978-1-4842-1332-2_30_Fig13_HTML.jpg](A978-1-4842-1332-2_30_Fig13_HTML.jpg)

图 30-13。

A window with a vehicle selected

### 添加剩余的命令

现在您已经理解了命令，您将使用命令替换剩余的两个按钮单击事件。

#### 添加 remove car 命令

就像`ChangeColorCommand`，`RemoveCarCommand`有一个 C#组件和一个 XAML 组件。首先移除`MainWindow.xaml.cs`类中的`btnRemoveCar_Click`事件处理程序。

##### 添加命令类

接下来，将另一个类添加到名为`RemoveCarCommand`的`Cmds`文件夹中，使该类成为内部类，并从`CommandBase`派生。该命令将作用于视图中的库存记录列表，因此为名为`_cars`的`IList<Inventory>`创建一个字段，并创建一个构造函数来接受现有列表。代码应该如下所示:

`internal class RemoveCarCommand : CommandBase`

`{`

`private readonly IList<Inventory> _cars;`

`public RemoveCarCommand(IList<Inventory> cars)`

`{`

`_cars = cars;`

`}`

`}`

就像`ChangeColorCommand`的`Execute`方法一样，该方法接收一条库存记录作为参数。重写`Execute`方法，将参数转换为`Inventory`对象，然后从列表中删除它，如下所示:

`public override void Execute(object parameter)`

`{`

`_cars.Remove((Inventory)parameter);`

`}`

最后，重写`CanExecute`方法，并添加与对`ChangeColorCommand`相同的代码:如果参数为空或者不是库存对象，则返回`false`，否则返回`true`。代码如下所示:

`public override bool CanExecute(object parameter) =>`

`(parameter as Inventory) != null && _cars != null && _cars.Count != 0;`

`}`

##### 更新 XAML

删除`btnRemoveCar`按钮的`Click`属性，添加`Command`和`CommandParameter`属性，如下所示:

`<Button x:Name="btnRemoveCar" Content="Remove Car" Margin="5,0,5,0" Padding="4,2"`

`Command="{Binding Path=RemoveCarCmd,`

`RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"`

`CommandParameter="{Binding ElementName=cboCars, Path=SelectedItem}"/>`

#### 添加 addcar 命令

删除`MainWindow.xaml.cs`文件中的`AddCar_Click`事件处理程序。

##### 添加命令类

首先将另一个类添加到名为`AddCarCommand`的`Cmds`文件夹中，使该类成为内部类，并从`CommandBase`派生。该命令还将作用于视图中的库存记录列表，因此为名为`_cars`的`IList<Inventory>`创建一个字段，并创建一个构造函数来接受现有列表。代码应该如下所示:

`internal class AddCarCommand : CommandBase`

`{`

`private readonly IList<Inventory> _cars;`

`public RemoveCarCommand(IList<Inventory> cars)`

`{`

`_cars = cars;`

`}`

`}`

与您已经创建的其他命令不同，您将不会从视图中接收任何值。这意味着您可以忽略`CanExecute`和`Execute`方法中的参数。在`Execute`方法中，向`_cars`列表中添加另一个条目。

`public override void Execute(object parameter)`

`{`

`var maxCount = _cars?.Max(x => x.CarId) ?? 0;`

`_cars?.Add(new Inventory { CarId = ++maxCount, Color = "Yellow", Make = "VW", PetName = "Birdie",`

`IsChanged = false });`

`}`

重写`CanExecute`方法，只返回`true`，就像这样:

`public override bool CanExecute(object parameter) => true;`

##### 更新 XAML

最后，更新 XAML 以删除`Click`属性并添加`Command`属性，如下所示:

`<Button x:Name="btnAddCar" Content="Add Car" Margin="5,0,5,0" Padding="4,2"`

`Command="{Binding Path=AddCarCmd,`

`RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"/>`

Source Code

命令项目可以在 [`Chapter 30`](30.html) 子目录中找到。

## 全面实施 MVVM

这个示例的最后一个练习是完成它到 MVVM 的转换。你可能会问为什么我选择说“完成”转换。原因是你在这一章中所做的一切都与 MVVM 在 WPF 的工作方式有关，并且都在模式中交织在一起。首先添加一个名为`ViewModels`的新文件夹。在这个文件夹中，添加一个名为`MainWindowViewModel`的类。

Note

一个流行的惯例是根据视图模型支持的窗口来命名视图模型。然而，像任何模式或惯例一样，这不是一条规则，你会发现关于这一点有各种各样的观点。

### 将数据源移出视图

如果您还记得对 MVVM 模式的解释，代码隐藏中唯一的代码应该与 UI 直接相关。视图所需的任何数据都应该从 ViewModel 中暴露给视图(最好从存储库带到 ViewModel 中)。在您当前的项目中，数据是在代码隐藏中硬编码的，所以第一步是将`Cars`集合从代码隐藏移动到视图模型。

首先添加一个名为`Cars`的`IList<Inventory>`类型的公共属性。在`ViewModel`的构造函数中，将`Cars`属性设置为新的`ObservableCollection<Inventory>`。

Note

在实际的应用程序中，这通常是调用存储库类或 web 服务来获取数据。

您的类应该是这样的:

`public class MainWindowViewModel`

`{`

`public IList<Inventory> Cars { get; set; }`

`public MainWindowViewModel()`

`{`

`Cars = new ObservableCollection<Inventory>`

`{`

`new Inventory {CarId=1,Color="Blue",Make="Chevy",PetName="Kit", IsChanged = false},`

`new Inventory {CarId=2,Color="Red",Make="Ford",PetName="Red Rider", IsChanged = false },`

`};`

`}`

`}`

在`MainWindow.xaml.cs`中，删除旧创建的列表(在构造函数中)，以及将`ComboBox`的`ItemSource`设置到列表的行。暂时离开后备场`(_cars`；您不需要它，但是有两个命令需要它，现在删除它会导致编译失败。你的构造函数中唯一剩下的代码应该是`InitializeComponent`，就像这样:

`public MainWindow()`

`{`

`InitializeComponent();`

`}`

回想一下，如果绑定表达式没有指定数据上下文，它会沿着元素树向上走，直到找到数据上下文。在 MVVM 中，`ViewModel`类充当整个窗口的数据上下文，所以在构造函数中将窗口的数据上下文设置为 ViewModel。为`MVVM.ViewModels`加一个`using`，像这样:

`using MVVM.ViewModels;`

`public partial class MainWindow:Window`

`{`

`public MainWindow()`

`{`

`InitializeComponent();`

`this.DataContext = new MainWindowViewModel();`

`}`

`}`

对窗口进行的最后一个更改是将`ItemSource`添加回`ComboBox`。打开`MainWindow.xaml`，给`ComboBox`添加`ItemsSource`属性，并绑定到 ViewModel 上的`Cars`属性。您不必指定数据源，因为 ViewModel 是窗口的数据上下文。您的标记应该如下所示:

`<ComboBox Name="cboCars" Grid.Column="1" DisplayMemberPath="PetName"`

`ItemsSource="{Binding Path=Cars}"/>`

运行应用程序，看到组合框中确实填充了初始的`Cars`集合。测试完应用程序后，从`MainWindow.xaml.cs`中删除`_cars`字段。接下来，您将把命令和相关代码移动到 ViewModel 中。

### 将命令移动到视图模型

将`MainWindow.xaml.cs`中的命令剪切并粘贴到`MainWindowViewModel.cs`中。您必须更新`AddCarCommand`和`RemoveCarCommand`的构造函数，以使用`Cars`属性而不是`_cars`字段。为`MVVM.Cmds`添加一条`using`语句。您在`MainWindowViewModel`中的代码将如下所示:

`private ICommand _changeColorCommand = null;`

`public ICommand ChangeColorCmd =>`

`_changeColorCommand ?? (_changeColorCommand = new ChangeColorCommand());`

`private ICommand _addCarCommand = null;`

`public ICommand AddCarCmd =>`

`_addCarCommand ?? (_addCarCommand = new AddCarCommand(Cars));`

`private ICommand _removeCarCommand = null;`

`public ICommand RemoveCarCmd =>`

`_removeCarCommand ?? (_removeCarCommand = new RemoveCarCommand(Cars));`

`private bool CanAddCar() => Cars != null;`

最后，打开`MainWindow.xaml`，将`DataContext`添加到每个`Button Command`绑定语句的路径中。

`<Button x:Name="cmdAddCar" Content="Add Car" Margin="5,0,5,0" Padding="4,2"`

`Command="{Binding Path=DataContext.AddCarCmd,`

`RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"/>`

`<Button x:Name="cmdChangeColor" Content="Change Color" Margin="5,0,5,0"  Padding="4,2"`

`Command="{Binding Path=DataContext.ChangeColorCmd,`

`RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"`

`CommandParameter="{Binding ElementName=cboCars, Path=SelectedItem}"/>`

`<Button x:Name="btnRemoveCar" Content="Remove Car" Margin="5,0,5,0"  Padding="4,2"`

`Command="{Binding Path=DataContext.RemoveCarCmd,`

`RelativeSource={RelativeSource Mode=FindAncestor, AncestorType={x:Type Window}}}"`

`CommandParameter="{Binding ElementName=cboCars, Path=SelectedItem}"/>`

运行该应用程序，您将看到按钮按预期工作。代码隐藏文件现在只有两行，分别用于`InitializeComponent`和设置`DataContext`。

Source Code

MVVM 项目可以在 [`Chapter 30`](30.html) 子目录中找到。

## 更新 MVVM 的 AutoLotDAL

此时你可能在想“太好了，如果我需要用一个模型和假数据来构建一个应用程序，我知道该怎么做！”好吧，是时候把真实的数据带回来了。在将 AutoLotDAL 插入 MVVM 应用程序之前，需要进行一些优化。

### 更新自动校准模型

您需要做的第一件事是用您创建的支持`IDataErrorInfo`和`INotifyDataErrorInfo`的验证代码更新所有的模型。由于大部分代码已经在一个基类中，所以只需要做一些修改。

#### 更新基类

在前面的例子中，您已经创建了一个基类。您将把该基类添加到 AutoLotDAL 中，并对其进行一些更改。然而，首先从第 23 章(或者从 [`Chapter 30`](30.html) 下载中的 MVVMFinal 项目)中复制一个最终的 AutoLotDAL 项目到你的 WPF 示例中。右键单击解决方案资源管理器中的`Models`文件夹，选择添加➤现有项，并从上一节的示例中选择`EntityBase`文件。确保将名称空间更改为`AutoLotDAL.Models`，并为`System.ComponentModel.DataAnnotations`和`System.ComponentModel.DataAnnotations.Schema`添加`using` s。接下来，添加`TimeStamp`属性，如下所示:

`[Timestamp]`

`public byte[] Timestamp { get; set; }`

接下来，添加`IsChanged`属性，就像这样(记住要添加`NotMapped`属性，因为这个属性不会存储在数据库中):

`[NotMapped]`

`public bool IsChanged { get; set; }`

对`EntityBase.cs`类的最后一个更改是将`IDataErrorInfo`接口添加到该类并实现该接口。确保将索引器方法标记为虚拟的，因为实际的实现将在`Model`类中:

`public virtual string this[string columnName] { get { throw new NotImplementedException(); } }`

`public string Error { get; }`

接下来，打开每个模型类(`Inventory`、`Customer`、`Order`和`CreditRisk`，删除`TimeStamp`字段，并添加`EntityBase`作为它们的基类。在实际的应用程序中，您通常为每个模型类创建分部类，并在那里添加`EntityBase`基类。为了简单起见，在这个例子中，您只是将它们添加到模型类中，而不是创建分部类。

#### 更新库存部分

将命令示例中的`InventoryPartial.cs`类中的字符串索引器复制到 AutoLotDAL 的`InventoryPartial.cs`类中。应该是这样的:

`public string this[string columnName]`

`{`

`get`

`{`

`string[] errors = null;`

`bool hasError = false;`

`switch (columnName)`

`{`

`case nameof(CarId):`

`errors = GetErrorsFromAnnotations(nameof(CarId), CarId);`

`break;`

`case nameof(Make):`

`hasError = CheckMakeAndColor();`

`if (Make == "ModelT")`

`{`

`AddError(nameof(Make), "Too Old");`

`hasError = true;`

`}`

`errors = GetErrorsFromAnnotations(nameof(Make), Make);`

`break;`

`case nameof(Color):`

`hasError = CheckMakeAndColor();`

`errors = GetErrorsFromAnnotations(nameof(Color), Color);`

`break;`

`case nameof(PetName):`

`errors = GetErrorsFromAnnotations(nameof(PetName), PetName);`

`break;`

`}`

`if (errors != null && errors.Length != 0)`

`{`

`AddErrors(columnName, errors);`

`hasError = true;`

`}`

`if (!hasError) ClearErrors(columnName);`

`return string.Empty;`

`}`

`}`

这(在很大程度上)将您在本章中学到的功能引入了 AutoLotDAL。缺少的一项是`INotifyPropertyChanged`，接下来您将添加它。

#### 实现 INotifyPropertyChanged

您可能已经注意到，您没有将`INotifyPropertyChanged`添加到`EntityBase`类或您的任何模型类中。如果您将`INotifyPropertyChanged`添加到模型中，您必须更新每个 setter 来引发`PropertyChangedEvent`(或者调用`OnPropertyChanged`事件)。对于像这样小的项目来说，这不是一个巨大的任务，但是对于任何大规模的项目来说，这都是一个大问题。如果您的模型类是从 ORM 生成的，并且它们需要重新生成，那么您也有丢失所有工作的风险。

幸运的是，一些非常聪明的头脑解决了这一困境。有一个名为`PropertyChanged.Fody`的开源项目解决了这个问题。这个项目是对 Fody ( [`https://github.com/Fody/Fody/`](https://github.com/Fody/Fody/) )的一个扩展，一个用于编织的开源工具。NET 程序集。编织是操纵构建过程中生成的 IL 的过程。`PropertyChanged.Fody`为您添加了`INotifyPropertyChanged`的所有管道代码，如果您有一个名为`IsChanged`的属性，当另一个属性改变时，它将被更新，就像您在本章前面的例子中手工做的那样。

Note

你可以在 [`https://github.com/Fody/PropertyChanged`](https://github.com/Fody/PropertyChanged) 找到更多关于`PropertyChanged`项目的信息。

要安装必要的包，右键单击您的项目名称，选择 Manage NuGet packages，然后搜索“propertychanged.fody”。您将看到类似于图 [30-14](#Fig14) 的内容(根据您阅读本文的时间，版本可能会有所不同)。

![A978-1-4842-1332-2_30_Fig14_HTML.jpg](A978-1-4842-1332-2_30_Fig14_HTML.jpg)

图 30-14。

Installing PropertyChanged.Fody

一旦完成，打开`ModelBase`，在类级别添加属性`[ImplementPropertyChanged]`。这就是你要做的！

## 完整的 MVVM 示例

现在您已经更新了 AutoLotDAL，您将把真实数据集成到最后一个示例中。将项目从全面实施 MVVM 部分复制到新位置。打开项目，通过在解决方案资源管理器中右击项目名称并选择“添加➤现有项目”来添加 AutoLotDAL。

从您的 WPF 项目中添加对 AutoLotDAL 的引用。通过右键单击解决方案并选择“管理解决方案的 NuGet 包”,将 EntityFramework 添加到 WPF 项目中。选择 EntityFramework(如果需要，通过过滤 Installed)，并选择 WPF 项目进行安装。更新`app.config`为您的数据库添加 ConnectionStrings 节点和 ConnectString。确切的字符串可能会有所不同，但应该是这样的:

`<connectionStrings>`

`<add name="AutoLotConnection" connectionString="data source=.\SQLEXPRESS2014;initial catalog=AutoLot;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework" providerName="System.Data.SqlClient" />`

`</connectionStrings>`

打开`MainWindowViewModel.cs`文件，为`AutoLotDAL.Models`和`AutoLotDAL.Repos`添加`using` s。更新构造函数以从`InventoryRepo`类中获取所有的`Inventory`记录，而不是手动创建列表。新的构造函数应该如下所示:

`public MainWindowViewModel()`

`{`

`Cars = new ObservableCollection<Inventory>(new InventoryRepo().GetAll());`

`}`

打开所有的命令类，更新名称空间以使用`AutoLotDAL.Models`，并删除`MVVM.Models`名称空间(或者您的示例中的任何名称空间)。最后，删除 WPF 项目的`Models`目录中的所有类。

运行 app，你会在下拉列表中看到所有的记录，如图 [30-15](#Fig15) 所示。

![A978-1-4842-1332-2_30_Fig15_HTML.jpg](A978-1-4842-1332-2_30_Fig15_HTML.jpg)

图 30-15。

Pulling data from the database

您可能会注意到的一个问题是，每辆车都选中了 IsChanged 复选框。这是因为 EF 通过设置属性来具体化每个记录，这当然会触发`PropertyChanged`代码并设置`IsChanged`标志。在下一节中，你将学习如何在 EF 中优雅地处理这个问题。

### 通过实体框架使用 ObjectMaterialized

如果您还记得第 23 章中的内容，那么每次 EF 从数据库中重建完一个对象，就会触发`ObjectMaterialized`事件。打开`AutoLotEntities.cs`，在`OnObjectMaterialized`事件处理程序中，检查`ObjectMaterializedEventArgs`的`Entity`属性是否为`EntityBase`类型。如果是，则将`IsChanged`属性设置为 false。代码将如下所示:

`private void OnObjectMaterialized(object sender, ObjectMaterializedEventArgs e)`

`{`

`var model = (e.Entity as EntityBase);`

`if (model != null)`

`{`

`model.IsChanged = false;`

`}`

`}`

运行应用程序。从下拉列表中选择一条记录，您会看到在表单第一次加载时不再设置`IsChanged`标志。如果您编辑一个字段，那么`IsChanged`标志仍然会被正确设置。

## 摘要

本章研究了支持模型-视图-视图模型(MVVM)模式的 WPF 主题。您已经开始学习如何在绑定管理器中将模型类和集合绑定到通知系统中。您实现了`INotifyPropertyChanged`，并使用`ObservableCollections`来保持 UI 与绑定数据的同步。在本章的后面，你学习了如何使用`PropertyChanged.Fody`来自动完成这项工作。

接下来，您使用`IDataErrorInfo`、`INotifyDataErrorInfo`向模型添加验证代码，并检查数据注释错误。然后在 UI 中显示任何验证错误，以便用户知道问题是什么以及如何修复它。

最后，您通过添加一个 ViewModel 将所有这些放在一起，并清理了 UI 标记和代码隐藏文件以增加关注点的分离。您更新了 AutoLotDAL 以添加验证和通知，并使用`ObjectMaterialized`在对象具体化时清理它们。