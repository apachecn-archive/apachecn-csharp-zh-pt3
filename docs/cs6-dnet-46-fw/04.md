# 4.核心 C#编程构造，第二部分

这一章从第三章停止的地方开始，完成你对 C#编程语言核心方面的研究。你将从检查关于 C#方法构造的各种细节开始，探索`out`、`ref`和`params`关键词。在这个过程中，您还将研究可选参数和命名参数的作用。

在您研究了方法重载这个主题之后，下一个任务是研究使用 C#语法操纵数组背后的细节，并了解相关的`System.Array`类类型中包含的功能。

此外，本章还讨论了枚举和结构类型的构造，包括对值类型和引用类型之间的区别的详细分析。本章最后研究了可空数据类型和相关操作符的作用。

在你完成这一章之后，你将处于学习 C#的面向对象能力的最佳位置，从第五章开始。

## 方法和参数修饰符

开始这一章，让我们检查定义方法的细节。就像`Main()`方法(见[第 3 章](03.html))一样，你的自定义方法可能会也可能不会带参数，可能会也可能不会返回值给调用者。正如您将在接下来的几章中看到的，方法可以在类或结构的范围内实现(以及在接口类型内原型化)，并且可以用各种关键字(例如，`static`、`virtual`、`public`、`new`)来修饰它们的行为。在文本的这一点上，你的每一个方法都遵循了以下基本格式:

`// Recall that static methods can be called directly`

`// without creating a class instance.`

`class Program`

`{`

`// static returnType MethodName(paramater list) { /* Implementation */ }`

`static int Add(int x, int y){ return x + y; }`

`}`

虽然 C#中方法的定义非常简单，但是您可以使用一些方法来控制参数如何传递给正在讨论的方法，如表 [4-1](#Tab1) 中所列。

表 4-1。

C# Parameter Modifiers

<colgroup><col> <col></colgroup> 
| 参数修改器 | 生命的意义 |
| --- | --- |
| (无) | 如果参数没有用参数修饰符标记，则假定它是通过值传递的，这意味着被调用的方法接收原始数据的副本。 |
| `out` | 输出参数必须由被调用的方法赋值，因此通过引用传递。如果被调用的方法未能分配输出参数，则会出现编译器错误。 |
| `ref` | 该值最初由调用者赋值，并可以由被调用的方法随意修改(因为数据也是通过引用传递的)。如果被调用的方法未能分配一个`ref`参数，则不会产生编译器错误。 |
| `params` | 这个参数修饰符允许您将可变数量的参数作为单个逻辑参数发送。一个方法只能有一个`params`修饰符，并且它必须是该方法的最终参数。实际上，您可能不需要经常使用`params`修饰符；但是，请注意，基类库中的许多方法确实利用了 C#语言的这一特性。 |

为了演示这些关键字的用法，创建一个名为 FunWithMethods 的新控制台应用项目。现在，我们来看一下每个关键字的作用。

### 默认的按值参数传递行为

将参数发送到函数的默认方式是通过值。简而言之，如果没有用参数修饰符标记参数，数据的副本将被传递到函数中。正如本章末尾所解释的，具体复制什么将取决于参数是值类型还是引用类型。现在，假设下面的方法在`Program`类中，它操作两个通过值传递的数字数据类型:

`// Arguments are passed by value by default.`

`static int Add(int x, int y)`

`{`

`int ans = x + y;`

`// Caller will not see these changes`

`// as you are modifying a copy of the`

`// original data.`

`x = 10000;`

`y = 88888;`

`return ans;`

`}`

数字数据属于值类型的范畴。因此，如果您在该成员的范围内更改参数值，调用者不会知道，因为您是在调用者原始数据的副本上更改值。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Methods *****\n");`

`// Pass two variables in by value.`

`int x = 9, y = 10;`

`Console.WriteLine("Before call: X: {0}, Y: {1}", x, y);`

`Console.WriteLine("Answer is: {0}", Add(x, y));`

`Console.WriteLine("After call: X: {0}, Y: {1}", x, y);`

`Console.ReadLine();`

`}`

正如您所希望的,`x`和`y`的值在调用`Add()`前后保持一致，如下图所示，因为数据点是通过值发送的。因此，`Add()`方法中对这些参数的任何更改都不会被调用者看到，因为`Add()`方法正在对数据的副本进行操作。

`***** Fun with Methods *****`

`Before call: X: 9, Y: 10`

`Answer is: 19`

`After call: X: 9, Y: 10`

### 外部修饰符

接下来，您可以使用输出参数。已经被定义为接受输出参数(通过`out`关键字)的方法有义务在退出方法范围之前将它们赋给一个适当的值(如果您没有这样做，您将收到编译器错误)。

举例来说，下面是另一个版本的`Add()`方法，它使用 C# `out`修饰符返回两个整数的和(注意这个方法的物理返回值现在是`void`):

`// Output parameters must be assigned by the called method.`

`static void Add(int x, int y, out int ans)`

`{`

`ans = x + y;`

`}`

调用带有输出参数的方法也需要使用`out`修饰符。但是，作为输出变量传递的局部变量在作为输出参数传递之前不需要赋值(如果这样做，原始值在调用后会丢失)。编译器允许你发送看似未赋值的数据是因为被调用的方法必须赋值。以下代码是一个示例:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Methods *****");`

`...`

`// No need to assign initial value to local variables`

`// used as output parameters, provided the first time`

`// you use them is as output arguments.`

`int ans;`

`Add(90, 90, out ans);`

`Console.WriteLine("90 + 90 = {0}", ans);`

`Console.ReadLine();`

`}`

前面的例子本质上是说明性的；你真的没有理由用一个输出参数来返回你求和的值。然而，C# `out`修饰符确实有一个有用的目的:它允许调用者从一次方法调用中获得多个输出。

`// Returning multiple output parameters.`

`static void FillTheseValues(out int a, out string b, out bool c)`

`{`

`a = 9;`

`b = "Enjoy your string.";`

`c = true;`

`}`

调用者将能够调用`FillTheseValues()`方法。请记住，当您调用方法以及实现方法时，您必须使用`out`修饰符。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Methods *****");`

`...`

`int i; string str; bool b;`

`FillTheseValues(out i, out str, out b);`

`Console.WriteLine("Int is: {0}", i);`

`Console.WriteLine("String is: {0}", str);`

`Console.WriteLine("Boolean is: {0}", b);`

`Console.ReadLine();`

`}`

最后，请始终记住，定义输出参数的方法必须在退出方法范围之前将参数赋给一个有效值。因此，以下代码将导致编译器错误，因为输出参数尚未在方法范围内赋值:

`static void ThisWontCompile(out int a)`

`{`

`Console.WriteLine("Error! Forgot to assign output arg!");`

`}`

### ref 修饰符

现在考虑 C# `ref`参数修饰符的使用。当您希望允许一个方法对在调用者作用域中声明的各种数据点(例如排序或交换例程)进行操作(并且通常更改其值)时，引用参数是必需的。请注意输出参数和参考参数之间的区别。

*   输出参数在传递给方法之前不需要初始化。原因是该方法必须在退出前分配输出参数。
*   引用参数在传递给方法之前必须初始化。这是因为您正在传递对现有变量的引用。如果你不把它赋给一个初始值，那就相当于对一个未赋值的局部变量进行操作。

让我们通过交换两个`string`变量的方法来检查一下`ref`关键字的用法(当然，这里可以使用任何两种数据类型，包括`int`、`bool`、`float`等等)。

`// Reference parameters.`

`public static void SwapStrings(ref string s1, ref string s2)`

`{`

`string tempStr = s1;`

`s1 = s2;`

`s2 = tempStr;`

`}`

此方法可以按如下方式调用:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Methods *****");`

`...`

`string str1 = "Flip";`

`string str2 = "Flop";`

`Console.WriteLine("Before: {0}, {1} ", str1, str2);`

`SwapStrings(ref str1, ref str2);`

`Console.WriteLine("After: {0}, {1} ", str1, str2);`

`Console.ReadLine();`

`}`

这里，调用者已经为本地字符串数据分配了一个初始值(`str1`和`str2`)。在对`SwapStrings()`的调用返回后，`str1`现在包含值`"Flop"`，而`str2`报告值`"Flip"`。

`Before: Flip, Flop`

`After: Flop, Flip`

Note

C# `ref`关键字将在本章后面的“理解值类型和引用类型”一节中重新讨论正如您将看到的，这个关键字的行为会根据参数是值类型还是引用类型而稍有变化。

### 参数修改器

C#支持使用关键字`params`来使用参数数组。要理解这种语言特性，您必须(顾名思义)理解如何操作 C#数组。如果不是这样，在阅读完本章后面的“理解 C#数组”一节后，您可能希望返回到这一节。

关键字`params`允许您将可变数量的相同类型的参数(或通过继承相关的类)作为单个逻辑参数传递给一个方法。同样，如果调用者发送强类型数组或逗号分隔的项目列表，则可以处理标有`params`关键字的参数。是的，这可能会令人困惑！为了搞清楚，假设您想要创建一个函数，允许调用者传入任意数量的参数并返回计算出的平均值。

如果您要将这个方法原型化以获取一个由`double`组成的数组，这将迫使调用者首先定义该数组，然后填充该数组，最后将其传递给该方法。然而，如果您将`CalculateAverage()`定义为接受`double[]`数据类型的`params`，调用者可以简单地传递一个逗号分隔的`double`列表。NET 运行时会在后台自动将一组`double`封装到一个`double`类型的数组中。

`// Return average of "some number" of doubles.`

`static double CalculateAverage(params double[] values)`

`{`

`Console.WriteLine("You sent me {0} doubles.", values.Length);`

`double sum = 0;`

`if(values.Length == 0)`

`return sum;`

`for (int i = 0; i < values.Length; i++)`

`sum += values[i];`

`return (sum / values.Length);`

`}`

该方法被定义为接受双精度参数数组。这个方法实际上说的是，“给我发送任意数量的`double`(包括零)，我将计算平均值。”考虑到这一点，您可以通过以下任何一种方式调用`CalculateAverage()`:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Methods *****");`

`...`

`// Pass in a comma-delimited list of doubles…`

`double average;`

`average = CalculateAverage(4.0, 3.2, 5.7, 64.22, 87.2);`

`Console.WriteLine("Average of data is: {0}", average);`

`// …or pass an array of doubles.`

`double[] data = { 4.0, 3.2, 5.7 };`

`average = CalculateAverage(data);`

`Console.WriteLine("Average of data is: {0}", average);`

`// Average of 0 is 0!`

`Console.WriteLine("Average of data is: {0}", CalculateAverage());`

`Console.ReadLine();`

`}`

如果您没有在`CalculateAverage()`的定义中使用`params`修饰符，那么这个方法的第一次调用将会导致编译器错误，因为编译器将会寻找一个带有五个`double`参数的`CalculateAverage()`版本。

Note

为了避免任何歧义，C#要求一个方法只支持单个`params`参数，该参数必须是参数列表中的最后一个参数。

正如您可能猜到的那样，这种技术只不过是为了方便调用者，因为数组是由 CLR 根据需要创建的。当数组处于被调用方法的范围内时，您就可以将其视为一个完全成熟的。NET 数组，它包含了`System.Array`基类库类型的所有功能。考虑以下输出:

`You sent me 5 doubles.`

`Average of data is: 32.864`

`You sent me 3 doubles.`

`Average of data is: 4.3`

`You sent me 0 doubles.`

`Average of data is: 0`

### 定义可选参数

C#允许您创建可以接受可选参数的方法。这种技术允许调用者调用单个方法，同时省略被认为不必要的参数，只要调用者对指定的缺省值满意。

Note

正如你将在第 16 章中看到的，给 C#添加可选参数的一个关键动机是简化与 COM 对象的交互。一些 Microsoft 对象模型(例如，Microsoft Office)通过 COM 对象公开它们的功能，其中许多是很久以前编写的，以利用可选参数，而早期版本的 C#不支持这些参数。

为了说明如何使用可选参数，假设您有一个名为`EnterLogData()`的方法，它定义了一个可选参数。

`static void EnterLogData(string message, string owner = "Programmer")`

`{`

`Console.Beep();`

`Console.WriteLine("Error: {0}", message);`

`Console.WriteLine("Owner of Error: {0}", owner);`

`}`

这里，通过参数定义中的赋值，最后一个`string`参数被赋予默认值`"Programmer"`。有鉴于此，你可以用两种方式从`Main()`内部调用`EnterLogData()`。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Methods *****");`

`...`

`EnterLogData("Oh no! Grid can’t find data");`

`EnterLogData("Oh no! I can’t find the payroll data", "CFO");`

`Console.ReadLine();`

`}`

因为第一次调用`EnterLogData()`时没有指定第二个`string`参数，所以您会发现程序员应该对网格数据的丢失负责，而 CFO 却错放了工资数据(由第二次方法调用中的第二个参数指定)。

需要注意的一件重要事情是，赋给可选参数的值必须在编译时已知，并且不能在运行时解析(如果您试图这样做，将会收到编译时错误！).举例来说，假设您想要用以下额外的可选参数更新`EnterLogData()`:

`// Error! The default value for an optional arg must be known`

`// at compile time!`

`static void EnterLogData(string message,`

`string owner = "Programmer", DateTime timeStamp = DateTime.Now)`

`{`

`Console.Beep();`

`Console.WriteLine("Error: {0}", message);`

`Console.WriteLine("Owner of Error: {0}", owner);`

`Console.WriteLine("Time of Error: {0}", timeStamp);`

`}`

这不会编译，因为`DateTime`类的`Now`属性的值是在运行时解析的，而不是在编译时。

Note

为了避免歧义，可选参数必须总是打包在方法签名的末尾。将可选参数列在非可选参数之前是一个编译器错误。

### 使用命名参数调用方法

C#中的另一个语言特性是支持命名参数。老实说，乍一看，这种语言结构除了导致混乱的代码之外，似乎没有什么作用。继续完全诚实地说，这可能是事实！与可选参数相似，包含对命名参数的支持部分是出于简化 COM 互用性层工作过程的愿望(再次参见[第 16 章](16.html))。

命名参数允许您通过以任意顺序指定参数值来调用方法。因此，您可以选择使用冒号操作符按名称指定每个参数，而不是只按位置传递参数(大多数情况下都会这样做)。为了说明命名参数的使用，假设您已经向`Program`类添加了以下方法:

`static void DisplayFancyMessage(ConsoleColor textColor,`

`ConsoleColor backgroundColor, string message)`

`{`

`// Store old colors to restore after message is printed.`

`ConsoleColor oldTextColor = Console.ForegroundColor;`

`ConsoleColor oldbackgroundColor = Console.BackgroundColor;`

`// Set new colors and print message.`

`Console.ForegroundColor = textColor;`

`Console.BackgroundColor = backgroundColor;`

`Console.WriteLine(message);`

`// Restore previous colors.`

`Console.ForegroundColor = oldTextColor;`

`Console.BackgroundColor = oldbackgroundColor;`

`}`

现在，按照编写`DisplayFancyMessage()`的方式，您会期望调用者通过传递两个`ConsoleColor`变量后跟一个`string`类型来调用这个方法。但是，使用命名参数，以下调用完全没问题:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Methods *****");`

`...`

`DisplayFancyMessage(message: "Wow! Very Fancy indeed!",`

`textColor: ConsoleColor.DarkRed,`

`backgroundColor: ConsoleColor.White);`

`DisplayFancyMessage(backgroundColor: ConsoleColor.Green,`

`message: "Testing...",`

`textColor: ConsoleColor.DarkBlue);`

`Console.ReadLine();`

`}`

关于命名参数的一个小问题是，如果您开始使用位置参数调用方法，您必须在任何命名参数之前列出它们。换句话说，命名参数必须总是打包到方法调用的末尾。以下代码是一个示例:

`// This is OK, as``positional args`T2】

`DisplayFancyMessage(ConsoleColor.Blue,`

`message: "Testing...",`

`backgroundColor: ConsoleColor.White);`

`// This is an ERROR, as positional args are listed after named args.`

`DisplayFancyMessage(message: "Testing...",`

`backgroundColor: ConsoleColor.White,`

`ConsoleColor.Blue);`

除了这个限制，您可能还想知道什么时候需要使用这个语言特性。毕竟，如果您需要为一个方法指定三个参数，为什么要麻烦地改变它们的位置呢？

事实证明，如果你有一个定义可选参数的方法，这个特性实际上非常有用。假设`DisplayFancyMessage()`已经重写，现在支持可选参数，因为您已经指定了拟合默认值。

`static void DisplayFancyMessage(ConsoleColor textColor = ConsoleColor.Blue,`

`ConsoleColor backgroundColor = ConsoleColor.White,`

`string message = "Test Message")`

`{`

`...`

`}`

假设每个参数都有一个默认值，命名参数允许调用者只指定他们不想接收默认值的参数。因此，如果调用者希望值`"Hello!"`以白色背景包围的蓝色文本显示，他们可以简单地指定以下内容:

`DisplayFancyMessage(message: "Hello!");`

或者，如果调用者希望看到“测试消息”打印出来，带有包含蓝色文本的绿色背景，他们可以调用`DisplayFancyMessage()`。

`DisplayFancyMessage(backgroundColor: ConsoleColor.Green);`

正如您所看到的，可选参数和命名参数往往一起工作。为了总结您对构建 C#方法的研究，我需要解决方法重载的问题。

Source Code

FunWithMethods 应用位于 [`Chapter 4`](04.html) 子目录中。

### 理解方法重载

像其他现代面向对象语言一样，C#允许方法重载。简而言之，当您定义一组名称相同但参数数量(或类型)不同的方法时，这个方法就被称为是重载的。

要理解重载为什么如此有用，请考虑一下作为一名老派 Visual Basic 6.0 (VB6)开发人员的生活。假设您正在使用 VB6 构建一组方法，这些方法返回各种传入数据类型的总和(`Integer` s、`Double` s 等等)。鉴于 VB6 不支持方法重载，您需要定义一组独特的方法，这些方法本质上做同样的事情(返回参数的总和)。

`’ VB6 code examples.`

`Public Function AddInts(ByVal x As Integer, ByVal y As Integer) As Integer`

`AddInts = x + y`

`End Function`

`Public Function AddDoubles(ByVal x As Double, ByVal y As Double) As Double`

`AddDoubles = x + y`

`End Function`

`Public Function AddLongs(ByVal x As Long, ByVal y As Long) As Long`

`AddLongs = x + y`

`End Function`

这样的代码不仅变得难以维护，而且调用者现在必须痛苦地意识到每个方法的名称。使用重载，您能够允许调用者调用一个名为`Add()`的方法。同样，关键是要确保方法的每个版本都有一组不同的参数(仅返回类型不同的方法是不够唯一的)。

Note

正如在第 9 章中所解释的，可以构建通用方法，将重载的概念提升到下一个层次。使用泛型，可以为方法实现定义类型占位符，这些占位符是在调用相关成员时指定的。

为了直接检验这一点，创建一个名为 MethodOverloading 的新控制台应用项目。现在，考虑下面的类定义:

`// C# code.`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`}`

`// Overloaded` `Add() method.`

`static int Add(int x, int y)`

`{ return x + y; }`

`static double Add(double x, double y)`

`{ return x + y; }`

`static long Add(long x, long y)`

`{ return x + y; }`

`}`

调用者现在可以简单地用所需的参数调用`Add()`,编译器很乐意遵从，因为编译器能够解析正确的实现来调用所提供的参数。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Method Overloading *****\n");`

`// Calls int version of Add()`

`Console.WriteLine(Add(10, 10));`

`// Calls long version of Add()`

`Console.WriteLine(Add(900000000000, 900000000000));`

`// Calls double version of Add()`

`Console.WriteLine(Add(4.3, 4.4));`

`Console.ReadLine();`

`}`

Visual Studio IDE 在调用重载方法进行引导时提供帮助。当您键入重载方法的名称时(例如您的好朋友`Console.WriteLine()`)，IntelliSense 将列出该方法的每个版本。请注意，您可以使用图 [4-1](#Fig1) 中所示的上下箭头键在重载方法的每个版本之间循环。

![A978-1-4842-1332-2_4_Fig1_HTML.jpg](img/A978-1-4842-1332-2_4_Fig1_HTML.jpg)

图 4-1。

Visual Studio IntelliSense for overloaded methods Source Code

MethodOverloading 应用位于 [`Chapter 4`](04.html) 子目录。

这就结束了使用 C#语法构建方法的初步研究。接下来，让我们看看如何构建和操作数组、枚举和结构。

## 了解 C#数组

我想你已经知道了，数组是一组数据项，使用数字索引来访问。更具体地说，数组是一组相同类型的连续数据点(一个由`int`组成的数组，一个由`string`组成的数组，一个由`SportsCar`组成的数组，等等)。用 C#声明、填充和访问数组非常简单。举例来说，创建一个新的控制台应用项目(名为 FunWithArrays ),它包含一个名为`SimpleArrays()`的助手方法，从`Main()`中调用。

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Arrays *****");`

`SimpleArrays();`

`Console.ReadLine();`

`}`

`static void SimpleArrays()`

`{`

`Console.WriteLine("=> Simple Array Creation.");`

`// Create an array of ints containing 3 elements indexed 0, 1, 2`

`int[] myInts = new int[3];`

`// Create a 100 item string array, indexed 0 - 99`

`string[] booksOnDotNet = new string[100];`

`Console.WriteLine();`

`}`

`}`

仔细看看前面的代码注释。当使用此语法声明 C#数组时，数组声明中使用的数字表示项目总数，而不是上限。还要注意数组的下限总是从`0`开始。因此，当你写`int[] myInts = new int[3]`时，你最终得到一个包含三个元素的数组，索引在位置`0, 1, 2`。

在定义了一个数组变量之后，就可以逐个索引地填充元素了，如更新后的`SimpleArrays()`方法所示:

`static void SimpleArrays()`

`{`

`Console.WriteLine("=> Simple Array Creation.");`

`// Create and fill an array of 3 Integers`

`int[] myInts = new int[3];`

`myInts[0] = 100;`

`myInts[1] = 200;`

`myInts[2] = 300;`

`// Now print each value.`

`foreach(int i in myInts)`

`Console.WriteLine(i);`

`Console.WriteLine();`

`}`

Note

请注意，如果您声明了一个数组，但没有显式填充每个索引，则每个项都将被设置为数据类型的默认值(例如，`bool`的数组将被设置为`false`，或者`int`的数组将被设置为`0`)。

### C#数组初始化语法

除了逐个元素地填充数组之外，您还可以使用 C#数组初始化语法来填充数组的项目。为此，在花括号(`{}`)的范围内指定每个数组项。当您创建一个已知大小的数组并希望快速指定初始值时，此语法会很有帮助。例如，考虑以下替代数组声明:

`static void ArrayInitialization()`

`{`

`Console.WriteLine("=> Array Initialization.");`

`// Array initialization syntax using the new keyword.`

`string[] stringArray = new string[]`

`{ "one", "two", "three" };`

`Console.WriteLine("stringArray has {0} elements", stringArray.Length);`

`// Array initialization syntax without using the new keyword.`

`bool[] boolArray = { false, false, true };`

`Console.WriteLine("boolArray has {0} elements", boolArray.Length);`

`// Array initialization with new keyword and size.`

`int[] intArray = new int[4] { 20, 22, 23, 0 };`

`Console.WriteLine("intArray has {0} elements", intArray.Length);`

`Console.WriteLine();`

`}`

请注意，当您使用这种“花括号”语法时，您不需要指定数组的大小(在构造`stringArray`变量时可以看到)，因为这将由花括号范围内的项数来推断。还要注意，`new`关键字的使用是可选的(在构造`boolArray`类型时显示)。

在`intArray`声明的情况下，再次回忆一下，指定的数值代表数组中元素的数量，而不是上限的值。如果声明的大小和初始值设定项的数量不匹配(无论您的初始值设定项太多还是太少)，就会发出一个编译时错误。下面是一个例子:

`// OOPS! Mismatch of size and elements!`

`int[] intArray = new int[2] { 20, 22, 23, 0 };`

### 隐式类型化局部数组

在第 3 章中，你学习了隐式类型化局部变量的主题。回想一下，`var`关键字允许您定义一个变量，它的底层类型由编译器决定。同样，`var`关键字可以用来定义隐式类型的局部数组。使用这种技术，您可以分配一个新的数组变量，而无需指定数组本身包含的类型(注意，使用这种方法时，您必须使用`new`关键字)。

`static void DeclareImplicitArrays()`

`{`

`Console.WriteLine("=> Implicit Array Initialization.");`

`// a is really int[].`

`var a = new[] { 1, 10, 100, 1000 };`

`Console.WriteLine("a is a: {0}", a.ToString());`

`// b is really double[].`

`var b = new[] { 1, 1.5, 2, 2.5 };`

`Console.WriteLine("b is a: {0}", b.ToString());`

`// c is really string[].`

`var c = new[] { "hello", null, "world" };`

`Console.WriteLine("c is a: {0}", c.ToString());`

`Console.WriteLine();`

`}`

当然，就像使用显式 C#语法分配数组一样，数组初始化列表中的项必须是相同的底层类型(例如，所有的`int`、所有的`string`或所有的`SportsCar`)。与您可能期望的不同，隐式类型的本地数组没有默认为`System.Object`；因此，下面的代码会生成一个编译时错误:

`// Error! Mixed types!`

`var d = new[] { 1, "one", 2, "two", false };`

### 定义对象数组

在大多数情况下，定义数组时，可以通过指定数组变量中的显式项类型来实现。虽然这看起来很简单，但是有一个值得注意的变化。正如你将在《T4》第 6 章中理解的那样，`System.Object`是。NET 类型系统。鉴于这一事实，如果您要定义一个`System.Object`数据类型的数组，那么子项可以是任何东西。考虑下面的`ArrayOfObjects()`方法(同样可以从`Main()`调用进行测试):

`static void ArrayOfObjects()`

`{`

`Console.WriteLine("=> Array of Objects.");`

`// An array of objects can be anything at all.`

`object[] myObjects = new object[4];`

`myObjects[0] = 10;`

`myObjects[1] = false;`

`myObjects[2] = new DateTime(1969, 3, 24);`

`myObjects[3] = "Form & Void";`

`foreach (object obj in myObjects)`

`{`

`// Print the type and value for each item in array.`

`Console.WriteLine("Type: {0}, Value: {1}", obj.GetType(), obj);`

`}`

`Console.WriteLine();`

`}`

在这里，当您迭代`myObjects`的内容时，您使用`System.Object`的`GetType()`方法打印每个项目的底层类型，以及当前项目的值。在本文的这一点上，不要涉及太多关于`System.Object.GetType()`的细节，简单地理解这个方法可以用来获得项目的完全限定名([第 15 章](15.html)详细地讨论了类型信息和反射服务的主题)。下面的输出显示了调用`ArrayOfObjects()`的结果:

`=> Array of Objects.`

`Type: System.Int32, Value: 10`

`Type: System.Boolean, Value: False`

`Type: System.DateTime, Value: 3/24/1969 12:00:00 AM`

`Type: System.String, Value: Form & Void`

### 使用多维数组

除了你已经看到的一维数组，C#还支持两种多维数组。第一种称为矩形阵列，它只是一个多维阵列，其中每行长度相同。要声明并填充多维矩形数组，请执行以下操作:

`static void RectMultidimensionalArray()`

`{`

`Console.WriteLine("=> Rectangular multidimensional array.");`

`// A rectangular MD array.`

`int[,] myMatrix;`

`myMatrix = new int[3,4];`

`// Populate (3 * 4) array.`

`for(int i = 0; i < 3; i++)`

`for(int j = 0; j < 4; j++)`

`myMatrix[i, j] = i * j;`

`// Print (3 * 4) array.`

`for(int i = 0; i < 3; i++)`

`{`

`for(int j = 0; j < 4; j++)`

`Console.Write(myMatrix[i, j] + "\t");`

`Console.WriteLine();`

`}`

`Console.WriteLine();`

`}`

第二种类型的多维数组被称为交错数组。顾名思义，交错数组包含一定数量的内部数组，每个内部数组可能有不同的上限。这里有一个例子:

`static void JaggedMultidimensionalArray()`

`{`

`Console.WriteLine("=> Jagged multidimensional array.");`

`// A jagged MD array (i.e., an array of arrays).`

`// Here we have an array of 5 different arrays.`

`int[][] myJagArray = new int[5][];`

`// Create the jagged array.`

`for (int i = 0; i < myJagArray.Length; i++)`

`myJagArray[i] = new int[i + 7];`

`// Print each row (remember, each element is defaulted to zero!).`

`for(int i = 0; i < 5; i++)`

`{`

`for(int j = 0; j < myJagArray[i].Length; j++)`

`Console.Write(myJagArray[i][j] + " ");`

`Console.WriteLine();`

`}`

`Console.WriteLine();`

`}`

调用`Main()`中的`RectMultidimensionalArray()`和`JaggedMultidimensionalArray()`方法的输出如下所示:

`=> Rectangular multidimensional array:`

`0       0       0       0`

`0       1       2       3`

`0       2       4       6`

`=> Jagged multidimensional array:`

`0 0 0 0 0 0 0`

`0 0 0 0 0 0 0 0`

`0 0 0 0 0 0 0 0 0`

`0 0 0 0 0 0 0 0 0 0`

`0 0 0 0 0 0 0 0 0 0 0`

### 数组作为参数或返回值

创建数组后，您可以自由地将其作为参数传递或作为成员返回值接收。例如，下面的`PrintArray()`方法获取一个传入的`int`数组并将每个成员打印到控制台，而`GetStringArray()`方法填充一个`string`数组并将其返回给调用者:

`static void PrintArray(int[] myInts)`

`{`

`for(int i = 0; i < myInts.Length; i++)`

`Console.WriteLine("Item {0} is {1}", i, myInts[i]);`

`}`

`static string[] GetStringArray()`

`{`

`string[] theStrings = {"Hello", "from", "GetStringArray"};`

`return theStrings;`

`}`

如您所料，这些方法可能会被调用:

`static void PassAndReceiveArrays()`

`{`

`Console.WriteLine("=> Arrays as params and return values.");`

`// Pass array as parameter.`

`int[] ages = {20, 22, 23, 0} ;`

`PrintArray(ages);`

`// Get array as return value.`

`string[] strs = GetStringArray();`

`foreach(string s in strs)`

`Console.WriteLine(s);`

`Console.WriteLine();`

`}`

至此，您应该对定义、填充和检查 C#数组变量内容的过程感到满意了。为了使画面完整，现在让我们检查一下`System.Array`类的角色。

### 系统。数组基类

您创建的每个数组都从`System.Array`类中收集了许多功能。使用这些通用成员，您可以使用一致的对象模型对数组进行操作。表 [4-2](#Tab2) 给出了一些更有趣的成员的概要(请务必查看。NET Framework 4.6 SDK 文档以了解完整的详细信息)。

表 4-2。

Select Members of System.Array

<colgroup><col> <col></colgroup> 
| 数组类的成员 | 生命的意义 |
| --- | --- |
| `Clear()` | 这个静态方法将数组中的元素范围设置为空值(0 表示数字，`null`表示对象引用，`false`表示布尔值)。 |
| `CopyTo()` | 此方法用于将源数组中的元素复制到目标数组中。 |
| `Length` | 该属性返回数组中的项数。 |
| `Rank` | 该属性返回当前数组的维数。 |
| `Reverse()` | 这个静态方法反转一维数组的内容。 |
| `Sort()` | 此静态方法对内部类型的一维数组进行排序。如果数组中的元素实现了`IComparer`接口，你也可以对你的自定义类型进行排序(参见[第 9 章](09.html))。 |

让我们看看这些成员的一些行动。下面的 helper 方法利用静态的`Reverse()`和`Clear()`方法将关于一组`string`类型的信息抽取到控制台:

`static void SystemArrayFunctionality()`

`{`

`Console.WriteLine("=> Working with System.Array.");`

`// Initialize items at startup.`

`string[] gothicBands = {"Tones on Tail", "Bauhaus", "Sisters of Mercy"};`

`// Print out names in declared order.`

`Console.WriteLine("-> Here is the array:");`

`for (int i = 0; i < gothicBands.Length; i++)`

`{`

`// Print a name.`

`Console.Write(gothicBands[i] + ", ");`

`}`

`Console.WriteLine("\n");`

`// Reverse them...`

`Array.Reverse(gothicBands);`

`Console.WriteLine("-> The reversed array");`

`// ... and print them.`

`for (int i = 0; i < gothicBands.Length; i++)`

`{`

`// Print a name.`

`Console.Write(gothicBands[i] + ", ");`

`}`

`Console.WriteLine("\n");`

`// Clear out all but the first member.`

`Console.WriteLine("-> Cleared out all but one...");`

`Array.Clear(gothicBands, 1, 2);`

`for (int i = 0; i < gothicBands.Length; i++)`

`{`

`// Print a name.`

`Console.Write(gothicBands[i] + ", ");`

`}`

`Console.WriteLine();`

`}`

如果您从`Main()`中调用该方法，您将得到如下所示的输出:

`=> Working with System.Array.`

`-> Here is the array:`

`Tones on Tail, Bauhaus, Sisters of Mercy,`

`-> The reversed array`

`Sisters of Mercy, Bauhaus, Tones on Tail,`

`-> Cleared out all but one...`

`Sisters of Mercy,,,`

注意，`System.Array`的许多成员被定义为静态成员，因此在类级别被调用(例如，`Array.Sort()`和`Array.Reverse()`方法)。诸如此类的方法在您想要处理的数组中传递。`System.Array`的其他成员(如`Length`属性)在对象级绑定；因此，您可以直接在数组上调用成员。

Source Code

FunWithArrays 应用位于 [`Chapter 4`](04.html) 子目录中。

## 了解枚举类型

回忆一下第一章中的。NET 类型系统由类、结构、枚举、接口和委托组成。为了开始探索这些类型，让我们使用一个名为 FunWithEnums 的新控制台应用项目来检查枚举(或者简单地说，`enum`)的角色。

Note

不要将术语 enum 与 enumerator 混淆；它们是完全不同的概念。枚举是名称-值对的自定义数据类型。枚举器是实现名为`IEnumerable`的. NET 接口的类或结构。通常，这个接口是在集合类和`System.Array`类上实现的。正如你将在[第 8 章](08.html)中看到的，支持`IEnumerable`的对象可以在`foreach`循环中工作。

构建系统时，创建一组映射到已知数值的符号名通常很方便。例如，如果您正在创建一个工资单系统，您可能希望使用诸如副总裁、经理、承包商和普通员工等常量来引用雇员的类型。正因为如此，C#支持自定义枚举的概念。例如，这里有一个名为`EmpType`的枚举(您可以在与您的`Program`类相同的文件中定义它，就在类定义之前):

`// A custom enumeration.`

`enum EmpType`

`{`

`Manager,      // = 0`

`Grunt,        // = 1`

`Contractor,   // = 2`

`VicePresident // = 3`

`}`

`EmpType`枚举定义了四个命名的常量，对应于离散的数值。默认情况下，第一个元素的值设置为零(0)，后面是 n+1 级数。你可以随意改变初始值。例如，如果将`EmpType`的成员编号为 102 到 105 是有意义的，您可以这样做:

`// Begin with 102.`

`enum EmpType`

`{`

`Manager = 102,`

`Grunt,        // = 103`

`Contractor,   // = 104`

`VicePresident // = 105`

`}`

枚举不一定需要遵循顺序，也不需要具有唯一的值。如果(由于这样或那样的原因)像这里所示的那样建立您的`EmpType`是有意义的，编译器会继续高兴:

`// Elements of an enumeration need not be sequential!`

`enum EmpType`

`{`

`Manager = 10,`

`Grunt = 1,`

`Contractor = 100,`

`VicePresident = 9`

`}`

### 控制枚举的基础存储

默认情况下，用于保存枚举值的存储类型是 a`System.Int32`(c#`int`)；但是，您可以根据自己的喜好随意更改。可以用类似的方式为任何核心系统类型(`byte`、`short`、`int`或`long`)定义 C#枚举。例如，如果您想将`EmpType`的底层存储值设置为`byte`而不是`int`，您可以编写以下代码:

`// This time, EmpType maps to an underlying byte.`

`enum EmpType : byte`

`{`

`Manager = 10,`

`Grunt = 1,`

`Contractor = 100,`

`VicePresident = 9`

`}`

如果您要生成一个将被部署到低内存设备上的. NET 应用，并且需要尽可能地节省内存，更改枚举的基础类型会很有帮助。当然，如果您确实建立了您的枚举来使用一个`byte`作为存储，每个值必须在它的范围之内！例如，以下版本的`EmpType`将导致编译器错误，因为值 999 不适合一个字节的范围:

`// Compile-time error! 999 is too big for a byte!`

`enum EmpType : byte`

`{`

`Manager = 10,`

`Grunt = 1,`

`Contractor = 100,`

`VicePresident = 999`

`}`

### 声明枚举变量

一旦你建立了枚举的范围和存储类型，你就可以用它来代替所谓的幻数。因为枚举只不过是用户定义的数据类型，所以您可以将它们用作函数返回值、方法参数、局部变量等等。假设您有一个名为`AskForBonus()`的方法，将一个`EmpType`变量作为唯一的参数。根据传入参数的值，您将打印出对支付奖金请求的合适响应。

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("**** Fun with Enums *****");`

`// Make an EmpType variable.`

`EmpType emp = EmpType.Contractor;`

`AskForBonus(emp);`

`Console.ReadLine();`

`}`

`// Enums as parameters.`

`static void AskForBonus(EmpType e)`

`{`

`switch (e)`

`{`

`case EmpType.Manager:`

`Console.WriteLine("How about stock options instead?");`

`break;`

`case EmpType.Grunt:`

`Console.WriteLine("You have got to be kidding...");`

`break;`

`case EmpType.Contractor:`

`Console.WriteLine("You already get enough cash...");`

`break;`

`case EmpType.VicePresident:`

`Console.WriteLine("VERY GOOD, Sir!");`

`break;`

`}`

`}`

`}`

请注意，当您给一个`enum`变量赋值时，您必须将`enum`名称(`EmpType`)限定为值(`Grunt`)。因为枚举是一组固定的名称-值对，所以将`enum`变量设置为不是由枚举类型直接定义的值是非法的。

`static void ThisMethodWillNotCompile()`

`{`

`// Error! SalesManager is not in the EmpType enum!`

`EmpType emp = EmpType.SalesManager;`

`// Error! Forgot to scope Grunt value to EmpType enum!`

`emp = Grunt;`

`}`

### 系统。枚举类型

有趣的是。NET 枚举的一个优点是它们从`System.Enum`类类型中获得功能。该类定义了许多方法，允许您查询和转换给定的枚举。一个有用的方法是静态的`Enum.GetUnderlyingType()`，顾名思义，它返回用于存储枚举类型值的数据类型(在当前的`EmpType`声明中是`System.Byte`)。

`static void Main(string[] args)`

`{`

`Console.WriteLine("**** Fun with Enums *****");`

`// Make a contractor type.`

`EmpType emp = EmpType.Contractor;`

`AskForBonus(emp);`

`// Print storage for the enum.`

`Console.WriteLine("EmpType uses a {0} for storage",`

`Enum.GetUnderlyingType(emp.GetType()));`

`Console.ReadLine();`

`}`

如果您查阅 Visual Studio 对象浏览器，您将能够验证`Enum.GetUnderlyingType()`方法要求您传入一个`System.Type`作为第一个参数。正如在第 15 章[中全面检查的那样，`Type`代表给定的元数据描述。网络实体。](15.html)

获取元数据的一种可能方式(如前所示)是使用`GetType()`方法，该方法对于。NET 基础类库。另一种方法是使用 C# `typeof`操作符。这样做的一个好处是，您不需要拥有想要获取其元数据描述的实体的变量。

`// This time use typeof to extract a Type.`

`Console.WriteLine("EmpType uses a {0} for storage",`

`Enum.GetUnderlyingType(typeof(EmpType)));`

### 动态发现枚举的名称/值对

除了`Enum.GetUnderlyingType()`方法，所有 C#枚举都支持一个名为`ToString()`的方法，该方法返回当前枚举值的字符串名称。以下代码是一个示例:

`static void Main(string[] args)`

`{`

`Console.WriteLine("**** Fun with Enums *****");`

`EmpType emp = EmpType.Contractor;`

`AskForBonus(emp);`

`// Prints out "emp is a Contractor".`

`Console.WriteLine("emp is a {0}.", emp.ToString());`

`Console.ReadLine();`

`}`

如果您对发现给定枚举变量的值感兴趣，而不是它的名称，您可以简单地将`enum`变量转换为底层存储类型。下面是一个例子:

`static void Main(string[] args)`

`{`

`Console.WriteLine("**** Fun with Enums *****");`

`EmpType emp = EmpType.Contractor;`

`...`

`// Prints out "Contractor = 100".`

`Console.WriteLine("{0} = {1}", emp.ToString(), (byte)emp);`

`Console.ReadLine();`

`}`

Note

静态的`Enum.Format()`方法通过指定一个期望的格式标志提供了一个更精细的格式化选项。请参考。NET Framework 4.6 SDK 文档，了解关于`System.Enum.Format()`方法的全部细节。

`System.Enum`还定义了另一个名为`GetValues()`的静态方法。这个方法返回一个`System.Array`的实例。数组中的每一项都对应于指定枚举的一个成员。考虑下面的方法，它将打印出您作为参数传入的任何枚举中的每个名称-值对:

`// This method will print out the details of any enum.`

`static void EvaluateEnum(System.Enum e)`

`{`

`Console.WriteLine("=> Information about {0}", e.GetType().Name);`

`Console.WriteLine("Underlying storage type: {0}",`

`Enum.GetUnderlyingType(e.GetType()));`

`// Get all name/value pairs for incoming parameter.`

`Array enumData = Enum.GetValues(e.GetType());`

`Console.WriteLine("This enum has {0} members.", enumData.Length);`

`// Now show the string name and associated value, using the D format`

`// flag (see Chapter`[`3`](03.html)T2】

`for(int i = 0; i < enumData.Length; i++)`

`{`

`Console.WriteLine("Name: {0}, Value: {0:D}",`

`enumData.GetValue(i));`

`}`

`Console.WriteLine();`

`}`

为了测试这个新方法，更新您的`Main()`方法来创建在`System`名称空间中声明的几种枚举类型的变量(以及一个`EmpType`枚举)。以下代码是一个示例:

`static void Main(string[] args)`

`{`

`Console.WriteLine("**** Fun with Enums *****");`

`...`

`EmpType e2 = EmpType.Contractor;`

`// These types are enums in the System namespace.`

`DayOfWeek day = DayOfWeek.Monday;`

`ConsoleColor cc = ConsoleColor.Gray;`

`EvaluateEnum(e2);`

`EvaluateEnum(day);`

`EvaluateEnum(cc);`

`Console.ReadLine();`

`}`

这里显示了部分输出:

`=> Information about DayOfWeek`

`Underlying storage type: System.Int32`

`This enum has 7 members.`

`Name: Sunday, Value: 0`

`Name: Monday, Value: 1`

`Name: Tuesday, Value: 2`

`Name: Wednesday, Value: 3`

`Name: Thursday, Value: 4`

`Name: Friday, Value: 5`

`Name: Saturday, Value: 6`

正如您将在本文中看到的，枚举在整个。NET 基础类库。例如，ADO.NET 使用许多枚举来表示数据库连接的状态(例如，打开或关闭)或`DataTable`中的行的状态(例如，已更改、新的或已分离)。因此，当您使用任何枚举时，请始终记住您能够使用`System.Enum`的成员与名称-值对进行交互。

Source Code

FunWithEnums 项目位于 [`Chapter 4`](04.html) 子目录下。

## 理解结构(又名值类型)

现在您已经理解了枚举类型的作用，让我们来研究。NET 结构(或简称为结构)。结构类型非常适合在应用中建模数学、几何和其他“原子”实体。结构(如枚举)是用户定义的类型；然而，结构不仅仅是名称-值对的集合。相反，结构是可以包含任意数量的数据字段和对这些字段进行操作的成员的类型。

Note

如果你有 OOP 的背景，你可以把一个结构想成一个“轻量级类类型”，因为结构提供了一种定义支持封装的类型的方法，但是不能用来构建一系列相关的类型。当你需要通过继承建立一个相关类型的家族时，你将需要利用类类型。

从表面上看，定义和使用结构的过程很简单，但是正如他们所说的，细节决定成败。为了开始理解结构类型的基础，创建一个名为 FunWithStructures 的新项目。在 C#中，使用`struct`关键字定义结构。定义一个名为`Point`的新结构，它定义了两个`int`类型的成员变量和一组与所述数据交互的方法。

`struct Point`

`{`

`// Fields of the structure.`

`public int X;`

`public int Y;`

`// Add 1 to the (X, Y) position.`

`public void Increment()`

`{`

`X++; Y++;`

`}`

`// Subtract 1 from the (X, Y) position.`

`public void Decrement()`

`{`

`X--; Y--;`

`}`

`// Display the current position.`

`public void Display()`

`{`

`Console.WriteLine("X = {0}, Y = {1}", X, Y);`

`}`

`}`

这里，您已经使用`public`关键字定义了两个整数字段(`X`和`Y`)，这是一个访问控制修饰符([第 5 章](05.html)进一步讨论)。用`public`关键字声明数据可以确保调用者可以直接访问给定的`Point`变量中的数据(通过点运算符)。

Note

在类或结构中定义公共数据通常被认为是不好的风格。相反，您会希望定义私有数据，可以使用公共属性来访问和更改这些数据。这些细节将在第 5 章中讨论。

这里有一个`Main()`方法，将`Point`型拿出来进行试驾:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** A First Look at Structures *****\n");`

`// Create an initial Point.`

`Point myPoint;`

`myPoint.X = 349;`

`myPoint.Y = 76;`

`myPoint.Display();`

`// Adjust the X and Y values.`

`myPoint.Increment();`

`myPoint.Display();`

`Console.ReadLine();`

`}`

输出如您所料。

`***** A First Look at Structures *****`

`X = 349, Y = 76`

`X = 350, Y = 77`

### 创建结构变量

当你想创建一个结构变量时，你有多种选择。在这里，您只需创建一个`Point`变量，并在调用它的成员之前分配每个公共字段数据。如果您在使用该结构之前没有分配每一段公共字段数据(在本例中是`X`和`Y`，您将会收到一个编译器错误。

`// Error! Did not assign Y value.`

`Point p1;`

`p1.X = 10;`

`p1.Display();`

`// OK! Both fields assigned before use.`

`Point p2;`

`p2.X = 10;`

`p2.Y = 10;`

`p2.Display();`

或者，您可以使用 C# `new`关键字创建结构变量，这将调用结构的默认构造函数。根据定义，默认构造函数不接受任何参数。调用结构的默认构造函数的好处是每一段字段数据都被自动设置为其默认值。

`// Set all fields to default values`

`// using the default constructor.`

`Point p1 = new Point();`

`// Prints X=0,Y=0.`

`p1.Display();`

也可以用自定义构造函数设计结构。这允许您在创建变量时指定字段数据的值，而不必逐个字段地设置每个数据成员。第 5 章将提供对构造者的详细检查；然而，为了说明，用下面的代码更新`Point`结构:

`struct Point`

`{`

`// Fields of the structure.`

`public int X;`

`public int Y;`

`// A custom constructor.`

`public Point(int XPos, int YPos)`

`{`

`X = XPos;`

`Y = YPos;`

`}`

`...`

`}`

这样，您现在可以创建`Point`变量，如下所示:

`// Call custom constructor.`

`Point p2 = new Point(50, 60);`

`// Prints X=50,Y=60.`

`p2.Display();`

如前所述，在曲面上处理结构非常简单。但是，为了加深对这种类型的理解，您需要探究. NET 值类型和. NET 引用类型之间的区别。

Source Code

FunWithStructures 项目位于 [`Chapter 4`](04.html) 子目录中。

## 了解值类型和引用类型

Note

下面对值类型和引用类型的讨论假设您有面向对象编程的背景。如果不是这样，你可能想跳到本章的“理解 C#可空类型”一节，并在阅读完第 5 章和第 6 章后回到这一节。

与数组、字符串或枚举不同，C#结构在。NET 库(也就是没有`System.Structure`类)但是从`System.ValueType`中隐式派生。简单地说，`System.ValueType`的作用是确保派生类型(如任何结构)被分配在堆栈上，而不是垃圾收集堆上。简而言之，分配在堆栈上的数据可以被快速地创建和销毁，因为它的生存期是由定义的范围决定的。另一方面，堆分配的数据由。NET 垃圾收集器，它的生命周期由许多因素决定，这些因素将在第 13 章的[中讨论。](13.html)

在功能上，`System.ValueType`的唯一目的是覆盖由`System.Object`定义的虚拟方法，使用基于值的语义，而不是基于引用的语义。您可能知道，重写是更改基类中定义的虚(或者可能是抽象)方法的实现的过程。`ValueType`的基类是`System.Object`。实际上，`System.ValueType`定义的实例方法和`System.Object`的是一样的。

`// Structures and enumerations implicitly extend System.ValueType.`

`public abstract class ValueType : object`

`{`

`public virtual bool Equals(object obj);`

`public virtual int GetHashCode();`

`public Type GetType();`

`public virtual string ToString();`

`}`

假设值类型使用基于值的语义，结构(包括所有数字数据类型[ `int`，`float` ]，以及任何`enum`或结构)的生命周期是可预测的。当一个结构变量超出定义范围时，它会被立即从内存中删除。

`// Local structures are popped off`

`// the stack when a method returns.`

`static void LocalValueTypes()`

`{`

`// Recall! "int" is really a System.Int32 structure.`

`int i = 0;`

`// Recall! Point is a structure type.`

`Point p = new Point();`

`} // "i" and "p" popped off the stack here!`

### 值类型、引用类型和赋值运算符

当您将一种值类型分配给另一种值类型时，将获得字段数据的逐个成员的副本。对于像`System.Int32`这样的简单数据类型，唯一要复制的成员是数值。然而，在您的`Point`中，`X`和`Y`的值被复制到新的结构变量中。举例来说，创建一个名为 ValueAndReferenceTypes 的新控制台应用项目，然后将之前的`Point`定义复制到新的名称空间中。接下来，将以下方法添加到您的`Program`类型中:

`// Assigning two intrinsic value types results in`

`// two independent variables on the stack.`

`static void ValueTypeAssignment()`

`{`

`Console.WriteLine("Assigning value types\n");`

`Point p1 = new Point(10, 10);`

`Point p2 = p1;`

`// Print both points.`

`p1.Display();`

`p2.Display();`

`// Change p1.X and print again. p2.X is not changed.`

`p1.X = 100;`

`Console.WriteLine("\n=> Changed p1.X\n");`

`p1.Display();`

`p2.Display();`

`}`

这里，您已经创建了一个类型为`Point`(名为`p1`)的变量，然后将它分配给另一个`Point` ( `p2`)。因为`Point`是一个值类型，所以你在堆栈上有两个`MyPoint`类型的副本，每个都可以被独立操作。因此，当您更改`p1.X`的值时，`p2.X`的值不受影响。

`Assigning value types`

`X = 10, Y = 10`

`X = 10, Y = 10`

`=> Changed p1.X`

`X = 100, Y = 10`

`X = 10, Y = 10`

与值类型形成鲜明对比的是，当您将赋值操作符应用于引用类型(意味着所有类实例)时，您是在内存中重定向引用变量所指向的内容。举例来说，创建一个名为`PointRef`的新类类型，它具有与`Point`结构相同的成员，除了重命名构造函数以匹配类名。

`// Classes are always reference types.`

`class PointRef`

`{`

`// Same members as the Point structure...`

`// Be sure to change your constructor name to PointRef!`

`public PointRef(int XPos, int YPos)`

`{`

`X = XPos;`

`Y = YPos;`

`}`

`}`

现在，在下面的新方法中使用您的`PointRef`类型。注意，除了使用`PointRef`类，而不是`Point`结构，代码与`ValueTypeAssignment()`方法相同。

`static void ReferenceTypeAssignment()`

`{`

`Console.WriteLine("Assigning reference types\n");`

`PointRef p1 = new PointRef(10, 10);`

`PointRef p2 = p1;`

`// Print both point refs.`

`p1.Display();`

`p2.Display();`

`// Change p1.X and print again.`

`p1.X = 100;`

`Console.WriteLine("\n=> Changed p1.X\n");`

`p1.Display();`

`p2.Display();`

`}`

在这种情况下，有两个引用指向托管堆上的同一个对象。因此，当您使用`p1`参考改变`X`的值时，`p2.X`报告相同的值。假设您已经在`Main()`中调用了这个新方法，您的输出应该如下所示:

`Assigning reference types`

`X = 10, Y = 10`

`X = 10, Y = 10`

`=> Changed p1.X`

`X = 100, Y = 10`

`X = 100, Y = 10`

### 包含引用类型的值类型

现在，您对值类型和引用类型之间的基本区别有了更好的理解，让我们来看一个更复杂的例子。假设您有下面的引用(类)类型，它维护一个可以使用自定义构造函数设置的信息性`string`:

`class ShapeInfo`

`{`

`public string infoString;`

`public ShapeInfo(string info)`

`{`

`infoString = info;`

`}`

`}`

现在假设您想在名为`Rectangle`的值类型中包含这个类类型的变量。为了允许调用者设置内部`ShapeInfo`成员变量的值，您还提供了一个定制的构造函数。以下是`Rectangle`类型的完整定义:

`struct Rectangle`

`{`

`// The Rectangle structure contains a reference type member.`

`public ShapeInfo rectInfo;`

`public int rectTop, rectLeft, rectBottom, rectRight;`

`public Rectangle(string info, int top, int left, int bottom, int right)`

`{`

`rectInfo = new ShapeInfo(info);`

`rectTop = top; rectBottom = bottom;`

`rectLeft = left; rectRight = right;`

`}`

`public void Display()`

`{`

`Console.WriteLine("String = {0}, Top = {1}, Bottom = {2}, " +`

`"Left = {3}, Right = {4}",`

`rectInfo.infoString, rectTop, rectBottom, rectLeft, rectRight);`

`}`

`}`

此时，您已经在值类型中包含了一个引用类型。这个百万美元的问题现在变成了，如果你把一个`Rectangle`变量赋给另一个，会发生什么？根据您对值类型的了解，假设整数数据(实际上是一种结构— `System.Int32`)应该是每个`Rectangle`变量的独立实体是正确的。但是内部引用类型呢？是完全复制对象的状态，还是复制对该对象的引用？要回答这个问题，定义以下方法并从`Main()`调用它:

`static void ValueTypeContainingRefType()`

`{`

`// Create the first Rectangle.`

`Console.WriteLine("-> Creating r1");`

`Rectangle r1 = new Rectangle("First Rect", 10, 10, 50, 50);`

`// Now assign a new Rectangle to r1.`

`Console.WriteLine("-> Assigning r2 to r1");`

`Rectangle r2 = r1;`

`// Change some values of r2.`

`Console.WriteLine("-> Changing values of r2");`

`r2.rectInfo.infoString = "This is new info!";`

`r2.rectBottom = 4444;`

`// Print values of both rectangles.`

`r1.Display();`

`r2.Display();`

`}`

输出如下所示:

`-> Creating r1`

`-> Assigning r2 to r1`

`-> Changing values of r2`

`String = This is new info!, Top = 10, Bottom = 50, Left = 10, Right = 50`

`String = This is new info!, Top = 10, Bottom = 4444, Left = 10, Right = 50`

如您所见，当您使用`r2`引用更改信息字符串的值时，`r1`引用显示相同的值。默认情况下，当值类型包含其他引用类型时，赋值会产生引用的副本。这样，你就有了两个独立的结构，每个结构都包含一个指向内存中同一个对象的引用(即浅拷贝)。当你想执行深度复制时，其中内部引用的状态被完全复制到一个新对象中，一种方法是实现`ICloneable`接口(正如你将在[第 8 章](08.html)中所做的)。

Source Code

ValueAndReferenceTypes 项目位于 [`Chapter 4`](04.html) 子目录中。

### 通过值传递引用类型

显然，引用类型或值类型可以作为参数传递给方法。然而，通过引用传递引用类型(例如，类)与通过值传递有很大不同。为了理解其中的区别，假设您在一个名为 RefTypeValTypeParams 的新控制台应用项目中定义了一个简单的`Person`类，定义如下:

`class Person`

`{`

`public string personName;`

`public int personAge;`

`// Constructors.`

`public Person(string name, int age)`

`{`

`personName = name;`

`personAge = age;`

`}`

`public Person(){}`

`public void Display()`

`{`

`Console.WriteLine("Name: {0}, Age: {1}", personName, personAge);`

`}`

`}`

现在，如果您创建一个方法，允许调用者通过值发送`Person`对象(注意缺少参数修饰符，如`out`或`ref`)会怎么样？

`static void SendAPersonByValue(Person p)`

`{`

`// Change the age of "p"?`

`p.personAge = 99;`

`// Will the caller see this reassignment?`

`p = new Person("Nikki", 99);`

`}`

注意`SendAPersonByValue()`方法如何试图将传入的`Person`引用重新分配给新的`Person`对象，以及更改一些状态数据。现在让我们使用下面的`Main()`方法来测试这个方法:

`static void Main(string[] args)`

`{`

`// Passing ref-types by value.`

`Console.WriteLine("***** Passing Person object by value *****");`

`Person fred = new Person("Fred", 12);`

`Console.WriteLine("\nBefore by value call, Person is:");`

`fred.Display();`

`SendAPersonByValue(fred);`

`Console.WriteLine("\nAfter by value call, Person is:");`

`fred.Display();`

`Console.ReadLine();`

`}`

以下是该调用的输出:

`***** Passing Person object by value *****`

`Before by value call, Person is:`

`Name: Fred, Age: 12`

`After by value call, Person is:`

`Name: Fred, Age: 99`

如您所见，`personAge`的值已经被修改。这种行为似乎违背了“按值”传递参数的含义假设您能够更改传入的`Person`的状态，那么复制了什么呢？答案是:调用方对象的引用的副本。因此，当`SendAPersonByValue()`方法与调用者指向同一个对象时，就有可能改变对象的状态数据。不可能的是重新分配引用所指向的内容。

### 通过引用传递引用类型

现在假设您有一个`SendAPersonByReference()`方法，它通过引用传递一个引用类型(注意`ref`参数修饰符)。

`static void SendAPersonByReference(ref Person p)`

`{`

`// Change some data of "p".`

`p.personAge = 555;`

`// "p" is now pointing to a new object on the heap!`

`p = new Person("Nikki", 999);`

`}`

如您所料，这使得被调用方能够完全灵活地操作传入参数。被调用者不仅可以改变对象的状态，而且如果它愿意，它还可以将引用重新分配给一个新的`Person`对象。现在思考以下更新`Main()`的方法:

`static void Main(string[] args)`

`{`

`// Passing ref-types by ref.`

`Console.WriteLine("***** Passing Person object by reference *****");`

`...`

`Person mel = new Person("Mel", 23);`

`Console.WriteLine("Before by ref call, Person is:");`

`mel.Display();`

`SendAPersonByReference(ref mel);`

`Console.WriteLine("After by ref call, Person is:");`

`mel.Display();`

`Console.ReadLine();`

`}`

请注意以下输出:

`***** Passing Person object by reference *****`

`Before by ref call, Person is:`

`Name: Mel, Age: 23`

`After by ref call, Person is:`

`Name: Nikki, Age: 999`

如您所见，名为`Mel`的对象在调用后作为名为`Nikki`的对象返回，因为该方法能够改变传入引用在内存中指向的内容。传递引用类型时要记住的黄金法则如下:

*   如果引用类型是通过引用传递的，则被调用方可以更改对象的状态数据的值，以及它所引用的对象。
*   如果引用类型通过值传递，则被调用方可以更改对象的状态数据的值，但不能更改它所引用的对象。

Source Code

RefTypeValTypeParams 项目位于 [`Chapter 4`](04.html) 子目录中。

### 关于值类型和引用类型的最终细节

为了总结这个主题，考虑表 [4-3](#Tab3) 中的信息，它总结了值类型和引用类型之间的核心区别。

表 4-3。

Value Types and Reference Types Comparison

<colgroup><col> <col> <col></colgroup> 
| 有趣的问题 | 值类型 | 参考类型 |
| --- | --- | --- |
| 对象被分配到哪里？ | 在堆栈上分配。 | 在托管堆上分配。 |
| 变量是如何表示的？ | 值类型变量是本地副本。 | 引用类型变量指向分配的实例所占用的内存。 |
| 基本类型是什么？ | 隐式扩展`System.ValueType`。 | 可以从任何其他类型派生(除了`System. ValueType`)，只要那个类型不是“密封的”(更多细节在[第 6 章](06.html))。 |
| 这个类型可以作为其他类型的基础吗？ | 不可以。值类型总是密封的，不能从。 | 是的。如果该类型不是密封的，它可能充当其他类型的基。 |
| 默认的参数传递行为是什么？ | 变量通过值传递(即，变量的副本被传递到被调用的函数中)。 | 对于引用类型，引用是按值复制的。 |
| 这个类型可以覆盖`System.Object.Finalize()`吗？ | 号码 | 是的，间接的(更多细节见[第 13 章](13.html))。 |
| 我可以为这种类型定义构造函数吗？ | 是的，但是默认构造函数是保留的(即，您的自定义构造函数必须都有参数)。 | 但是，当然！ |
| 这种类型的变量什么时候消亡？ | 当它们超出定义范围时。 | 当对象被垃圾回收时。 |

尽管存在差异，值类型和引用类型都具有实现接口的能力，并且可以支持任意数量的字段、方法、重载运算符、常数、属性和事件。

## 了解 C#可空类型

为了总结本章，让我们使用一个名为 NullableTypes 的最终控制台应用项目来研究可空数据类型的作用。众所周知，C#数据类型有一个固定的范围，并且在`System`名称空间中被表示为一个类型。例如，可以从集合`{true, false}`中为`System.Boolean`数据类型赋值。现在，回想一下，所有的数字数据类型(以及`Boolean`数据类型)都是值类型。值类型永远不能被赋予`null`的值，因为它被用来建立一个空的对象引用。

`static void Main(string[] args)`

`{`

`// Compiler errors!`

`// Value types cannot be set to null!`

`bool myBool = null;`

`int myInt = null;`

`// OK! Strings are reference types.`

`string myString = null;`

`}`

C#支持可空数据类型的概念。简单地说，可空类型可以表示其基础类型的所有值，加上值`null`。因此，如果你声明一个可空的`bool`，它可以从集合`{true, false, null}`中被赋值。这在处理关系数据库时非常有用，因为在数据库表中经常会遇到未定义的列。如果没有可空数据类型的概念，C#中就没有方便的方式来表示没有值的数字数据点。

为了定义可空变量类型，问号符号(`?`)作为基础数据类型的后缀。请注意，这种语法只有在应用于值类型时才是合法的。如果你试图创建一个可空的引用类型(包括`string` s)，你会得到一个编译时错误。像不可空变量一样，在使用局部可空变量之前，必须给它们分配一个初始值。

`static void LocalNullableVariables()`

`{`

`// Define some local nullable variables.`

`int? nullableInt = 10;`

`double? nullableDouble = 3.14;`

`bool? nullableBool = null;`

`char? nullableChar = ’a’;`

`int?[] arrayOfNullableInts = new int?[10];`

`// Error! Strings are reference types!`

`// string? s = "oops";`

`}`

在 C#中，`?`后缀符号是创建通用`System.Nullable<T>`结构类型实例的简写。虽然在第 9 章之前你不会检查泛型，但是理解`System.Nullable<T>`类型提供了一组所有可空类型都可以利用的成员是很重要的。

例如，您能够通过编程发现可空变量是否确实已经使用`HasValue`属性或`!=`操作符被赋予了一个`null`值。可空类型的赋值可以直接获得，也可以通过`Value`属性获得。事实上，鉴于`?`后缀只是使用`Nullable<T>`的简写，您可以如下实现您的`LocalNullableVariables()`方法:

`static void LocalNullableVariablesUsingNullable()`

`{`

`// Define some local nullable types using Nullable<T>.`

`Nullable<int> nullableInt = 10;`

`Nullable<double> nullableDouble = 3.14;`

`Nullable<bool> nullableBool = null;`

`Nullable<char> nullableChar = ’a’;`

`Nullable<int>[] arrayOfNullableInts = new Nullable<int>[10];`

`}`

### 使用可空类型

如上所述，当您与数据库交互时，可空数据类型可能特别有用，因为数据表中的列可能故意为空(例如，未定义)。为了说明，假设下面的类，它模拟了访问一个数据库的过程，该数据库的表包含两个可能是`null`的列。注意，`GetIntFromDatabase()`方法没有给可空整数成员变量赋值，而`GetBoolFromDatabase()`给`bool?`成员赋值。

`class DatabaseReader`

`{`

`// Nullable data field.`

`public int? numericValue = null;`

`public bool? boolValue = true;`

`// Note the nullable return type.`

`public int? GetIntFromDatabase()`

`{ return numericValue; }`

`// Note the nullable return type.`

`public bool? GetBoolFromDatabase()`

`{ return boolValue; }`

`}`

现在，假设下面的`Main()`方法，该方法调用`DatabaseReader`类的每个成员，并使用`HasValue`和`Value`成员以及 C#相等运算符(确切地说，不等于)来发现赋值:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Nullable Data *****\n");`

`DatabaseReader dr = new DatabaseReader();`

`// Get int from "database".`

`int? i = dr.GetIntFromDatabase();`

`if (i.HasValue)`

`Console.WriteLine("Value of ’i’ is: {0}", i.Value);`

`else`

`Console.WriteLine("Value of ’i’ is undefined.");`

`// Get bool from "database".`

`bool? b = dr.GetBoolFromDatabase();`

`if (b != null)`

`Console.WriteLine("Value of ’b’ is: {0}", b.Value);`

`else`

`Console.WriteLine("Value of ’b’ is undefined.");`

`Console.ReadLine();`

`}`

### 零合并算子

下一个需要注意的方面是，任何可能有一个`null`值的变量(即引用类型变量或可空值类型变量)都可以使用 C# `??`操作符，这在形式上被称为空合并操作符。如果检索到的值实际上是`null`，这个操作符允许您将一个值赋给一个可空类型。对于这个例子，假设如果从`GetIntFromDatabase()`返回的值是`null`，你想将一个局部可空整数赋给 100(当然，这个方法被编程为总是返回`null`，但是我相信你已经明白了大概的意思)。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Nullable Data *****\n");`

`DatabaseReader dr = new DatabaseReader();`

`...`

`// If the value from GetIntFromDatabase() is null,`

`// assign local variable to 100.`

`int myData = dr.GetIntFromDatabase() ?? 100;`

`Console.WriteLine("Value of myData: {0}", myData);`

`Console.ReadLine();`

`}`

使用`??`操作符的好处是它提供了传统`if` / `else`条件的一个更紧凑的版本。但是，如果您愿意，您可以编写以下功能等效的代码，以确保如果一个值作为`null`返回，它将确实被设置为值 100:

`// Long-hand notation not using ?? syntax.`

`int? moreData = dr.GetIntFromDatabase();`

`if (!moreData.HasValue)`

`moreData = 100;`

`Console.WriteLine("Value of moreData: {0}", moreData);`

### 空条件运算符

当你写软件时，通常会检查输入参数，从类型成员(方法、属性、索引器)返回的值与值`null`的对比。例如，让我们假设您有一个将字符串数组作为单个参数的方法。为了安全起见，您可能想在继续之前测试一下`null`。这样，如果数组为空，就不会出现运行时错误。以下是执行这种检查的传统方式:

`static void TesterMethod(string[] args)`

`{`

`// We should check for null before accessing the array data!`

`if (args != null)`

`{`

`Console.WriteLine($"You sent me {args.Length} arguments.");`

`}`

`}`

这里，您使用一个条件作用域来确保如果数组是`null`，那么`string`数组的`Length`属性将不会被访问。如果调用方未能生成数据数组并像这样调用您的方法，您仍然是安全的，不会触发运行时错误:

`TesterMethod(null);`

在 C#语言的当前版本中，现在可以利用`null`条件操作符标记(一个放在变量类型之后、访问操作符之前的问号)来简化之前的错误检查。现在，您可以编写以下代码，而不是显式地构建一个条件语句来检查`null`:

`static void TesterMethod(string[] args)`

`{`

`// We should check for null before accessing the array data!`

`Console.WriteLine($"You sent me {args?.Length} arguments.");`

`}`

在这种情况下，您没有使用条件语句。更确切地说，您是直接在`string`数组变量后面加上了`?`操作符的后缀。如果这是`null`，它对`Length`属性的调用将不会抛出运行时错误。如果您想打印一个实际值，您可以利用 null 合并操作符来分配一个默认值，如下所示:

`Console.WriteLine($"You sent me {args?.Length ?? 0} arguments.");`

新的 C# 6.0 `null`条件操作符在一些额外的编码领域会非常方便，尤其是在处理委托和事件的时候。然而，由于这些主题直到本书的后面才被提及(见[第 10 章](10.html)，你将保留任何额外的用例。至此，您对 C#编程语言的初步研究就完成了！在第五章中，你将开始深入研究面向对象开发的细节。

Source Code

NullableTypes 应用位于 [`Chapter 4`](04.html) 子目录中。

## 摘要

本章从几个 C#关键字开始，这些关键字允许您构建自定义方法。回想一下，默认情况下，参数是通过值传递的；但是，如果用`ref`或`out`标记，您可以通过引用传递参数。您还了解了可选参数或命名参数的作用，以及如何定义和调用采用参数数组的方法。

在您研究了方法重载这一主题之后，本章的大部分讨论了有关数组、枚举和结构如何在 C#中定义以及如何在？NET 基础类库。在此过程中，您研究了关于值类型和引用类型的一些细节，包括当将它们作为参数传递给方法时它们如何响应，以及如何使用`?`和`??`操作符与可能是`null`的可空数据类型和变量(例如，引用类型变量和可空值类型变量)进行交互。