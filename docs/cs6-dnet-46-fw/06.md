# 6.理解继承和多态

第 5 章研究了 OOP 的第一个支柱:封装。那时，您学习了如何用构造函数和各种成员(字段、属性、方法、常量和只读字段)构建一个定义良好的类类型。本章将关注 OOP 的其余两个支柱:继承和多态。

首先，您将学习如何使用继承来构建相关类的族。正如您将看到的，这种形式的代码重用允许您在父类中定义公共功能，这些功能可以被子类利用，也可能被子类修改。在这个过程中，您将学习如何使用虚拟和抽象成员建立一个多态的类层次结构接口，以及显式类型转换的作用。

本章将通过研究。NET 基础类库:`System.Object`。

## 遗传的基本机制

回想一下第 5 章中的内容，继承是 OOP 的一个方面，有助于代码重用。具体来说，代码重用有两种风格:继承(“is-a”关系)和包容/委托模型(“has-a”关系)。让我们从检查“是-a”关系的经典继承模型开始这一章。

当您在类之间建立“is-a”关系时，您正在构建两个或更多类类型之间的依赖关系。经典继承背后的基本思想是，可以使用现有的类作为起点来创建新的类。从一个简单的示例开始，创建一个名为基本继承的新控制台应用程序项目。现在假设你已经设计了一个名为`Car`的类，它模拟了汽车的一些基本细节。

`// A simple base class.`

`class Car`

`{`

`public readonly int maxSpeed;`

`private int currSpeed;`

`public Car(int max)`

`{`

`maxSpeed = max;`

`}`

`public Car()`

`{`

`maxSpeed = 55;`

`}`

`public int Speed`

`{`

`get { return currSpeed; }`

`set`

`{`

`currSpeed = value;`

`if (currSpeed > maxSpeed)`

`{`

`currSpeed = maxSpeed;`

`}`

`}`

`}`

`}`

注意，`Car`类使用封装服务来控制对私有`currSpeed`字段的访问，该字段使用一个名为`Speed`的公共属性。此时，你可以锻炼你的`Car`类型如下:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Basic Inheritance *****\n");`

`// Make a Car object and set max speed.`

`Car myCar = new Car(80);`

`// Set the current speed, and print it.`

`myCar.Speed = 50;`

`Console.WriteLine("My car is going {0} MPH", myCar.Speed);`

`Console.ReadLine();`

`}`

### 指定现有类的父类

现在假设您想要构建一个名为`MiniVan`的新类。像基本的`Car`一样，您希望定义`MiniVan`类来支持最大速度、当前速度和名为`Speed`的属性的数据，以允许对象用户修改对象的状态。显然，`Car`和`MiniVan`类是相关的；其实可以说 a `MiniVan`是`Car`的-a 型。“is-a”关系(正式术语为经典继承)允许您构建扩展现有类功能的新类定义。

将作为新类基础的现有类称为基类、超类或父类。基类的作用是为扩展它的类定义所有公共数据和成员。扩展类在形式上被称为派生类或子类。在 C#中，在类定义上使用冒号操作符来建立类之间的“is-a”关系。假设您已经编写了以下新的`MiniVan`类:

`// MiniVan "is-a" Car.`

`class MiniVan : Car`

`{`

`}`

目前，这个新类还没有定义任何成员。那么，从`Car`基类扩展`MiniVan`你得到了什么？简单地说，`MiniVan`对象现在可以访问父类中定义的每个公共成员。

Note

尽管构造函数通常被定义为公共的，但派生类从不继承父类的构造函数。构造函数仅用于构造定义它们的类。

给定这两个类类型之间的关系，您现在可以像这样使用`MiniVan`类:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Basic Inheritance *****\n");`

`...`

`// Now make a MiniVan object.`

`MiniVan myVan = new MiniVan();`

`myVan.Speed = 10;`

`Console.WriteLine("My van is going {0} MPH",`

`myVan.Speed);`

`Console.ReadLine();`

`}`

同样，请注意，尽管您没有向`MiniVan`类添加任何成员，但是您可以直接访问父类的公共`Speed`属性，因此可以重用代码。这比创建一个与`Car`有相同成员的`MiniVan`类，比如一个`Speed`属性，要好得多。如果您确实在这两个类之间复制了代码，那么您现在需要维护两个代码体，这无疑是对您时间的浪费。

永远记住，继承保持封装；因此，下面的代码会导致编译器错误，因为私有成员永远不能从对象引用中访问:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Basic Inheritance *****\n");`

`...`

`// Make a MiniVan object.`

`MiniVan myVan = new MiniVan();`

`myVan.Speed = 10;`

`Console.WriteLine("My van is going {0} MPH",`

`myVan.Speed);`

`// Error! Can’t access private members!`

`myVan.currSpeed = 55;`

`Console.ReadLine();`

`}`

与此相关，如果`MiniVan`定义了自己的成员集，它仍然不能访问`Car`基类的任何私有成员。记住，私有成员只能被定义它的类访问。例如，`MiniVan`中的以下方法会导致编译器错误:

`// MiniVan derives from Car.`

`class MiniVan : Car`

`{`

`public void TestMethod()`

`{`

`// OK! Can access public members`

`// of a parent within a derived type.`

`Speed = 10;`

`// Error! Cannot access private`

`// members of parent within a derived type.`

`currSpeed = 10;`

`}`

`}`

### 关于多个基类

说到基类，重要的是要记住 C#要求一个给定的类只有一个直接基类。不可能创建直接从两个或更多基类派生的类类型(这种技术在非托管 C++中受支持，称为多重继承，简称 MI)。如果您试图创建一个指定两个直接父类的类，如下面的代码所示，您将收到编译器错误:

`// Illegal! C# does not allow`

`// multiple inheritance for classes!`

`class WontWork`

`: BaseClassOne, BaseClassTwo`

`{}`

正如你将在第 8 章看到的。NET 平台确实允许给定的类或结构实现任意数量的离散接口。通过这种方式，C#类型可以展示许多行为，同时避免与 MI 相关的复杂性。另外，虽然一个类只能有一个直接基类，但是一个接口可以直接从多个接口派生。使用这种技术，你可以构建复杂的接口层次结构来模拟复杂的行为(同样，参见[第八章](08.html))。

### 密封的关键字

C#提供了另一个关键字`sealed`，它阻止了继承的发生。当你将一个类标记为`sealed`时，编译器不允许你从这个类型派生。例如，假设您已经决定进一步扩展`MiniVan`类是没有意义的。

`// The MiniVan class cannot be extended!`

`sealed class MiniVan : Car`

`{`

`}`

如果您(或您的队友)试图从这个类派生，您将会收到一个编译时错误。

`// Error! Cannot extend`

`// a class marked with the sealed keyword!`

`class DeluxeMiniVan`

`: MiniVan`

`{}`

大多数情况下，在设计实用程序类时，密封一个类是最有意义的。例如，`System`名称空间定义了许多密封的类。您可以通过打开 Visual Studio 对象浏览器(通过视图菜单)并在`mscorlib.dll`程序集的`System`命名空间中选择`String`类来验证这一点。注意图 [6-1](#Fig1) 中用于表示`sealed`等级的图标。

![A978-1-4842-1332-2_6_Fig1_HTML.jpg](img/A978-1-4842-1332-2_6_Fig1_HTML.jpg)

图 6-1。

The base class libraries define numerous sealed types, such as `System.String`

因此，就像`MiniVan`一样，如果您试图构建一个扩展了`System.String`的新类，您将会收到一个编译时错误。

`// Another error! Cannot extend`

`// a class marked as sealed!`

`class MyString`

`: String`

`{}`

Note

在第 4 章的[中，你了解到 C#结构总是隐式密封的(见表](04.html) [4-3](04.html#Tab3) )。因此，您永远不能从另一个结构派生一个结构，从一个结构派生一个类，或者从一个类派生一个结构。结构只能用于建模独立的、原子的、用户定义的数据类型。如果你想利用 is-a 关系，你必须使用类。

正如您所猜测的，在本章的剩余部分，您将会了解到更多关于继承的细节。现在，只要记住冒号操作符允许您建立基类/派生类关系，而`sealed`关键字防止后续继承发生。

## 修订 Visual Studio 类图

在[第 2 章](02.html)中，我简单提到了 Visual Studio 允许你在设计时可视化地建立基类/派生类关系。为了利用 IDE 的这一方面，第一步是在当前项目中包含一个新的类图文件。为此，访问项目➤添加新项菜单选项，并单击类图图标(在图 [6-2](#Fig2) ，我将文件从`ClassDiagram1.cd`重命名为`Cars.cd`)。

![A978-1-4842-1332-2_6_Fig2_HTML.jpg](img/A978-1-4842-1332-2_6_Fig2_HTML.jpg)

图 6-2。

Inserting a new class diagram

单击“添加”按钮后，您将看到一个空白的设计器图面。若要向类设计器添加类型，只需将每个文件从解决方案资源管理器窗口拖到图面上。还记得，如果您从可视化设计器中删除一个项(只需选择它并按 delete 键)，这不会破坏关联的源代码，而只是将该项从设计器图面中移除。图 [6-3](#Fig3) 显示了当前的等级结构。

![A978-1-4842-1332-2_6_Fig3_HTML.jpg](img/A978-1-4842-1332-2_6_Fig3_HTML.jpg)

图 6-3。

The visual designer of Visual Studio

除了简单地显示当前应用程序中类型的关系之外，回想一下第 2 章中的内容，您还可以使用类设计器工具箱和类细节窗口创建新类型并填充它们的成员。

如果您想在本书的剩余部分使用这些可视化工具，请随意。但是，一定要确保您分析了生成的代码，以便您对这些工具为您做了什么有一个坚实的理解。

Source Code

基本继承项目位于 [`Chapter 6`](06.html) 子目录下。

## OOP 的第二个支柱:继承的细节

既然您已经看到了继承的基本语法，让我们创建一个更复杂的例子，并了解构建类层次结构的众多细节。为此，你将重用你在第五章中设计的`Employee`类。首先，创建一个名为 Employees 的新 C#控制台应用程序项目。

接下来，激活项目➤添加现有项目菜单选项，并导航到您在第 5 章的[的 EmployeeApp 示例中创建的`Employee.cs`和`Employee.Core.cs`文件的位置。选择它们中的每一个(通过 Ctrl+单击),然后单击 Add 按钮。Visual Studio 的响应是将每个文件复制到当前项目中(因为这些是完整的副本，所以您无需担心更改您在](05.html)[第 5 章](05.html)项目中所做的原始工作)。

在开始构建一些派生类之前，有一个细节需要注意。因为最初的`Employee`类是在一个名为 EmployeeApp 的项目中创建的，所以该类被包装在一个同名的。NET 命名空间。[第十四章](14.html)将详细考察名称空间；然而，为了简单起见，将当前名称空间(在两个文件位置中)重命名为`Employees`,以匹配您的新项目名称。

`// Be sure to change the namespace name in both C# files!`

`namespace Employees`

`{`

`partial class Employee`

`{...}`

`}`

Note

作为健全性检查，通过按 Ctrl+F5 编译并运行您的新项目。程序此时不会做任何事情；但是，这将确保您没有任何编译器错误。

您的目标是创建一系列类来模拟公司中各种类型的员工。假设您想要利用`Employee`类的功能来创建两个新类(`SalesPerson`和`Manager`)。新的`SalesPerson`级“is-an”`Employee`(as is a`Manager`)。请记住，在经典继承模型下，基类(如`Employee`)用于定义所有后代共有的一般特征。子类(比如`SalesPerson`和`Manager`)扩展了这个通用功能，同时增加了更多的特定功能。

对于您的示例，您将假设`Manager`类通过记录股票期权的数量来扩展`Employee`，而`SalesPerson`类维护销售的数量。插入一个新的类文件(`Manager.cs`)，该文件用以下自动属性定义了`Manager`类:

`// Managers need to know their number of stock options.`

`class Manager : Employee`

`{`

`public int StockOptions { get; set; }`

`}`

接下来，添加另一个新的类文件(`SalesPerson.cs`)，该文件使用拟合自动属性定义了`SalesPerson`类。

`// Salespeople need to know their number of sales.`

`class SalesPerson : Employee`

`{`

`public int SalesNumber { get; set; }`

`}`

既然已经建立了“是-a”关系，`SalesPerson`和`Manager`已经自动继承了`Employee`基类的所有公共成员。举例来说，更新您的`Main()`方法如下:

`// Create a subclass object and access base class functionality.`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** The Employee Class Hierarchy *****\n");`

`SalesPerson fred = new SalesPerson();`

`fred.Age = 31;`

`fred.Name = "Fred";`

`fred.SalesNumber = 50;`

`Console.ReadLine();`

`}`

### 用 Base 关键字控制基类创建

目前，`SalesPerson`和`Manager`只能使用“免费”的默认构造函数创建(见[第五章](05.html))。记住这一点，假设您已经向`Manager`类型添加了一个新的六参数构造函数，调用如下:

`static void Main(string[] args)`

`{`

`...`

`// Assume Manager has a constructor matching this signature:`

`// (string fullName, int age, int empID,`

`// float currPay, string ssn, int numbOfOpts)`

`Manager chucky = new Manager("Chucky", 50, 92, 100000, "333-23-2322", 9000);`

`Console.ReadLine();`

`}`

如果你看一下参数列表，你可以清楚地看到这些参数大部分应该存储在由`Employee`基类定义的成员变量中。为此，您可以在`Manager`类上实现这个自定义构造函数，如下所示:

`public Manager(string fullName, int age, int empID,`

`float currPay, string ssn, int numbOfOpts)`

`{`

`// This property is defined by the Manager class.`

`StockOptions = numbOfOpts;`

`// Assign incoming parameters using the`

`// inherited properties of the parent class.`

`ID = empID;`

`Age = age;`

`Name = fullName;`

`Pay = currPay;`

`// OOPS! This would be a compiler error,`

`// if the SSN property were read-only!`

`SocialSecurityNumber = ssn;`

`}`

这种方法的第一个问题是，如果您将任何属性定义为只读(例如，`SocialSecurityNumber`属性)，您就不能将传入的`string`参数赋给这个字段，如这个自定义构造函数的最终代码语句所示。

第二个问题是，你已经间接地创建了一个相当低效的构造函数，假设在 C#下，除非你另有说明，否则基类的默认构造函数是在派生构造函数的逻辑被执行之前自动调用的。在这之后，当前的实现访问`Employee`基类的许多公共属性来建立它的状态。因此，在创建一个`Manager`对象的过程中，您实际上已经点击了七次(五个继承属性和两个构造函数调用)!

为了帮助优化派生类的创建，最好实现子类构造函数来显式调用适当的自定义基类构造函数，而不是默认构造函数。这样，您就能够减少对继承的初始化成员的调用次数(从而节省处理时间)。首先，确保您的`Employee`父类具有以下五个参数的构造函数:

`// Add to the Employee base class.`

`public Employee(string name, int age, int id, float pay, string ssn)   :this(name, age, id, pay)`

`{`

`empSSN = ssn;`

`}`

现在，让我们改造一下`Manager`类型的定制构造函数，使用`base`关键字来做这件事。

`public Manager(string fullName, int age, int empID,`

`float currPay, string ssn, int numbOfOpts)`

`: base(fullName, age, empID, currPay, ssn)`

`{`

`// This property is defined by the Manager class.`

`StockOptions = numbOfOpts;`

`}`

这里，`base`关键字挂在构造函数签名上(很像使用`this`关键字链接单个类上的构造函数的语法，正如在[第 5 章](05.html)中讨论的)，它总是指示派生构造函数正在将数据传递给直接的父构造函数。在这种情况下，您显式地调用了由`Employee`定义的五参数构造函数，并在创建子类的过程中节省了不必要的调用。定制的`SalesPerson`构造函数看起来几乎是一样的。

`// As a general rule, all subclasses should explicitly call an appropriate`

`// base class constructor.`

`public SalesPerson(string fullName, int age, int empID,`

`float currPay, string ssn, int numbOfSales)`

`: base(fullName, age, empID, currPay, ssn)`

`{`

`// This belongs with us!`

`SalesNumber = numbOfSales;`

`}`

Note

每当子类想要访问由父类定义的公共或受保护成员时，可以使用`base`关键字。此关键字的使用不限于构造函数逻辑。在本章后面的多态性检查中，你会看到以这种方式使用`base`的例子。

最后，回想一下，一旦您将自定义构造函数添加到类定义中，默认构造函数就会被自动移除。因此，一定要为`SalesPerson`和`Manager`类型重新定义默认构造函数。这里有一个例子:

`// Add back the default ctor`

`// in the Manager class as well.`

`public SalesPerson() {}`

### 保守家庭秘密:受保护的关键字

正如您已经知道的，公共项可以从任何地方直接访问，而私有项只能由定义它们的类访问。回想一下第五章中，C#领先于许多其他现代对象语言，并提供了一个额外的关键字来定义成员可访问性:`protected`。

当基类定义受保护的数据或受保护的成员时，它建立了一组可以被任何后代直接访问的项。如果你想让`SalesPerson`和`Manager`子类直接访问由`Employee`定义的数据扇区，你可以如下更新原来的`Employee`类定义:

`// Protected state data.`

`partial class Employee`

`{`

`// Derived classes can now directly access this information.`

`protected string empName;`

`protected int empID;`

`protected float currPay;`

`protected int empAge;`

`protected string empSSN;`

`...`

`}`

在基类中定义受保护成员的好处是，派生类型不再需要使用公共方法或属性间接访问数据。当然，可能的问题是，当派生类型可以直接访问其父类型的内部数据时，就有可能意外地绕过公共属性中的现有业务规则。当您定义受保护成员时，您在父类和子类之间创建了一个信任级别，因为编译器不会捕捉到任何违反您的类型的业务规则的情况。

最后，请理解，就对象用户而言，受保护的数据被视为私有数据(因为用户“不属于”家庭)。因此，以下行为是非法的:

`static void Main(string[] args)`

`{`

`// Error! Can’t access protected data from client code.`

`Employee emp = new Employee();`

`emp.empName = "Fred";`

`}`

Note

虽然`protected`字段数据可以打破封装，但是定义`protected`方法是非常安全的(也是非常有用的)。在构建类层次结构时，通常定义一组只供派生类型使用的方法，而不是供外界使用的方法。

### 添加密封类

回想一下，密封类不能被其他类扩展。如上所述，这种技术最常用于设计实用程序类。然而，当构建类层次结构时，您可能会发现继承链中的某个分支应该被“封顶”，因为进一步扩展 linage 是没有意义的。例如，假设您已经向您的程序(`PTSalesPerson`)添加了另一个类，它扩展了现有的`SalesPerson`类型。图 [6-4](#Fig4) 显示了当前的更新。

![A978-1-4842-1332-2_6_Fig4_HTML.jpg](img/A978-1-4842-1332-2_6_Fig4_HTML.jpg)

图 6-4。

The `PTSalesPerson` class

是一个代表兼职销售人员的类。为了便于讨论，假设您希望确保没有其他开发人员能够从`PTSalesPerson`继承子类。(毕竟兼职能比“兼职”多拿多少钱？)同样，为了防止其他人扩展一个类，使用`sealed`关键字。

`sealed class PTSalesPerson : SalesPerson`

`{`

`public PTSalesPerson(string fullName, int age, int empID,`

`float currPay, string ssn, int numbOfSales)`

`:base (fullName, age, empID, currPay, ssn, numbOfSales)`

`{`

`}`

`// Assume other members here...`

`}`

## 包容/委托的编程

回想一下，代码重用有两种形式。你刚刚探索了经典的“是”的关系。在研究 OOP 的第三个支柱(多态性)之前，让我们先研究一下“has-a”关系(也称为包含/委托模型或聚合)。假设您已经创建了一个模拟员工福利包的新类，如下所示:

`// This new type will function as a contained class.`

`class BenefitPackage`

`{`

`// Assume we have other members that represent`

`// dental/health benefits, and so on.`

`public double ComputePayDeduction()`

`{`

`return 125.0;`

`}`

`}`

显然，在`BenefitPackage`类和雇员类型之间建立“is-a”关系是很奇怪的。(`Employee`“is-a”`BenefitPackage`？我不这么认为。)然而，应该清楚的是，可以在两者之间建立某种关系。简而言之，你想表达的想法是，每个员工都“有-a”`BenefitPackage`。为此，您可以如下更新`Employee`类定义:

`// Employees now have benefits.`

`partial class Employee`

`{`

`// Contain a BenefitPackage object.`

`protected BenefitPackage empBenefits = new BenefitPackage();`

`...`

`}`

至此，您已经成功地包含了另一个对象。但是，向外界公开所包含对象的功能需要委托。委托只是将公共成员添加到使用被包含对象功能的包含类的行为。

例如，您可以更新`Employee`类，使用自定义属性公开包含的`empBenefits`对象，并使用名为`GetBenefitCost()`的新方法在内部使用其功能。

`partial class Employee`

`{`

`// Contain a BenefitPackage object.`

`protected BenefitPackage empBenefits = new BenefitPackage();`

`// Expose certain benefit behaviors of object.`

`public double GetBenefitCost()`

`{ return empBenefits.ComputePayDeduction(); }`

`// Expose object through a custom property.`

`public BenefitPackage Benefits`

`{`

`get { return empBenefits; }`

`set { empBenefits = value; }`

`}`

`...`

`}`

在下面更新的`Main()`方法中，注意如何与由`Employee`类型定义的内部`BenefitsPackage`类型交互。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** The Employee Class Hierarchy *****\n");`

`...`

`Manager chucky = new Manager("Chucky", 50, 92, 100000, "333-23-2322", 9000);`

`double cost = chucky.GetBenefitCost();`

`Console.ReadLine();`

`}`

### 了解嵌套类型定义

[第 5 章](05.html)简单提到了嵌套类型的概念，这是对你刚刚检查过的“has-a”关系的一个旋转。在 C#(以及其他。NET 语言)，可以直接在类或结构的范围内定义类型(枚举、类、接口、结构或委托)。当您这样做时，嵌套(或“内部”)类型被视为嵌套(或“外部”)类的成员，并且在运行时看来，可以像任何其他成员(字段、属性、方法和事件)一样进行操作。用于嵌套类型的语法非常简单。

`public class OuterClass`

`{`

`// A public nested type can be used by anybody.`

`public class PublicInnerClass {}`

`// A private nested type can only be used by members`

`// of the containing class.`

`private class PrivateInnerClass {}`

`}`

尽管语法相当清楚，但理解您为什么想要这样做可能并不容易。要理解这种技术，请思考嵌套类型的以下特征:

*   嵌套类型允许您完全控制内部类型的访问级别，因为它们可以被私有声明(回想一下，非嵌套类不能使用`private`关键字声明)。
*   因为嵌套类型是包含类的成员，所以它可以访问包含类的私有成员。
*   通常，嵌套类型只在作为外部类的助手时有用，并不打算供外部世界使用。

当一个类型嵌套另一个类类型时，它可以创建该类型的成员变量，就像对任何数据点一样。但是，如果要使用包含类型之外的嵌套类型，必须用嵌套类型的范围来限定它。考虑以下代码:

`static void Main(string[] args)`

`{`

`// Create and use the public inner class. OK!`

`OuterClass.PublicInnerClass inner;`

`inner = new OuterClass.PublicInnerClass();`

`// Compiler Error! Cannot access the private class.`

`OuterClass.PrivateInnerClass inner2;`

`inner2 = new OuterClass.PrivateInnerClass();`

`}`

为了在 employees 示例中使用这个概念，假设您现在已经将`BenefitPackage`直接嵌套在了`Employee`类类型中。

`partial class Employee`

`{`

`public class BenefitPackage`

`{`

`// Assume we have other members that represent`

`// dental/health benefits, and so on.`

`public double ComputePayDeduction()`

`{`

`return 125.0;`

`}`

`}`

`...`

`}`

嵌套过程可以像你要求的那样“深”。例如，假设您想要创建一个名为`BenefitPackageLevel`的枚举，它记录了员工可能选择的各种福利级别。为了以编程方式强制`Employee`、`BenefitPackage`和`BenefitPackageLevel`之间的紧密连接，可以如下嵌套枚举:

`// Employee nests BenefitPackage.`

`public partial class Employee`

`{`

`// BenefitPackage nests BenefitPackageLevel.`

`public class BenefitPackage`

`{`

`public enum BenefitPackageLevel`

`{`

`Standard, Gold, Platinum`

`}`

`public double ComputePayDeduction()`

`{`

`return 125.0;`

`}`

`}`

`...`

`}`

由于嵌套关系，请注意如何要求您使用此枚举:

`static void Main(string[] args)`

`{`

`...`

`// Define my benefit level.`

`Employee.BenefitPackage.BenefitPackageLevel myBenefitLevel =`

`Employee.BenefitPackage.BenefitPackageLevel.Platinum;`

`Console.ReadLine();`

`}`

太棒了！至此，您已经接触了许多关键字(和概念)，它们允许您通过传统的继承、包容和嵌套类型来构建相关类型的层次结构。如果细节现在还不清楚，不要担心。在本书的剩余部分，您将构建一些额外的层次结构。接下来，让我们检查 OOP 的最后一个支柱:多态性。

## OOP 的第三个支柱:C#的多态支持

回想一下，`Employee`基类定义了一个名为`GiveBonus()`的方法，最初实现如下:

`public partial class Employee`

`{`

`public void GiveBonus(float amount)`

`{`

`Pay += amount;`

`}`

`...`

`}`

因为这个方法是用`public`关键字定义的，所以现在可以给销售人员和经理(以及兼职销售人员)发放奖金。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** The Employee Class Hierarchy *****\n");`

`// Give each employee a bonus?`

`Manager chucky = new Manager("Chucky", 50, 92, 100000, "333-23-2322", 9000);`

`chucky.GiveBonus(300);`

`chucky.DisplayStats();`

`Console.WriteLine();`

`SalesPerson fran = new SalesPerson("Fran", 43, 93, 3000, "932-32-3232", 31);`

`fran.GiveBonus(200);`

`fran.DisplayStats();`

`Console.ReadLine();`

`}`

当前设计的问题是，公共继承的`GiveBonus()`方法对所有子类的操作都是一样的。理想情况下，销售人员或兼职销售人员的奖金应该考虑销售数量。或许经理们应该获得额外的股票期权，同时增加工资。考虑到这一点，您突然面临一个有趣的问题:“相关类型如何对同一请求做出不同的响应？”再次，很高兴你问了！

### 虚拟和覆盖关键字

多态性为子类提供了一种方式来定义其基类定义的方法的自己的版本，使用称为方法覆盖的过程。要改进您当前的设计，您需要理解`virtual`和`override`关键字的含义。如果一个基类想要定义一个可能(但不是必须)被子类覆盖的方法，它必须用`virtual`关键字标记这个方法。

`partial class Employee`

`{`

`// This method can now be "overridden" by a derived class.`

`public virtual void GiveBonus(float amount)`

`{`

`Pay += amount;`

`}`

`...`

`}`

Note

用关键字`virtual`标记的方法被称为虚方法(这并不奇怪)。

当子类想要改变虚拟方法的实现细节时，它使用关键字`override`来实现。例如，`SalesPerson`和`Manager`可以如下覆盖`GiveBonus()`(假设`PTSalesPerson`不会覆盖`GiveBonus()`，因此，简单地继承由`SalesPerson`定义的版本):

`class SalesPerson : Employee`

`{`

`...`

`// A salesperson’s bonus is influenced by the number of sales.`

`public override void GiveBonus(float amount)`

`{`

`int salesBonus = 0;`

`if (SalesNumber >= 0 && SalesNumber <= 100)`

`salesBonus = 10;`

`else`

`{`

`if (SalesNumber >= 101 && SalesNumber <= 200)`

`salesBonus = 15;`

`else`

`salesBonus = 20;`

`}`

`base.GiveBonus(amount * salesBonus);`

`}`

`}`

`class Manager : Employee`

`{`

`...`

`public override void GiveBonus(float amount)`

`{`

`base.GiveBonus(amount);`

`Random r = new Random();`

`StockOptions += r.Next(500);`

`}`

`}`

注意每个被覆盖的方法是如何使用`base`关键字自由利用默认行为的。

这样，您不需要完全重新实现`GiveBonus()`背后的逻辑，而是可以重用(并且可能扩展)父类的默认行为。

还假设`Employee`类的当前`DisplayStats()`方法已经被虚拟声明。

`public virtual void DisplayStats()`

`{`

`Console.WriteLine("Name: {0}", Name);`

`Console.WriteLine("ID: {0}", ID);`

`Console.WriteLine("Age: {0}", Age);`

`Console.WriteLine("Pay: {0}", Pay);`

`Console.WriteLine("SSN: {0}", SocialSecurityNumber);`

`}`

通过这样做，每个子类都可以覆盖这个方法来显示销售额(对于销售人员)和当前股票期权(对于经理)。例如，考虑一下`Manager`版本的`DisplayStats()`方法(`SalesPerson`类将以类似的方式实现`DisplayStats()`来显示销售额)。

`public override void DisplayStats()`

`{`

`base.DisplayStats();`

`Console.WriteLine("Number of Stock Options: {0}", StockOptions);`

`}`

现在每个子类都可以解释这些虚方法对自己的意义，每个对象实例都表现为一个更加独立的实体。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** The Employee Class Hierarchy *****\n");`

`// A better bonus system!`

`Manager chucky = new Manager("Chucky", 50, 92, 100000, "333-23-2322", 9000);`

`chucky.GiveBonus(300);`

`chucky.DisplayStats();`

`Console.WriteLine();`

`SalesPerson fran = new SalesPerson("Fran", 43, 93, 3000, "932-32-3232", 31);`

`fran.GiveBonus(200);`

`fran.DisplayStats();`

`Console.ReadLine();`

`}`

以下输出显示了到目前为止您的应用程序可能的测试运行:

`***** The Employee Class Hierarchy *****`

`Name: Chucky`

`ID: 92`

`Age: 50`

`Pay: 100300`

`SSN: 333-23-2322`

`Number of Stock Options: 9337`

`Name: Fran`

`ID: 93`

`Age: 43`

`Pay: 5000`

`SSN: 932-32-3232`

`Number of Sales: 31`

### 使用 Visual Studio IDE 重写虚拟成员

您可能已经注意到，当您重写一个成员时，您必须回忆每个参数的类型——更不用说方法名和参数传递约定(`ref`、`out`和`params`)。Visual Studio 有一个有用的功能，您可以在重写虚拟成员时利用它。如果你在一个类类型的范围内键入单词`override`(然后按空格键)，智能感知将自动显示在你的父类中定义的所有可重写成员的列表，如图 [6-5](#Fig5) 所示。

![A978-1-4842-1332-2_6_Fig5_HTML.jpg](img/A978-1-4842-1332-2_6_Fig5_HTML.jpg)

图 6-5。

Quickly viewing overridable methods à la Visual Studio

当您选择一个成员并按下 Enter 键时，IDE 会自动为您填充方法存根。请注意，您还会收到一条代码语句，该语句调用您的父版本的虚拟成员(如果不需要，您可以随意删除这一行)。例如，如果您在重写`DisplayStats()`方法时使用了这种技术，您可能会发现以下自动生成的代码:

`public override void DisplayStats()`

`{`

`base.DisplayStats();`

`}`

### 密封虚拟成员

回想一下，`sealed`关键字可以应用于一个类类型，以防止其他类型通过继承来扩展它的行为。您可能还记得，您密封了`PTSalesPerson`,因为您认为其他开发人员进一步扩展这条继承线是没有意义的。

另一方面，有时您可能不想密封整个类，而只想防止派生类型重写特定的虚方法。例如，假设您不希望兼职销售人员获得定制的奖金。为了防止`PTSalesPerson`类覆盖虚拟的`GiveBonus()`方法，您可以有效地将该方法密封在`SalesPerson`类中，如下所示:

`// SalesPerson has sealed the GiveBonus() method!`

`class SalesPerson : Employee`

`{`

`...`

`public override sealed void GiveBonus(float amount)`

`{`

`...`

`}`

`}`

这里，`SalesPerson`确实覆盖了在`Employee`类中定义的虚拟`GiveBonus()`方法；但是，它已经明确标记为密封。因此，如果您试图在`PTSalesPerson`类中覆盖此方法，您将会收到编译时错误，如以下代码所示:

`sealed class PTSalesPerson : SalesPerson`

`{`

`public PTSalesPerson(string fullName, int age, int empID,`

`float currPay, string ssn, int numbOfSales)`

`:base (fullName, age, empID, currPay, ssn, numbOfSales)`

`{`

`}`

`// Compiler error! Can’t override this method`

`// in the PTSalesPerson class, as it was sealed.`

`public override void GiveBonus(float amount)`

`{`

`}`

`}`

### 理解抽象类

目前，`Employee`基类已经被设计为向它的后代提供各种数据成员，以及提供两个可能被给定后代覆盖的虚方法(`GiveBonus()`和`DisplayStats()`)。虽然这一切都很好，但目前的设计有一个相当奇怪的副产品；您可以直接创建`Employee`基类的实例。

`// What exactly does this mean?`

`Employee X = new Employee();`

在这个例子中，`Employee`基类的唯一真正目的是为所有子类定义公共成员。十有八九，你不希望任何人创建这个类的直接实例，原因是`Employee`类型本身是一个过于一般化的概念。例如，如果我走到你面前说，“我是一名员工！”我敢打赌，你问我的第一个问题会是，“你是哪种类型的员工？”你是顾问、培训师、行政助理、文字编辑还是白宫助理？

鉴于许多基类往往是相当模糊的实体，对于这个例子来说，更好的设计是防止在代码中直接创建新的`Employee`对象。在 C#中，您可以通过在类定义中使用`abstract`关键字以编程方式强制实现这一点，从而创建一个抽象基类。

`// Update the Employee class as abstract`

`// to prevent direct instantiation.`

`abstract partial class Employee`

`{`

`...`

`}`

这样，如果您现在试图创建一个`Employee`类的实例，就会出现一个编译时错误。

`// Error! Cannot create an instance of an abstract class!`

`Employee X = new Employee();`

乍一看，定义一个不能直接创建实例的类似乎很奇怪。然而，回想一下，基类(抽象或非抽象)是有用的，因为它们包含了派生类型的所有公共数据和功能。使用这种形式的抽象，你能够模拟一个雇员的“想法”是完全有效的；它只是不是一个具体的实体。还要明白，虽然不能直接创建抽象类的实例，但在创建派生类时，它仍然会在内存中进行组装。因此，当分配派生类时，抽象类定义任意数量的被间接调用的构造函数是非常好的(也是常见的)。

至此，您已经构建了一个相当有趣的员工层次结构。在本章的后面，当你研究 C#转换规则的时候，你会给这个应用程序添加更多的功能。在此之前，图 [6-6](#Fig6) 说明了您当前设计的症结所在。

![A978-1-4842-1332-2_6_Fig6_HTML.jpg](img/A978-1-4842-1332-2_6_Fig6_HTML.jpg)

图 6-6。

The Employee hierarchy Source Code

Employees 项目包含在 [`Chapter 6`](06.html) 子目录中。

### 理解多态接口

当一个类被定义为抽象基类时(通过`abstract`关键字)，它可以定义任意数量的抽象成员。当您想要定义一个不提供默认实现但必须由每个派生类负责的成员时，可以使用抽象成员。通过这样做，您在每个后代上实施了一个多态接口，让他们去处理提供抽象方法背后的细节的任务。

简单来说，抽象基类的多态接口只是指它的一组虚拟和抽象方法。这比第一眼看到的要有趣得多，因为 OOP 的这一特性允许您构建易于扩展和灵活的软件应用程序。举例来说，在 OOP 的支柱概述中，你将实现(并稍微修改)在第 5 章中简要讨论过的形状层次。首先，创建一个名为 Shapes 的新 C#控制台应用程序项目。

在图 [6-7](#Fig7) 中，注意到`Hexagon`和`Circle`类型都扩展了`Shape`基类。像任何基类一样，`Shape`定义了许多成员(在本例中是一个`PetName`属性和一个`Draw()`方法)，这些成员是所有后代共有的。

![A978-1-4842-1332-2_6_Fig7_HTML.jpg](img/A978-1-4842-1332-2_6_Fig7_HTML.jpg)

图 6-7。

The shapes hierarchy

与雇员层次结构非常相似，您应该能够判断出您不希望允许对象用户直接创建`Shape`的实例，因为它是一个太抽象的概念。同样，为了防止直接创建`Shape`类型，您可以将其定义为一个抽象类。同样，假设您希望派生类型唯一地响应`Draw()`方法，让我们将其标记为`virtual`并定义一个默认实现。

`// The abstract base class of the hierarchy.`

`abstract class Shape`

`{`

`public Shape(string name = "NoName")`

`{ PetName = name; }`

`public string PetName { get; set; }`

`// A single virtual method.`

`public virtual void Draw()`

`{`

`Console.WriteLine("Inside Shape.Draw()");`

`}`

`}`

注意，虚拟的`Draw()`方法提供了一个默认的实现，它只是打印出一条消息，通知您正在调用`Shape`基类中的`Draw()`方法。现在回想一下，当一个方法用`virtual`关键字标记时，该方法提供了一个所有派生类型自动继承的默认实现。如果子类选择这样做，它可以重写方法，但不是必须这样做。鉴于此，考虑下面的`Circle`和`Hexagon`类型的实现:

`// Circle DOES NOT override Draw().`

`class Circle : Shape`

`{`

`public Circle() {}`

`public Circle(string name) : base(name){}`

`}`

`// Hexagon DOES override Draw().`

`class Hexagon : Shape`

`{`

`public Hexagon() {}`

`public Hexagon(string name) : base(name){}`

`public override void Draw()`

`{`

`Console.WriteLine("Drawing {0} the Hexagon", PetName);`

`}`

`}`

当你再次记住子类从来不需要覆盖虚方法时，抽象方法的用处就变得非常清楚了(就像在`Circle`的情况中)。因此，如果您创建一个`Hexagon`和`Circle`类型的实例，您会发现`Hexagon`知道如何正确地“绘制”自己，或者至少向控制台输出一条适当的消息。然而，`Circle`却不止是有点困惑。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Polymorphism *****\n");`

`Hexagon hex = new Hexagon("Beth");`

`hex.Draw();`

`Circle cir = new Circle("Cindy");`

`// Calls base class implementation!`

`cir.Draw();`

`Console.ReadLine();`

`}`

现在考虑前面的`Main()`方法的以下输出:

`***** Fun with Polymorphism *****`

`Drawing Beth the Hexagon`

`Inside Shape.Draw()`

很明显，对于当前的等级制度来说，这不是一个明智的设计。为了强制每个子类覆盖`Draw()`方法，您可以将`Draw()`定义为`Shape`类的一个抽象方法，根据定义，这意味着您不提供任何默认实现。在 C#中，要将一个方法标记为抽象的，可以使用`abstract`关键字。请注意，抽象成员不提供任何实现。

`abstract class Shape`

`{`

`// Force all child classes to define how to be rendered.`

`public abstract void Draw();`

`...`

`}`

Note

抽象方法只能在抽象类中定义。如果您尝试不这样做，您将被发出一个编译器错误。

标有`abstract`的方法是纯协议。它们只是定义名称、返回类型(如果有的话)和参数集(如果需要的话)。这里，抽象的`Shape`类通知派生的类型“我有一个名为`Draw()`的方法，它没有参数，也不返回任何东西。如果你从我这里得到，你就能弄清楚细节。”

鉴于此，您现在有义务在`Circle`类中覆盖`Draw()`方法。如果不这样做，`Circle`也被认为是一个不可创建的抽象类型，必须用`abstract`关键字来修饰(这在本例中显然没有用)。下面是代码更新:

`// If we did not implement the abstract Draw() method, Circle would also be`

`// considered abstract, and would have to be marked abstract!`

`class Circle : Shape`

`{`

`public Circle() {}`

`public Circle(string name) : base(name) {}`

`public override void Draw()`

`{`

`Console.WriteLine("Drawing {0} the Circle", PetName);`

`}`

`}`

简而言之，你现在可以假设从`Shape`派生的任何东西确实有一个唯一版本的`Draw()`方法。为了说明多态性的全部情况，考虑下面的代码:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Polymorphism *****\n");`

`// Make an array of Shape-compatible objects.`

`Shape[] myShapes = {new Hexagon(), new Circle(), new Hexagon("Mick"),`

`new Circle("Beth"), new Hexagon("Linda")};`

`// Loop over each item and interact with the`

`// polymorphic interface.`

`foreach (Shape s in myShapes)`

`{`

`s.Draw();`

`}`

`Console.ReadLine();`

`}`

下面是修改后的`Main()`方法的输出:

`***** Fun with Polymorphism *****`

`Drawing NoName the Hexagon`

`Drawing NoName the Circle`

`Drawing Mick the Hexagon`

`Drawing Beth the Circle`

`Drawing Linda the Hexagon`

这个`Main()`方法最好地说明了多态性。尽管不可能直接创建一个抽象基类的实例(即`Shape`)，但是您可以自由地存储对任何具有抽象基类变量的子类的引用。因此，当您创建一个由`Shape`组成的数组时，该数组可以保存从`Shape`基类派生的任何对象(如果您试图将与`Shape`不兼容的对象放入该数组，您会收到一个编译器错误)。

鉴于`myShapes`数组中的所有元素确实都是从`Shape`派生的，你知道它们都支持相同的“多态接口”(或者更直白地说，它们都有一个`Draw()`方法)。当您迭代`Shape`引用的数组时，底层类型是在运行时确定的。此时，内存中调用了正确版本的`Draw()`方法。

这种技术也使得安全地扩展当前层次变得简单。例如，假设您从抽象的`Shape`基类(`Triangle`、`Square`等)派生了更多的类。).由于多态接口，您的`foreach`循环中的代码不需要做任何改动，因为编译器强制要求只有与`Shape`兼容的类型才放在`myShapes`数组中。

### 了解成员隐藏

C#提供了一个与方法重写逻辑相反的功能，称为隐藏。从形式上讲，如果一个派生类定义了一个与基类中定义的成员相同的成员，那么派生类就隐藏了父类的版本。在现实世界中，当你从一个不是你(或你的团队)自己创建的类中创建子类时(比如当你购买第三方时)，这种情况发生的可能性是最大的。NET 软件包)。

为了便于说明，假设您从同事(或同学)那里收到一个名为`ThreeDCircle`的类，该类定义了一个名为`Draw()`的不带参数的子例程。

`class ThreeDCircle`

`{`

`public void Draw()`

`{`

`Console.WriteLine("Drawing a 3D Circle");`

`}`

`}`

你认为 a `ThreeDCircle`是-a`Circle`，所以你从你现有的`Circle`类型中派生出来。

`class ThreeDCircle : Circle`

`{`

`public void Draw()`

`{`

`Console.WriteLine("Drawing a 3D Circle");`

`}`

`}`

重新编译后，您会发现以下警告:

`’ThreeDCircle.Draw()’ hides inherited member ’Circle.Draw()’. To make the`

`current member override that implementation, add the override keyword. Otherwise add the new keyword.`

问题是您有一个派生类(`ThreeDCircle`)，它包含一个与继承方法相同的方法。要解决这个问题，您有几个选择。您可以简单地使用`override`关键字更新`Draw()`的父版本(正如编译器所建议的)。使用这种方法，`ThreeDCircle`类型能够根据需要扩展父类的默认行为。然而，如果您没有访问定义基类的代码的权限(这也是许多第三方库中的情况)，您将无法作为虚拟成员修改`Draw()`方法，因为您没有访问代码文件的权限！

作为一种选择，您可以将`new`关键字包含到派生类型的违规`Draw()`成员中(在本例中为`ThreeDCircle`)。这样做显式地声明了派生类型的实现被有意地设计为有效地忽略父类型的版本(同样，在现实世界中，如果是外部的，这可能是有帮助的。NET 软件不知何故和你现在的软件冲突)。

`// This class extends Circle and hides the inherited Draw() method.`

`class ThreeDCircle : Circle`

`{`

`// Hide any Draw() implementation above me.`

`public new void Draw()`

`{`

`Console.WriteLine("Drawing a 3D Circle");`

`}`

`}`

还可以将`new`关键字应用于从基类继承的任何成员类型(字段、常量、静态成员或属性)。作为进一步的例子，假设`ThreeDCircle`想要隐藏继承的`PetName`属性。

`class ThreeDCircle : Circle`

`{`

`// Hide the PetName property above me.`

`public new string PetName { get; set; }`

`// Hide any Draw() implementation above me.`

`public new void Draw()`

`{`

`Console.WriteLine("Drawing a 3D Circle");`

`}`

`}`

最后，请注意，仍有可能使用显式强制转换来触发被隐藏成员的基类实现，如下一节所述。例如，下面的代码显示:

`static void Main(string[] args)`

`{`

`...`

`// This calls the Draw() method of the ThreeDCircle.`

`ThreeDCircle o = new ThreeDCircle();`

`o.Draw();`

`// This calls the Draw() method of the parent!`

`((Circle)o).Draw();`

`Console.ReadLine();`

`}`

Source Code

形状项目可以在 [`Chapter 6`](06.html) 子目录中找到。

## 了解基类/派生类转换规则

既然您可以构建一系列相关的类类型，那么您需要学习类转换操作的规则。为此，让我们返回到本章前面创建的 Employees 层次结构，并向`Program`类添加一些新方法(如果您是一个人，请在 Visual Studio 中打开 Employee 项目)。如本章最后一节所述，系统中的最终基类是`System.Object`。因此，`Object`一切事物都“是-个”并能被如此对待。鉴于这一事实，在对象变量中存储任何类型的实例都是合法的。

`static void CastingExamples()`

`{`

`// A Manager "is-a" System.Object, so we can`

`// store a Manager reference in an object variable just fine.`

`object frank = new Manager("Frank Zappa", 9, 3000, 40000, "111-11-1111", 5);`

`}`

在`Employees`示例中，`Managers`、`SalesPerson`和`PTSalesPerson`类型都扩展了`Employee`，因此您可以将这些对象中的任何一个存储在有效的基类引用中。因此，下列语句也是合法的:

`static void CastingExamples()`

`{`

`// A Manager "is-a" System.Object, so we can`

`// store a Manager reference in an object variable just fine.`

`object frank = new Manager("Frank Zappa", 9, 3000, 40000, "111-11-1111", 5);`

`// A Manager "is-an" Employee too.`

`Employee moonUnit = new Manager("MoonUnit Zappa", 2, 3001, 20000, "101-11-1321", 1);`

`// A PTSalesPerson "is-a" SalesPerson.`

`SalesPerson jill = new PTSalesPerson("Jill", 834, 3002, 100000, "111-12-1119", 90);`

`}`

类类型之间转换的第一条法则是，当两个类通过“is-a”关系相关联时，将派生对象存储在基类引用中总是安全的。从形式上来说，这被称为隐式强制转换，因为根据遗传法则“它只是工作”。这导致了一些强大的编程结构。例如，假设您已经在当前的`Program`类中定义了一个新方法。

`static void GivePromotion(Employee emp)`

`{`

`// Increase pay...`

`// Give new parking space in company garage...`

`Console.WriteLine("{0} was promoted!", emp.Name);`

`}`

因为这个方法只接受一个类型为`Employee`的参数，考虑到“is-a”关系，您可以有效地将来自`Employee`类的任何后代直接传递给这个方法。

`static void CastingExamples()`

`{`

`// A Manager "is-a" System.Object, so we can`

`// store a Manager reference in an object variable just fine.`

`object frank = new Manager("Frank Zappa", 9, 3000, 40000, "111-11-1111", 5);`

`// A Manager "is-an" Employee too.`

`Employee moonUnit = new Manager("MoonUnit Zappa", 2, 3001, 20000, "101-11-1321", 1);`

`GivePromotion(moonUnit);`

`// A PTSalesPerson "is-a" SalesPerson.`

`SalesPerson jill = new PTSalesPerson("Jill", 834, 3002, 100000, "111-12-1119", 90);`

`GivePromotion(jill);`

`}`

给定从基类类型(`Employee`)到派生类型的隐式转换，前面的代码进行编译。但是，如果您也想解雇弗兰克·扎帕(目前存储在一个通用的`System.Object`引用中)，该怎么办呢？如果您将`frank`对象直接传递给这个方法，您会发现如下编译器错误:

`object frank = new Manager("Frank Zappa", 9, 3000, 40000, "111-11-1111", 5);`

`// Error!`

`GivePromotion(frank);`

问题是你试图传入一个没有被声明为`Employee`而是更一般的`System.Object`的变量。考虑到`object`比`Employee`在继承链中处于更高的位置，编译器将不允许隐式强制转换，以尽可能保证代码的类型安全。

即使您可以知道`object`引用指向内存中的`Employee`兼容类，编译器也不能，因为这要到运行时才能知道。您可以通过执行显式强制转换来满足编译器的要求。这是造型的第二条法则:在这种情况下，可以使用 C#造型运算符进行显式向下造型。执行显式强制转换时要遵循的基本模板如下所示:

`(ClassIWantToCastTo)referenceIHave`

因此，要将对象变量传递给`GivePromotion()`方法，您可以编写以下代码:

`// OK!`

`GivePromotion((Manager)frank);`

### C#作为关键字

请注意，显式强制转换是在运行时计算的，而不是在编译时。为了便于讨论，假设您的 Employees 项目有一个本章前面创建的`Hexagon`类的副本。为简单起见，您可以将以下类添加到当前项目中:

`class Hexagon`

`{`

`public void Draw() { Console.WriteLine("Drawing a hexagon!"); }`

`}`

尽管将 employee 对象转换为 shape 对象完全没有意义，但可以编译如下代码，而不会出错:

`// Ack! You can’t cast frank to a Hexagon, but this compiles fine!`

`object frank = new Manager();`

`Hexagon hex = (Hexagon)frank;`

但是，您会收到一个运行时错误，或者更正式地说，一个运行时异常。[第 7 章](07.html)将研究结构化异常处理的全部细节；然而，目前值得指出的是，当你执行显式强制转换时，你可以使用关键字`try`和`catch`来捕获无效强制转换的可能性(同样，参见[第 7 章](07.html)了解全部细节)。

`// Catch a possible invalid cast.`

`object frank = new Manager();`

`Hexagon hex;`

`try`

`{`

`hex = (Hexagon)frank;`

`}`

`catch (InvalidCastException ex)`

`{`

`Console.WriteLine(ex.Message);`

`}`

显然这是一个人为的例子；在这种情况下，你绝不会费心在这两种类型之间进行选择。然而，假设您有一个`System.Object`类型的数组，其中只有少数包含与`Employee`兼容的对象。在这种情况下，您希望确定数组中的某个项是否兼容，如果兼容，则执行强制转换。

C#提供了关键字`as`来在运行时快速确定一个给定的类型是否与另一个兼容。当您使用`as`关键字时，您可以通过检查`null`返回值来确定兼容性。请考虑以下几点:

`// Use "as" to test compatability.`

`object[] things = new object[4];`

`things[0] = new Hexagon();`

`things[1] = false;`

`things[2] = new Manager();`

`things[3] = "Last thing";`

`foreach (object item in things)`

`{`

`Hexagon h = item as Hexagon;`

`if (h == null)`

`Console.WriteLine("Item is not a hexagon");`

`else`

`{`

`h.Draw();`

`}`

`}`

在这里，循环遍历对象数组中的每一项，检查每一项与`Hexagon`类的兼容性。如果(且仅如果！)找到一个与`Hexagon`兼容的对象，调用`Draw()`方法。否则，您只需报告项目不兼容。

### C#是关键字

除了`as`关键字，C#语言还提供了`is`关键字来确定两个项目是否兼容。然而，与`as`关键字不同，如果类型不兼容，`is`关键字返回`false`，而不是`null`引用。换句话说，`is`关键字不执行任何类型的强制转换；它只是检查兼容性。如果事情是兼容的，那么你可以执行一个安全的造型。

目前，`GivePromotion()`方法已经被设计成接受从`Employee`派生的任何可能的类型。考虑下面的更新，它现在检查您被传递的是哪种“雇员类型”:

`static void GivePromotion(Employee emp)`

`{`

`Console.WriteLine("{0} was promoted!", emp.Name);`

`if (emp is SalesPerson)`

`{`

`Console.WriteLine("{0} made {1} sale(s)!", emp.Name,`

`((SalesPerson)emp).SalesNumber);`

`Console.WriteLine();`

`}`

`if (emp is Manager)`

`{`

`Console.WriteLine("{0} had {1} stock options...", emp.Name,`

`((Manager)emp).StockOptions);`

`Console.WriteLine();`

`}`

`}`

这里，您正在执行运行时检查，以确定传入的基类引用实际上指向内存中的什么。在确定接收的是`SalesPerson`还是`Manager`类型之后，您就可以执行显式强制转换来访问该类的专用成员。还要注意，您不需要将您的造型操作包装在一个`try` / `catch`构造中，因为您知道如果您进入任一个`if`范围，造型是安全的，给定您的条件检查。

## 主父类:System。目标

为了总结这一章，我想研究一下。NET 平台:`Object`。当您在阅读前一节时，您可能已经注意到您的层次结构中的基类(`Car`、`Shape`、`Employee`)从来没有显式地指定它们的父类。

`// Who is the parent of Car?`

`class Car`

`{...}`

在。NET universe 中，每种类型最终都是从一个名为`System.Object`的基类派生而来，这个基类可以用 C# `object`关键字(小写 o)来表示。`Object`类为框架中的每种类型定义了一组公共成员。事实上，当您构建一个没有显式定义其父类的类时，编译器会自动从`Object`中派生出您的类型。如果你想弄清楚你的意图，你可以自由地定义从`Object`派生的类，如下所示(然而，也没有必要这样做):

`// Here we are explicitly deriving from System.Object.`

`class Car : object`

`{...}`

像任何类一样，`System.Object`定义了一组成员。在下面的正式 C#定义中，注意其中一些项被声明为`virtual`，它指定一个给定的成员可以被一个子类覆盖，而其他的被标记为`static`(因此在类级别被调用):

`public class Object`

`{`

`// Virtual members.`

`public virtual bool Equals(object obj);`

`protected virtual void Finalize();`

`public virtual int GetHashCode();`

`public virtual string ToString();`

`// Instance-level, nonvirtual members.`

`public Type GetType();`

`protected object MemberwiseClone();`

`// Static members.`

`public static bool Equals(object objA, object objB);`

`public static bool ReferenceEquals(object objA, object objB);`

`}`

表 [6-1](#Tab1) 提供了一些你最可能使用的方法所提供的功能的概要。

表 6-1。

Core Members of `System.Object`

<colgroup><col> <col></colgroup> 
| 对象类的实例方法 | 生命的意义 |
| --- | --- |
| `Equals()` | 默认情况下，只有当被比较的项目引用内存中的同一个项目时，该方法才返回`true`。因此，`Equals()`用于比较对象引用，而不是对象的状态。通常，只有当被比较的对象具有相同的内部状态值(即基于值的语义)时，该方法才会被覆盖以返回`true`。 |
|   | 注意，如果你覆盖了`Equals()`，你也应该覆盖`GetHashCode()`，因为这些方法被`Hashtable`类型内部使用来从容器中检索子对象。 |
|   | 还记得第四章中的[吗，`ValueType`类覆盖了所有结构的这个方法，所以它们使用基于值的比较。](04.html) |
| `Finalize()` | 目前，您可以理解调用这个方法(当被覆盖时)是为了在对象被销毁之前释放所有分配的资源。我将在第 9 章中详细讨论 CLR 垃圾收集服务。 |
| `GetHashCode()` | 该方法返回一个标识特定对象实例的`int`。 |
| `ToString()` | 该方法使用`<namespace>.<type name>`格式(称为完全限定名)返回该对象的字符串表示。这个方法通常会被一个子类覆盖，以返回一个表示对象内部状态的名称/值对的标记化字符串，而不是它的完全限定名。 |
| `GetType()` | 这个方法返回一个`Type`对象，它完整地描述了你当前引用的对象。简而言之，这是一个对所有对象都可用的运行时类型识别(RTTI)方法(在第十五章中有更详细的讨论)。 |
| `MemberwiseClone()` | 这个方法的存在是为了返回当前对象的一个成员接一个成员的副本，这在克隆一个对象时经常用到(见[第 8 章](08.html))。 |

为了演示由`Object`基类提供的一些默认行为，创建一个名为 ObjectOverrides 的最终 C#控制台应用程序项目。插入一个新的 C#类类型，它包含以下名为`Person`的类型的空类定义:

`// Remember! Person extends Object.`

`class Person {}`

现在，更新您的`Main()`方法以与`System.Object`的继承成员交互，如下所示:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with System.Object *****\n");`

`Person p1 = new Person();`

`// Use inherited members of System.Object.`

`Console.WriteLine("ToString: {0}", p1.ToString());`

`Console.WriteLine("Hash code: {0}", p1.GetHashCode());`

`Console.WriteLine("Type: {0}", p1.GetType());`

`// Make some other references to p1.`

`Person p2 = p1;`

`object o = p2;`

`// Are the references pointing to the same object in memory?`

`if (o.Equals(p1) && p2.Equals(o))`

`{`

`Console.WriteLine("Same instance!");`

`}`

`Console.ReadLine();`

`}`

`}`

下面是当前`Main()`方法的输出:

`***** Fun with System.Object *****`

`ToString: ObjectOverrides.Person`

`Hash code: 46104728`

`Type: ObjectOverrides.Person`

`Same instance!`

首先，注意`ToString()`的默认实现如何返回当前类型的完全限定名(`ObjectOverrides.Person`)。正如你将在第 14 章的[中看到的，每个 C#项目都定义了一个“根名称空间”，它与项目本身同名。这里，您创建了一个名为 ObjectOverrides 的项目；因此，`Person`类型和`Program`类都被放在了`ObjectOverrides`名称空间中。](14.html)

`Equals()`的默认行为是测试两个变量是否指向内存中的同一个对象。在这里，您创建了一个名为`p1`的新的`Person`变量。此时，一个新的`Person`对象被放在托管堆上。`p2`也是`Person`类型。然而，您不是在创建一个新的实例，而是将这个变量分配给引用`p1`。因此，`p1`和`p2`都指向内存中的同一个对象，变量`o`(类型`object`，为了更好的测量，它被抛出)也是如此。假设`p1`、`p2`和`o`都指向相同的存储位置，则相等测试成功。

虽然`System.Object`的固定行为在很多情况下可以满足要求，但是对于你的自定义类型来说，重写这些继承的方法是很常见的。举例来说，更新`Person`类以支持一些表示个人名字、姓氏和年龄的属性，每个属性都可以由自定义构造函数设置。

`// Remember! Person extends Object.`

`class Person`

`{`

`public string FirstName { get; set; } = "";`

`public string LastName { get; set; } = "";`

`public int Age { get; set; }`

`public Person(string fName, string lName, int personAge)`

`{`

`FirstName = fName;`

`LastName = lName;`

`Age = personAge;`

`}`

`public Person(){}`

`}`

### 超驰系统。Object.ToString()

您创建的许多类(和结构)可以从覆盖`ToString()`中受益，以便返回类型当前状态的字符串文本表示。这对于调试非常有帮助(还有其他原因)。你如何选择构造这个字符串是个人的选择；但是，推荐的方法是用分号分隔每个名称-值对，并将整个字符串放在方括号内(许多类型在。NET 基础类库遵循这种方法)。为您的`Person`类考虑以下被覆盖的`ToString()`:

`public override string ToString()`

`{`

`string myState;`

`myState = string.Format("[First Name: {0}; Last Name: {1}; Age: {2}]",`

`FirstName, LastName, Age);`

`return myState;`

`}`

鉴于`Person`类只有三条状态数据，所以`ToString()`的实现非常简单。然而，永远记住，一个适当的`ToString()`覆盖也应该考虑继承链上定义的任何数据。

当您为一个扩展自定义基类的类重写`ToString()`时，首先要做的是使用`base`关键字从父类获取`ToString()`值。获得父级的字符串数据后，可以追加派生类的自定义信息。

### 超驰系统。对象。等于()

让我们也覆盖`Object.Equals()`的行为来处理基于值的语义。回想一下，默认情况下，只有当两个被比较的对象引用内存中的同一个对象实例时，`Equals()`才会返回`true`。对于`Person`类，如果被比较的两个变量包含相同的状态值(例如，名字、姓氏和年龄)，实现`Equals()`以返回`true`可能会有所帮助。

首先，注意到`Equals()`方法的传入参数是一个通用的`System. Object`。鉴于此，您的首要任务是确保调用者确实传入了一个`Person`对象，并且作为额外的保护措施，确保传入的参数不是一个`null`引用。

在您建立了调用者已经向您传递了一个分配的`Person`之后，实现`Equals()`的一种方法是对传入对象的数据和当前对象的数据进行逐字段比较。

`public override bool Equals(object obj)`

`{`

`if (obj is Person && obj != null)`

`{`

`Person temp;`

`temp = (Person)obj;`

`if (temp.FirstName == this.FirstName`

`&& temp.LastName == this.LastName`

`&& temp.Age == this.Age)`

`{`

`return true;`

`}`

`else`

`{`

`return false;`

`}`

`}`

`return false;`

`}`

这里，您将对照您的内部值检查传入对象的值(注意使用了`this`关键字)。如果每个对象的名称和年龄都相同，那么您就有两个具有相同状态数据的对象，因此返回`true`。任何其他的可能性导致返回`false`。

虽然这种方法确实有效，但是您可以想象为可能包含几十个数据字段的非平凡类型实现一个定制的`Equals()`方法会有多费力。一个常见的捷径是利用您自己的`ToString()`实现。如果一个类有一个基本且正确的`ToString()`实现，它包含了继承链上的所有字段数据，那么你可以简单地对对象的字符串数据进行比较。

`public override bool Equals(object obj)`

`{`

`// No need to cast "obj" to a Person anymore,`

`// as everything has a ToString() method.`

`return obj.ToString() == this.ToString();`

`}`

请注意，在这种情况下，您不再需要检查传入参数的类型是否正确(在本例中是 a `Person`),因为。NET 支持一个`ToString()`方法。更好的是，您不再需要执行逐个属性的相等检查，因为您不仅仅是测试从`ToString()`返回的值。

### 超驰系统。Object.GetHashCode()

当一个类覆盖了`Equals()`方法时，你也应该覆盖`GetHashCode()`的默认实现。简单地说，哈希代码是一个数值，它将对象表示为一种特定的状态。例如，如果您创建两个保存值`Hello`的`string`变量，您将获得相同的哈希代码。然而，如果其中一个`string`对象全部是小写的(`hello`，您将获得不同的散列码。

默认情况下，`System.Object.GetHashCode()`使用对象在内存中的当前位置来产生哈希值。但是，如果您正在构建一个自定义类型，并打算存储在一个`Hashtable`类型中(在`System.Collections`名称空间中)，您应该总是覆盖这个成员，因为`Hashtable`将在内部调用`Equals()`和`GetHashCode()`来检索正确的对象。

Note

更具体地说，`System.Collections.Hashtable`类在内部调用`GetHashCode()`来获得对象所在位置的大致信息，但是对`Equals()`的后续(内部)调用确定了精确匹配。

虽然你不打算把你的`Person`放入`System.Collections.Hashtable`中，但是为了完成，让我们覆盖`GetHashCode()`。有许多算法可以用来创建散列码——有些很奇特，有些则不那么奇特。大多数时候，您可以通过利用`System.String`的`GetHashCode()`实现来生成一个散列码值。

假设`String`类已经有了一个可靠的哈希代码算法，它使用`String`的字符数据来计算哈希值，如果您可以在您的类中识别出一个对于所有实例都应该是唯一的字段数据(比如一个社会保险号)，只需在该字段数据点上调用`GetHashCode()`。因此，如果`Person`类定义了一个`SSN`属性，您可以编写以下代码:

`// Assume we have an SSN property as so.`

`class Person`

`{`

`public string SSN {get; set;} = "";`

`// Return a hash code based on a point of unique string data.`

`public override int GetHashCode()`

`{`

`return SSN.GetHashCode();`

`}`

`}`

如果您找不到唯一的`string`数据的单点，但是您已经覆盖了`ToString()`，那么就用您自己的字符串表示调用`GetHashCode()`:

`// Return a hash code based on the person’s ToString() value.`

`public override int GetHashCode()`

`{`

`return this.ToString().GetHashCode();`

`}`

### 测试修改后的 Person 类

现在你已经覆盖了`Object`的`virtual`成员，更新`Main()`来测试你的更新。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with System.Object *****\n");`

`// NOTE: We want these to be identical to test`

`// the Equals() and GetHashCode() methods.`

`Person p1 = new Person("Homer", "Simpson", 50);`

`Person p2 = new Person("Homer", "Simpson", 50);`

`// Get stringified version of objects.`

`Console.WriteLine("p1.ToString() = {0}", p1.ToString());`

`Console.WriteLine("p2.ToString() = {0}", p2.ToString());`

`// Test overridden Equals().`

`Console.WriteLine("p1 = p2?: {0}", p1.Equals(p2));`

`// Test hash codes.`

`Console.WriteLine("Same hash codes?: {0}", p1.GetHashCode() == p2.GetHashCode());`

`Console.WriteLine();`

`// Change age of p2 and test again.`

`p2.Age = 45;`

`Console.WriteLine("p1.ToString() = {0}", p1.ToString());`

`Console.WriteLine("p2.ToString() = {0}", p2.ToString());`

`Console.WriteLine("p1 = p2?: {0}", p1.Equals(p2));`

`Console.WriteLine("Same hash codes?: {0}", p1.GetHashCode() == p2.GetHashCode());`

`Console.ReadLine();`

`}`

输出如下所示:

`***** Fun with System.Object *****`

`p1.ToString() = [First Name: Homer; Last Name: Simpson; Age: 50]`

`p2.ToString() = [First Name: Homer; Last Name: Simpson; Age: 50]`

`p1 = p2?: True`

`Same hash codes?: True`

`p1.ToString() = [First Name: Homer; Last Name: Simpson; Age: 50]`

`p2.ToString() = [First Name: Homer; Last Name: Simpson; Age: 45]`

`p1 = p2?: False`

`Same hash codes?: False`

### 系统的静态成员。目标

除了您刚刚检查的实例级成员之外，`System.Object`还定义了两个(非常有用的)静态成员，它们也测试基于值或基于引用的相等性。考虑以下代码:

`static void StaticMembersOfObject()`

`{`

`// Static members of System.Object.`

`Person p3 = new Person("Sally", "Jones", 4);`

`Person p4 = new Person("Sally", "Jones", 4);`

`Console.WriteLine("P3 and P4 have same state: {0}", object.Equals(p3, p4));`

`Console.WriteLine("P3 and P4 are pointing to same object: {0}",`

`object.ReferenceEquals(p3, p4));`

`}`

在这里，您可以简单地发送两个对象(任何类型)并允许`System.Object`类自动确定细节。

Source Code

ObjectOverrides 项目位于 [`Chapter 6`](06.html) 子目录中。

## 摘要

本章探讨了继承和多态的作用和细节。在这些页面中，向您介绍了许多新的关键字和令牌来支持这些技术。例如，回想一下冒号标记用于建立给定类型的父类。父类型能够定义任意数量的虚拟和/或抽象成员来建立多态接口。派生类型使用`override`关键字覆盖这样的成员。

除了构建大量的类层次结构之外，本章还研究了如何在基类和派生类之间进行显式转换，并通过深入研究。NET 基础类库:`System.Object`。