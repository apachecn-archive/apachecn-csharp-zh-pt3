# 26.介绍 Windows 演示基础和 XAML

当 1.0 版的。NET 平台发布后，需要构建图形桌面应用程序的程序员使用了两个名为 Windows Forms 和 GDI+的 API，它们主要打包在`System.Windows.Forms.dll`和`System.Drawing.dll`程序集中。虽然 Windows Forms/GDI+是构建传统桌面 GUI 的优秀 API，但从发布开始，微软提供了一个名为 Windows Presentation Foundation(WPF)的替代 GUI 桌面 API。NET 3.0。

WPF 的第一章从研究这个新的 GUI 框架背后的动机开始，这将帮助你了解 Windows 窗体/GDI+和 WPF 编程模型之间的区别。接下来，您将研究 API 支持的不同类型的 WPF 应用程序，并了解几个重要类的作用，包括`Application`、`Window`、`ContentControl`、`Control`、`UIElement`和`FrameworkElement`。在此期间，您将学习截取键盘和鼠标活动，定义应用程序范围的数据，以及只使用 C#代码的其他常见 WPF 任务。

本章将向您介绍一种基于 XML 的语法，名为可扩展应用程序标记语言(XML 发音为“zammel”)。在这里，您将学习 XAML 的语法和语义(包括附加属性语法，以及类型转换器和标记扩展的作用)，并开始理解如何在运行时生成、加载和解析 XAML。此外，您还将学习如何将 XAML 数据集成到 C# WFP 代码库中(以及这样做的好处)。

本章通过调查 Visual Studio 的集成 WPF 设计器来结束。在这里，您将构建自己的自定义 XAML 编辑器/解析器，它将演示如何在运行时操纵 XAML 来构建动态用户界面。

## WPF 背后的动机

多年来，微软创造了许多图形用户界面工具包(原始 C/C++/Windows API 开发，VB6，MFC 等。)来构建桌面可执行文件。这些 API 中的每一个都提供了一个代码库来表示 GUI 应用程序的基本方面，包括主窗口、对话框、控件、菜单系统和其他基本必需品。的初始版本。NET 平台上，Windows Forms API 很快成为 UI 开发的首选模型，因为它具有简单但非常强大的对象模型。

虽然许多功能齐全的桌面应用程序已经使用 Windows 窗体成功地创建了，但事实是这种编程模型是相当不对称的。简而言之，`System.Windows.Forms.dll`和`System.Drawing.dll`没有为构建功能丰富的桌面应用程序所需的许多附加技术提供直接支持。为了说明这一点，考虑 WPF 发布之前 GUI 桌面开发的特殊性质(见表 [26-1](#Tab1) )。

表 26-1。

Pre-WPF Solutions to Desired Functionalities

<colgroup><col> <col></colgroup> 
| 期望的功能 | 技术 |
| --- | --- |
| 用控件构建窗口 | Windows 窗体 |
| 2D 图形支持 | GDI+ ( `System.Drawing.dll`) |
| 3D 图形支持 | directx apis |
| 支持流式视频 | Windows Media Player APIs |
| 支持流样式的文档 | PDF 文件的编程操作 |

如您所见，Windows 窗体开发人员必须从许多不相关的 API 和对象模型中引入类型。虽然使用这些不同的 API 在语法上看起来确实相似(毕竟这只是 C#代码)，但您可能也同意每种技术需要完全不同的思维方式。例如，使用 DirectX 创建 3D 渲染动画所需的技能与将数据绑定到网格所需的技能完全不同。当然，对于 Windows 窗体程序员来说，掌握每个 API 的多样性是非常困难的。

### 统一不同的 API

WPF(介绍与。NET 3.0)的目的是将这些以前不相关的编程任务合并到一个统一的对象模型中。因此，如果您需要创作一个 3D 动画，您不需要针对 DirectX API 手动编程(尽管您可以这样做),因为 3D 功能是直接嵌入到 WPF 中的。为了了解事情已经清理得有多好，考虑一下表 [26-2](#Tab2) ，它展示了从。NET 3.0。

表 26-2。

.NET 3.0 Solutions to Desired Functionalities

<colgroup><col> <col></colgroup> 
| 期望的功能 | 技术 |
| --- | --- |
| 使用控件构建窗体 | 数据绑定 |
| 2D 图形支持 | 数据绑定 |
| 3D 图形支持 | 数据绑定 |
| 支持流式视频 | 数据绑定 |
| 支持流样式的文档 | 数据绑定 |

这里明显的好处是。NET 程序员现在有一个单一的、对称的 API 来满足所有常见的 GUI 桌面编程需求。当你熟悉了关键的 WPF 程序集的功能和 XAML 的语法后，你会惊奇地发现你可以如此快速地创建非常复杂的 ui。

### 通过 XAML 提供关注点分离

也许最引人注目的好处之一是 WPF 提供了一种方法，将 GUI 应用程序的外观和感觉与驱动它的编程逻辑完全分开。使用 XAML，可以通过 XML 标记定义应用程序的用户界面。这种标记(理想情况下使用 Microsoft Visual Studio 或 Microsoft Expression Blend 等工具生成)可以连接到相关的 C#代码文件，以提供程序功能的核心。

Note

XAML 不限于 WPF 应用。任何应用程序都可以用 XAML 来描述一棵。NET 对象，即使它们与可见的用户界面无关。例如，Windows Workflow Foundation API 使用基于 XAML 的语法来定义业务流程和自定义活动。还有，其他的。NET GUI 框架，如 Silverlight(正在衰落，但今天仍在大量使用)、Windows Phone 和 Windows 10 应用程序都使用 XAML。

当你深入研究 WPF 时，你可能会惊讶于这种“桌面标记”所提供的灵活性。XAML 不仅允许你定义简单的用户界面元素(按钮、网格、列表框等)。)以及交互式 2D 和 3D 图形、动画、数据绑定逻辑和多媒体功能(如视频回放)。

XAML 还使得定制控件如何呈现其视觉外观变得非常容易。例如，定义一个使公司徽标生动的圆形按钮控件只需要几行标记。如[第 29 章](29.html)所示，WPF 控件可以通过样式和模板来修改，这允许你以最少的麻烦和麻烦来改变应用程序的整体外观。与 Windows 窗体开发不同，从头开始构建自定义 WPF 控件的唯一令人信服的原因是您需要更改控件的行为(例如，添加自定义方法、属性或事件；子类化现有控件以重写虚拟成员)。如果你只是需要改变一个控件的外观(比如一个圆形的动画按钮)，你可以完全通过标记来实现。

### 提供优化的渲染模型

GUI 工具包(如 Windows 窗体、MFC 或 VB6)使用低级的、基于 C 的 API (GDI)执行所有图形呈现请求(包括按钮和列表框等 UI 元素的呈现),该 API 多年来一直是 Windows 操作系统的一部分。GDI 为典型的商业应用程序或简单的图形程序提供了足够的性能；然而，如果一个 UI 应用程序需要利用高性能图形，DirectX 是必需的。

WPF 编程模型非常不同，因为在呈现图形数据时不使用 GDI。所有渲染操作(例如，2D 图形、3D 图形、动画、控件渲染等。)现在利用 DirectX API。第一个明显的好处是，您的 WPF 应用程序将自动利用硬件和软件优化。此外，WPF 应用程序可以利用非常丰富的图形服务(模糊效果，抗锯齿，透明度等)。)而没有直接针对 DirectX API 编程的复杂性。

Note

尽管 WPF 确实将所有渲染请求都推送到 DirectX 层，但我并不想暗示 WPF 应用程序会像直接使用非托管 C++和 DirectX 构建应用程序一样快。尽管 WPF 在 2000 年取得了重大进展。NET 4.6，如果您打算构建一个需要最快执行速度的桌面应用程序(如 3D 视频游戏)，非托管 C++和 DirectX 仍然是最好的方法。

### 简化复杂的 UI 编程

概括一下到目前为止的故事，Windows Presentation Foundation(WPF)是一个用于构建桌面应用程序的 API，它将各种桌面 API 集成到单个对象模型中，并通过 XAML 提供了关注点的清晰分离。除了这些要点之外，WPF 应用程序还受益于一种将服务集成到程序中的非常简单的方式，这在历史上是相当复杂的。以下是 WPF 核心功能的简要概述:

*   许多布局管理器(比 Windows 窗体多得多)为内容的放置和重新定位提供了极其灵活的控制。
*   使用增强的数据绑定引擎以多种方式将内容绑定到 UI 元素。
*   一个内置的样式引擎，允许你为 WPF 应用程序定义“主题”。
*   使用矢量图形，允许内容自动调整大小，以适应应用程序所在屏幕的大小和分辨率。
*   支持 2D 和三维图形，动画，视频和音频播放。
*   丰富的排版 API，例如支持 XML 纸张规范(XPS)文档、固定文档(WYSIWYG)、流文档和文档注释(例如，便笺 API)。
*   支持与传统 GUI 模型(例如，Windows 窗体、ActiveX 和 Win32 HWNDs)的互操作。例如，可以将自定义 Windows 窗体控件合并到 WPF 应用程序中，反之亦然。

现在您已经对 WPF 带来了什么有了一些了解，让我们看看可以使用这个 API 创建的各种类型的应用程序。这些特性中的许多将在后面的章节中详细探讨。

## WPF 的各种风味

WPF API 可用于构建各种以 GUI 为中心的应用程序，这些应用程序的导航结构和部署模型基本上是不同的。接下来的几节对每个选项进行了高度概括。

### 传统桌面应用程序

第一种(也是最常见的)选择是使用 WPF 构建一个在本地机器上运行的传统可执行程序集。例如，您可以使用 WPF 构建文本编辑器、绘画程序或多媒体程序，如数字音乐播放器、照片查看器等。像任何其他桌面应用程序一样，这些`*.exe`文件可以使用传统方式安装(安装程序、Windows Installer 软件包等)。)或通过 ClickOnce 技术，允许通过远程 web 服务器分发和安装桌面应用程序。

从编程角度来说，除了预期的对话框、工具栏、状态栏、菜单系统和其他 UI 元素之外，这种类型的 WPF 应用程序将(至少)使用`Window`和`Application`类类型。

现在，你当然可以使用 WPF 来构建不支持任何附加功能的基本业务应用程序，但是当你包含这些功能时，WPF 会大放异彩。考虑图 [26-1](#Fig1) ，它显示了一个在医疗环境中查看患者记录的 WPF 样本桌面应用程序。

![A978-1-4842-1332-2_26_Fig1_HTML.jpg](img/A978-1-4842-1332-2_26_Fig1_HTML.jpg)

图 26-1。

This WPF desktop application makes use of several WPF APIs

遗憾的是，打印的页面没有显示该程序的全部功能。例如，如果您看到该应用程序正在运行，您会注意到主窗口的右上方正在显示患者窦性心律的实时图形。如果点击右下方的患者详细信息按钮，将出现几个动画来翻转、旋转和变换用户界面，使其具有如图 [26-2](#Fig2) 所示的外观。

![A978-1-4842-1332-2_26_Fig2_HTML.jpg](img/A978-1-4842-1332-2_26_Fig2_HTML.jpg)

图 26-2。

Transformations and animations are very simple under WPF

没有 WPF，你能构建同样的应用程序吗？绝对的。然而，代码的数量——以及代码的复杂性——会高得多。

Note

这个示例应用程序和许多其他应用程序可以从 WPF 官方网站 [`http://windowsclient.net`](http://windowsclient.net/) 下载(带源代码)。在这里，您可以找到大量的 WPF(和 Windows Forms)白皮书、示例项目、技术演练和论坛。不幸的是，在写这篇文章的时候，只有很少的几个。NET 4.6 示例。好消息是 XAML 团队致力于将样本更新到。净 4.6。

### 基于导航的 WPF 应用

WPF 应用程序可以选择使用基于导航的结构，这使得传统的桌面应用程序具有 web 浏览器应用程序的基本行为。使用这个模型，您可以构建一个提供前进和后退按钮的桌面`*.exe`,允许终端用户在各种 UI 显示页面之间来回移动。

这种类型的应用程序维护每个页面的列表，并提供必要的基础结构来在页面之间导航、跨页面传递数据(类似于基于 web 的应用程序变量)，以及维护历史列表。作为一个具体的例子，考虑 Windows 资源管理器(见图 [26-3](#Fig3) )，它利用了这样的功能。请注意安装在窗口左上角的导航按钮。

![A978-1-4842-1332-2_26_Fig3_HTML.jpg](img/A978-1-4842-1332-2_26_Fig3_HTML.jpg)

图 26-3。

A navigation-based desktop program

尽管 WPF 桌面应用程序可以采用类似 web 的导航结构，但要明白这只是一个 UI 设计问题。应用程序本身仍然只是运行在台式机上的本地可执行文件，除了采用稍微相似的外观和感觉之外，它与 web 应用程序没有什么关系。从编程的角度来说，这种类型的 WPF 应用程序是使用诸如`Application`、`Page`、`NavigationWindow`和`Frame`这样的类构建的。

### XBAP 应用

WPF 还允许您构建可以在 web 浏览器中托管的应用程序。这种 WPF 风格的应用程序被称为 XAML 浏览器应用程序，或 XBAP。在这种模型下，最终用户导航到一个给定的 URL，在这一点上 XBAP(本质上是一个`Page`对象的集合)被透明地下载并安装到本地机器上。然而，与可执行应用程序的传统 ClickOnce 安装不同，XBAP 程序直接驻留在浏览器中，并采用浏览器的内在导航系统。图 [26-4](#Fig4) 展示了一个正在运行的 XBAP 程序(特别是 ExpenseIt WPF 样本程序，可以在 [`http://windowsclient.net`](http://windowsclient.net/) 找到)。

![A978-1-4842-1332-2_26_Fig4_HTML.jpg](img/A978-1-4842-1332-2_26_Fig4_HTML.jpg)

图 26-4。

XBAP programs are downloaded to a local machine and hosted within a web browser

XBAP 的一个好处是，它允许您创建复杂的 ui，比用 HTML 和 JavaScript 构建的典型网页更具表现力(然而，HTML 5 无疑改善了当前的情况)。XBAP `Page`对象可以使用与桌面 WPF 应用相同的 WPF 服务，包括动画、2D 和 3D 图形、主题等等。实际上，网页浏览器只是 WPF 对象的容器，并不显示 ASP.NET 网页。

然而，假设这些`Page`对象被部署到远程 web 服务器，XBAPs 可以很容易地被版本化和更新，而不需要将可执行文件重新部署到用户的桌面。像传统的 web 程序一样，您可以简单地更新 web 服务器中的`Page`对象，当用户访问 URL 时，他们将获得“最新和最棒的”。

这种 WPF 的一个缺点是 XBAPs 必须托管在微软的 Internet Explorer 或 Firefox 浏览器中。注意微软 Edge 不支持 XBAPs，新的 Windows 10 浏览器；您必须在 Windows 10 上使用 Internet Explorer。如果您在公司内部网中部署 XBAPs，浏览器兼容性应该不是问题，因为系统管理员可以决定在用户机器上安装哪个浏览器。但是，如果您希望外部世界使用您的 XBAP，不可能确保每个最终用户都使用 Internet Explorer/Firefox，因此一些外部用户可能无法查看您的 WPF XBAP。

需要注意的另一个问题是，查看 XBAP 的计算机必须在本地安装。因为`Page`对象将使用相同的。NET 程序集作为本机运行在计算机上的应用程序。鉴于这一点，XBAPs 仅限于 Windows 操作系统，因此不能在运行 Mac OS X 或 Linux 的系统上查看。

Note

虽然你仍然可以在 Visual Studio 2015 中创建 XBAP 项目，但它们在很大程度上被基于 HTML5/JavaScript 的应用程序(如 ASP.NET MVC)所取代。

### WPF 和 Silverlight 的关系

WPF 和 XAML 也为跨平台、跨浏览器的基于 WPF 的技术 Silverlight 提供了基础。从高层次来看，你可以把 Silverlight 看作是 Adobe Flash 的竞争对手，它的好处是使用 C#和 XAML，而不是一套新的工具和语言。Silverlight 是 WPF 功能的子集，用于为更大的基于 HTML 的网页构建高度交互式的插件。然而实际上，Silverlight 是。NET 平台，它附带了“迷你”CLR 和“迷你”版本的。NET 基础类库。

与 XBAP 不同，用户的计算机不需要完全安装。NET 框架。只要目标计算机安装了 Silverlight 运行时，浏览器就会自动加载 Silverlight 运行时并显示 Silverlight 应用程序。最重要的是，Silverlight 插件不局限于 Windows 操作系统。微软还为 Mac OS X 开发了 Silverlight 运行时。

有了 Silverlight，您就能够构建功能极其丰富(而且是交互式的)的 web 应用程序。例如，像 WPF 一样，Silverlight 有基于矢量的图形系统、动画支持和多媒体支持。此外，您还可以合并。NET 基础类库到您的应用程序中。这个子集包括 LINQ API、通用集合、对 WCF 的支持，以及一个健康的子集`mscorlib.dll`(文件 I/O、XML 操作等。).

Note

微软正在脱离 Silverlight 作为开发平台。虽然您仍然可以在 Visual Studio 2015 中创建 Silverlight 项目，但 Silverlight 的需求一旦得到满足，就会被基于 HTML5/JavaScript 的应用程序所取代。微软承诺在 Silverlight 正式停产后的 10 年内支持它，这将为您提供大约另外 8 年(取决于您何时阅读本书)的积极支持。

## 调查 WPF 议会

无论您想要构建哪种类型的 WPF 应用程序，WPF 最终都只不过是捆绑在其中的类型的集合。NET 程序集。表 [26-3](#Tab3) 描述了用于构建 WPF 应用程序的关键组件，每个组件在创建新项目时都必须被引用。正如您所希望的，Visual Studio WPF 项目会自动引用这些必需的程序集。

表 26-3。

Core WPF Assemblies

<colgroup><col> <col></colgroup> 
| 装配 | 生命的意义 |
| --- | --- |
| `PresentationCore.dll` | 该程序集定义了许多名称空间，这些名称空间构成了 WPF GUI 层的基础。例如，该程序集包含对 WPF 墨迹 API(针对 Pocket PCs 和 Tablet PCs 的手写笔输入进行编程)、动画原语和许多图形呈现类型的支持。 |
| `PresentationFramework.dll` | 该程序集包含大多数 WPF 控件、`Application`和`Window`类，支持交互式 2D 图形和数据绑定中使用的许多类型。 |
| `System.Xaml.dll` | 此程序集提供了允许您在运行时针对 XAML 文档进行编程的命名空间。总的来说，这个库只有在您创作 WPF 支持工具或者需要在运行时绝对控制 XAML 时才有用。 |
| `WindowsBase.dll` | 这个程序集定义了构成 WPF API 基础设施的类型，包括那些代表 WPF 线程类型、安全类型、各种类型转换器以及对依赖属性和路由事件的支持(在第 27 章中描述)。 |

这四个程序集共同定义了许多新的命名空间和数百个新的。NET 类、接口、结构、枚举和委托。尽管您应该参考。NET Framework 4.6 SDK 文档完整的细节，表 [26-4](#Tab4) 描述了一些(但肯定不是全部)重要命名空间的作用。

表 26-4。

Core WPF Namespaces

<colgroup><col> <col></colgroup> 
| 命名空间 | 生命的意义 |
| --- | --- |
| `System.Windows` | 这是 WPF 的根命名空间。在这里，您会发现任何 WPF 桌面项目都需要的核心类(比如`Application`和`Window`)。 |
| `System.Windows.Controls` | 包含所有预期的 WPF 小部件，包括构建菜单系统的类型、工具提示和许多布局管理器。 |
| `System.Windows.Data` | 包含使用 WPF 数据绑定引擎的类型，以及对数据绑定模板的支持。 |
| `System.Windows.Documents` | 包含使用文档 API 的类型，该 API 允许您通过 XML 纸张规范(XPS)协议将 PDF 样式的功能集成到您的 WPF 应用程序中。 |
| `System.Windows.Ink` | 提供对 Ink API 的支持，这允许您捕获来自手写笔或鼠标的输入，响应输入手势，等等。对平板电脑编程非常有用；然而，任何 WPF 都可以使用这个 API。 |
| `System.Windows.Markup` | 该命名空间定义了许多类型，这些类型允许以编程方式解析和处理 XAML 标记(以及等效的二进制格式 BAML)。 |
| `System.Windows.Media` | 这是几个以媒体为中心的命名空间的根命名空间。在这些命名空间中，您可以找到处理动画、3D 呈现、文本呈现和其他多媒体原语的类型。 |
| `System.Windows.Navigation` | 此命名空间提供了一些类型，用于说明 XAML 浏览器应用程序(XBAPs)以及需要导航页面模型的标准桌面应用程序所采用的导航逻辑。 |
| `System.Windows.Shapes` | 定义允许您呈现自动响应鼠标输入的交互式 2D 图形的类。 |

为了开始您的 WPF 编程模型之旅，您将研究任何传统桌面开发工作中常见的两个名称空间成员:`Application`和`Window`。

Note

如果您已经使用 Windows 窗体 API 创建了桌面用户界面，请注意`System.Windows.Forms.*`和`System.Drawing.*`程序集与 WPF 无关。这些库代表了原始的。NET GUI 工具包，Windows Forms/GDI+。

### 应用程序类的角色

`System.Windows.Application`类代表一个正在运行的 WPF 应用程序的全局实例。这个类提供了一个`Run()`方法(用于启动应用程序)，一系列您能够处理的事件，以便与应用程序的生命周期进行交互(例如`Startup`和`Exit`)，以及许多特定于 XAML 浏览器应用程序的事件(例如当用户在页面间导航时触发的事件)。表 [26-5](#Tab5) 详细描述了一些关键属性。

表 26-5。

Key Properties of the Application Type

<colgroup><col> <col></colgroup> 
| 财产 | 生命的意义 |
| --- | --- |
| `Current` | 这个静态属性允许您从代码中的任何地方访问正在运行的`Application`对象。当一个窗口或对话框需要访问创建它的`Application`对象时，这是非常有用的，通常是访问应用程序范围的变量和功能。 |
| `MainWindow` | 此属性允许您以编程方式获取或设置应用程序的主窗口。 |
| `Properties` | 此属性允许您建立和获取可在 WPF 应用程序的所有方面(窗口、对话框等)访问的数据。). |
| `StartupUri` | 此属性获取或设置一个 URI，它指定应用程序启动时自动打开的窗口或页面。 |
| `Windows` | 该属性返回一个`WindowCollection`类型，它提供对从创建`Application`对象的线程创建的每个窗口的访问。当您想要迭代应用程序的每个打开的窗口并改变其状态(例如最小化所有窗口)时，这非常有用。 |

### 构造应用程序类

任何 WPF 应用程序都需要定义一个扩展`Application`的类。在这个类中，您将定义程序的入口点(`Main()`方法)，它创建这个子类的一个实例，并且通常处理`Startup`和`Exit`事件。您将很快构建一个完整的示例项目，但这里有一个快速示例:

`// Define the global application object`

`// for this WPF program.`

`class MyApp : Application`

`{`

`[STAThread]`

`static void Main(string[] args)`

`{`

`// Create the application object.`

`MyApp app = new MyApp();`

`// Register the Startup/Exit events.`

`app.Startup += (s, e) => { /* Start up the app */ };`

`app.Exit += (s, e) => { /* Exit the app */ };`

`}`

`}`

在`Startup`处理程序中，您通常会处理任何传入的命令行参数，并启动程序的主窗口。如您所料，在`Exit`处理程序中，您可以为程序编写任何必要的关闭逻辑(例如，保存用户首选项，写入 Windows 注册表)。

### 枚举 Windows 集合

`Application`公开的另一个有趣的属性是`Windows`，它提供了对一个集合的访问，该集合代表当前 WPF 应用程序加载到内存中的每个窗口。回想一下，当您创建新的`Window`对象时，它们会自动添加到`Application.Windows`集合中。下面是一个最小化应用程序每个窗口的示例方法(可能是为了响应终端用户触发的给定键盘手势或菜单选项):

`static void MinimizeAllWindows()`

`{`

`foreach (Window wnd in Application.Current.Windows)`

`{`

`wnd.WindowState = WindowState.Minimized;`

`}`

`}`

在接下来的例子中，您将构建一个完整的`Application`派生类型。在此之前，让我们检查一下`Window`类型的核心功能，并在此过程中了解一些重要的 WPF 基类。

### 窗口类的作用

`System.Windows.Window`类(位于`PresentationFramework.dll`汇编中)代表由`Application`派生类拥有的单个窗口，包括主窗口显示的任何对话框。毫不奇怪，`Window`有一系列的父类，每个父类都为表带来了更多的功能。考虑图 [26-5](#Fig5) ，它显示了通过 Visual Studio 对象浏览器看到的`System.Windows.Window`的继承链(和实现的接口)。

![A978-1-4842-1332-2_26_Fig5_HTML.jpg](img/A978-1-4842-1332-2_26_Fig5_HTML.jpg)

图 26-5。

The hierarchy of the Window class

随着本章和后续章节的学习，你会逐渐理解这些基类所提供的功能。然而，为了激起您的兴趣，下面几节将对每个基类提供的功能进行细分(请参考。NET Framework 4.6 SDK 文档以了解完整的详细信息)。

#### 系统的作用。窗口.控件.内容控件

`Window`的直接父类是`ContentControl`，它很可能是所有 WPF 类中最吸引人的。这个基类为派生类型提供了承载单个内容的能力，简而言之，这是指通过`Content`属性放置在控件表面区域内部的可视数据。WPF 内容模型使得定制内容控件的基本外观变得非常简单。

例如，当您想到一个典型的“按钮”控件时，您倾向于假设内容是一个简单的字符串(OK、Cancel、Abort 等)。).如果您使用 XAML 来描述一个 WPF 控件，并且您想要分配给属性`Content`的值可以被捕获为一个简单的字符串，那么您可以在元素的开始定义中这样设置`Content`属性(此时不要担心确切的标记):

`<!--``Setting the Content value in the opening element`T2】

`<Button Height="80" Width="100" Content="OK"/>`

Note

也可以在 C#代码中设置`Content`属性，这允许你在运行时改变控件的内部。

然而，内容几乎可以是任何东西。例如，假设您想要一个比简单字符串更有趣的“按钮”，可能是一个自定义图形和一个文本广告。在其他 UI 框架(如 Windows 窗体)中，您可能需要构建一个自定义控件，这可能需要维护相当多的代码和一个全新的类。对于 WPF 内容模型，没有必要这样做。

当您想要将`Content`属性赋给一个不能被捕获为简单字符数组的值时，您不能使用控件的开始定义中的属性来分配它。相反，您必须在元素范围内隐式定义内容数据。例如，下面的`<Button>`包含一个`<StackPanel>`作为内容，它本身包含一些唯一的数据(确切地说是一个`<Ellipse>`和`<Label>`):

`<!--``Implicitly setting the Content property with complex data`T2】

`<Button Height="80" Width="100">`

`<StackPanel>`

`<Ellipse Fill="Red" Width="25" Height="25"/>`

`<Label Content ="OK!"/>`

`</StackPanel>`

`</Button>`

您还可以利用 XAML 的属性元素语法来设置复杂的内容。考虑下面的功能等价的`<Button>`定义，它使用属性元素语法显式地设置了`Content`属性(同样，在本章的后面你会找到更多关于 XAML 的信息，所以现在还不要过多考虑细节):

`<!--``Setting the Content property using property-element syntax`T2】

`<Button Height="80" Width="100">`

`<Button.Content>`

`<StackPanel>`

`<Ellipse Fill="Red" Width="25" Height="25"/>`

`<Label Content ="OK!"/>`

`</StackPanel>`

`</Button.Content>`

`</Button>`

请注意，不是每个 WPF 元素都是从`ContentControl`派生的，因此，不是所有的控件都支持这种独特的内容模型(然而，大多数都支持)。此外，一些 WPF 控件对您刚刚检查过的基本内容模型进行了一些改进。[第 27 章](27.html)将更详细地考察 WPF 内容的作用。

#### 系统的作用。窗口.控件.控件

与`ContentControl`不同，所有的 WPF 控件共享`Control`基类作为一个公共的父类。这个基类提供了许多核心成员，这些成员负责基本的 UI 功能。例如，`Control`定义属性来建立控件的大小、不透明度、tab 键顺序逻辑、显示光标、背景颜色等等。此外，这个父类提供了对模板服务的支持。正如在[第 29 章](29.html)中解释的，WPF 控件可以使用模板和样式完全改变它们的外观。表 [26-6](#Tab6) 记录了`Control`类型的一些关键成员，按相关功能分组。

表 26-6。

Key Members of the Control Type

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `Background`、`Foreground`、`BorderBrush`、`BorderThickness`、`Padding`、`HorizontalContentAlignment`、`VerticalContentAlignment` | 这些属性允许您设置有关如何呈现和定位控件的基本设置。 |
| `FontFamily`、`FontSize`、`FontStretch`、`FontWeight` | 这些属性控制各种字体居中设置。 |
| `IsTabStop`，`TabIndex` | 这些属性用于在窗口上的控件之间建立 tab 键顺序。 |
| `MouseDoubleClick`，`PreviewMouseDoubleClick` | 这些事件处理双击小部件的行为。 |
| `Template` | 此属性允许您获取和设置控件的模板，该模板可用于更改小部件的呈现输出。 |

#### 系统的作用。Windows.FrameworkElement

这个基类提供了许多在整个 WPF 框架中使用的成员，例如对故事板(在动画中使用)和数据绑定的支持，以及命名成员(通过`Name`属性)的能力，获取由派生类型定义的任何资源，以及建立派生类型的整体维度。表 [26-7](#Tab7) 击中亮点。

表 26-7。

Key Members of the FrameworkElement Type

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `ActualHeight`、`ActualWidth`、`MaxHeight`、`MaxWidth`、`MinHeight`、`MinWidth`、`Height`、`Width` | 这些属性控制派生类型的大小。 |
| `ContextMenu` | 获取或设置与派生类型关联的弹出菜单。 |
| `Cursor` | 获取或设置与派生类型关联的鼠标光标。 |
| `HorizontalAlignment`，`VerticalAlignment` | 获取或设置类型在容器(如面板或列表框)中的定位方式。 |
| `Name` | 允许您为类型指定一个名称，以便在代码文件中访问其功能。 |
| `Resources` | 提供对由类型定义的任何资源的访问(见第 29 章关于 WPF 资源系统的检查)。 |
| `ToolTip` | 获取或设置与派生类型关联的工具提示。 |

#### 系统的作用。Windows.UIElement

在`Window`的继承链中的所有类型中，`UIElement`基类提供了最多的功能。`UIElement`的主要任务是为派生类型提供大量的事件，以允许派生类型接收焦点和处理输入请求。例如，该类提供了许多事件来解释拖放操作、鼠标移动、键盘输入和手写笔输入(适用于 Pocket PCs 和 Tablet PCs)。

[第 27 章](27.html)详细挖掘 WPF 事件模型；然而，许多核心事件看起来都很熟悉(`MouseMove`、`KeyUp`、`MouseDown`、`MouseEnter`、`MouseLeave`等)。).除了定义几十个事件之外，这个父类还提供了许多属性来说明控件焦点、启用状态、可见性和点击测试逻辑，如表 [26-8](#Tab8) 所示。

表 26-8。

Key Members of the UIElement Type

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `Focusable`，`IsFocused` | 这些属性允许您将焦点设置在给定的派生类型上。 |
| `IsEnabled` | 此属性允许您控制是启用还是禁用给定的派生类型。 |
| `IsMouseDirectlyOver`，`IsMouseOver` | 这些属性提供了一种执行点击测试逻辑的简单方法。 |
| `IsVisible`，`Visibility` | 这些属性允许您使用派生类型的可见性设置。 |
| `RenderTransform` | 此属性允许您建立将用于呈现派生类型的转换。 |

#### 系统的作用。Windows.Media.Visual

`Visual`类类型在 WPF 中提供核心渲染支持，包括图形数据的命中测试、坐标转换和边界框计算。实际上，`Visual`类与底层 DirectX 子系统交互，在屏幕上实际绘制数据。正如你将在[第 28 章](28.html)中看到的，WPF 提供了三种可能的方式来呈现图形数据，每种方式在功能和性能上都有所不同。使用`Visual`类型(及其子类型，如`DrawingVisual`)提供了最轻量级的方式来呈现图形数据，但它也需要大量的手动代码来处理所有需要的服务。同样，更多细节将在第 28 章中出现。

#### 系统的作用。Windows . DependencyObject 对象

WPF 支持一种特殊的口味。称为依赖属性的. NET 属性。简而言之，这种属性样式提供了额外的代码，以允许属性响应多种 WPF 技术，如样式、数据绑定、动画等。为了让一个类型支持这个新的属性方案，它需要从`DependencyObject`基类派生。虽然依赖属性是 WPF 开发的一个关键方面，但是大部分时间它们的细节是隐藏的。第 27 章深入探究依赖属性的细节。

#### 系统的作用。windows . threading . dispatch object

`Window`类型的最后一个基类是`DispatcherObject`(在`System.Object`之后，我认为在这本书的这一点上不需要进一步解释)。这个类型提供了一个感兴趣的属性，`Dispatcher`，它返回相关的`System.Windows.Threading.Dispatcher`对象。`Dispatcher`类是 WPF 应用程序事件队列的入口点，它提供了处理并发和线程的基本构造。

## 构建没有 XAML 的 WPF 应用程序

给定由`Window`类型的父类提供的所有功能，通过直接创建一个`Window`对象或者使用这个类作为强类型后代的父类，可以在你的应用程序中表示一个窗口。让我们在下面的代码示例中检查这两种方法。尽管大多数 WPF 应用程序将使用 XAML，但从技术上来说，这样做是可选的。任何可以用 XAML 语言表达的东西都可以用代码来表达，反之亦然。如果您愿意，可以使用底层对象模型和过程化 C#代码构建一个完整的 WPF 项目。

为了举例说明，让我们直接使用`Application`和`Window`类创建一个不使用 XAML 的最小但完整的应用程序。首先创建一个名为 WpfAppAllCode 的新控制台应用程序(不要担心；您将在本章后面使用 Visual Studio WPF 项目模板。进入项目属性，将输出类型更改为 Windows 应用程序(这可以防止控制台窗口弹出)。接下来，进入项目添加引用对话框，添加对`WindowsBase.dll`、`PresentationCore.dll`、`System.Xaml.dll`和`PresentationFramework.dll`的引用。

现在，用下面的代码更新您的初始 C#文件，这将创建一个中等功能的窗口(这里，我只展示了编译代码必须导入的名称空间；请随意保留任何自动包含`using`语句):

`// A simple WPF application, written without XAML.`

`using System;`

`using System.Windows;`

`using System.Windows.Controls;`

`namespace WpfAppAllCode`

`{`

`// In this first example, you are defining a single class type to`

`// represent the application itself and the main window.`

`class Program : Application`

`{`

`[STAThread]`

`static void Main(string[] args)`

`{`

`// Handle the Startup and Exit events, and then run the application.`

`Program app = new Program();`

`app.Startup += AppStartUp;`

`app.Exit += AppExit;`

`app.Run(); // Fires the Startup event.`

`}`

`static void AppExit(object sender, ExitEventArgs e)`

`{`

`MessageBox.Show("App has exited");`

`}`

`static void AppStartUp(object sender, StartupEventArgs e)`

`{`

`// Create a Window object and set some basic properties.`

`Window mainWindow = new Window();`

`mainWindow.Title = "My First WPF App!";`

`mainWindow.Height = 200;`

`mainWindow.Width = 300;`

`mainWindow.WindowStartupLocation = WindowStartupLocation.CenterScreen;`

`mainWindow.Show();`

`}`

`}`

`}`

Note

WPF 应用程序的`Main()`方法必须具有`[STAThread]`属性，这确保了应用程序使用的任何遗留 COM 对象都是线程安全的。如果你不以这种方式注释`Main()`，你将会遇到一个运行时异常。

注意，`Program`类扩展了`System.Windows.Application`类。在`Main()`方法中，创建 application 对象的一个实例，并使用方法组转换语法处理`Startup`和`Exit`事件。回想一下第 10 章中的内容，这个简写符号消除了手动指定特定事件所使用的底层委托的需要。当然，如果您愿意，可以直接通过名称指定基础委托。

在下面修改过的`Main()`方法中，注意到`Startup`事件与`StartupEventHandler`委托协同工作，后者只能指向以`Object`作为第一个参数和以`StartupEventArgs`作为第二个参数的方法。另一方面，`Exit`事件与`ExitEventHandler`委托一起工作，这要求所指向的方法将`ExitEventArgs`类型作为第二个参数。

`[STAThread]`

`static void Main(string[] args)`

`{`

`// This time, specify the underlying delegates.`

`Program app = new Program();`

`app.Startup += new StartupEventHandler(AppStartUp);`

`app.Exit += new ExitEventHandler(AppExit);`

`app.Run(); // Fires the Startup event.`

`}`

无论如何，`AppStartUp()`方法已经被配置为创建一个`Window`对象，建立一些非常基本的属性设置，并调用`Show()`以非模态方式在屏幕上显示窗口(可以使用`ShowDialog()`方法启动模态对话框)。`AppExit()`方法只是利用 WPF `MessageBox`类在应用程序终止时显示一条诊断消息。

编译并运行项目后，您会发现一个非常简单的主窗口，可以最小化、最大化和关闭。为了增加趣味，您需要添加一些用户界面元素。然而，在此之前，您应该重构您的代码库，以考虑强类型和良好封装的`Window`派生类。

### 创建强类型窗口

目前，`Application`派生类在应用程序启动时直接创建一个`Window`类型的实例。理想情况下，你应该创建一个从`Window`派生的类来封装它的外观和功能。向您的项目添加另一个名为`MainWindow`的类，并添加以下类定义(确保导入`System.Windows`名称空间):

`class MainWindow : Window`

`{`

`public MainWindow(string windowTitle, int height, int width)`

`{`

`this.Title = windowTitle;`

`this.WindowStartupLocation = WindowStartupLocation.CenterScreen;`

`this.Height = height;`

`this.Width = width;`

`}`

`}`

您现在可以更新您的`Startup`事件处理程序来简单地直接创建一个`MainWindow`的实例，就像这样:

`static void AppStartUp(object sender, StartupEventArgs e)`

`{`

`// Create a MainWindow object.`

`var main = new MainWindow("My better WPF App!", 200, 300);`

`main.Show();`

`}`

一旦程序被重新编译和执行，输出是相同的。显而易见的好处是，您现在有了一个强类型的类来表示要构建的主窗口。

Note

当你创建一个`Window`(或`Window` -derived)对象时，它将自动被添加到`Application`类的 windows 集合中(通过在`Window`类本身中找到的一些构造器逻辑)。您可以使用`Application.Windows`属性遍历当前内存中的`Window`对象列表。

### 创建简单的用户界面

在 C#代码中添加一个 UI 元素(比如一个`Button`)到一个`Window`将涉及以下基本步骤:

Define a member variable to represent the control.   Configure the control’s look and feel upon `Window` construction.   Assign the control to the inherited `Content` property, or alternatively, as a parameter to the inherited `AddChild()` method.  

回想一下，WPF 控件内容模型要求将`Content`属性设置为单个元素。当然，只包含一个 UI 控件的`Window`是没有用的。因此，几乎在每种情况下，分配给`Content`属性的“单个内容”实际上是一个布局管理器，例如`DockPanel`、`Grid`、`Canvas`或`StackPanel`。在布局管理器中，可以有内部控件的任意组合，包括其他嵌套的布局管理器。(在第 27 章中阅读更多关于 WPF 发展的信息。)

现在，您将向您的`Window`派生类添加一个单独的`Button`控件。当你点击按钮时，你将关闭当前窗口，这将间接地终止应用程序，因为你在内存中没有其他窗口。思考下面对`MainWindow`类的更新(确保您已经导入了`System.Windows.Controls`来访问`Button`类):

`class MainWindow : Window`

`{`

`// Our UI element.`

`private Button btnExitApp = new Button();`

`public MainWindow(string windowTitle, int height, int width)`

`{`

`// Configure button and set the child control.`

`btnExitApp.Click += new RoutedEventHandler(btnExitApp_Clicked);`

`btnExitApp.Content = "Exit Application";`

`btnExitApp.Height = 25;`

`btnExitApp.Width = 100;`

`// Set the content of this window to a single button.`

`this.Content = btnExitApp;`

`// Configure the window.`

`this.Title = windowTitle;`

`this.WindowStartupLocation = WindowStartupLocation.CenterScreen;`

`this.Height = height;`

`this.Width = width;`

`this.Show();`

`}`

`private void btnExitApp_Clicked(object sender, RoutedEventArgs e)`

`{`

`// Close the window.`

`this.Close();`

`}`

`}`

注意，WPF `Button`的`Click`事件与名为`RoutedEventHandler`的委托协同工作，这就引出了一个问题，什么是路由事件？您将在下一章中研究 WPF 事件模型的细节；现在，简单地理解一下，`RoutedEventHandler`委托的目标必须提供一个`object`作为第一个参数，一个`RoutedEventArgs`作为第二个参数。

无论如何，在你重新编译并运行这个应用程序后，你会发现如图 [26-6](#Fig6) 所示的定制窗口。请注意，您的按钮被自动放置在窗口客户区的正中央；当内容没有放置在 WPF 面板类型中时，这是默认行为。

![A978-1-4842-1332-2_26_Fig6_HTML.jpg](img/A978-1-4842-1332-2_26_Fig6_HTML.jpg)

图 26-6。

A simple WPF application writen entirely in C# code

### 与应用程序级数据交互

回想一下，`Application`类定义了一个名为`Properties`的属性，它允许您通过类型索引器定义一组名称/值对。因为这个索引器被定义为在类型`System.Object`上操作，所以您可以在这个集合中存储任何种类的项目(包括您的自定义类)，以便在以后使用友好的名字对象进行检索。使用这种方法，在 WPF 应用程序的所有窗口之间共享数据变得很简单。

举例来说，您将更新当前的`Startup`事件处理程序，以检查名为`/GODMODE`(许多 PC 视频游戏的常见欺骗代码)的值的传入命令行参数。如果找到这个标记，您将在同名的 properties 集合中建立一个设置为`true`的`bool`值(否则，您将把该值设置为`false`)。

听起来很简单，但是如何将传入的命令行参数(通常从`Main()`方法获得)传递给`Startup`事件处理程序呢？一种方法是调用静态的`Environment.GetCommandLineArgs()`方法。然而，这些相同的参数被自动添加到传入的`StartupEventArgs`参数中，并且可以通过`Args`属性来访问。也就是说，这是对当前代码库的第一次更新:

`private static void AppStartUp(object sender, StartupEventArgs e)`

`{`

`// Check the incoming command-line arguments and see if they`

`// specified a flag for /GODMODE.`

`Application.Current.Properties["GodMode"] = false;`

`foreach(string arg in e.Args)`

`{`

`if (arg.ToLower() == "/godmode")`

`{`

`Application.Current.Properties["GodMode"] = true;`

`break;`

`}`

`}`

`// Create a MainWindow object.`

`MainWindow wnd = new MainWindow("My better WPF App!", 200, 300);`

`}`

可以从 WPF 应用程序中的任何位置访问应用程序范围的数据。您需要做的就是获得一个全局应用程序对象的访问点(通过`Application.Current`)并研究这个集合。例如，您可以这样更新`Button`的`Click`事件处理程序:

`private void btnExitApp_Clicked(object sender, RoutedEventArgs e)`

`{`

`// Did user enable /godmode?`

`if((bool)Application.Current.Properties["GodMode"])`

`{`

`MessageBox.Show("Cheater!");`

`}`

`this.Close();`

`}`

这样，如果最终用户通过

`WpfAppAllCode.exe /godmode`

当终止应用程序时，他或她将看到显示的可耻的消息框。

Note

回想一下，您可以在 Visual Studio 中提供命令行参数。只需双击解决方案资源管理器中的属性图标，在结果编辑器中单击 Debug 选项卡，然后在“命令行参数”编辑器中输入`/godmode`。

### 处理窗口对象的关闭

最终用户可以使用许多内置的系统级技术(例如，单击窗口框架上的“x”关闭按钮)或通过间接调用`Close()`方法来响应一些用户交互元素(例如，文件➤退出)来关闭窗口。在这两种情况下，WPF 都提供了两个事件，您可以截取这两个事件来确定用户是否真的准备好关闭窗口并将其从内存中移除。第一个触发的事件是`Closing`，它与`CancelEventHandler`委托一起工作。

该委托期望目标方法将`System.ComponentModel.CancelEventArgs`作为第二个参数。`CancelEventArgs`提供了`Cancel`属性，当设置为`true`时，将阻止窗口实际关闭(当您询问用户是否真的想关闭窗口，或者他是否想先保存他的工作时，这很方便)。

如果用户确实希望关闭窗口，可以将`CancelEventArgs.Cancel`设置为`false`(默认设置)。这将导致`Closed`事件被触发(与`System.EventHandler`委托一起工作)，使它成为窗口将要被永久关闭的点。

通过将这些代码语句添加到当前构造函数中，更新`MainWindow`类来处理这两个事件，如下所示:

`public MainWindow(string windowTitle, int height, int width)`

`{`

`...`

`this.Closing += MainWindow_Closing;`

`this.Closed += MainWindow_Closed;`

`}`

现在，实现相应的事件处理程序，如下所示:

`private void MainWindow_Closing(object sender,`

`System.ComponentModel.CancelEventArgs e)`

`{`

`// See if the user really wants to shut down this window.`

`string msg = "Do you want to close without saving?";`

`MessageBoxResult result = MessageBox.Show(msg,`

`"My App", MessageBoxButton.YesNo, MessageBoxImage.Warning);`

`if (result == MessageBoxResult.No)`

`{`

`// If user doesn’t want to close, cancel closure.`

`e.Cancel = true;`

`}`

`}`

`private void MainWindow_Closed(object sender, EventArgs e)`

`{`

`MessageBox.Show("See ya!");`

`}`

现在，运行您的程序并尝试关闭窗口，方法是单击窗口右上角的“X”图标或单击按钮控件。你应该会看到如图 [26-7](#Fig7) 所示的确认对话框。

![A978-1-4842-1332-2_26_Fig7_HTML.jpg](img/A978-1-4842-1332-2_26_Fig7_HTML.jpg)

图 26-7。

Trapping the closing event of a window

如果单击“是”按钮，应用程序将终止；但是，单击“否”按钮会将该窗口保留在内存中。

### 拦截鼠标事件

WPF API 提供了许多可以捕捉的事件，以便与鼠标进行交互。具体来说，`UIElement`基类定义了许多以鼠标为中心的事件，比如`MouseMove`、`MouseUp`、`MouseDown`、`MouseEnter`、`MouseLeave`等等。

例如，考虑处理`MouseMove`事件的行为。该事件与`System.Windows.Input.MouseEventHandler`委托协同工作，该委托期望其目标将一个`System.Windows.Input.MouseEventArgs`类型作为第二个参数。使用`MouseEventArgs`，您可以提取出鼠标的(x，y)位置和其他相关细节。考虑以下部分定义:

`public class MouseEventArgs : InputEventArgs`

`{`

`...`

`public Point GetPosition(IInputElement relativeTo);`

`public MouseButtonState LeftButton { get; }`

`public MouseButtonState MiddleButton { get; }`

`public MouseDevice MouseDevice { get; }`

`public MouseButtonState RightButton { get; }`

`public StylusDevice StylusDevice { get; }`

`public MouseButtonState XButton1 { get; }`

`public MouseButtonState XButton2 { get; }`

`}`

Note

`XButton1`和`XButton2`属性允许您与“扩展鼠标按钮”交互(例如一些鼠标控件上的“下一个”和“上一个”按钮)。这些通常用于与浏览器的历史列表交互，以便在访问过的页面之间导航。

方法允许你获得相对于窗口中 UI 元素的(x，y)值。如果您对捕捉相对于激活窗口的位置感兴趣，只需传入`this`。在你的`MainWindow`类的构造函数中处理`MouseMove`事件，就像这样:

`public MainWindow(string windowTitle, int height, int width)`

`{`

`...`

`this.MouseMove += MainWindow_MouseMove;`

`}`

这里有一个`MouseMove`的事件处理程序，它将在窗口的标题区域显示鼠标的位置(注意，您正在通过`ToString()`将返回的`Point`类型转换为文本值):

`private void MainWindow_MouseMove(object sender,`

`System.Windows.Input.MouseEventArgs e)`

`{`

`// Set the title of the window to the current (x,y) of the mouse.`

`this.Title = e.GetPosition(this).ToString();`

`}`

### 截取键盘事件

为聚焦窗口处理键盘输入也非常简单。`UIElement`定义了许多事件，您可以通过捕获这些事件来截取活动元素上键盘的按键(例如`KeyUp`、`KeyDown`)。`KeyUp`和`KeyDown`事件都与`System.Windows.Input.KeyEventHandler`委托一起工作，委托期望目标的第二个事件处理程序是`KeyEventArgs`类型，它定义了几个感兴趣的公共属性，如下所示:

`public class KeyEventArgs : KeyboardEventArgs`

`{`

`...`

`public bool IsDown { get; }`

`public bool IsRepeat { get; }`

`public bool IsToggled { get; }`

`public bool IsUp { get; }`

`public Key Key { get; }`

`public KeyStates KeyStates { get; }`

`public Key SystemKey { get; }`

`}`

为了说明如何在`MainWindow`的构造函数中处理`KeyDown`事件(就像您对前面事件所做的那样)，实现下面的事件处理程序，它用当前按下的键来改变按钮的内容:

`private void MainWindow_KeyDown(object sender, System.Windows.Input.KeyEventArgs e)`

`{`

`// Display key press on the button.`

`btnExitApp.Content = e.Key.ToString();`

`}`

图 [26-8](#Fig8) 展示了你的第一个 WPF 项目的最终产品。

![A978-1-4842-1332-2_26_Fig8_HTML.jpg](img/A978-1-4842-1332-2_26_Fig8_HTML.jpg)

图 26-8。

Your first WPF program, 100 percent XAML free

在本章的这一点上，WPF 可能看起来只不过是另一个 GUI 框架，提供(或多或少)与 Windows 窗体、MFC 或 VB6 相同的服务。如果事实上是这样的话，您可能会质疑是否还需要另一个 UI 工具包。要真正了解 WPF 的独特之处，需要理解基于 XML 的语法，XAML。

Source Code

WpfAppAllCode 项目包含在 [`Chapter 26`](26.html) 子目录中。

## 仅使用 XAML 构建 WPF 应用程序

典型的 WPF 应用程序不会像您在第一个例子中所做的那样完全由代码组成。相反，你的 C#代码文件将与一个相关的 XAML 源文件配对，它们一起代表了一个给定的`Window`或`Application`的整体，以及你还没有检查过的其他类类型，比如`UserControl`和`Page`。

这种方法被称为构建 WPF 应用程序的代码文件方法，您将在本书 WPF 部分的剩余内容中广泛使用这种技术。但是，在此之前，下一个示例将演示如何仅使用 XAML 文件构建一个 WPF 应用程序。虽然不推荐这种百分之百的 XAML 方法，但它将帮助您清楚地理解标记块是如何转换成相应的 C#代码库，并最终转换成. NET 程序集的。

Note

下一个例子将使用一些您还没有正式研究过的 XAML 技术，所以如果您遇到一些不熟悉的语法，请不要担心。您可能希望简单地将解决方案文件加载到一个文本编辑器中，然后跟着做；但是，不要用 Visual Studio 这样做！Visual Studio 将自动对内容进行更改，并干扰本节的目标。您将有足够的时间来使用 VS2015 创建 WPF 应用程序。只是还没有。

一般来说，XAML 文件将包含描述窗口外观的标记，而相关的 C#代码文件包含实现逻辑。例如，`Window`的 XAML 文件可能会描述整个布局系统、该布局系统中的控件，并指定各种事件处理程序的名称。相关的 C#文件将包含这些事件处理程序的实现逻辑和应用程序所需的任何自定义代码。

XAML 是一种基于 XML 的语法，它允许您定义一棵。NET 对象。当用 WPF 构建 ui 时，经常使用 XAML，但实际上它可以用来描述任何非抽象的树。NET 类型(包括您自己在自定义。NET 程序集)，前提是每个都支持默认构造函数。正如您将看到的，`*.xaml`文件中的标记被转换成一个完整的对象模型。

因为 XAML 是一种基于 XML 的语法，所以我们获得了 XML 给我们带来的所有好处(和缺点)。从好的方面来说，XAML 文件是非常自描述的(任何 XML 文档都应该如此)。总的来说，XAML 文件中的每个元素代表给定文件中的一个类型名(如`Button`、`Window`或`Application`)。NET 命名空间。开始元素范围内的属性映射到属性(`Height`、`Width`等)。)和事件(`Startup`、`Click`等)。)的指定类型。

鉴于 XAML 只是一种定义对象状态的声明性方式，因此可以通过标记或程序代码来定义 WPF 小部件。例如，这个 XAML

`<!--``Defining a WPF Button in XAML`T2】

`<Button Name = "btnClickMe" Height = "40" Width = "100" Content = "Click Me" />`

可以用编程方式表示为

`// Defining the same WPF Button in C# code.`

`Button btnClickMe = new Button();`

`btnClickMe.Height = 40;`

`btnClickMe.Width = 100;`

`btnClickMe.Content = "Click Me";`

不利的一面是，XAML 可能很冗长，而且(像任何 XML 文档一样)区分大小写。因此，复杂的 XAML 定义会导致大量的标记。大多数开发人员不需要手动编写他们的 WPF 应用程序的完整 XAML 描述。更确切地说，这项任务的大部分(谢天谢地)将被交付给开发工具，如 Visual Studio、Microsoft Expression Blend 或任何数量的第三方产品。工具生成基本标记后，如果需要，您可以手动微调 XAML 定义。

### 在 XAML 定义窗口对象

虽然工具可以为您生成大量的 XAML，但是理解 XAML 语法的基本工作原理以及这些标记如何最终被转换成有效的。NET 程序集。为了演示 XAML 的运行，在下一个例子中，您将只使用一对`*.xaml`文件来构建一个 WPF 应用程序。

第一个`Window`派生类(`MainWindow)`在 C#中被定义为扩展`System.Windows.Window`基类的类类型。这个类包含一个单独的`Button`对象，当被点击时调用一个注册的事件处理程序。在 XAML 语法中定义同样的`Window`类型可以如下实现。首先，使用一个简单的文本编辑器(比如记事本)创建一个名为`MainWindow.xaml`的新文件，并确保将其保存在`C:`驱动器上一个易于访问的子目录中，因为您将在命令行中处理该文件。现在，添加以下 XAML:

`<!--``Here is your Window definition`T2】

`<Window x:Class="WpfAppAllXaml.MainWindow"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`Title="A Window built using 100% XAML"`

`Height="200" Width="300"`

`WindowStartupLocation ="CenterScreen">`

`<Windows.Content>`

`<!--``This window has a single button as content`T2】

`<Button x:Name="btnExitApp" Width="133" Height="24"`

`Content = "Close Window" Click ="btnExitApp_Clicked"/>`

`</Window.Content>`

`<!--``The implementation of your button’s Click event handler!`T2】

`<x:Code>`

`<![CDATA[`

`private void btnExitApp_Clicked(object sender, RoutedEventArgs e)`

`{`

`this.Close();`

`}`

`]]>`

`</x:Code>`

`</Window>`

首先，注意根元素`<Window>`使用了`Class`属性，该属性用于指定处理 XAML 文件时将生成的 C#类的名称。还要注意的是，`Class`属性以`x:`标签前缀为前缀。如果查看开始的`<Window>`元素，您会看到这个 XML 标记前缀被分配给字符串“ [`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml) ”来构建 XML 名称空间声明。在本章的稍后部分，您将理解这些 XML 名称空间定义的细节，但是现在，只要注意，任何时候您想要引用由“[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)”XAML 名称空间定义的项目，您必须在前缀前面加上`x:`标记。

在`<Window>`开始标记的范围内，您已经为`Title`、`Height`、`Width`和`WindowStartupLocation`属性指定了值，这些值直接映射到由`PresentationFramework.dll`汇编中的`System.Windows.Window`类支持的同名属性。

接下来，注意在窗口定义的范围内，您已经编写了标记来描述一个`Button`对象的外观，该对象将用于隐式设置窗口的`Content`属性。除了设置变量名(使用`x:Name` XAML 令牌)和它的总体维度，您还处理了`Button`类型的`Click`事件，方法是在`Click`事件发生时将方法分配给 delegate。

这个 XAML 文件的最后一个方面是`<x:Code>`元素，它允许您直接在`*.xaml`文件中创作事件处理程序和这个类的其他方法。作为一种安全措施，代码本身被包装在一个`CDATA`范围内，以防止 XML 解析器试图直接解释数据(尽管这并不是当前示例的严格要求)。

需要指出的是，不推荐在`<Code>`元素中使用创作功能。尽管这种“单文件方法”将所有操作隔离在一个位置，但是内联代码并没有提供 UI 标记和编程逻辑之间的清晰分离。在大多数 WPF 应用程序中，实现代码可以在一个相关的 C#文件中找到(您最终会找到)。

### 在 XAML 定义应用对象

记住，XAML 可以用来在标记中定义任何非抽象的东西。支持默认构造函数的. NET 类。考虑到这一点，您当然也可以在标记中定义应用程序对象。考虑新文件中的以下内容，`MyApp.xaml`:

`<!--` `The Main() method seems to be missing!`

`However, the StartupUri attribute is the`

`functional equivalent` `-->`

`<Application x:Class="WpfAppAllXaml.MyApp"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`StartupUri="MainWindow.xaml">`

`</Application>`

在这里，你可能会同意，`Application`派生的 C#类类型和它的 XAML 描述之间的映射不像你的`MainWindow`的 XAML 定义那样清晰。确切地说，似乎没有任何`Main()`方法的痕迹。鉴于任何。NET 可执行文件必须有一个程序入口点，部分基于`StartupUri`属性，假设它是在编译时生成的是正确的。分配给`StartupUri`的值表示应用程序启动时要加载哪个 XAML 资源。在这个例子中，您已经将`StartupUri`属性设置为定义初始`Window`对象`MainWindow.xaml`的 XAML 资源的名称。

虽然`Main()`方法是在编译时自动创建的，但是您可以自由地使用`<x:Code>`元素来捕获其他 C#代码块。例如，如果您想在程序关闭时显示一条消息，您可以处理`Exit`事件并实现它(注意开始的`<Application>`元素现在已经设置了`Exit`属性来捕获`Application`类的`Exit`事件):

`<Application x:Class="WpfAppAllXaml.MyApp"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`StartupUri="MainWindow.xaml" Exit ="AppExit">`

`<x:Code>`

`<![CDATA[`

`private void AppExit(object sender, ExitEventArgs e)`

`{`

`MessageBox.Show("App has exited");`

`}`

`]]>`

`</x:Code>`

`</Application>`

### 使用 msbuild.exe 处理 XAML 文件

此时，您已经准备好将标记转换成有效的。NET 程序集。但是，您不能直接使用 C#编译器来这样做。迄今为止，C#编译器还没有对 XAML 标记的本地理解。然而，`msbuild.exe`命令行实用程序确实知道如何将 XAML 转换成 C#代码，并在被告知正确的`*.targets`文件时动态编译这些代码。

`Msbuild.exe`是一个会编译的工具。NET 代码基于包含在基于 XML 的构建脚本中的指令。事实证明，这些构建脚本文件包含的数据与 Visual Studio 生成的`*.csproj`文件中的数据完全相同。因此，可以在命令行使用`msbuild.exe`或使用 Visual Studio 本身编译一个. NET 程序。

Note

对`msbuild.exe`实用程序的全面检查超出了本章的范围。如果您想了解更多信息，请在。NET Framework 4.6 SDK 文档。

下面是一个非常简单的构建脚本，`WpfAppAllXaml.csproj`，它包含了足够的信息来告诉`msbuild.exe`如何将你的 XAML 文件转换成相关的 C#代码库:

`<Project DefaultTargets="Build"`

`xmlns="`[`http://schemas.microsoft.com/developer/msbuild/2003`](http://schemas.microsoft.com/developer/msbuild/2003)T2】

`<PropertyGroup>`

`<RootNamespace>WpfAppAllXaml</RootNamespace>`

`<AssemblyName>WpfAppAllXaml</AssemblyName>`

`<OutputType>winexe</OutputType>`

`</PropertyGroup>`

`<ItemGroup>`

`<Reference Include="System" />`

`<Reference Include="System.XAML" />`

`<Reference Include="WindowsBase" />`

`<Reference Include="PresentationCore" />`

`<Reference Include="PresentationFramework" />`

`</ItemGroup>`

`<ItemGroup>`

`<ApplicationDefinition Include="MyApp.xaml" />`

`<Page Include="MainWindow.xaml" />`

`</ItemGroup>`

`<Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />`

`</Project>`

Note

这个`*.csproj`文件不能直接加载到 Visual Studio 中，因为它只包含在命令行构建应用程序所需的最少指令。

`<PropertyGroup>`元素用于指定构建的一些基本方面，比如根名称空间、结果程序集的名称和输出类型(相当于`csc.exe`的`/target:winexe`选项)。

第一个`<ItemGroup>`指定了当前构建引用的一组外部程序集，正如您所看到的，这是本章前面检查的核心 WPF 程序集。

第二个`<ItemGroup>`有趣多了。注意，`<ApplicationDefinition>`元素的`Include`属性被分配给定义应用程序对象的`*.xaml`文件。`<Page>`的`Include`属性可用于列出由应用程序对象处理的定义窗口(和页面，在构建 XAML 浏览器应用程序时经常使用)的剩余`*.xaml`文件。

然而，这个构建脚本的神奇之处在于最后的`<Import>`元素。这里，您引用的是`Microsoft.CSharp.Targets`，它包含与 C#编译器本身交互的数据。

在任何情况下，此时您都可以使用开发人员命令提示符通过`msbuild.exe`来处理您的 XAML 数据。为此，切换到包含您的`MainWindow.xaml`、`MyApp.xaml`和`WpfAppAllXaml.csproj`文件的目录，并输入以下命令:

`msbuild WpfAppAllXaml.csproj`

构建过程完成后，您会发现您的工作目录现在包含一个`\bin`和`\obj`子目录(就像 Visual Studio 项目一样)。如果你打开`\bin\Debug`文件夹，你会发现一个新的。名为`WpfAppAllXaml.exe`的. NET 程序集。如果你在`ildasm.exe`中打开这个程序集，你可以看到你的 XAML 已经被转换成一个有效的可执行应用程序(见图 [26-9](#Fig9) )。

![A978-1-4842-1332-2_26_Fig9_HTML.jpg](img/A978-1-4842-1332-2_26_Fig9_HTML.jpg)

图 26-9。

Transforming XAML into a .NET executable? Interesting . . .

如果你通过双击可执行文件来运行你的程序，你会在屏幕上看到你的主窗口启动。

## 将标记转换为. NET 程序集

为了准确理解您的标记是如何转换成. NET 程序集的，您需要更深入地研究一下`msbuild.exe`过程，并检查一些编译器生成的文件，包括编译时嵌入到程序集中的特定二进制资源。第一个任务是了解你的`*.xaml`文件是如何转换成相应的 C#代码库的。

### 将窗口 XAML 标记映射到 C#代码

msbuild 脚本中指定的`*.targets`文件包含许多将 XAML 元素翻译成 C#代码的指令。`msbuild.exe`在处理你的`*.csproj`文件时，产生了两个格式为`*.g.cs`(其中`g`表示自动生成)的文件，保存在`\obj\Debug`目录中。根据您的`*.xaml`文件名的名称，有问题的 C#文件是`MainWindow.g.cs`和`MyApp.g.cs`。

如果你在文本编辑器中打开`MainWindow.g.cs`文件，你会发现一个名为`MainWindow`的类，它扩展了`Window`基类。这个类的名字是由`<Window>`开始标签中的`x:Class`属性直接产生的。这个类还包含一个类型为`System.Windows.Controls.Button`的成员变量，名为`btnExitApp`。在这种情况下，控件的名称基于开始的`<Button>`声明中的`x:Name`属性值。这个类还包含按钮的`Click`事件`btnExitApp_Clicked()`的处理程序。下面是编译器生成的`MainWindow.g.cs`文件的部分清单:

`public partial class MainWindow :`

`System.Windows.Window, System.Windows.Markup.IComponentConnector`

`{`

`internal System.Windows.Controls.Button btnExitApp;`

`private void btnExitApp_Clicked(object sender, RoutedEventArgs e)`

`{`

`this.Close();`

`}`

`...`

`}`

这个类定义了一个类型为`bool`(名为`_contentLoaded`)的私有成员变量，它在 XAML 标记中没有被直接考虑。这个数据成员用于确定(并确保)窗口的内容只被分配一次。

`public partial class MainWindow :`

`System.Windows.Window, System.Windows.Markup.IComponentConnector`

`{`

`// This member variable will be explained soon enough.`

`private bool _contentLoaded;`

`...`

`}`

注意，编译器生成的类还显式实现了在`System.Windows.Markup`名称空间中定义的 WPF `IComponentConnector`接口。该接口定义了一个名为`Connect()`的方法，该方法已经被实现来准备标记中定义的每个控件，并按照原始`MainWindow.xaml`文件中指定的那样装配事件逻辑。在方法完成之前，`_contentLoaded`成员变量被设置为`true`。这是该方法的关键:

`void System.Windows.Markup.IComponentConnector.Connect(int connectionId, object target)`

`{`

`switch (connectionId)`

`{`

`case 1:`

`this.btnExitApp = ((System.Windows.Controls.Button)(target));`

`this.btnExitApp.Click += new`

`System.Windows.RoutedEventHandler(this.btnExitApp_Clicked);`

`return;`

`}`

`this._contentLoaded = true;`

`}`

最后但同样重要的是，`MainWindow`类还定义并实现了一个名为`InitializeComponent()`的方法。您可能希望这个方法包含通过设置各种属性(`Height`、`Width`、`Content`等)来设置每个控件的外观和感觉的代码。).然而事实并非如此！那么控件如何呈现正确的用户界面呢？带有`InitializeComponent()`的逻辑解析与原始`*.xaml`文件同名的嵌入式汇编资源的位置，如下所示:

`public void InitializeComponent()`

`{`

`if (_contentLoaded)`

`{`

`return;`

`}`

`_contentLoaded = true;`

`System.Uri resourceLocater = new`

`System.Uri("/WpfAppAllXaml;component/mainwindow.xaml",`

`System.UriKind.Relative);`

`System.Windows.Application.LoadComponent(this, resourceLocater);`

`}`

此时，问题变成了，这个嵌入式资源到底是什么？

### BAML 的角色

当`msbuild.exe`处理你的`*.csproj`文件时，它生成一个扩展名为`*.baml`的文件。这个文件的全名是根据最初的`MainWindow.xaml`文件命名的。因此，您应该会在`\obj\Debug`文件夹中看到一个名为`MainWindow.baml`的文件(参见图 [26-10](#Fig10) )。

![A978-1-4842-1332-2_26_Fig10_HTML.jpg](img/A978-1-4842-1332-2_26_Fig10_HTML.jpg)

图 26-10。

BAML is simply a compact, binary version of XAML

正如您可能从名称中猜到的那样，二进制应用程序标记语言(BAML)是原始 XAML 数据的一种紧凑的二进制表示。这个`*.baml`文件作为资源(通过一个生成的`*.g.resources`文件)嵌入到编译后的程序集中。

这个 BAML 资源包含了建立 UI 小部件的外观所需的所有数据(同样，比如`Height`和`Width`属性)。

这里重要的一点是理解 WPF 应用程序本身包含标记的二进制表示(BAML)。在运行时，这个 BAML 将从资源容器中提取出来，用于确保所有的窗口和控件都被初始化为正确的外观。

另外，请记住，这些二进制资源的名称与您创作的独立`*.xaml`文件的名称相同。然而，这并不意味着您必须将松散的`*.xaml`文件与您编译的 WPF 程序一起分发。除非您构建了一个 WPF 应用程序，可以在运行时动态加载和解析`*.xaml`文件，否则您永远不需要发送原始标记。

### 将应用程序 XAML 标记映射到 C#代码

要检查的自动生成代码的最后一部分是`MyApp.g.cs`文件。在这里，你可以看到你的`Application`派生类有一个合适的`Main()`入口点方法。该方法的实现在`Application`派生的类型上调用`InitializeComponent()`，这反过来设置`StartupUri`属性，允许每个对象基于二进制 XAML 定义建立其正确的属性设置。

`namespace WpfAppAllXaml`

`{`

`public partial class MyApp : System.Windows.Application`

`{`

`void AppExit(object sender, ExitEventArgs e)`

`{`

`MessageBox.Show("App has exited");`

`}`

`[System.Diagnostics.DebuggerNonUserCodeAttribute()]`

`public void InitializeComponent()`

`{`

`this.Exit += new System.Windows.ExitEventHandler(this.AppExit);`

`this.StartupUri = new System.Uri("MainWindow.xaml", System.UriKind.Relative);`

`}`

`[System.STAThreadAttribute()]`

`[System.Diagnostics.DebuggerNonUserCodeAttribute()]`

`public static void Main() {`

`WpfAppAllXaml.MyApp app = new WpfAppAllXaml.MyApp();`

`app.InitializeComponent();`

`app.Run();`

`}`

`}`

`}`

### XAML 到装配流程总结

至此，你已经只用两个 XAML 文件和一个相关的构建脚本创建了一个成熟的 WPF 程序。如您所见，`msbuild.exe`利用在`*.targets`文件中定义的辅助设置来处理构建过程的 XAML 文件(并生成`*.baml`)。图 [26-11](#Fig11) 展示了`*.xaml`文件编译时处理的整体情况。

![A978-1-4842-1332-2_26_Fig11_HTML.gif](img/A978-1-4842-1332-2_26_Fig11_HTML.gif)

图 26-11。

The XAML-to-assembly compile-time process

希望您现在对如何使用 XAML 数据构建. NET 应用程序有了更好的了解。至此，您已经准备好了解 XAML 本身的语法和语义了。

Source Code

WpfAppAllXaml 项目可以在 [`Chapter 26`](26.html) 子目录中找到。

## 理解 WPF·XAML 的句法

生产级 WPF 应用程序通常会利用专用工具来生成必要的 XAML。尽管这些工具很有帮助，但是理解 XAML 标记的整体结构是一个非常好的主意。为了帮助你的学习过程，请允许我介绍一个非常流行的(免费的)工具，它可以让你轻松地体验 XAML。

### Kaxaml 简介

当你第一次学习 XAML 语法时，使用一个名为 Kaxaml 的免费工具会很有帮助。您可以从以下网站获得这个流行的 XAML 编辑器/解析器:

[T2`http://www.kaxaml.com`](http://www.kaxaml.com/)

Kaxaml 很有帮助，因为它对 C#源代码、事件处理程序或实现逻辑一无所知。与使用完整的 Visual Studio WPF 项目模板相比，这是一种更直接的测试 XAML 代码片段的方法。此外，Kaxaml 有许多集成的工具，如颜色选择器，xaml 片段管理器，甚至还有一个“XAML 洗涤器”选项，可以根据您的设置格式化您的 XAML。当您第一次打开 Kaxaml 时，您会发现一个`<Page>`控件的简单标记，如下所示:

`<Page`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`<Grid>`

`</Grid>`

`</Page>`

像`Window`一样，`Page`包含各种布局管理器和控件。然而，与`Window`不同，`Page`对象不能作为独立实体运行。相反，它们必须放在一个合适的主机中，比如`NavigationWindow`、`Frame`，或者一个网络浏览器(在这种情况下，你就完成了一个 XBAP！).好消息是，您可以在`<Page>`或`<Window>`范围内键入相同的标记。

Note

如果您将 Kaxaml 标记窗口中的`<Page>`和`</Page>`元素更改为`<Window>`和`</Window>`，您可以按 F5 键将一个新窗口加载到屏幕上。

作为初始测试，在工具底部的 XAML 窗格中输入以下标记:

`<Page`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`<Grid>`

`<!--``A button with custom content`T2】

`<Button Height="100" Width="100">`

`<Ellipse Fill="Green" Height="50" Width="50"/>`

`</Button>`

`</Grid>`

`</Page>`

现在你应该看到你的页面呈现在 Kaxaml 编辑器的上部(见图 [26-12](#Fig12) )。

![A978-1-4842-1332-2_26_Fig12_HTML.jpg](img/A978-1-4842-1332-2_26_Fig12_HTML.jpg)

图 26-12。

Kaxaml is a very helpful (and free) tool used to learn the grammar of XAML

当您使用 Kaxaml 时，请记住该工具不允许您创作任何需要代码编译的标记(但是，允许使用`x:Name`)。这包括定义一个`x:Class`属性(用于指定代码文件)，在标记中输入事件处理程序名称，或者使用任何需要代码编译的 XAML 关键字(比如`FieldModifier`或者`ClassModifier`)。任何这样做的尝试都将导致标记错误。

### XAML XML 名称空间和 XAML“关键词”

WPF XAML 文档的根元素(如`<Window>`、`<Page>`、`<UserControl>`或`<Application>`定义)几乎总是引用以下两个预定义的 XML 名称空间:

`<Page`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`<Grid>`

`</Grid>`

`</Page>`

第一个 XML 名称空间， [`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation) ，映射了一系列 WPF。NET 命名空间供当前的`*.xaml`文件使用(`System.Windows`、`System.Windows.Controls`、`System.Windows.Ink`、`System.Windows.Media`、`System.Windows.Navigation`等)。).

这种一对多的映射实际上是在 WPF 程序集(`WindowsBase.dll`、`PresentationCore.dll`和`PresentationFramework.dll`)中使用程序集级的`[XmlnsDefinition]`属性硬编码的。例如，如果您打开 Visual Studio 对象浏览器并选择`PresentationCore.dll`程序集，您将看到如下清单，它实际上导入了`System.Windows`:

`[assembly: XmlnsDefinition("`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`"System.Windows")]`

第二个 XML 名称空间， [`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml) ，用于包含特定于 XAML 的“关键字”(因为缺少更好的术语)以及`System.Windows.Markup`名称空间，如下所示:

`[assembly: XmlnsDefinition("`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`"System.Windows.Markup")]`

任何格式良好的 XML 文档的一个规则(记住，XAML 是一种基于 XML 的语法)是，开始的根元素指定一个 XML 名称空间作为主名称空间，它通常是包含最常用项的名称空间。如果根元素需要包含额外的辅助名称空间(如此处所示)，则必须使用惟一的标记前缀来定义它们(以解决任何可能的名称冲突)。按照惯例，前缀简单来说就是`x`；然而，这可以是您需要的任何唯一令牌，比如`XamlSpecificStuff`。

`<Page`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:XamlSpecificStuff="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`<Grid>`

`<!--``A button with custom content`T2】

`<Button XamlSpecificStuff:Name="button1" Height="100" Width="100">`

`<Ellipse Fill="Green" Height="50" Width="50"/>`

`</Button>`

`</Grid>`

`</Page>`

定义冗长的 XML 名称空间前缀的明显缺点是，每次 XAML 文件需要引用这个以 XAML 为中心的 XML 名称空间中定义的一个项目时，您都需要键入`XamlSpecificStuff`。鉴于`XamlSpecificStuff`需要许多额外的击键，只需坚持使用`x`。

在任何情况下，除了`x:Name`、`x:Class`和`x:Code`关键字之外， [`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml) XML 名称空间还提供了对其他 XAML 关键字的访问，其中最常见的如表 [26-9](#Tab9) 所示。

表 26-9。

XAML Keywords

<colgroup><col> <col></colgroup> 
| XAML 关键词 | 生命的意义 |
| --- | --- |
| `x:Array` | 表示 XAML 中的. NET 数组类型。 |
| `x:ClassModifier` | 允许您定义由关键字`Class`表示的 C#类(内部或公共)的可见性。 |
| `x:FieldModifier` | 允许您为根的任何命名子元素(例如，`<Window>`元素中的`<Button>`)定义类型成员(内部、公共、私有或受保护)的可见性。使用`Name` XAML 关键字定义命名元素。 |
| `x:Key` | 允许您为将放入 dictionary 元素中的 XAML 项建立一个键值。 |
| `x:Name` | 允许您指定给定 XAML 元素的生成 C#名称。 |
| `x:Null` | 代表一个`null`引用。 |
| `x:Static` | 允许您引用某个类型的静态成员。 |
| `x:Type` | C# `typeof`操作符的 XAML 等价物(它将基于所提供的名称产生一个`System.Type`)。 |
| `x:TypeArguments` | 允许您将元素建立为具有特定类型参数的泛型类型(例如，`List<int>`与`List<bool>`)。 |

除了这两个必要的 XML 名称空间声明之外，在 XAML 文档的开始元素中定义额外的标记前缀是可能的，有时也是必要的。每当您需要在 XAML 中描述外部程序集中定义的. NET 类时，通常都会这样做。

例如，假设您已经构建了一些定制的 WPF 控件，并将它们打包在一个名为`MyControls.dll`的库中。现在，如果您想创建一个使用这些控件的新的`Window`，您可以使用`clr-namespace`和`assembly`标记建立一个映射到您的库的定制 XML 名称空间。以下是创建名为`myCtrls`的标签前缀的一些示例标记，该标签前缀可用于访问库中的控件:

`<Window x:Class="WpfApplication1.MainWindow"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`xmlns:myCtrls="clr-namespace:MyControls;assembly=MyControls"`

`Title="MainWindow" Height="350" Width="525">`

`<Grid>`

`<myCtrls:MyCustomControl />`

`</Grid>`

`</Window>`

`clr-namespace`标记被分配给。NET 命名空间，而`assembly`标记被设置为外部`*.dll`程序集的友好名称。您可以将此语法用于任何外部。您希望在标记中操作的. NET 库。虽然目前还不需要这样做，但以后的章节将要求您定义自定义的 XML 名称空间声明来描述标记中的类型。

Note

如果需要在作为当前程序集一部分的标记中定义一个类，但在不同的。NET 命名空间中，您的`xmlns`标记前缀是在没有`assembly=`属性的情况下定义的，如下所示:

`xmlns:myCtrls="clr-namespace:SomeNamespaceInMyApp"`

### 控制类和成员变量的可见性

在接下来的章节中，你会在需要的地方看到很多这样的关键词；然而，作为一个简单的例子，考虑下面的 XAML `<Window>`定义，它使用了`ClassModifier`和`FieldModifier`关键字，以及`x:Name`和`x:`T5(记住`kaxaml.exe`不允许您使用任何需要代码编译的 XAML 关键字，比如`x:Code`、`x:FieldModifier`或`x:ClassModifier`):

`<!--``This class will now be declared internal in the *.g.cs file`T2】

`<Window x:Class="MyWPFApp.MainWindow" x:ClassModifier ="internal"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`<!--``This button will be public in the *.g.cs file`T2】

`<Button x:Name ="myButton" x:FieldModifier ="public" Content = "OK"/>`

`</Window>`

默认情况下，所有 C#/XAML 类型定义都是公共的，而成员默认为内部的。然而，基于您的 XAML 定义，最终自动生成的文件包含一个带有公共`Button`变量的内部类类型。

`internal` `partial class MainWindow : System.Windows.Window,`

`System.Windows.Markup.IComponentConnector`

`{`

`public` `System.Windows.Controls.Button myButton;`

`...`

`}`

### XAML 元素、XAML 属性和类型转换器

在建立了根元素和任何必需的 XML 名称空间之后，下一个任务是用子元素填充根元素。在现实世界的 WPF 应用程序中，这个孩子将是一个布局管理器(比如一个`Grid`或`StackPanel`)，它依次包含任意数量的描述用户界面的附加 UI 元素。下一章将详细研究这些布局管理器，所以现在假设您的`<Window>`类型将包含一个`Button`元素。

正如你在本章已经看到的，XAML 元素映射到一个给定的类或结构类型。NET 命名空间，而开始元素标记中的属性映射到该类型的属性或事件。举例来说，在 Kaxaml 中输入下面的`<Button>`定义:

`<Page`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`<Grid>`

`<!-- Configure the look and feel of a Button -->`

`<Button Height="50" Width="100" Content="OK!"`

`FontSize="20" Background="Green" Foreground="Yellow"/>`

`</Grid>`

`</Page>`

请注意，分配给每个属性的值已经被捕获为一个简单的文本值。这看起来像是完全不匹配的数据类型，因为如果你在 C#代码中使用这个`Button`，你不会将 string 对象分配给这些属性，而是使用特定的数据类型。例如，下面是用代码创作的同一个按钮:

`public void MakeAButton()`

`{`

`Button myBtn = new Button();`

`myBtn.Height = 50;`

`myBtn.Width = 100;`

`myBtn.FontSize = 20;`

`myBtn.Content = "OK!";`

`myBtn.Background = new SolidColorBrush(Colors.Green);`

`myBtn.Foreground = new SolidColorBrush(Colors.Yellow);`

`}`

事实证明，WPF 附带了许多类型转换器类，用于将简单的文本值转换为正确的底层数据类型。这个过程透明地(并且自动地)发生。

虽然这很好，但是很多时候您需要为 XAML 属性分配一个更复杂的值，而这个值不能作为一个简单的字符串被捕获。例如，假设您想要构建一个自定义画笔来设置`Button`的`Background`属性。如果您正在用代码构建画笔，这非常简单，如下所示:

`public void MakeAButton()`

`{`

`...`

`// A fancy brush for the background.`

`LinearGradientBrush fancyBruch =`

`new LinearGradientBrush(Colors.DarkGreen, Colors.LightGreen, 45);`

`myBtn.Background = fancyBruch;`

`myBtn.Foreground = new SolidColorBrush(Colors.Yellow);`

`}`

但是，如何将复杂的画笔表示为字符串呢？嗯，你不能！幸运的是，XAML 提供了一种特殊的语法，当您需要为复杂对象分配属性值时，可以使用这种语法，称为属性元素语法。

### 理解 XAML 属性元素语法

属性元素语法允许您将复杂对象分配给属性。下面是一个对使用一个`LinearGradientBrush`来设置其`Background`属性的`Button`的 XAML 描述:

`<Button Height="50" Width="100" Content="OK!"`

`FontSize="20" Foreground="Yellow">`

`<Button.Background>`

`<LinearGradientBrush>`

`<GradientStop Color="DarkGreen" Offset="0"/>`

`<GradientStop Color="LightGreen" Offset="1"/>`

`</LinearGradientBrush>`

`</Button.Background>`

`</Button>`

注意，在`<Button>`和`</Button>`标记的范围内，您已经定义了一个名为`<Button.Background>`的子范围。在这个范围内，您已经定义了一个自定义的`<LinearGradientBrush>`。(不用担心画笔的确切代码；你会在第 28 章的[中了解到 WPF 图形。)](28.html)

一般来说，任何属性都可以使用属性元素语法来设置，这通常可以分解为以下模式:

`<DefiningClass>`

`<DefiningClass.PropertyOnDefiningClass>`

`<!--``Value for Property here!`T2】

`</DefiningClass.PropertyOnDefiningClass>`

`</DefiningClass>`

虽然可以使用这种语法设置任何属性，但是如果可以将一个值捕获为一个简单的字符串，就可以节省键入时间。例如，这里有一个更详细的方法来设置您的`Button`的`Width`:

`<Button Height="50" Content="OK!"`

`FontSize="20" Foreground="Yellow">`

`...`

`<Button.Width>`

`100`

`</Button.Width>`

`</Button>`

### 了解 XAML 附加属性

除了属性元素语法之外，XAML 还定义了一种特殊的语法，用于为附加属性设置值。本质上，附加的属性允许子元素设置在父元素中实际定义的属性的值。要遵循的通用模板如下所示:

`<ParentElement>`

`<ChildElement ParentElement.PropertyOnParent = "Value">`

`</ParentElement>`

附加属性语法最常见的用法是将 UI 元素放置在 WPF 布局管理器的一个类中(`Grid`、`DockPanel`等)。).下一章将详细介绍这些面板；现在，在 Kaxaml 中输入以下内容:

`<Page`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`<Canvas Height="200" Width="200" Background="LightBlue">`

`<Ellipse Canvas.Top="40" Canvas.Left="40" Height="20" Width="20" Fill="DarkBlue"/>`

`</Canvas>`

`</Page>`

这里，您已经定义了一个包含一个`Ellipse`的`Canvas`布局管理器。请注意，`Ellipse`能够使用附加的属性语法通知其父节点(`Canvas`)在哪里放置它的顶部/左侧位置。

关于附加属性，有一些事项需要注意。首先，这不是一个通用的语法，不能应用于任何父类的任何属性。例如，以下 XAML 无法正确解析:

`<!--``Error! Set Background property on Canvas via attached property?`T2】

`<Canvas Height="200" Width="200">`

`<Ellipse Canvas.Background="LightBlue"`

`Canvas.Top="40" Canvas.Left="90"`

`Height="20" Width="20" Fill="DarkBlue"/>`

`</Canvas>`

实际上，附加属性是 WPF 特有概念的一种特殊形式，称为依赖属性。除非属性是以非常特定的方式实现的，否则不能使用附加属性语法设置其值。你将在第 27 章中详细探讨依赖属性。

Note

Kaxaml、Visual Studio 和 Expression Blend(Visual Studio 2015 附带的免费配套工具，可用于编辑基于 xaml 的应用程序)都具有智能感知，它将向您显示可由给定元素设置的有效附加属性。

### 了解 XAML 标记扩展

如前所述，属性值通常使用简单的字符串或通过属性元素语法来表示。但是，还有另一种方法来指定 XAML 属性的值，即使用标记扩展。标记扩展允许 XAML 解析器从专用的外部类获取属性值。这是非常有益的，因为有些属性值需要执行许多代码语句来计算值。

标记扩展提供了一种用新功能干净地扩展 XAML 语法的方法。标记扩展在内部表示为从`MarkupExtension`派生的类。请注意，您需要构建自定义标记扩展的机会微乎其微。然而，XAML 关键字的子集(如`x:Array`、`x:Null`、`x:Static`和`x:Type`)是伪装的标记扩展！

标记扩展夹在大括号之间，就像这样:

`<Element PropertyToSet = "{MarkUpExtension}"/>`

要查看一些正在运行的标记扩展，请将以下代码编写到 Kaxaml 中:

`<Page`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`xmlns:CorLib="clr-namespace:System;assembly=mscorlib">`

`<StackPanel>`

`<!--` `The Static markup extension lets us obtain a value`

`from a static member of a class` `-->`

`<Label Content ="{x:Static CorLib:Environment.OSVersion}"/>`

`<Label Content ="{x:Static CorLib:Environment.ProcessorCount}"/>`

`<!--` `The Type markup extension is a XAML verion of`

`the C# typeof operator -->`

`<Label Content ="{x:Type Button}" />`

`<Label Content ="{x:Type CorLib:Boolean}" />`

`<!--``Fill a ListBox with an array of strings!`T2】

`<ListBox Width="200" Height="50">`

`<ListBox.ItemsSource>`

`<x:Array Type="CorLib:String">`

`<CorLib:String>Sun Kil Moon</CorLib:String>`

`<CorLib:String>Red House Painters</CorLib:String>`

`<CorLib:String>Besnard Lakes</CorLib:String>`

`</x:Array>`

`</ListBox.ItemsSource>`

`</ListBox>`

`</StackPanel>`

`</Page>`

首先，注意到`<Page>`定义有一个新的 XML 名称空间声明，它允许您访问`mscorlib.dll`的`System`名称空间。建立了这个 XML 名称空间后，首先使用`x:Static`标记扩展，并从`System.Environment`类的`OSVersion`和`ProcessorCount`中获取值。

`x:Type`标记扩展允许您访问指定项目的元数据描述。这里，您只是简单地指定了 WPF `Button`和`System.Boolean`类型的完全限定名。

这个标记中最有趣的部分是`ListBox`。这里，您将`ItemsSource`属性设置为完全在标记中声明的字符串数组！注意这里的`x:Array`标记扩展如何允许你在它的范围内指定一组子项:

`<x:Array Type="CorLib:String">`

`<CorLib:String>Sun Kil Moon</CorLib:String>`

`<CorLib:String>Red House Painters</CorLib:String>`

`<CorLib:String>Besnard Lakes</CorLib:String>`

`</x:Array>`

Note

前面的 XAML 例子只是用来说明标记扩展的作用。正如你将在第 27 章中看到的，有更简单的方法来填充`ListBox`控件！

图 [26-13](#Fig13) 显示了这个`<Page>`在 Kaxaml 中的标记。

![A978-1-4842-1332-2_26_Fig13_HTML.jpg](img/A978-1-4842-1332-2_26_Fig13_HTML.jpg)

图 26-13。

Markup extensions allow you to set values via the functionality of a dedicated class

现在，您已经看到了许多展示 XAML 语法每个核心方面的例子。你可能会同意，XAML 是非常有趣的，因为它允许你描述一个树。NET 对象。虽然这在配置图形用户界面时非常有用，但请记住，XAML 可以描述任何程序集中的任何类型，只要它是包含默认构造函数的非抽象类型。

## 使用代码隐藏文件构建 WPF 应用程序

本章的前两个例子展示了使用全部代码或全部 XAML 构建 WPF 应用程序的极端情况。然而，构建任何 WPF 应用程序的推荐方法是使用代码文件方法。在这种模型下，项目的 XAML 文件只包含描述类的一般状态的标记，而代码文件包含实现细节。

### 为 MainWindow 类添加代码文件

为了进行说明，您将更新 WpfAppAllXaml 示例以使用代码文件。如果您正在跟进，请复制整个文件夹，并将其命名为 WpfAppCodeFiles。现在，在这个名为`MainWindow.xaml.cs`的文件夹中创建一个新的 C#代码文件(按照惯例，C#代码隐藏文件的名称采用`*.xaml.cs`的形式)。将以下代码添加到这个新文件中:

`// MainWindow.xaml.cs`

`using System;`

`using System.Windows;`

`using System.Windows.Controls;`

`namespace WpfAppAllXaml`

`{`

`public partial class MainWindow : Window`

`{`

`public MainWindow()`

`{`

`// Remember! This method is defined`

`// within the generated MainWindow.g.cs file.`

`InitializeComponent();`

`}`

`private void btnExitApp_Clicked(object sender, RoutedEventArgs e)`

`{`

`this.Close();`

`}`

`}`

`}`

这里，您已经定义了一个包含事件处理逻辑的分部类，该逻辑将与`*.g.cs`文件中相同类型的分部类定义合并。假设`InitializeComponent()`是在`MainWindow.g.cs`文件中定义的，那么你的窗口的构造函数就会调用来加载和处理嵌入的 BAML 资源。

`MainWindow.xaml`文件也需要更新；这仅仅包括删除以前 C#代码的所有痕迹。

`<Window x:Class="WpfAppAllXaml.MainWindow"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`Title="A Window built using Code Files!"`

`Height="200" Width="300"`

`WindowStartupLocation ="CenterScreen">`

`<Window.Content>`

`<!--``The event handler is now in your code file`T2】

`<Button x:Name="btnExitApp" Width="133" Height="24"`

`Content = "Close Window" Click ="btnExitApp_Clicked"/>`

`</Window.Content>`

`</Window>`

### 为 MyApp 类添加代码文件

如果需要，您还可以为您的`Application`派生类型构建一个代码隐藏文件。因为大部分动作发生在`MyApp.g.cs`文件中，所以`MyApp.xaml.cs`中的代码只不过如下所示:

`// MyApp.xaml.cs`

`using System;`

`using System.Windows;`

`using System.Windows.Controls;`

`namespace WpfAppAllXaml`

`{`

`public partial class MyApp : Application`

`{`

`private void AppExit(object sender, ExitEventArgs e)`

`{`

`MessageBox.Show("App has exited");`

`}`

`}`

`}`

`MyApp.xaml`文件现在看起来像这样:

`<Application x:Class="WpfAppAllXaml.MyApp"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`StartupUri="MainWindow.xaml"`

`Exit ="AppExit">`

`</Application>`

### 用 msbuild.exe 处理代码文件

在使用`msbuild.exe`重新编译您的文件之前，您需要更新您的`*.csproj`文件，以便通过`<Compile>`元素(这里以粗体显示)将新的 C#文件包含在编译过程中:

`<Project DefaultTargets="Build" xmlns=`

`"`[`http://schemas.microsoft.com/developer/msbuild/2003`](http://schemas.microsoft.com/developer/msbuild/2003)T2】

`<PropertyGroup>`

`<RootNamespace>WpfAppAllXaml</RootNamespace>`

`<AssemblyName>WpfAppAllXaml</AssemblyName>`

`<OutputType>winexe</OutputType>`

`</PropertyGroup>`

`<ItemGroup>`

`<Reference Include="System" />`

`<Reference Include="WindowsBase" />`

`<Reference Include="PresentationCore" />`

`<Reference Include="PresentationFramework" />`

`<Reference Include=”System.Xaml” />`

`</ItemGroup>`

`<ItemGroup>`

`<ApplicationDefinition Include="MyApp.xaml" />`

`<Compile Include = "MainWindow.xaml.cs" />`

`<Compile Include = "MyApp.xaml.cs" />`

`<Page Include="MainWindow.xaml" />`

`</ItemGroup>`

`<Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />`

`</Project>`

一旦您将构建脚本通过

`msbuild WpfAppAllXaml.csproj`

您将再次找到与 WpfAppAllXaml 应用程序相同的可执行程序集(位于`bin\Debug`文件夹中，记得吗？).然而，就开发而言，现在你已经有了一个清晰的表示(XAML)和编程逻辑(C#)的划分。

鉴于这是 WPF 开发的首选方法，您会很高兴知道使用 Visual Studio(或 Expression Blend)创建的 WPF 应用程序总是使用刚才介绍的代码隐藏模型。

Source Code

WpfAppCodeFiles 项目可以在 [`Chapter 26`](26.html) 子目录中找到。

## 使用 Visual Studio 构建 WPF 应用程序

在本章的过程中，你已经使用简单的文本编辑器、命令行编译器和 Kaxaml 创建了一些例子。当然，这样做的原因是为了专注于 WPF 应用程序的核心语法，而不被图形设计者的花里胡哨所分心。既然您已经了解了如何从头开始构建 WPF 应用程序，那么让我们来看看 Visual Studio 如何简化 WPF 程序的构造。

Note

在这里，我将指出使用 Visual Studio 构建 WPF 应用程序的一些关键特性。接下来的章节将在必要的地方说明 IDE 的其他方面。

### WPF 项目模板

Visual Studio 的“新建项目”对话框定义了一组 WPF 项目工作区，所有这些工作区都包含在 Visual C#根目录的窗口节点下。在这里，您可以从 WPF 应用程序、WPF 用户控件库、WPF 自定义控件库和 WPF 浏览器应用程序(即 XBAP)中进行选择。首先，创建一个名为 WpfTesterApp 的新 WPF 应用程序(参见图 [26-14](#Fig14) )。

![A978-1-4842-1332-2_26_Fig14_HTML.jpg](img/A978-1-4842-1332-2_26_Fig14_HTML.jpg)

图 26-14。

The WPF project templates of Visual Studio can be found under the Windows node

除了设置对每个 WPF 程序集(`PresentationCore.dll`、`PresentationFramework.dll`、`System.Xaml.dll`和`WindowsBase.dll`)的引用，还将为您提供初始的`Window`和`Application`派生类，每个派生类都使用 XAML 和 C#代码文件来表示。考虑图 [26-15](#Fig15) ，它显示了这个新 WPF 项目的解决方案浏览器。

![A978-1-4842-1332-2_26_Fig15_HTML.jpg](img/A978-1-4842-1332-2_26_Fig15_HTML.jpg)

图 26-15。

The initial files of a WPF application project

### 工具箱和 XAML 设计器/编辑器

Visual Studio 提供了一个工具箱(可以通过视图菜单打开)，其中包含许多 WPF 控件(参见图 [26-16](#Fig16) )。

![A978-1-4842-1332-2_26_Fig16_HTML.jpg](img/A978-1-4842-1332-2_26_Fig16_HTML.jpg)

图 26-16。

The toolbox contains the WPF controls that can be placed on the designer surface

使用标准的鼠标拖放操作，您可以将这些控件中的任何一个放置在窗口的设计器图面上，或者将控件拖动到设计器底部的 XAML 标记编辑器中。当你这样做的时候，最初的 XAML 将会以你的名义被创作。用鼠标将`Button`和`Calendar`控件拖动到设计器表面。完成后，请注意如何重新定位和调整控件的大小(并确保检查基于编辑生成的 XAML)。

除了通过鼠标和工具箱构建 UI 之外，您还可以使用集成的 XAML 编辑器手动输入标记。正如你在图 [26-17](#Fig17) 中看到的，你得到了智能感知支持，这可以帮助简化标记的创作。例如，尝试将`Background`属性添加到开始的`<Window>`元素中。

![A978-1-4842-1332-2_26_Fig17_HTML.jpg](img/A978-1-4842-1332-2_26_Fig17_HTML.jpg)

图 26-17。

The WPF Window designer

花点时间在 XAML 编辑器中直接添加一些属性值。确保你花时间去适应使用 WPF 设计器的这个方面。

### 使用“属性”窗口设置属性

将一些控件放置到设计器上(或在编辑器中手动定义它们)后，可以利用“属性”窗口来设置所选控件的属性值，以及装配所选控件的事件处理程序。通过一个简单的测试，在设计器上选择您的`Button`控件。现在，使用属性窗口通过集成的笔刷编辑器改变`Button`的`Background`颜色(见图[26-18](#Fig18)；你会在第 28 章的[里学到更多关于笔刷编辑器的知识，在你检查 WPF 图形的时候。](28.html)

![A978-1-4842-1332-2_26_Fig18_HTML.jpg](img/A978-1-4842-1332-2_26_Fig18_HTML.jpg)

图 26-18。

The Properties window can be used to configure the UI of a WPF control Note

“属性”窗口在顶部提供了一个搜索文本区域。键入要设置的属性的名称，以便快速找到有问题的项目。

在您完成了对笔刷编辑器的修改之后，检查生成的标记。它可能看起来像这样:

`<Button x:Name="button" Content="Button" HorizontalAlignment="Left" Margin="10,10,0,0"`

`VerticalAlignment="Top" Width="75">`

`<Button.Background>`

`<LinearGradientBrush EndPoint="0.5,1" StartPoint="0.5,0">`

`<GradientStop Color="#FF80EB4F" Offset="0"/>`

`<GradientStop Color="#FFCE3058" Offset="1"/>`

`<GradientStop Color="#FF8293DD" Offset="0.5"/>`

`</LinearGradientBrush>`

`</Button.Background>`

`</Button>`

### 使用“属性”窗口处理事件

如果您想要处理给定控件的事件，也可以使用“属性”窗口，但是这一次您需要单击“属性”窗口右上角的“事件”按钮(寻找闪电图标)。确保在您的设计器上选择了按钮，并定位到`Click`事件。完成后，直接双击`Click`事件条目。这将导致 Visual Studio 自动生成一个事件处理程序，该处理程序采用以下常规形式:

`NameOfControl_NameOfEvent`

因为你没有重命名你的按钮，属性窗口显示它生成了一个名为`Button_Click`的事件处理程序(见图 [26-19](#Fig19) )。

![A978-1-4842-1332-2_26_Fig19_HTML.jpg](img/A978-1-4842-1332-2_26_Fig19_HTML.jpg)

图 26-19。

Handling events using the Properties window

同样，Visual Studio 在窗口的代码文件中生成了相应的 C#事件处理程序。在这里，您可以添加任何类型的代码，这些代码必须在按钮被单击时执行。要进行快速测试，只需输入以下代码语句:

`public partial class MainWindow : Window`

`{`

`public MainWindow()`

`{`

`InitializeComponent();`

`}`

`private void Button_Click(object sender, RoutedEventArgs e)`

`{`

`MessageBox.Show("You clicked the button!");`

`}`

`}`

### 在 XAML 编辑器中处理事件

您也可以直接在 XAML 编辑器中处理事件。举个例子，将鼠标放在`<Window>`元素中，输入`MouseMove`事件，然后输入等号。一旦你这样做了，你会看到 Visual Studio 在你的代码文件中显示任何兼容的处理程序(如果它们存在的话)，以及`Create method`选项(见图 [26-20](#Fig20) )。

![A978-1-4842-1332-2_26_Fig20_HTML.jpg](img/A978-1-4842-1332-2_26_Fig20_HTML.jpg)

图 26-20。

Handling events using the XAML editor

让 IDE 创建 MouseMove 事件处理程序，输入以下代码，然后运行应用程序以查看最终结果:

`private void MainWindow_MouseMove (object sender, MouseEventArgs e)`

`{`

`this.Title = e.GetPosition(this).ToString();`

`}`

### “文档大纲”窗口

当你使用任何基于 XAML 的项目(WPF、Silverlight、Windows Phone/Windows 10 Mobile 或 Windows 10 应用程序)时，你肯定会使用大量的标记来表示你的用户界面。当您开始使用更复杂的 XAML 时，为了快速选择要在 Visual Studio 设计器上编辑的项，可视化标记会很有用。

目前，您的标记相当平淡，因为您只在初始的`<Grid>`中定义了几个控件。但是，在 IDE 中找到文档大纲窗口，默认情况下，该窗口安装在 IDE 的左下角(如果找不到，只需使用“查看其他窗口”菜单选项激活它)。现在，确保你的 XAML 设计器是 IDE 中的活动窗口(而不是 C#代码文件)，你会注意到文档轮廓显示了嵌套的元素(见图 [26-21](#Fig21) )。

![A978-1-4842-1332-2_26_Fig21_HTML.jpg](img/A978-1-4842-1332-2_26_Fig21_HTML.jpg)

图 26-21。

Visualizing your XAML via the Document Outline window

此工具还提供了一种在设计器上临时隐藏给定项(或一组项)以及锁定项以防止发生额外编辑的方法。在下一章中，您将看到文档大纲窗口如何还提供了许多其他功能来将所选项目分组到新的布局管理器中(以及其他功能)。

### 查看自动生成的代码文件

在构建本章的最后一个示例之前，找到解决方案资源管理器窗口，并点击显示所有文件按钮(参见图 [26-22](#Fig22) )。请注意，BAML 和`*.g.cs`文件存在并被考虑在内(在`obj\Debug`文件夹中)。我并不是建议你在这些自动生成的文件中添加你自己的代码，本章前面的例子应该有助于明确你的 XAML 是如何被处理的。

![A978-1-4842-1332-2_26_Fig22_HTML.jpg](img/A978-1-4842-1332-2_26_Fig22_HTML.jpg)

图 26-22。

Viewing the output files of a WPF project using Solution Explorer

## 用 Visual Studio 构建自定义 XAML 编辑器

现在你已经看到了在 Visual Studio 中用来设计 WPF 窗口的基本工具，本章的最后一个例子将带你构建一个应用程序，允许你在运行时操作 XAML。关闭当前项目，并创建一个名为 MyXamlPad 的新 WPF 应用程序。这个项目(完成后)的功能将类似于 Kaxaml，但没有额外的功能。具体来说，这个应用程序将允许您键入任何格式良好的标记，并单击一个按钮将 XAML 动态呈现到一个新的`Window`对象中。

### 设计窗口的图形用户界面

WPF API 支持以编程方式加载、解析和保存 XAML 描述。这样做在各种情况下都非常有用。例如，假设你有五个不同的 XAML 文件来描述一个`Window`类型的外观和感觉。只要每个文件中每个控件(以及任何必要的事件处理程序)的名称是相同的，就可以动态地将“皮肤”应用于窗口(可能基于传递到应用程序中的启动参数)。

在运行时与 XAML 交互围绕着`XamlReader`和`XamlWriter`类型，这两个类型都是在`System.Windows.Markup`名称空间中定义的。为了说明如何以编程方式从外部`*.xaml`文件中合成一个`Window`对象，您将构建一个模拟 Kaxaml 基本功能的应用程序。

Note

`XamlReader`和`XamlWriter`类提供了在运行时操纵 XAML 的基本功能。如果你曾经需要获得对 XAML 对象模型的完全控制，你会想要探索`System.Xaml.dll`汇编。

虽然您的应用程序肯定不会像 Kaxaml 那样功能丰富，但它将提供输入有效 xaml 标记、查看结果以及将 XAML 保存到外部文件的能力。首先，更新您的`<Window>`的初始 XAML 定义，如下所示(我建议此时手动输入 XAML；但是，使用 IDE 生成事件处理程序，如前面所示)。

Note

下一章将深入研究使用控件和面板的细节，所以不要为控件声明的细节而烦恼。

`<Window x:Class="MyXamlPad.MainWindow"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`Title="My Custom XAML Editor"`

`Height="338" Width="1041"`

`Loaded="Window_Loaded" Closed="Window_Closed"`

`WindowStartupLocation="CenterScreen">`

`<!--``You will use a DockPanel, not a Grid`T2】

`<DockPanel LastChildFill="True" >`

`<!--``This button will launch a window with defined XAML`T2】

`<Button DockPanel.Dock="Top" Name = "btnViewXaml" Width="100" Height="40"`

`Content ="View Xaml" Click="btnViewXaml_Click" />`

`<!--``This will be the area to type within`T2】

`<TextBox AcceptsReturn ="True" Name ="txtXamlData"`

`FontSize ="14" Background="Black" Foreground="Yellow"`

`BorderBrush ="Blue" VerticalScrollBarVisibility="Auto"`

`AcceptsTab="True"/>`

`</DockPanel>`

`</Window>`

首先，请注意，您已经用包含一个`Button`(名为`btnViewXaml`)和一个`TextBox`(名为`txtXamlData`)的`<DockPanel>`布局管理器替换了初始的`<Grid>`，并且已经处理了`Button`类型的`Click`事件。

还要注意的是，`Window`本身的`Loaded`和`Closed`事件已经在开始的`<Window>`元素中进行了处理(同样，使用 IDE 来生成事件处理程序，如本章前面部分所述)。如果你已经使用了设计器来处理你的事件，你应该在你的`MainWindow.xaml.cs`文件中找到下面的代码:

`public partial class MainWindow : Window`

`{`

`public MainWindow()`

`{`

`InitializeComponent();`

`}`

`private void btnViewXaml_Click(object sender, RoutedEventArgs e)`

`{`

`}`

`private void Window_Closed(object sender, EventArgs e)`

`{`

`}`

`private void Window_Loaded(object sender, RoutedEventArgs e)`

`{`

`}`

`}`

在继续之前，请确保将以下名称空间导入到您的`MainWindow.xaml.cs`文件中:

`using System.IO;`

`using System.Windows.Markup;`

### 实现加载的事件

主窗口的`Loaded`事件负责确定当前包含应用程序的文件夹中是否有一个名为`YourXaml.xaml`的文件。如果这个文件确实存在，你将读入数据并把它放到主窗口的`TextBox`中。如果没有，您将用一个空窗口的初始默认 XAML 描述来填充`TextBox`(这个描述与初始窗口定义是完全相同的标记，除了您使用的是`<StackPanel>`而不是`<Grid>`)。

Note

考虑到嵌入引用所需的转义字符，您构建的用于表示要在编辑器中显示的初始标记的字符串输入起来有点麻烦，所以请小心输入。

`private void Window_Loaded(object sender, RoutedEventArgs e)`

`{`

`// When the main window of the app loads,`

`// place some basic XAML text into the text block.`

`if (File.Exists("YourXaml.xaml"))`

`{`

`txtXamlData.Text = File.ReadAllText("YourXaml.xaml");`

`}`

`else`

`{`

`txtXamlData.Text =`

`"<Window xmlns=\"`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`+"xmlns:x=\"`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`+"Height =\"400\" Width =\"500\" WindowStartupLocation=\"CenterScreen\">\n"`

`+"<StackPanel>\n"`

`+"</StackPanel>\n"`

`+"</Window>";`

`}`

`}`

使用这种方法，您的应用程序将能够加载在以前的会话中输入的 XAML，或者在必要时提供默认的标记块。此时，你应该能够运行你的程序并在`TextBox`类型中找到如图 [26-23](#Fig23) 所示的显示。

![A978-1-4842-1332-2_26_Fig23_HTML.jpg](img/A978-1-4842-1332-2_26_Fig23_HTML.jpg)

图 26-23。

The first run of `MyXamlPad.exe`

### 实现按钮的 Click 事件

当您点击`Button`时，您将首先把`TextBox`中的当前数据保存到`YourXaml.xaml`文件中。此时，您将通过`File.Open()`读入持久化数据以获得一个`FileStream`。这是必要的，因为`XamlReader.Load()`方法需要一个`Stream`派生的类型(而不是简单的`System.String`)来表示要解析的 XAML。

在加载了您想要构建的`<Window>`的 XAML 描述之后，基于内存中的 XAML 创建一个`System.Windows.Window`的实例，并将`Window`显示为一个模态对话框，如下所示:

`private void btnViewXaml_Click(object sender, RoutedEventArgs e)`

`{`

`// Write out the data in the text block to a local *.xaml file.`

`File.WriteAllText("YourXaml.xaml", txtXamlData.Text);`

`// This is the window that will be dynamically XAML-ed.`

`Window myWindow = null;`

`// Open local *.xaml file.`

`try`

`{`

`using (Stream sr = File.Open("YourXaml.xaml", FileMode.Open))`

`{`

`// Connect the XAML to the Window object.`

`myWindow = (Window)XamlReader.Load(sr);`

`// Show window as a dialog and clean up.`

`myWindow.ShowDialog();`

`myWindow.Close();`

`myWindow = null;`

`}`

`}`

`catch (Exception ex)`

`{`

`MessageBox.Show(ex.Message);`

`}`

`}`

请注意，您将大部分逻辑包装在一个`try` / `catch`块中。这样，如果`YourXaml.xaml`文件包含格式错误的标记，您可以在结果消息框中看到您的方法的错误。例如，运行你的程序，通过在开始元素中添加一个额外的字母 P 或诸如此类的东西，故意拼错`<StackPanel>`。如果你点击按钮，你会看到一个类似图 [26-24](#Fig24) 的错误。

![A978-1-4842-1332-2_26_Fig24_HTML.jpg](img/A978-1-4842-1332-2_26_Fig24_HTML.jpg)

图 26-24。

Catching markup errors

### 实现关闭的事件

最后，您的`Window`类型的`Closed`事件将确保`TextBox`中最新最大的数据被持久化到`YourXaml.xaml`文件中。

`private void Window_Closed(object sender, EventArgs e)`

`{`

`// Write out the data in the text block to a local *.xaml file.`

`File.WriteAllText("YourXaml.xaml", txtXamlData.Text);`

`Application.Current.Shutdown();`

`}`

### 测试应用程序

现在启动你的程序，在文本区输入一些 XAML。请注意(像 Kaxaml 一样)，这个程序不允许您指定任何以代码生成为中心的 xaml 属性(比如`Class`或任何事件处理程序)。作为第一个测试，在您的`<StackPanel>`范围内输入以下 XAML:

`<Button Height = "100" Width = "100" Content = "Click Me!">`

`<Button.Background>`

`<LinearGradientBrush StartPoint = "0,0" EndPoint = "1,1">`

`<GradientStop Color = "Blue" Offset = "0" />`

`<GradientStop Color = "Yellow" Offset = "0.25" />`

`<GradientStop Color = "Green" Offset = "0.75" />`

`<GradientStop Color = "Pink" Offset = "0.50" />`

`</LinearGradientBrush>`

`</Button.Background>`

`</Button>`

当您单击该按钮时，您将看到一个窗口出现，呈现您的 XAML 定义(或者您可能会在消息框中看到一个解析错误——注意您的键入！).图 [26-25](#Fig25) 显示了可能的输出。

![A978-1-4842-1332-2_26_Fig25_HTML.jpg](img/A978-1-4842-1332-2_26_Fig25_HTML.jpg)

图 26-25。

`MyXamlPad.exe` in action

现在，在当前的`<Button>`定义后直接输入以下 XAML 标记:

`<Label Content = "Interesting...">`

`<Label.Triggers>`

`<EventTrigger RoutedEvent = "Label.Loaded">`

`<EventTrigger.Actions>`

`<BeginStoryboard>`

`<Storyboard TargetProperty = "FontSize">`

`<DoubleAnimation From = "12" To = "100" Duration = "0:0:4"`

`RepeatBehavior = "Forever"/>`

`</Storyboard>`

`</BeginStoryboard>`

`</EventTrigger.Actions>`

`</EventTrigger>`

`</Label.Triggers>`

`</Label>`

这个标记很好地展示了 XAML 的强大。当您测试这个标记时，您会注意到您已经创建了一个简单的动画序列。动画服务(以及图形渲染)将在接下来的章节中详细讨论；但是，可以随意调整 XAML，看看最终结果。

### 探索 WPF 文档

在结束这一章之前，我想指出。NET 4.6 Framework SDK 文档提供了一整节专门讨论 WPF 的内容。当您研究这个 API 并阅读剩余的以 WPF 为中心的章节时，如果您尽早并经常查阅帮助系统，将会对您自己有很大帮助。在这里，你会发现大量的示例 XAML 和详细的教程，涉及从 3D 图形编程到复杂的数据绑定操作等各种各样的主题。

WPF 文档位于。NET 框架 4.6 ➤。NET 框架开发指南➤开发客户端应用程序的路径位于 [`https://msdn.microsoft.com/en-us/library/vstudio/54xbah2z(v=vs.110)`](https://msdn.microsoft.com/en-us/library/vstudio/54xbah2z(v=vs.110)) 。

当您深入研究帮助系统的这一部分时，您将会遇到许多 XAML 的例子，您可以将它们直接复制到剪贴板并粘贴到您的自定义 XAML 编辑器中。但是，在测试之前，您需要确保根元素从`<Page>`更改为`<Window>`(如果示例使用了<页面>元素)(您的应用程序没有被编程为显示页面对象，只显示整个窗口对象)。在进入下一章之前，花点时间深入研究您感兴趣的主题，并在您的定制工具中测试额外的标记。

Source Code

MyXamlPad 项目可以在 [`Chapter 26`](26.html) 子目录中找到。

## 摘要

Windows 演示基础(WPF)是自发布以来引入的用户界面工具包。NET 3.0。WPF 的主要目标是集成和统一许多以前不相关的桌面技术(2D 图形、3D 图形、窗口和控件开发等)。)集成到一个统一的编程模型中。除此之外，WPF 程序通常使用可扩展的应用程序标记语言(XAML)，它允许你通过标记来声明你的 WPF 元素的外观和感觉。

回想一下 XAML 允许你描述。NET 对象使用声明性语法。在本章对的研究中，ou 接触到了一些新的语法，包括属性-元素语法和附加属性，以及类型转换器和标记扩展的作用。

虽然 XAML 是任何生产级 WPF 应用程序的一个关键方面，但你在本章的第一个例子说明了如何只用 C#代码就能构建一个 WPF 程序。接下来，您发现了如何只用 XAML 构建一个 WPF 程序(不推荐这样做；然而，这是一个有用的学习练习！).最后，您了解了代码隐藏文件的使用，它允许您将外观与功能分开。

本章的最后一个例子让你有机会构建一个 WPF 应用程序，它允许你使用`XamlReader`和`XamlWriter`类以编程方式与 XAML 定义进行交互。一路上，您参观了 Visual Studio 的核心 WPF 设计人员。在接下来的章节中，你会学到更多关于 WPF 设计师的知识。