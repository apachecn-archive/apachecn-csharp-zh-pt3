# 25.Windows 通信基础简介

windows Communication Foundation(WCF)是专门为构建分布式系统而设计的 API 的名称。与您过去可能使用过的其他特定分布式 API 不同(例如，DCOM。NET remoting、XML web services、消息队列)，WCF 提供了一个单一的、统一的、可扩展的编程对象模型，您可以用它来与许多以前不同的分布式技术进行交互。

本章首先描述了 WCF 的需求，并通过快速回顾以前的分布式计算 API 来研究它想要解决的问题。在你看完 WCF 提供的服务后，你会把注意力转向检查钥匙。表示此编程模型的. NET 程序集、命名空间和类型。在本章的剩余部分，您将使用各种 WCF 开发工具构建几个 WCF 服务、主机和客户端。

Note

在本章中，您将创作要求您以管理权限启动 Visual Studio 的代码(此外，您必须具有管理权限)。若要以正确的管理员权限启动 Visual Studio，请右击 Visual Studio 图标并选择“以管理员身份运行”。

## 分布式计算 API 的大杂烩

历史上，Windows 操作系统为构建分布式系统提供了许多 API。虽然大多数人认为分布式系统至少包括两台联网的计算机，但这个术语在更广泛的意义上可以指需要交换数据的两个可执行程序，即使它们碰巧运行在同一台物理机器上。使用这个定义，为您当前的编程任务选择一个分布式 API 通常涉及到询问以下关键问题:

> Is this system only used internally, or do external users need to access the functions of the application?

如果您构建一个供内部使用的分布式系统，您就有更大的机会确保每台连接的计算机运行相同的操作系统并使用相同的编程框架(例如。NET、COM 或 Java 平台)。运行内部系统还意味着您可以利用现有的安全系统进行身份验证、授权等。在这种情况下，为了提高性能，您可能希望选择一个特定的分布式 API，将您与特定的操作系统/编程框架联系起来。

相比之下，如果你建立了一个系统，其他人必须从你的墙外到达，你有一整套其他的问题要处理。首先，您很可能无法指示外部用户可以使用哪个(些)操作系统，可以使用哪个(些)编程框架，或者如何配置他们的安全设置。

第二，如果你碰巧在一家大公司工作，或者在一所使用大量操作系统和编程技术的大学里工作，那么内部应用程序会突然面临与面向外部的应用程序相同的挑战。在这两种情况下，您都需要限制自己使用更灵活的分布式 API，以确保应用程序的最大范围。

根据您对这个关键的分布式计算问题的回答，下一个任务是准确定位使用哪个 API(或 API 集)。下面几节简要回顾了 Windows 软件开发人员过去使用的一些主要分布式 API。在您完成这个简短的历史课程后，您将能够很容易地看到 Windows Communication Foundation 的有用性。

Note

为了确保我们在这一点上意见一致，我觉得有必要指出，WCF(及其包含的技术)与构建基于 HTML 的网站没有任何关系。虽然 web 应用程序确实可以被认为是分布式的，因为通常有两台机器参与交换，但 WCF 是关于在机器之间建立连接以共享远程组件的功能，而不是为了在 web 浏览器中显示 HTML。第 32 章你将从。NET 平台。

### DCOM 的角色

在发布之前。NET 平台，分布式组件对象模型(DCOM)是以微软为中心的开发工作选择的远程 API。使用 DCOM，有可能使用 COM 对象、系统注册表和大量的工作来构建分布式系统。DCOM 的一个好处是它允许组件的位置透明。简单地说，这允许您以这样一种方式对客户端软件进行编程，即远程对象的物理位置没有被硬编码到应用程序中。不管远程对象是在同一台机器上还是在第二台联网的机器上，代码库都可以保持中立，因为实际位置记录在系统注册表的外部。

虽然 DCOM 确实取得了一定程度的成功，但实际上它是一个以 Windows 为中心的 API。单靠 DCOM 并不能提供一种架构来构建涉及多个操作系统(如 Windows、Unix 和 Mac)的综合解决方案，也不能促进不同架构(如 COM、Java 或 CORBA)之间的数据共享。

Note

曾经有人试图将 DCOM 移植到各种风格的 Unix/Linux 上，但最终结果乏善可陈，最终成为技术的注脚。

总的来说，DCOM 最适合内部应用程序开发，因为将 COM 对象暴露在公司之外会带来一系列额外的复杂性(防火墙等等)。随着。NET 平台，DCOM 很快成为遗留编程模型；除非您维护遗留的 DCOM 系统，否则您可以认为它是一种过时的技术。

### COM+/企业服务的作用

DCOM 一人除了定义了一种在两个基于 COM 的软件之间建立通信通道的方法之外，几乎没有做什么工作。为了填补构建功能丰富的分布式计算解决方案所需的空白，微软最终发布了 Microsoft Transaction Server (MTS ),后来更名为 COM+。

尽管名为 COM+,但 COM+不仅仅被 COM 程序员使用，它完全可以被。网络专业人士，以及。自从第一次发布。NET 平台，基础类库提供了一个名为`System.EnterpriseServices`的命名空间。在这里。NET 程序员可以构建托管库，这些托管库可以安装到 COM+运行时中，以访问与传统的支持 COM+的 COM 服务器相同的一组服务。在这两种情况下，一旦 COM+感知库被安装到 COM+运行时，它就被称为服务组件。

COM+提供了许多服务组件可以利用的功能，包括事务管理、对象生存期管理、池服务、基于角色的安全系统、松散耦合的事件模型等等。这在当时是一个很大的好处，因为大多数分布式系统需要相同的服务集。COM+没有强迫开发人员手工编写代码，而是提供了一个开箱即用的解决方案。

COM+的一个引人注目的方面是，所有这些设置都可以使用管理工具以声明的方式进行配置。因此，如果您想要确保某个对象在事务上下文中受到监视或者属于某个特定的安全角色，只需选择正确的复选框。

虽然 COM+/Enterprise Services 今天仍在使用，但这种技术是一种仅适用于 Windows 的解决方案，最适合于内部应用程序开发或作为后端服务，由更具竞争性的前端间接操作(例如，在后台调用服务组件[也称为 COM+ objects]的公共网站)。

Note

WCF 没有提供构建服务组件的方法。但是，它确实为 WCF 服务提供了一种与现有 COM+对象通信的方式。如果您需要使用 C#构建服务组件，您将需要直接使用`System.EnterpriseServices`名称空间。请参考。NET Framework 4.6 SDK 文档了解详细信息。

### MSMQ 的角色

Microsoft 消息队列(MSMQ) API 允许开发人员构建需要确保消息数据在网络上可靠传递的分布式系统。正如开发人员所熟知的那样，在任何分布式系统中，都存在网络服务器停机、数据库离线或连接莫名其妙丢失的风险。此外，您必须以这样一种方式构造许多应用程序，即它们保存消息数据以便以后传递(这个过程称为数据排队)。

微软最初将 MSMQ 打包成一组低级的基于 C 的 API 和 COM 对象。随着。NET 平台，C#程序员可以使用`System.Messaging`名称空间来连接到 MSMQ，并构建以可靠的方式与间歇连接的应用程序通信的软件。

与此相关，COM+层使用一种称为队列组件(QC)的技术将 MSMQ 功能合并到运行时中(以一种简化的格式)。这种与 MSMQ 通信的方式被打包到上一节提到的`System.EnterpriseServices`名称空间中。

无论您使用哪种编程模型与 MSMQ 运行时进行交互，最终结果都会确保应用程序能够以可靠和及时的方式传递消息。像 COM+一样，MSMQ 仍然是在 Windows 操作系统上构建分布式软件的一部分。

### 的作用。网络远程处理

如前所述，DCOM 在发布了。NET 平台。在它的位置上。NET 基础类库。NET remoting 层，由名称空间`System.Runtime.Remoting`表示。这个(现在是遗留的)API 允许多台计算机分发对象，只要它们都在。NET 平台。

那个。NET remoting APIs 提供了许多有用的功能。最重要的是使用基于 XML 的配置文件来声明性地定义客户机和服务器软件使用的底层管道。使用`*.config`文件，只需改变配置文件的内容并重启应用程序，就可以从根本上改变分布式系统的功能。

还有鉴于此。NET 应用程序可以使用此 API，您可以获得各种性能优势，因为数据可以以紧凑的二进制格式编码，并且您可以在定义参数和返回值时使用通用类型系统(CTS)。虽然有可能使用。NET remoting 来构建跨多个操作系统的分布式系统(使用 Mono，这在第 1 章中有简要提及)，其他编程架构(例如 Java)之间的互操作性仍然不可能直接实现。

### XML Web 服务的角色

以前的每个分布式 API 都很少(如果有的话)支持外部调用者以不可知的方式访问所提供的功能。当您需要向任何操作系统和任何编程模型公开远程对象的服务时，XML web services 提供了一种简单的方法。

与传统的基于浏览器的 web 应用程序不同，web 服务提供了一种使用标准 web 协议公开远程组件功能的方式。自从最初发布以来。NET 为程序员提供了更好的支持来构建和使用带有`System.Web.Services`名称空间的 XML web 服务。在许多情况下，构建一个功能完整的 web 服务并不比将`[WebMethod]`属性应用于您想要提供访问的每个公共方法更复杂。此外，Visual Studio 允许您通过单击一个(或两个)按钮来连接到远程 web 服务。

Web 服务允许开发人员构建。NET 程序集包含可以使用简单 HTTP 访问的类型。此外，web 服务将其数据编码为简单的 XML。假设 web 服务基于开放的行业标准(例如 HTTP、XML 和 SOAP ),而不是专有的类型系统和专有的网络格式(如 DCOM 或。NET remoting)，它们允许高度的互操作性和数据交换。图 25-1 说明了 XML web 服务的不可知本质。

![A978-1-4842-1332-2_25_Fig1_HTML.gif](img/A978-1-4842-1332-2_25_Fig1_HTML.gif)

图 25-1。

XML web services allow for a high degree of interoperability

当然，没有一个分布式 API 是完美的。web 服务的一个潜在缺点是它们可能会遇到一些性能问题(假定使用 HTTP 和 XML 数据表示)。另一个缺点是，它们可能不是内部应用程序的理想解决方案，在内部应用程序中，您可以使用基于 TCP 的协议和数据的二进制格式，而不会招致损失。

### Web 服务标准

web 服务早期面临的另一个问题是，所有大的行业参与者(例如，Microsoft、IBM 和 Sun Microsystems)创建的 web 服务实现与其他 web 服务实现不是 100%兼容。显然，这是一个问题，因为 web 服务的全部目的是实现跨平台和操作系统的高度互操作性！

为了确保 web 服务的互操作性，诸如万维网联盟(W3C: [`www.w3.org`](http://www.w3.org/) )和 Web 服务互操作性组织(WS-I: [`www.ws-i.org`](http://www.ws-i.org/) )之类的组织开始编写一些规范，这些规范规定了软件供应商(例如 IBM、微软或 Sun Microsystems)应该如何构建以 Web 服务为中心的软件库来确保兼容性。

所有这些规范被统称为 WS-*，它们涵盖了安全性、附件、web 服务描述(使用 Web 服务描述语言，或 WSDL)、策略、SOAP 格式以及许多其他重要细节。正如您将看到的，WCF 支持许多 WS-*规范。通常，您的 WCF 服务会根据您对绑定的选择选择各种 WS-*规范。

Note

除了简要介绍的分布式 API 之外，开发人员还可以使用各种进程间通信协议，比如命名管道和套接字。

## WCF 的角色

大量的分布式技术使得为这项工作选择合适的工具变得困难。这些技术提供的服务中有几项是重叠的(最明显的是在交易和安全领域)，这使得情况更加复杂。

即使. NET 开发人员已经为手头的任务选择了正确的技术，构建、维护和配置这样的应用程序也是非常复杂的。每个 API 都有自己的编程模型、自己独特的配置工具集等等。在 WCF 之前，这意味着如果不创建大量的定制基础设施，就很难即插即用分布式 API。例如，如果您使用。并且您后来决定 XML web 服务是更合适的解决方案，那么您需要重新设计您的代码库。

WCF 是一个分布式计算工具包，它将这些以前独立的分布式技术集成到一个主要由`System.ServiceModel`名称空间表示的流线型 API 中。使用 WCF，您可以使用多种技术向调用者公开服务。例如，如果您构建一个内部应用程序，其中所有连接的机器都是基于 Windows 的，那么您可以使用各种 TCP 协议来确保尽可能快的性能。您还可以通过 HTTP 和 SOAP 公开相同的服务，以允许外部调用方利用其功能，而不管编程语言或操作系统如何。

假设 WCF 允许您为这项工作选择正确的协议(使用通用编程模型)，您会发现即插即用分布式应用程序的底层管道变得非常容易。在大多数情况下，您无需重新编译或重新部署客户端/服务软件就可以做到这一点，因为这些繁琐的细节通常被归入应用程序配置文件中。

### WCF 特色概述

不同 API 的互操作性和集成只是 WCF 的两个(重要)方面。WCF 还提供了丰富的软件结构来补充它所公开的远程技术。请考虑以下 WCF 的主要功能:

*   支持强类型和非类型消息。这种方法允许。NET 应用程序高效地共享定制类型，而使用其他平台(如 Java)创建的软件可以使用松散类型的 XML 流。
*   对多种绑定的支持(例如，原始 HTTP、TCP、MSMQ、WebSockets、命名管道等)允许您选择最合适的管道来传输消息数据。
*   支持最新最好的 web 服务规范(WS-*)。
*   包含本机 Windows/的完全集成的安全模型。NET 安全协议和许多基于 web 服务标准的中立安全技术。
*   支持类似会话的状态管理技术，以及支持单向或无状态消息。

尽管这个功能列表可能令人印象深刻，但它只是触及了 WCF 提供的功能的皮毛。WCF 还提供跟踪和日志记录工具、性能计数器、发布-订阅事件模型和事务支持等功能。

### 面向服务的体系结构概述

WCF 的另一个好处是它基于面向服务架构(SOA)建立的设计原则。诚然，SOA 是业界的一个主要术语；像大多数流行词一样，SOA 可以有多种定义方式。简而言之，SOA 是一种设计分布式系统的方法，在这种系统中，几个自治服务通过使用定义良好的接口跨边界(联网的机器或同一台机器上的两个进程)传递消息来协同工作。

在 WCF 的世界里，你通常使用 CLR 接口类型创建这些定义良好的接口(见第 9 章)。然而，从更一般的意义上来说，服务的接口只是描述了可能被外部调用者调用的一组成员。

设计 WCF 的团队遵循了 SOA 设计原则的四个原则。虽然这些原则通常通过构建 WCF 应用程序自动实现，但是理解 SOA 的这四个基本设计规则可以帮助您更好地理解 WCF。接下来的部分提供了每个原则的简要概述。

### 原则 1:界限是明确的

这一原则重申了 WCF 服务的功能是使用定义良好的接口来表达的(例如，每个成员的描述、参数和返回值)。外部调用者与 WCF 服务通信的唯一方式是通过接口，并且外部调用者仍然不知道底层的实现细节。

### 原则 2:服务是自治的

术语自治实体指的是给定的 WCF 服务(尽可能地)是其自身的孤岛的事实。自治服务应该独立于版本、部署和安装问题。为了帮助推广这一原则，您可以依靠基于接口编程的一个关键方面。一旦一个接口投入生产，它就不应该被改变(否则你将冒破坏现有客户端的风险)。当您需要扩展 WCF 服务的功能时，您需要创建新的接口来模拟所需的功能。

### 宗旨 3:服务通过契约而不是实现进行交流

第三个原则是基于接口编程的另一个副产品。WCF 服务的实现细节(例如，它是用什么语言编写的，它是如何完成工作的，等等。)与外部呼叫者无关。WCF 客户端仅通过其公开的公共接口与服务进行交互。

### 原则 4:服务兼容性基于策略

因为 CLR 接口为所有 WCF 客户端提供了强类型协定(也可以用于根据您选择的绑定生成相关的 WSDL 文档)，所以认识到接口和 WSDL 本身不足以表达服务所能做的细节是很重要的。鉴于此，SOA 允许您定义进一步限定服务语义的策略(例如，用于与服务对话的预期安全需求)。使用这些策略，您基本上可以将服务的低级语法描述(公开的接口)与它们如何工作以及它们需要如何被调用的语义细节分离开来。

### WCF:底线

前面的简短历史教训解释了为什么 WCF 是构建分布式应用程序的首选方法。无论您是要使用 TCP 协议构建内部应用程序、使用命名管道在同一台计算机上的程序之间移动数据，还是使用基于 HTTP 的协议向整个世界公开数据，都推荐使用 API。

这并不是说你不能使用原件。NET 分布式中心命名空间(例如，`System.Runtime.Remoting`、`System.Messaging`、`System.EnterpriseServices`和`System.Web.Services`)。在某些情况下(例如，如果您需要构建 COM+对象)，您必须这样做。无论如何，如果你在以前的项目中使用过这些 API，你会发现学习 WCF 很简单。像之前的技术一样，WCF 大量使用基于 XML 的配置文件。NET 属性和代理生成实用程序。

有了这个介绍性的基础，您就可以专注于构建 WCF 应用程序这个主题了。同样，您应该理解，覆盖整个 WCF 将需要一整本书，因为每个支持的服务(例如，MSMQ、COM+、P2P 和命名管道)可能是其自身的一章。在这里，您将学习使用基于 TCP 和基于 HTTP(例如，web 服务)的协议构建 WCF 程序的整个过程。这将使你处于一个很好的位置，在你认为合适的时候进一步研究这些话题。

## 调查核心 WCF 组件

如您所料，WCF 的编程结构由一组。安装到 GAC 中的. NET 程序集。表 [25-1](#Tab1) 描述了您需要在几乎任何 WCF 应用中使用的核心 WCF 组件的总体作用。

表 25-1。

Core WCF Assemblies

<colgroup><col> <col></colgroup> 
| 装配 | 生命的意义 |
| --- | --- |
| `System.Runtime.Serialization.dll` | 该核心程序集定义了可用于在 WCF 框架中序列化和反序列化对象的命名空间和类型。 |
| `System.ServiceModel.dll` | 这个核心程序集包含用于构建任何种类的 WCF 应用程序的类型。 |

表 [25-1](#Tab1) 中列出的两个程序集定义了许多新的名称空间和类型。您应该参考。NET Framework 4.6 SDK 文档了解完整的详细信息；然而，表 [25-2](#Tab2) 记录了一些重要名称空间的角色。

表 25-2。

Core WCF Namespaces

<colgroup><col> <col></colgroup> 
| 命名空间 | 生命的意义 |
| --- | --- |
| `System.Runtime.Serialization` | 它定义了许多类型，用于控制数据在 WCF 框架中如何序列化和反序列化。 |
| `System.ServiceModel` | 这个主要的 WCF 命名空间定义了绑定和宿主类型，以及基本的安全和事务类型。 |
| `System.ServiceModel.Configuration` | 这定义了许多类型，提供对 WCF 配置文件的编程访问。 |
| `System.ServiceModel.Description` | 这定义了为 WCF 配置文件中定义的地址、绑定和契约提供对象模型的类型。 |
| `System.ServiceModel.MsmqIntegration` | 这包含与 MSMQ 服务集成的类型。 |
| `System.ServiceModel.Security` | 这定义了许多类型来控制 WCF 安全层的各个方面。 |

## Visual Studio WCF 项目模板

正如本章后面将详细解释的那样，一个 WCF 应用程序通常由三个相互关联的程序集来表示，其中一个是包含外部调用方可以与之通信的类型的`*.dll`(换句话说，就是 WCF 服务本身)。当你想构建一个 WCF 服务时，选择一个标准类库项目模板(见第 14 章)作为起点并手动引用 WCF 程序集是完全允许的。

或者，您可以通过选择 Visual Studio 的 WCF 服务库项目模板来创建一个新的 WCF 服务(参见图 [25-2](#Fig2) )。此项目类型自动设置对所需 WCF 程序集的引用；但是，它也会生成大量的起始代码，您可能会经常删除这些代码。

![A978-1-4842-1332-2_25_Fig2_HTML.jpg](img/A978-1-4842-1332-2_25_Fig2_HTML.jpg)

图 25-2。

The Visual Studio WCF Service Library project template

选择 WCF 服务库项目模板的一个好处是，它还为您提供了一个`App.config`文件，这可能看起来很奇怪，因为您正在构建一个. NET `*.dll`，而不是. NET `*.exe`。但是，此文件很有用，因为当您调试或运行 WCF 服务库项目时，Visual Studio IDE 将自动启动 WCF 测试客户端应用程序。这个程序(`WcfTestClient.exe`)将在`App.config`文件中查找设置，因此它可以托管您的服务用于测试目的。在本章的后面，您将了解更多关于 WCF 测试客户端的内容。

Note

WCF 服务库项目的`App.config`文件也很有用，因为它向您展示了用于配置 WCF 主机应用程序的基本设置。事实上，您可以将大部分代码复制并粘贴到生产服务的配置文件中。

除了基本的 WCF 服务库模板，新建项目对话框的 WCF 项目类别还定义了一个 WCF 库项目，该项目将 Windows Workflow Foundation (WF)功能集成到 WCF 服务中，以及一个用于构建 RSS 库的模板(参见图 [25-2](#Fig2) )。

### WCF 服务网站项目模板

您可以在“新建网站”对话框中找到另一个以 Visual Studio WCF 为中心的项目模板，您可以使用“文件➤新➤网站”菜单选项激活该对话框(参见图 [25-3](#Fig3) )。

![A978-1-4842-1332-2_25_Fig3_HTML.jpg](img/A978-1-4842-1332-2_25_Fig3_HTML.jpg)

图 25-3。

The Visual Studio web-based WCF Service project template

当您从一开始就知道您的 WCF 服务将使用基于 HTTP 的协议，而不是 TCP 或命名管道时，这个 WCF 服务项目模板就非常有用。该选项可以自动创建一个新的 Internet 信息服务(IIS)虚拟目录来包含您的 WCF 程序文件，创建一个适当的`Web.config`文件来通过 HTTP 公开服务，并创作必要的`*.svc`文件(您将在本章后面了解更多关于`*.svc`文件的信息)。因此，基于 web 的 WCF 服务项目可以节省时间，因为 IDE 会自动设置所需的 IIS 基础结构。

相比之下，如果您使用 WCF 服务库选项构建新的 WCF 服务，则您能够以多种方式承载该服务(例如，自定义主机、Windows 服务或手动构建的 IIS 虚拟目录)。当您需要为 WCF 服务构建一个可以与任意数量的 WCF 绑定一起工作的自定义主机时，此选项更合适。

## WCF 应用程序的基本组成

当您构建 WCF 分布式系统时，通常会通过创建以下三个相互关联的程序集来实现:

*   WCF 服务组装:这个`*.dll`包含了表示您想要向外部调用者公开的全部功能的类和接口。
*   WCF 服务主机:该软件模块是托管您的 WCF 服务程序集的实体。
*   WCF 客户端:这是通过中介代理访问服务功能的应用程序。

如前所述，WCF 服务程序集是一个. NET 类库，它包含许多 WCF 协定及其实现。关键的区别在于接口契约用各种属性来修饰，这些属性控制数据类型表示、WCF 运行时如何与公开的类型交互等等。

第二个程序集，WCF 服务主机，实际上可以是任何程序集。NET 可执行文件。正如您将在本章后面看到的，WCF 的设置使您可以从任何类型的应用程序(例如，Windows 窗体、Windows 服务和 WPF 应用程序)中轻松地公开服务。当您构建一个定制主机时，您可以使用`ServiceHost`类型和一个相关的`*.config`文件。后者包含关于您想要使用的服务器端管道的详细信息。然而，如果您使用 IIS 作为您的 WCF 服务的主机，您不需要以编程方式构建自定义主机，因为 IIS 将在后台使用`ServiceHost`类型。

Note

还可以使用 Windows 激活服务(WAS)托管 WCF 服务；您可以参考。NET Framework 4.6 SDK 文档了解详细信息。

最终的程序集代表调用 WCF 服务的客户端。如您所料，这个客户机可以是任何类型的。NET 应用程序。与主机类似，客户端应用程序通常使用定义客户端管道的客户端`*.config`文件。您还应该知道，如果您使用基于 HTTP 的绑定来构建您的 WCF 服务，您可以很容易地在另一个框架(例如 Java)中编写客户端应用程序。

图 [25-4](#Fig4) 展示了这三个相互关联的 WCF 组件之间的关系(从较高的层面)。在幕后，使用几个较低级别的细节来表示所需的管道(例如，工厂、通道和侦听器)。这些低层次的细节通常是隐藏的；但是，如果需要，可以对它们进行扩展或定制。在大多数情况下，默认管道完全符合要求。

![A978-1-4842-1332-2_25_Fig4_HTML.gif](img/A978-1-4842-1332-2_25_Fig4_HTML.gif)

图 25-4。

A high-level look at a typical WCF application

同样值得指出的是，使用服务器端或客户端`*.config`文件在技术上是可选的。如果您愿意，可以对主机(以及客户机)进行硬编码，以指定必要的管道(例如，端点、绑定和地址)。这种方法的明显问题是，如果您需要更改管道细节，您将需要重新编码、重新编译和重新部署许多程序集。使用一个`*.config`文件可以让您的代码更加灵活，因为改变管道就像更新文件内容和重启应用程序一样简单。另一方面，编程式配置为应用程序提供了更大的动态灵活性——例如，它可以根据 if-tests 选择如何配置管道。

## WCF 的基础知识

主机和客户端通过商定 ABC 来相互通信，ABC 是一种友好的助记符，用于记住 WCF 应用程序地址、绑定和合同的核心构建块，定义如下:

*   地址:描述服务的位置。在代码中，您用一个`System.Uri`类型来表示它；然而，您通常将该值存储在`*.config`文件中。
*   绑定:WCF 附带了许多不同的绑定，这些绑定指定了网络协议、编码机制和传输层。
*   Contract:提供从 WCF 服务公开的每个方法的描述。

你应该意识到 ABC 缩写并不意味着开发者必须首先定义地址，然后是绑定，最后是合同。在许多情况下，WCF 开发人员从定义服务契约开始，然后建立地址和绑定(任何顺序都可以，只要考虑到每个方面)。在开始构建您的第一个 WCF 应用程序之前，让我们更详细地了解一下基础知识。

### 了解 WCF 合同

理解契约的概念是构建 WCF 服务的关键。虽然不是强制性的，但是绝大多数 WCF 应用程序都是从定义一组。NET 接口类型，用于表示给定 WCF 服务将支持的成员集。具体来说，表示 WCF 契约的接口称为服务契约。实现它们的类(或结构)被称为服务类型。

WCF 服务契约有各种属性，其中最常见的属性在`System.ServiceModel`名称空间中定义。当服务契约的成员(接口中的方法)只包含简单的数据类型(例如，数字数据、布尔值和字符串数据)时，您只需使用`[ServiceContract]`和`[OperationContract]`属性就可以构建一个完整的 WCF 服务。

然而，如果你的成员公开自定义类型，你可能会在`System.Runtime.Serialization.dll`程序集的`System.Runtime.Serialization`命名空间中使用各种类型(见图 [25-5](#Fig5) )。在这里，您可以找到附加属性(例如，`[DataMember]`和`[DataContract]`)来微调定义当复合类型被传递到服务操作和从服务操作传递时，复合类型如何被序列化到 XML 和从 XML 序列化的过程。

![A978-1-4842-1332-2_25_Fig5_HTML.jpg](img/A978-1-4842-1332-2_25_Fig5_HTML.jpg)

图 25-5。

System.Runtime.Serialization defines a number of attributes used when building WCF data contracts

严格地说，您不需要使用 CLR 接口来定义 WCF 协定。许多相同的属性可以应用于公共类(或结构)的公共成员。然而，考虑到基于接口的编程的许多好处(例如，多态性和优雅的版本控制)，可以放心地认为使用 CLR 接口来描述 WCF 协定是一种最佳实践。

### 了解 WCF 绑定

一旦在服务库中定义并实现了一个契约(或一组契约)，下一个合乎逻辑的步骤就是为 WCF 服务本身构建一个托管代理。如前所述，您有多种可能的主机可供选择，所有这些主机都必须指定远程调用者用来访问服务类型功能的绑定。

WCF 提供了许多有约束力的选择，每一个都是针对特定的需求。如果没有现成的绑定符合要求，您可以通过扩展`CustomBinding`类型来创建自己的绑定(这是您在本章中不会做的事情)。WCF 绑定可以指定以下特征:

*   用于移动数据的传输层(HTTP、MSMQ、命名管道、REST、WebSockets 和 TCP)
*   传输使用的通道(单向、请求-应答和双工)
*   用于处理数据本身的编码机制(例如，XML 和二进制)
*   任何受支持的 web 服务协议(如果绑定允许的话)，比如 WS- Security、WS-Transactions、WS-Reliability 等等

让我们看看你的基本选择。

### 基于 HTTP 的绑定

`BasicHttpBinding`、`WSHttpBinding`、`WSDualHttpBinding`和`WSFederationHttpBinding`选项适合于通过 HTTP/SOAP 协议公开契约类型。如果您需要尽可能广泛的服务(例如，多个操作系统和多个编程架构)，那么您应该关注这些绑定，因为所有这些绑定类型都基于 XML 表示对数据进行编码，并在网络上使用 HTTP。

表 [25-3](#Tab3) 展示了如何在代码中表示 WCF 绑定(使用`System.ServiceModel`名称空间中的类类型)或者作为在`*.config`文件中定义的 XML 属性。

表 25-3。

The HTTP-Centric WCF Bindings

<colgroup><col> <col> <col></colgroup> 
| 绑定类 | 粘结剂 | 生命的意义 |
| --- | --- | --- |
| `BasicHttpBinding` | `<basicHttpBinding>` | 您可以使用它来构建符合 WS-Basic Profile(WS-I Basic Profile 1.1)的 WCF 服务。这个绑定使用 HTTP 作为传输协议，使用 Text/XML 作为默认的消息编码。 |
| `WSHttpBinding` | `<wsHttpBinding>` | 这类似于`BasicHttpBinding`，但是提供了更多的 web 服务特性。该绑定增加了对事务、可靠消息传递和 WS-Addressing 的支持。 |
| `WSDualHttpBinding` | `<wsDualHttpBinding>` | 这与`WSHttpBinding`类似，但旨在用于双工契约(例如，服务和客户端可以来回发送消息)。此绑定仅支持 SOAP 安全性，并且需要可靠的消息传递。 |
| `WSFederationHttpBinding` | `<wsFederationHttpBinding>` | 这是一个安全且可互操作的绑定，支持 WS- Federation 协议，使联盟中的组织能够有效地对用户进行身份验证和授权。 |

顾名思义，`BasicHttpBinding`是所有以 web 服务为中心的协议中最简单的。具体来说，此绑定确保您的 WCF 服务符合名为 WS-I Basic Profile 1.1(由 WS-I 定义)的规范。使用此绑定的主要原因是为了保持与应用程序的向后兼容性，这些应用程序以前是为了与 ASP.NET web 服务通信而构建的(已经成为。从 1.0 版开始的. NET 库)。

`WSHttpBinding`协议不仅支持 WS-*规范的子集(事务、安全和可靠会话),还支持使用消息传输优化机制(MTOM)处理二进制数据编码的能力。

`WSDualHttpBinding`的主要好处是它增加了允许呼叫者和发送者使用双工消息进行通信的能力，这是一种他们可以进行双向对话的奇特方式。当选择`WSDualHttpBinding`时，您可以挂钩到 WCF 发布/订阅事件模型。

最后，`WSFederationHttpBinding`是一种基于 web 服务的协议，当一组组织中的安全性至关重要时，您可能要考虑这种协议。此绑定支持 WS-Trust、WS-Security 和 WS-SecureConversation 规范，这些规范由 WCF CardSpace API 表示。

### 基于 TCP 的绑定

如果您构建的分布式应用程序涉及使用。NET 4.5 库(换句话说，所有机器都运行 Windows 操作系统)，您可以通过绕过 web 服务绑定并选择 TCP 绑定来获得性能优势，这可以确保所有数据都以紧凑的二进制格式编码，而不是 XML。同样，当您使用表 [25-4](#Tab4) 中所示的绑定时，客户端和主机必须是。NET 应用程序。

表 25-4。

The TCP-Centric WCF Bindings

<colgroup><col> <col> <col></colgroup> 
| 绑定类 | 粘结剂 | 生命的意义 |
| --- | --- | --- |
| `NetNamedPipeBinding` | `<netNamedPipeBinding>` | 之间在同一台计算机上进行通信的安全、可靠、优化的绑定。网络应用 |
| `NetPeerTcpBinding` | `<netPeerTcpBinding>` | 为 P2P 网络应用程序提供安全绑定 |
| `NetTcpBinding` | `<netTcpBinding>` | 作为安全和优化的绑定，适用于。NET 应用程序 |

`NetTcpBinding`类使用 TCP 在客户端和 WCF 服务之间移动二进制数据。如前所述，这将导致比 web 服务协议更高的性能，但会限制您使用内部的 Windows 解决方案。从好的方面来看，`NetTcpBinding`支持事务、可靠的会话和安全的通信。

像`NetTcpBinding`，`NetNamedPipeBinding`支持事务、可靠会话和安全通信；但是，它没有跨机调用的能力。如果您想找到在同一台机器上的 WCF 应用程序之间推送数据的最快方式(例如，跨应用程序域通信)，`NetNamedPipeBinding`是绑定冠军的选择。有关`NetPeerTcpBinding`的更多信息，请参考。NET Framework 4.6 SDK 文档，了解有关 P2P 网络的详细信息。

### 基于 msmq 的绑定

最后，如果您想与微软 MSMQ 服务器集成，那么`NetMsmqBinding`和`MsmqIntegrationBinding`绑定是您最感兴趣的。本章将不检查使用 MSMQ 绑定的细节，但是表 [25-5](#Tab5) 记录了每一个的基本角色。

表 25-5。

The MSMQ-Centric WCF Bindings

<colgroup><col> <col> <col></colgroup> 
| 绑定类 | 粘结剂 | 生命的意义 |
| --- | --- | --- |
| `MsmqIntegrationBinding` | `<msmqIntegrationBinding>` | 您可以使用此绑定使 WCF 应用程序能够向使用 COM、本机 C++或在`System.Messaging`命名空间中定义的类型的现有 MSMQ 应用程序发送消息，并从其接收消息。 |
| `NetMsmqBinding` | `<netMsmqBinding>` | 您可以将此排队绑定用于。NET 应用程序。这是以 MSMQ 为中心的绑定中的首选方法。 |

### 了解 WCF 地址

一旦建立了契约和绑定，最后一个难题就是为 WCF 服务指定一个地址。这一点很重要，因为如果远程调用方找不到远程类型，他们将无法与远程类型通信！像 WCF 的大多数方面一样，地址可以被硬编码在一个程序集中(使用`System.Uri`类型)或者卸载到一个`*.config`文件中。

在这两种情况下，WCF 地址的确切格式将根据您选择的绑定(基于 HTTP、基于命名管道、基于 TCP 或基于 MSMQ)而有所不同。从高层次来看，WCF 地址可以指定以下信息:

*   `Scheme`:传输协议(例如 HTTP)
*   `MachineName`:机器的全限定域
*   `Port`:这在很多情况下是可选的；例如，HTTP 绑定的默认端口是 80。
*   `Path`:WCF 服务之路

这些信息可以用下面的通用模板来表示(`Port`值是可选的，因为有些绑定不使用它们):

`scheme://<MachineName>[:Port]/Path`

当您使用基于 HTTP 的绑定(例如，`basicHttpBinding`、`wsHttpBinding`、`wsDualHttpBinding`或`wsFederationHttpBinding`)时，地址会像这样分解(回想一下，如果您不指定端口号，基于 HTTP 的协议默认为端口 80):

`http://localhost:8080/MyWCFService`

如果您使用以 TCP 为中心的绑定(例如，`NetTcpBinding`或`NetPeerTcpBinding`)，则 URI 采用以下格式:

`net.tcp://localhost:8080/MyWCFService`

以 MSMQ 为中心的绑定(`NetMsmqBinding`和`MsmqIntegrationBinding`)在它们的 URI 格式中是独一无二的，因为 MSMQ 可以使用公共或私有队列(仅在本地机器上可用)，而端口号在以 MSMQ 为中心的 URI 中没有任何意义。考虑下面的 URI，它描述了一个名为`MyPrivateQ`的私有队列:

`net.msmq://localhost/private$/MyPrivateQ`

最后但并非最不重要的是，用于命名管道绑定的地址格式`NetNamedPipeBinding`分解如下(回想一下，命名管道允许同一物理机器上的应用程序进行进程间通信):

`net.pipe://localhost/MyWCFService`

虽然单个 WCF 服务可能仅公开单个地址(基于单个绑定)，但是可以配置一组唯一的地址(使用不同的绑定)。您可以在一个`*.config`文件中通过定义多个`<endpoint>`元素来做到这一点。在这里，您可以为同一服务指定任意数量的 ABC。当您希望允许调用者选择他们在与服务通信时希望使用的协议时，这种方法会很有帮助。

## 建立 WCF 服务

现在，您已经对 WCF 应用程序的构建模块有了更好的理解，是时候创建您的第一个示例应用程序了，看看 ABC 是如何在代码和配置中得到体现的。第一个示例避免使用 Visual Studio WCF 项目模板，因此您可以专注于创建 WCF 服务所涉及的特定步骤。

首先创建一个名为 MagicEightBallServiceLib 的新 C#类库项目。接下来，将初始文件从`Class1.cs`重命名为`MagicEightBallService.cs`，然后添加对`System.ServiceModel.dll`程序集的引用。在初始代码文件中，指定您使用的是`System.ServiceModel`名称空间。此时，您的 C#文件应该如下所示(注意，此时您有一个公共类):

`// The key WCF namespace.`

`using System.ServiceModel;`

`namespace MagicEightBallServiceLib`

`{`

`public class MagicEightBallService`

`{`

`}`

`}`

您的类类型实现了一个由名为`IEightBall`的强类型 CLR 接口表示的 WCF 服务契约。正如你最可能知道的，魔术 8 球是一个玩具，允许你查看你可能会问的问题的少数固定答案之一。这里您的接口将定义一个方法，允许调用者向 Magic 8-Ball 提出一个问题，以获得随机答案。

WCF 服务接口用`[ServiceContract]`属性装饰，而每个接口成员用`[OperationContract]`属性装饰(稍后您将了解关于这两个属性的更多细节)。下面是`IEightBall`界面的定义:

`[ServiceContract]`

`public interface IEightBall`

`{`

`// Ask a question, receive an answer!`

`[OperationContract]`

`string ObtainAnswerToQuestion(string userQuestion);`

`}`

Note

允许定义包含没有用`[OperationContract]`属性修饰的方法的服务契约接口；但是，这些成员不会通过 WCF 运行时公开。

正如你对接口类型的研究(见第八章)中所知，接口是毫无用处的，除非它们被一个类或结构来实现，来充实它们的功能。像一个真正的魔术 8 球一样，您的服务类型(`MagicEightBallService`)的实现将从一个字符串数组中随机返回一个固定答案。此外，您的默认构造函数将显示一条信息消息，该消息将(最终)显示在主机的控制台窗口中(用于诊断目的)。

`public class MagicEightBallService : IEightBall`

`{`

`// Just for display purposes on the host.`

`public MagicEightBallService()`

`{`

`Console.WriteLine("The 8-Ball awaits your question...");`

`}`

`public string ObtainAnswerToQuestion(string userQuestion)`

`{`

`string[] answers = { "Future Uncertain", "Yes", "No",`

`"Hazy", "Ask again later", "Definitely" };`

`// Return a random response.`

`Random r = new Random();`

`return answers[r.Next(answers.Length)];`

`}`

`}`

至此，您的 WCF 服务库就完成了。然而，在为这个服务构建主机之前，您需要检查一些关于`[ServiceContract]`和`[OperationContract]`属性的额外细节。

### [ServiceContract]属性

对于要参与 WCF 提供的服务的 CLR 接口，它必须用`[ServiceContract]`属性来修饰。像许多其他人一样。NET 属性，`ServiceContractAttribute`类型支持许多进一步限定其预期用途的属性。您可以设置两个属性，`Name`和`Namespace`，来控制服务类型的名称和定义服务类型的 XML 名称空间的名称。如果使用特定于 HTTP 的绑定，则使用这些值来定义相关 WSDL 文档的`<portType>`元素。

在这里，您不需要费心分配一个`Name`值，因为服务类型的默认名称直接基于 C#类名。然而，底层 XML 名称空间的默认名称只是 [`http://tempuri.org`](http://tempuri.org/) (您应该为您所有的 WCF 服务更改这个名称)。

当您构建将发送和接收自定义数据类型的 WCF 服务时(您目前没有这样做)，为基础 XML 名称空间建立一个有意义的值是很重要的，因为这可以确保您的自定义类型是唯一的。正如您从构建 XML web services 的经验中可能知道的那样，XML 命名空间提供了一种将您的自定义类型包装在一个唯一的容器中的方法，以确保您的类型不会与另一个组织中的类型冲突。

因此，您可以使用更合适的定义来更新您的接口定义，这与在. NET Web 服务项目中定义 XML 命名空间的过程非常相似，通常是服务起点的 URI，如下例所示:

`[ServiceContract(Namespace = "`[`http://MyCompany.com`](http://mycompany.com/)T2】

`public interface IEightBall`

`{`

`...`

`}`

除了`Namespace`和`Name`之外，`[ServiceContract]`属性可以配置表 [25-6](#Tab6) 所示的附加属性。请注意，根据您的绑定选择，其中一些设置将被忽略。

表 25-6。

Various Named Properties of the [ServiceContract] Attribute

<colgroup><col> <col></colgroup> 
| 财产 | 生命的意义 |
| --- | --- |
| `CallbackContract` | 确定此服务协定是否需要双向消息交换的回调功能(例如，双工绑定)。 |
| `ConfigurationName` | 在应用程序配置文件中定位服务元素。默认值是服务实现类的名称。 |
| `ProtectionLevel` | 允许您为公开协定的终结点指定协定绑定要求加密和/或数字签名的程度。 |
| `SessionMode` | 确定此服务合同是否允许、不允许或要求会话。 |

### [OperationContract]属性

您打算在 WCF 框架中使用的方法必须用`[OperationContract]`属性进行属性化，也可以用各种命名属性进行配置。您可以使用表 [25-7](#Tab7) 中所示的属性来声明给定的方法本质上是单向的，支持异步调用，需要加密的消息数据，等等(同样，根据您的绑定选择，这些值中的许多可能会被忽略)。

表 25-7。

Various Named Properties of the [OperationContract] Attribute

<colgroup><col> <col></colgroup> 
| 财产 | 生命的意义 |
| --- | --- |
| `AsyncPattern` | 指示是否使用服务上的`Begin` / `End`方法对异步实现操作。这允许服务将处理卸载到另一个服务器端线程；这与客户端异步调用方法无关！ |
| `IsInitiating` | 指定此操作是否可以是会话中的初始操作。 |
| `IsOneWay` | 指示操作是否仅由单个输入消息组成(没有关联的输出)。 |
| `IsTerminating` | 指定操作完成后，WCF 运行时是否应尝试终止当前会话。 |

对于最初的例子，您不需要为`ObtainAnswerToQuestion()`方法配置额外的特征；这意味着您可以使用当前定义的`[OperationContract]`属性。

### 作为运营合同的服务类型

最后，回想一下，在构建 WCF 服务类型时，并不需要使用接口。事实上，可以将`[ServiceContract]`和`[OperationContract]`属性直接应用于服务类型本身，如下所示:

`// This is only for illustrative purposes`

`// and not used for the current example.`

`[ServiceContract(Namespace = "`[`http://MyCompany.com`](http://mycompany.com/)T2】

`public class ServiceTypeAsContract`

`{`

`[OperationContract]`

`void SomeMethod() { }`

`[OperationContract]`

`void AnotherMethod() { }`

`}`

你可以采取这种方法；然而，如果您显式地定义一个接口类型来表示服务契约，那么您将获得许多好处。最明显的好处是，您可以将给定的接口应用于多种服务类型(用多种语言和架构编写)，以实现高度的多态性。另一个好处是，您可以使用服务契约接口作为新契约的基础(使用接口继承)，而不必背负任何实现包袱。

无论如何，你的第一个 WCF 服务图书馆现在已经完成了。编译你的项目，以确保你没有任何错别字。

Source Code

您可以在 [`Chapter 25`](25.html) 的`MagicEightBallServiceHTTP`子目录中找到 MagicEightBallServiceLib 项目。

## 托管 WCF 服务

您现在可以定义主机了。尽管您将从 Windows 服务或 IIS 虚拟目录承载生产级服务，但您将使您的第一个主机成为一个名为 MagicEightBallServiceHost 的简单控制台。

创建这个新的控制台应用程序项目后，添加对`System.ServiceModel.dll`和`MagicEightBallServiceLib.dll`程序集的引用，然后通过导入`System.ServiceModel`和`MagicEightBallServiceLib`名称空间来更新您的初始代码文件，如下所示:

`using System;`

`...`

`using System.ServiceModel;`

`using MagicEightBallServiceLib;`

`namespace MagicEightBallServiceHost`

`{`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Console Based WCF Host *****");`

`Console.ReadLine();`

`}`

`}`

`}`

为 WCF 服务类型构建宿主时，您必须采取的第一步是决定是要完全在代码中定义必要的宿主逻辑，还是将一些低级细节放到应用程序配置文件中。如前所述，`*.config`文件的好处是主机可以改变底层管道，而不需要您重新编译和重新部署可执行文件。但是，请记住这是严格可选的，因为您可以使用`System.ServiceModel.dll`程序集内的类型硬编码宿主逻辑。

此基于控制台的主机将使用应用程序配置文件，因此使用“项目➤”“添加新项”菜单选项，然后选择“应用程序配置文件”，将此新文件(如果您的项目当前没有)插入到当前项目中。

### 在 App.config 文件中建立 ABC

当您为 WCF 服务类型构建主机时，您遵循一组可预测的步骤—一些步骤依赖于配置，一些步骤依赖于代码。这些步骤如下:

*   在主机的配置文件中定义托管的 WCF 服务的端点。
*   以编程方式使用`ServiceHost`类型来公开该端点可用的服务类型。
*   确保主机保持运行，为传入的客户端请求提供服务。显然，如果您使用 Windows 服务或 IIS 来承载服务类型，则不需要这一步。

在 WCF 的世界中，术语端点代表地址、绑定和契约，它们被打包在一个漂亮、整洁的包中。在 XML 中，端点使用`<endpoint>`元素和`address`、`binding`和`contract`元素来表示。更新您的`*.config`文件，以指定由该主机公开的单个端点(可通过端口 8080 到达)，如下所示:

`<?xml version = "1.0" encoding = "utf-8" ?>`

`<configuration>`

`<system.serviceModel>`

`<services>`

`<service name = "MagicEightBallServiceLib.MagicEightBallService">`

`<endpoint address = "``http://localhost:8080/MagicEightBallService`T2】

`binding = "basicHttpBinding"`

`contract = "MagicEightBallServiceLib.IEightBall"/>`

`</service>`

`</services>`

`</system.serviceModel>`

`</configuration>`

请注意，`<system.serviceModel>`元素是主机所有 WCF 设置的根。主机公开的每个服务都由一个由`<services>`基本元素包装的`<service>`元素表示。这里，您的单个`<service>`元素使用(可选)`name`属性来指定服务类型的友好名称。

嵌套的`<endpoint>`元素处理定义地址、绑定模型(在本例中为`basicHttpBinding`)和定义 WCF 服务契约的接口类型的完全限定名(T2)的任务。因为您正在使用基于 HTTP 的绑定，所以您使用了`http://`方案，指定了一个任意的端口 ID。

### 针对 ServiceHost 类型编码

有了当前的配置文件，完成主机所需的实际编程逻辑就很简单了。当您的可执行文件启动时，您将创建一个`ServiceHost`类的实例，并通知它负责托管哪个 WCF 服务。在运行时，该对象将自动读取主机的`*.config`文件的`<system.serviceModel>`元素范围内的数据，以确定正确的地址、绑定和契约。然后，它将创建必要的管道。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Console Based WCF Host *****");`

`using (ServiceHost serviceHost = new ServiceHost(typeof(MagicEightBallService)))`

`{`

`// Open the host and start listening for incoming messages.`

`serviceHost.Open();`

`// Keep the service running until the Enter key is pressed.`

`Console.WriteLine("The service is ready.");`

`Console.WriteLine("Press the Enter key to terminate service.");`

`Console.ReadLine();`

`}`

`}`

如果您现在运行这个应用程序，您会发现主机在内存中是活动的，准备好接受来自远程客户端的传入请求。

Note

回想一下，您必须使用管理权限启动 Visual Studio 才能运行许多 WCF 项目类型！

### 指定基址

目前，您使用一个只需要服务类型信息的构造函数来创建您的`ServiceHost`。然而，也可以传入一个`System.Uri`类型的数组作为构造函数参数，以表示可以访问该服务的地址集合。目前，您使用`*.config`文件找到地址。然而，假设您要像这样更新`using`范围:

`using (ServiceHost serviceHost = new`

`ServiceHost(typeof(MagicEightBallService),`

`new Uri[]{new Uri("``http://localhost:8080/MagicEightBallService`T2】

`{`

`...`

`}`

如果您这样做了，您现在可以这样定义您的端点:

`<endpoint address = ""`

`binding = "basicHttpBinding"`

`contract = "MagicEightBallServiceLib.IEightBall"/>`

当然，主机代码库中过多的硬编码会降低灵活性。因此，当前主机示例假设您只需像以前一样，通过提供以下类型信息来创建服务主机:

`using (ServiceHost serviceHost = new ServiceHost(typeof(MagicEightBallService)))`

`{`

`...`

`}`

创作主机`*.config`文件的一个(有点令人沮丧的)方面是，根据代码库中硬编码的数量，您有多种方法来构造 XML 描述符(正如您刚刚在可选的`Uri`数组中看到的)。这里有一个修改，展示了创作`*.config`文件的另一种方式:

`<?xml version = "1.0" encoding = "utf-8" ?>`

`<configuration>`

`<system.serviceModel>`

`<services>`

`<service name = "MagicEightBallServiceLib.MagicEightBallService">`

`<!--``Address obtained from <baseAddresses>`T2】

`<endpoint address = ""`

`binding = "basicHttpBinding"`

`contract = "MagicEightBallServiceLib.IEightBall"/>`

`<!--``List all of the base addresses in a dedicated section`T2】

`<host>`

`<baseAddresses>`

`<add baseAddress = "``http://localhost:8080/MagicEightBallService`T2】

`</baseAddresses>`

`</host>`

`</service>`

`</services>`

`</system.serviceModel>`

`</configuration>`

在这种情况下，`<endpoint>`元素的`address`属性仍然为空；尽管在创建`ServiceHost`时没有在代码中指定`Uri`对象的数组，但是应用程序会像以前一样运行，因为值是从`baseAddresses`范围中提取的。将基址存储在`<host>`的`<baseAddresses>`区域中的好处是`*.config`文件的其他部分也需要知道服务端点的地址。因此，不必在单个`*.config`文件中复制和粘贴地址值，您可以隔离单个值，如前面的代码片段所示。

Note

在后面的例子中，将向您介绍一个图形化的配置工具，它允许您以一种不那么繁琐的方式创作配置文件。

无论如何，在构建与服务通信的客户端应用程序之前，您还有一些工作要做。具体来说，您将更深入地研究`ServiceHost`类类型和`<service.serviceModel>`元素的角色，以及元数据交换(MEX)服务的角色。

### 服务主机类型的详细信息

您使用`ServiceHost`类类型来配置和公开来自宿主可执行文件的 WCF 服务。但是，请注意，只有在构建自定义的`*.exe`来托管您的服务时，您才会直接使用这种类型。如果您使用 IIS 来公开一个服务，那么会自动为您创建一个`ServiceHost`对象。

正如您所看到的，这种类型需要一个完整的服务描述，它是通过主机的`*.config`文件的配置设置动态获得的。虽然这是在创建一个`ServiceHost`对象时自动发生的，但是也可以使用一些成员手动配置`ServiceHost`对象的状态。除了`Open()`和`Close()`(它们以同步的方式与您的服务通信)，表 [25-8](#Tab8) 还显示了一些感兴趣的成员。

表 25-8。

Select Members of the ServiceHost Type

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `Authorization` | 此属性获取所承载服务的授权级别。 |
| `AddDefaultEndpoints()` | 此方法用于以编程方式配置 WCF 服务主机，因此它可以使用框架提供的任意数量的预构建端点。 |
| `AddServiceEndpoint()` | 此方法允许您以编程方式向主机注册端点。 |
| `BaseAddresses` | 此属性获取当前服务的注册基址列表。 |
| `BeginOpen() BeginClose()` | 这些方法允许您使用标准的异步方式异步打开和关闭一个`ServiceHost`对象。NET 委托语法。 |
| `CloseTimeout` | 此属性允许您设置和获取允许服务关闭的时间。 |
| `Credentials` | 此属性获取当前服务使用的安全凭据。 |
| `EndOpen() EndClose()` | 这些方法是`BeginOpen()`和`BeginClose()`的异步对应方法。 |
| `OpenTimeout` | 此属性允许您设置和获取服务启动所允许的时间。 |
| `State` | 该属性获取一个指示通信对象当前状态的值，该值由`CommunicationState`枚举表示(例如，`opened`、`closed`和`created`)。 |

通过更新您的`Program`类，您可以看到`ServiceHost`的一些其他方面，如下所示，用一个新的静态方法打印出主机使用的每个端点的 ABC:

`static void DisplayHostInfo(ServiceHost host)`

`{`

`Console.WriteLine();`

`Console.WriteLine("***** Host Info *****");`

`foreach (System.ServiceModel.Description.ServiceEndpoint se`

`in host.Description.Endpoints)`

`{`

`Console.WriteLine("Address: {0}", se.Address);`

`Console.WriteLine("Binding: {0}", se.Binding.Name);`

`Console.WriteLine("Contract: {0}", se.Contract.Name);`

`Console.WriteLine();`

`}`

`Console.WriteLine("**********************");`

`}`

现在，假设您在打开主机后从`Main()`内部调用这个新方法:

`using (ServiceHost serviceHost = new ServiceHost(typeof(MagicEightBallService)))`

`{`

`// Open the host and start listening for incoming messages.`

`serviceHost.Open();`

`DisplayHostInfo(serviceHost);`

`...`

`}`

以下统计数据将显示为输出:

`***** Console Based WCF Host *****`

`***** Host Info *****`

`Address:` `http://localhost:8080/MagicEightBallService`

`Binding: BasicHttpBinding`

`Contract: IEightBall`

`**********************`

`The service is ready.`

`Press the Enter key to terminate service.`

Note

在本章中运行宿主(或客户端)时，请确保真正从 Visual Studio (Ctrl+F5)中“运行”程序，而不是调试(F5)程序，以确保宿主和客户端进程可以独立运行。

### <system.servicemodel>元素的详细信息</system.servicemodel>

像任何 XML 元素一样，`<system.serviceModel>`可以定义一组子元素，每个子元素都可以使用不同的属性来限定。尽管您应该参考。NET Framework 4.6 SDK 文档有关可能的属性集的完整详细信息，下面是列出一些(但不是全部)有用子元素的框架:

`<system.serviceModel>`

`<behaviors>`

`</behaviors>`

`<client>`

`</client>`

`<commonBehaviors>`

`</commonBehaviors>`

`<diagnostics>`

`</diagnostics>`

`<comContracts>`

`</comContracts>`

`<services>`

`</services>`

`<bindings>`

`</bindings>`

`</system.serviceModel>`

当你阅读本章时，你会看到更多奇特的配置文件；然而，你可以在表 [25-9](#Tab9) 中看到每个子元素的症结所在。

表 25-9。

Select Subelements of <service.serviceModel>

<colgroup><col> <col></colgroup> 
| 子元件 | 生命的意义 |
| --- | --- |
| `behaviors` | WCF 支持各种端点和服务行为。简而言之，行为允许您进一步限定主机、服务或客户端的功能。 |
| `bindings` | 该元素允许您微调 WCF 提供的每个绑定(例如，`basicHttpBinding`和`netMsmqBinding`)，以及指定主机使用的任何自定义绑定。 |
| `client` | 此元素包含客户端用来连接到服务的端点列表。显然，这在主机的`*.config`文件中并不是特别有用。 |
| `comContracts` | 此元素定义为 WCF 和 COM 互操作性启用的 COM 协定。 |
| `commonBehaviors` | 该元素只能在`machine.config`文件中设置。您可以使用它来定义给定机器上每个 WCF 服务使用的所有行为。 |
| `diagnostics` | 此元素包含 WCF 诊断功能的设置。用户可以启用/禁用跟踪、性能计数器和 WMI 提供程序。用户还可以添加自定义的消息过滤器。 |
| `services` | 该元素包含宿主公开的 WCF 服务的集合。 |

### 启用元数据交换

回想一下，WCF 客户端应用程序通过中间的代理类型与 WCF 服务进行通信。虽然您可以完全手动创作代理代码，但这样做将是乏味且容易出错的。理想情况下，您可以使用工具来生成必要的垃圾代码(包括客户端的`*.config`文件)。谢天谢地。NET Framework 4.6 SDK 为此提供了一个命令行工具(`svcutil.exe`)。此外，Visual Studio 通过其项目➤添加服务引用菜单选项提供了类似的功能。

然而，要让这些工具生成必要的代理代码/ `*.config`文件，它们必须能够发现 WCF 服务接口的格式和任何已定义的数据契约(例如，方法名和参数类型)。

元数据交换(MEX)是一种 WCF 服务行为，可用于微调 WCF 运行时处理服务的方式。简单地说，每个`<behavior>`元素可以定义给定服务可以订阅的一组活动。WCF 提供了许多开箱即用的行为，您也可以创建自己的行为。

MEX 行为(默认情况下是禁用的)将拦截通过 HTTP GET 发送的任何元数据请求。如果您希望允许`svcutil.exe`或 Visual Studio 自动创建所需的客户端代理`*.config`文件，您必须启用 MEX。

启用 MEX 就是用适当的设置调整主机的`*.config`文件(或者编写相应的 C#代码)。首先，您必须为墨西哥添加一个新的`<endpoint>`。其次，您需要定义一个 WCF 行为来允许 HTTP GET 访问。第三，您需要使用开始的`<service>`元素上的`behaviorConfiguration`属性通过名称将此行为与您的服务关联起来。最后，您需要添加一个`<host>`元素来定义这个服务的基址(MEX 将在这里找出要描述的类型的位置)。

Note

如果您传入一个`System.Uri`对象将基址表示为`ServiceHost`构造函数的一个参数，那么您可以绕过这最后一步。

考虑下面更新的主机`*.config`文件，它创建了一个定制的`<behavior>`元素(名为`EightBallServiceMEXBehavior`)，该元素通过`<service>`定义中的`behaviorConfiguration`属性与您的服务相关联:

`<?xml version = "1.0" encoding = "utf-8" ?>`

`<configuration>`

`<system.serviceModel>`

`<services>`

`<service name = "MagicEightBallServiceLib.MagicEightBallService"`

`behaviorConfiguration="EightBallServiceMEXBehavior">`

`<endpoint address = ""`

`binding = "basicHttpBinding"`

`contract = "MagicEightBallServiceLib.IEightBall"/>`

`<!--``Enable the MEX endpoint`T2】

`<endpoint address = "mex"`

`binding = "mexHttpBinding"`

`contract = "IMetadataExchange" />`

`<!--``Need to add this so MEX knows the address of our service`T2】

`<host>`

`<baseAddresses>`

`<add baseAddress = "``http://localhost:8080/MagicEightBallService`T2】

`</baseAddresses>`

`</host>`

`</service>`

`</services>`

`<!--``A behavior definition for MEX`T2】

`<behaviors>`

`<serviceBehaviors>`

`<behavior name = "EightBallServiceMEXBehavior" >`

`<serviceMetadata httpGetEnabled = "true" />`

`</behavior>`

`</serviceBehaviors>`

`</behaviors>`

`</system.serviceModel>`

`</configuration>`

现在，您可以重新运行您的服务主机应用程序，并使用您选择的 web 浏览器查看其元数据描述。为此，在主机仍在运行时输入地址作为 URL，如下所示:

`http://localhost:8080/MagicEightBallService`

一旦你进入 WCF 服务的主页(见图 [25-6](#Fig6) )，你将获得关于如何以编程方式与该服务交互的基本细节，以及通过点击页面顶部的超链接查看 WSDL 合同的方法。回想一下，web 服务描述语言(WSDL)是一种描述给定端点的 Web 服务结构的语法。

![A978-1-4842-1332-2_25_Fig6_HTML.jpg](img/A978-1-4842-1332-2_25_Fig6_HTML.jpg)

图 25-6。

Ready-to-view metadata using MEX

您的主机现在公开了两个不同的端点(一个用于服务，一个用于 MEX)，因此您的主机的控制台输出将如下所示:

`***** Console Based WCF Host *****`

`***** Host Info *****`

`Address:` `http://localhost:8080/MagicEightBallService`

`Binding: BasicHttpBinding`

`Contract: IEightBall`

`Address:` `http://localhost:8080/MagicEightBallService/mex`

`Binding: MetadataExchangeHttpBinding`

`Contract: IMetadataExchange`

`**********************`

`The service is ready.`

Source Code

您可以在 [`Chapter 25`](25.html) `.`的`MagicEightBallServiceHTTP`子目录中找到 MagicEightBallServiceHost 项目

## 构建 WCF 客户端应用程序

现在您的主机已经就绪，最后的任务是构建一个软件来与这个 WCF 服务类型进行通信。虽然您可以走很长的路，手工构建必要的基础设施(一个可行但劳动密集型的任务)，但是。NET Framework 4.6 SDK 提供了几种快速生成客户端代理的方法。首先创建一个名为 MagicEightBallServiceClient 的新控制台应用程序项目。

### 使用 svcutil.exe 生成代理代码

构建客户端代理的第一种方法是使用`svcutil.exe`命令行工具。使用`svcutil.exe`，您可以生成一个表示代理代码本身的新 C#语言文件，以及一个客户端配置文件。您可以通过将服务的端点指定为第一个参数来实现这一点。您使用`/out:`标志来定义包含代理的`*.cs`文件的名称，并使用`/config:`选项来指定生成的客户端`*.config`文件的名称。

假设您的服务当前正在运行，传递到`svcutil.exe`中的以下命令集将在工作目录中生成两个新文件(当然，应该在开发人员命令提示符中作为一行输入):

`svcutil` `http://localhost:8080/MagicEightBallService`

`/out:myProxy.cs /config:app.config`

如果您打开`myProxy.cs`文件，您会发现一个客户端表示的`IEightBall`接口，以及一个名为`EightBallClient`的新类，它本身就是代理类。这个类从通用类`System.ServiceModel.ClientBase<T>`派生而来，其中`T`是注册的服务接口。

除了许多自定义构造函数之外，代理的每个方法(基于原始接口方法)都将被实现，以使用继承的`Channel`属性来调用正确的服务方法。以下是代理类型的部分快照:

`[System.Diagnostics.DebuggerStepThroughAttribute()]`

`[System.CodeDom.Compiler.GeneratedCodeAttribute("System.ServiceModel",`

`"4.0.0.0")]`

`public partial class EightBallClient :`

`System.ServiceModel.ClientBase<IEightBall>, IEightBall`

`{`

`...`

`public string ObtainAnswerToQuestion(string userQuestion)`

`{`

`return base.Channel.ObtainAnswerToQuestion(userQuestion);`

`}`

`}`

当您在客户端应用程序中创建代理类型的实例时，基类将使用客户端应用程序配置文件中指定的设置建立到终结点的连接。与服务器端配置文件非常相似，生成的客户端`App.config`文件包含一个`<endpoint>`元素和关于用于与服务通信的`basicHttpBinding`的细节。

您还会发现下面的`<client>`元素，它(再次)从客户的角度建立了 ABC:

`<client>`

`<endpoint`

`address = "``http://localhost:8080/MagicEightBallService`T2】

`binding = "basicHttpBinding" bindingConfiguration = "BasicHttpBinding_IEightBall"`

`contract = "IEightBall" name = "BasicHttpBinding_IEightBall" />`

`</client>`

此时，您可以将这两个文件包含到一个客户端项目中(并引用`System.ServiceModel.dll`程序集),然后使用代理类型与远程 WCF 服务进行通信。但是，这里您将采用不同的方法，看看 Visual Studio 如何帮助您进一步自动化客户端代理文件的创建。

### 使用 Visual Studio 生成代理代码

像任何好的命令行工具一样，`svcutil.exe`提供了大量选项，您可以使用这些选项来控制如何生成客户端代理。如果不需要这些高级选项，可以使用 Visual Studio IDE 生成相同的两个文件。对于客户端项目，创建一个新的控制台应用程序项目，并从项目菜单中选择添加服务引用选项。

激活此菜单选项后，系统会提示您输入服务 URI。此时，点击 Go 按钮查看服务描述(见图 [25-7](#Fig7) )。

![A978-1-4842-1332-2_25_Fig7_HTML.jpg](img/A978-1-4842-1332-2_25_Fig7_HTML.jpg)

图 25-7。

Generating the proxy files using Visual Studio

除了创建代理文件并将其插入到当前项目中，该工具还可以代表您自动引用 WCF 程序集。根据命名约定，代理类在名为`ServiceReference1`的名称空间中定义，该名称空间嵌套在客户机的名称空间中(以避免可能的名称冲突)。以下是完整的客户端代码:

`// Location of the proxy.`

`using MagicEightBallServiceClient.ServiceReference1;`

`namespace MagicEightBallServiceClient`

`{`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Ask the Magic 8 Ball *****\n");`

`using (EightBallClient ball = new EightBallClient())`

`{`

`Console.Write("Your question: ");`

`string question = Console.ReadLine();`

`string answer =`

`ball.ObtainAnswerToQuestion(question);`

`Console.WriteLine("8-Ball says: {0}", answer);`

`}`

`Console.ReadLine();`

`}`

`}`

`}`

现在假设您的 WCF 控制台主机正在运行，这样您就可以执行客户机了。下面是一个可能的输出:

`***** Ask the Magic 8 Ball *****`

`Your question: Will I ever finish Fallout 4?`

`8-Ball says: No`

`Press any key to continue...`

Source Code

您可以在 [`Chapter 25`](25.html) 的`MagicEightBallServiceHTTP`子目录中找到 MagicEightBallServiceClient 项目。

### 配置基于 TCP 的绑定

此时，主机和客户机应用程序都被配置为使用最简单的基于 HTTP 的绑定`basicHttpBinding`。回想一下，将设置卸载到配置文件的好处是，您可以以声明的方式更改底层管道，并为同一服务公开多个绑定。

为了说明这一点，你可以尝试一个小实验。在你的`C:`驱动器上(或者你保存代码的地方)创建一个名为`EightBallTCP`的新文件夹；在这个新文件夹中，创建两个名为`Host`和`Client`的子目录。

接下来，使用 Windows 资源管理器导航到宿主项目的`\bin\Debug`文件夹(在本章的前面),并将`MagicEightBallServiceHost.exe`、`MagicEightBallServiceHost.exe.config`和`MagicEightBallServiceLib.dll`复制到`C:\EightBallTCP\Host`文件夹。现在使用一个简单的文本编辑器打开`*.config`文件进行编辑，修改现有内容如下:

`<?xml version = "1.0" encoding = "utf-8" ?>`

`<configuration>`

`<system.serviceModel>`

`<services>`

`<service name = "MagicEightBallServiceLib.MagicEightBallService">`

`<endpoint address = ""`

`binding = "netTcpBinding"`

`contract = "MagicEightBallServiceLib.IEightBall"/>`

`<host>`

`<baseAddresses>`

`<add baseAddress =` `"net.tcp://localhost:8090/MagicEightBallService"/>`

`</baseAddresses>`

`</host>`

`</service>`

`</services>`

`</system.serviceModel>`

`</configuration>`

本质上，这个主机的`*.config`文件去掉了所有的 MEX 设置(因为您已经构建了代理),并确定它正在通过一个唯一的端口使用`netTcpBinding`绑定类型。现在双击`*.exe`运行应用程序。如果一切正常，您应该会看到如下所示的主机输出:

`***** Console Based WCF Host *****`

`***** Host Info *****`

`Address: net.tcp://localhost:8090/MagicEightBallService`

`Binding: NetTcpBinding`

`Contract: IEightBall`

`**********************`

`The service is ready.`

`Press the Enter key to terminate service.`

为了完成测试，将客户端应用程序的`\bin\Debug folder`中的`MagicEightBallServiceClient.exe`和`MagicEightBallServiceClient.exe.config`文件复制到`C:\EightBallTCP\Client`文件夹中。像这样更新客户端配置文件:

`<?xml version = "1.0" encoding = "utf-8" ?>`

`<configuration>`

`<system.serviceModel>`

`<client>`

`<endpoint address = "net.tcp://localhost:8090/MagicEightBallService"`

`binding = "netTcpBinding"`

`contract = "ServiceReference1.IEightBall"`

`name = "netTcpBinding_IEightBall" />`

`</client>`

`</system.serviceModel>`

`</configuration>`

与 Visual Studio 代理生成器创作的文件相比，这个客户端配置文件是一个巨大的简化。请注意，您已经完全删除了现有的`<bindings>`元素。最初，`*.config`文件包含一个带有`<basicHttpBinding>`子元素的`<bindings>`元素，子元素提供了客户端绑定设置的许多细节(例如，超时)。

事实是，对于这个例子，您从来不需要这些细节，因为您自动获得了底层`BasicHttpBinding`对象的默认值。如果需要，您当然可以更新现有的`<bindings>`元素来定义`<netTcpBinding>`子元素的细节；但是，如果您对`NetTcpBinding`对象的默认值满意，就不需要这样做。

无论如何，您现在应该能够运行您的客户端应用程序了。假设宿主仍在后台运行，您将能够使用 TCP 在程序集之间移动数据。

Source Code

您可以在 [`Chapter 25`](25.html) 子目录中找到 MagicEightBallTCP 配置文件。

## 简化配置设置

当你在学习本章的第一个例子时，你可能已经注意到主机配置逻辑非常冗长。例如，您的主机的`*.config`文件(用于最初的基本 HTTP 绑定)需要为服务定义一个`<endpoint>`元素，为 MEX 定义第二个`<endpoint>`元素，为减少冗余的 URIs 定义一个`<baseAddresses>`元素(技术上是可选的)，然后定义元数据交换的运行时特性的`<behaviors>`部分。

当然，学习如何创作托管文件可能是构建 WCF 服务的一个主要障碍。更令人沮丧的是，许多 WCF 服务倾向于在主机配置文件中要求相同的基本设置。例如，如果您要创建一个新的 WCF 服务和一个新的主机，并且您想要使用带有 MEX 支持的`<basicHttpBinding>`来公开这个服务，那么所需的`*.config`文件看起来将与您之前创建的文件几乎相同。

谢天谢地，自从。NET 4.0 中，Windows Communication Foundation API 进行了大量简化，包括默认设置(和其他快捷方式)，使构建主机配置文件的过程更加容易。

### 利用默认端点

在支持默认端点之前，如果您在`ServiceHost`对象上调用了`Open()`,并且您还没有在您的配置文件中指定至少一个`<endpoint>`元素，那么运行时将抛出一个异常。如果您在代码中调用`AddServiceEndpoint()`来指定一个端点，您会得到类似的结果。然而，自从。NET 4.5 中，每个 WCF 服务都自动提供有默认端点，这些端点捕获每个受支持协议的常见配置细节。

如果你要打开`machine.config`文件。NET 4.5 中，您会发现一个名为`<protocolMapping>`的新元素。该元素记录了默认情况下要使用的 WCF 绑定(如果未指定任何绑定)。

`<system.serviceModel>`

`...`

`<protocolMapping>`

`<add scheme = "http" binding="basicHttpBinding"/>`

`<add scheme = "net.tcp" binding="netTcpBinding"/>`

`<add scheme = "net.pipe" binding="netNamedPipeBinding"/>`

`<add scheme = "net.msmq" binding="netMsmqBinding"/>`

`</protocolMapping>`

`...`

`</system.serviceModel>`

要使用这些默认绑定，您只需在主机配置文件中指定基址。要查看实际效果，请在 Visual Studio 中打开基于 HTTP 的 MagicEightBallServiceHost 项目。现在，通过完全删除 WCF 服务的`<endpoint>`元素和所有特定于墨西哥的数据来更新您的托管`*.config`文件。您的配置文件现在应该如下所示:

`<configuration>`

`<system.serviceModel>`

`<services>`

`<service name = "MagicEightBallServiceLib.MagicEightBallService" >`

`<host>`

`<baseAddresses>`

`<add baseAddress = "``http://localhost:8080/MagicEightBallService`T2】

`</baseAddresses>`

`</host>`

`</service>`

`</services>`

`</system.serviceModel>`

`</configuration>`

因为您指定了有效的 HTTP `<baseAddress>`，所以您的主机将自动使用`basicHttpBinding`。如果您再次运行主机，您将看到相同的 ABC 数据列表。

`***** Console Based WCF Host *****`

`***** Host Info *****`

`Address:` `http://localhost:8080/MagicEightBallService`

`Binding: BasicHttpBinding`

`Contract: IEightBall`

`**********************`

`The service is ready.`

`Press the Enter key to terminate service.`

您还没有启用 MEX，但是稍后您将使用另一种称为默认行为配置的简化方式来启用它。但是，首先，您将学习如何使用多个绑定来公开单个 WCF 服务。

### 使用多个绑定公开单个 WCF 服务

自第一次发布以来，WCF 已经能够允许一个主机使用多个端点来公开一个 WCF 服务。例如，您可以通过向配置文件中添加新的端点，使用 HTTP、TCP 和命名管道绑定来公开`MagicEightBallService`。重新启动主机后，所有必需的管道都将自动创建。

这是一个巨大的好处，原因有很多。在 WCF 之前，很难使用多个绑定来公开单个服务，因为每种类型的绑定(例如 HTTP 和 TCP)都有自己的编程模型。

然而，允许调用者选择最合适的绑定的能力是非常有用的。内部调用者可能喜欢使用 TCP 绑定，面向外部的客户端(在公司防火墙之外)需要使用 HTTP 来访问，而同一台机器上的客户端可能选择使用命名管道。

来做这件事。NET 4.5 中，您的主机配置文件需要手动定义多个`<endpoint>`元素。它还必须为每个协议定义多个`<baseAddress>`元素。但是，现在您可以简单地编写以下配置文件:

`<configuration>`

`<system.serviceModel>`

`<services>`

`<service name = "MagicEightBallServiceLib.MagicEightBallService" >`

`<host>`

`<baseAddresses>`

`<add baseAddress = "``http://localhost:8080/MagicEightBallService`T2】

`<add baseAddress =`

`"net.tcp://localhost:8099/MagicEightBallService"/>`

`</baseAddresses>`

`</host>`

`</service>`

`</services>`

`</system.serviceModel>`

`</configuration>`

如果您编译您的项目(刷新部署的`*.config`文件)并重启主机，您现在将看到以下端点数据:

`***** Console Based WCF Host *****`

`***** Host Info *****`

`Address:` `http://localhost:8080/MagicEightBallService`

`Binding: BasicHttpBinding`

`Contract: IEightBall`

`Address: net.tcp://localhost:8099/MagicEightBallService`

`Binding: NetTcpBinding`

`Contract: IEightBall`

`**********************`

`The service is ready.`

`Press the Enter key to terminate service.`

既然您的 WCF 服务可以从两个唯一的端点到达，您可能想知道调用者如何能够在它们之间进行选择。当您生成客户端代理时，添加服务引用工具将在客户端`*.config`文件中为每个公开的端点提供一个字符串名称。在代码中，您可以将正确的字符串名称传递给代理的构造函数，果然，将使用正确的绑定。但是，在这样做之前，您需要为这个修改后的主机配置文件重新建立 MEX，并了解如何调整默认绑定的设置。

### 更改 WCF 绑定的设置

如果你用 C#代码指定一个服务的 ABC(你将在本章后面做)，你如何改变一个 WCF 绑定的默认设置就变得很明显了；您只需更改对象的属性值！例如，如果您想使用`BasicHttpBinding`但又想更改超时设置，您可以按如下方式操作:

`void ConfigureBindingInCode()`

`{`

`BasicHttpBinding binding = new BasicHttpBinding();`

`binding.OpenTimeout = TimeSpan.FromSeconds(30);`

`...`

`}`

以声明的方式配置绑定的设置总是可能的。例如，。NET 3.5 允许您构建一个主机配置文件来更改`BasicHttpBinding`的`OpenTimeout`属性，如下所示:

`<configuration>`

`<system.serviceModel>`

`<bindings>`

`<basicHttpBinding>`

`<binding` `name = "myCustomHttpBinding"`

`openTimeout = "00:00:30" />`

`</basicHttpBinding>`

`</bindings>`

`<services>`

`<service name = "WcfMathService.MyCalc">`

`<endpoint address = "``http://localhost:8080/MyCalc`T2】

`binding = "basicHttpBinding"`

`bindingConfiguration = "myCustomHttpBinding"`

`contract = "WcfMathService.IBasicMath" />`

`</service>`

`</services>`

`</system.serviceModel>`

`</configuration>`

这里，您有一个名为`WcfMathService.MyCalc`的服务的配置文件，它支持名为`IBasicMath`的单一接口。请注意`<bindings>`部分如何允许您定义一个命名的`<binding>`元素，它调整给定绑定的设置。在服务的`<endpoint>`中，您可以使用`bindingConfiguration`属性连接您的特定设置。

这种托管配置仍然像预期的那样工作；然而，如果您利用默认端点，您就不能将`<binding>`连接到`<endpoint>`！幸运的是，您可以简单地通过省略`<binding>`元素的`name`属性来控制默认端点的设置。例如，这个代码片段更改了背景中使用的默认`BasicHttpBinding`和`NetTcpBinding`对象的一些属性:

`<configuration>`

`<system.serviceModel>`

`<services>`

`<service name = "MagicEightBallServiceLib.MagicEightBallService" >`

`<host>`

`<baseAddresses>`

`<add baseAddress = "``http://localhost:8080/MagicEightBallService`T2】

`<add baseAddress =`

`"net.tcp://localhost:8099/MagicEightBallService"/>`

`</baseAddresses>`

`</host>`

`</service>`

`</services>`

`<bindings>`

`<basicHttpBinding>`

`<binding openTimeout = "00:00:30" />`

`</basicHttpBinding>`

`<netTcpBinding>`

`<binding closeTimeout = "00:00:15" />`

`</netTcpBinding>`

`</bindings>`

`</system.serviceModel>`

`</configuration>`

### 利用默认的墨西哥行为配置

代理生成工具必须在运行时发现服务的组成，然后才能工作。在 WCF，您可以通过启用 MEX 来允许这种运行时发现的发生。同样，大多数主机配置文件需要启用 MEX(至少在开发期间)；幸运的是，您配置 MEX 的方式很少改变，所以。NET 4.5 及以上版本提供了一些方便的快捷方式。

最有用的快捷方式是开箱即用的 MEX 支持。您不需要添加一个 MEX 端点，定义一个命名的 MEX 服务行为，然后将命名的绑定连接到服务(就像您在 MagicEightBallServiceHost 的 HTTP 版本中所做的那样)；相反，您现在可以简单地添加以下内容:

`<configuration>`

`<system.serviceModel>`

`<services>`

`<service name = "MagicEightBallServiceLib.MagicEightBallService" >`

`<host>`

`<baseAddresses>`

`<add baseAddress = "``http://localhost:8080/MagicEightBallService`T2】

`<add baseAddress =`

`"net.tcp://localhost:8099/MagicEightBallService"/>`

`</baseAddresses>`

`</host>`

`</service>`

`</services>`

`<bindings>`

`<basicHttpBinding>`

`<binding openTimeout = "00:00:30" />`

`</basicHttpBinding>`

`<netTcpBinding>`

`<binding closeTimeout = "00:00:15" />`

`</netTcpBinding>`

`</bindings>`

`<behaviors>`

`<serviceBehaviors>`

`<behavior>`

`<!--` `To get default MEX,`

`don’t name your <serviceMetadata> element` `-->`

`<serviceMetadata httpGetEnabled = "true"/>`

`</behavior>`

`</serviceBehaviors>`

`</behaviors>`

`</system.serviceModel>`

`</configuration>`

诀窍是`<serviceMetadata>`元素不再有`name`属性(还要注意`<service>`元素不再需要`behaviorConfiguration`属性)。通过这种调整，您可以在运行时获得免费的 MEX 支持。要测试这一点，您可以运行您的主机(在您编译以刷新配置文件之后),并在浏览器中键入以下 URL:

`http://localhost:8080/MagicEightBallService`

完成此操作后，您可以点击网页顶部的`wsdl`链接来查看服务的 WSDL 描述(请参考图 [25-6](#Fig6) 进行复习)。请注意，您看不到主机的控制台窗口打印 MEX 端点的数据，因为您没有在配置文件中明确定义`IMetadataExchange`的端点。尽管如此，MEX 已经启用，您可以开始构建客户机代理了。

### 刷新客户端代理并选择绑定

假设您更新的主机已经编译并在后台运行，那么您现在需要打开客户机应用程序并刷新当前的服务引用。首先在解决方案资源管理器中打开`Service References`文件夹。接下来，右键单击当前服务参考 1，并选择更新服务参考菜单选项(见图 [25-8](#Fig8) )。

![A978-1-4842-1332-2_25_Fig8_HTML.jpg](img/A978-1-4842-1332-2_25_Fig8_HTML.jpg)

图 25-8。

Refreshing the proxy and client-side *.config file

完成这些之后，您将看到客户端的`*.config`文件有两个绑定可供选择:一个用于 HTTP，一个用于 TCP。如您所见，您为每个绑定指定了一个合适的名称。以下是刷新后的配置文件的部分列表:

`<configuration>`

`<system.serviceModel>`

`<bindings>`

`<basicHttpBinding>`

`<binding name = "BasicHttpBinding_IEightBall" ... />`

`</basicHttpBinding>`

`<netTcpBinding>`

`<binding name = "NetTcpBinding_IEightBall" ... />`

`</netTcpBinding>`

`</bindings>`

`...`

`</system.serviceModel>`

`</configuration>`

客户端可以在创建代理对象时使用这些名称来选择想要使用的绑定。因此，如果您的客户端想要使用 TCP，您可以更新客户端 C#代码，如下所示:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Ask the Magic 8 Ball *****\n");`

`using (EightBallClient ball = new EightBallClient("NetTcpBinding_IEightBall"))`

`{`

`...`

`}`

`Console.ReadLine();`

`}`

如果客户端更愿意使用 HTTP 绑定，您可以编写以下代码:

`using (EightBallClient ball = new`

`EightBallClient("BasicHttpBinding_IEightBall"))`

`{`

`...`

`}`

这就结束了当前的例子，它展示了许多有用的快捷方式。这些功能简化了您创作宿主配置文件的方式。接下来，您将看到如何使用 WCF 服务图书馆项目模板。

Source Code

您可以在 [`Chapter 25`](25.html) 子目录中找到 MagicEightBallServiceHTTPDefaultBindings 项目。

## 使用 WCF 服务图书馆项目模板

在构建与您在第 21 章的[中创建的`AutoLot`数据库通信的更奇特的 WCF 服务之前，下一个例子将说明一些重要的主题，包括 WCF 服务库项目模板、WCF 测试客户端、WCF 配置编辑器、在 Windows 服务中托管 WCF 服务以及异步客户端调用的好处。为了专注于这些新概念，这项 WCF 服务将有意保持简单。](21.html)

### 构建简单的数学服务

首先，创建一个名为 MathServiceLibrary 的新 WCF 服务库项目，确保在“新建项目”对话框的“WCF”节点下选择了正确的选项(如果需要微调，请参见图 [25-2](#Fig2) )。现在将初始的`IService1.cs`文件的名称改为`IBasicMath.cs`。这样做之后，删除`MathServiceLibrary`名称空间中的所有示例代码，并用下面的代码替换它:

`[ServiceContract(Namespace="`[`http://MyCompany.com`](http://mycompany.com/)T2】

`public interface IBasicMath`

`{`

`[OperationContract]`

`int Add(int x, int y);`

`}`

接下来，将`Service1.cs`文件的名称改为`MathService.cs`，删除`MathServiceLibrary`名称空间中的所有示例代码(再次)，并如下实现您的服务契约:

`public class MathService : IBasicMath`

`{`

`public int Add(int x, int y)`

`{`

`// To simulate a lengthy request.`

`System.Threading.Thread.Sleep(5000);`

`return x + y;`

`}`

`}`

还要花点时间注意这个`*.config`文件已经被启用来支持 MEX 默认情况下，您的服务端点使用`basicHttpBinding`协议。

### 与 WcfTestClient.exe 一起测试 WCF 服务

使用 WCF 服务库项目的一个好处是，当您调试或运行您的库时，它将读取`*.config`文件中的设置，并使用它们来加载 WCF 测试客户端应用程序(`WcfTestClient.exe`)。这个基于 GUI 的应用程序允许您在构建 WCF 服务时测试服务接口的每个成员；这意味着您不必像以前那样，仅仅为了测试而手动构建主机/客户机。

图 [25-9](#Fig9) 显示了`MathService`的测试环境。请注意，双击接口方法时，可以指定输入参数并调用成员。

![A978-1-4842-1332-2_25_Fig9_HTML.jpg](img/A978-1-4842-1332-2_25_Fig9_HTML.jpg)

图 25-9。

Testing the WCF service using WcfTestClient.exe

当您已经创建了一个 WCF 服务库项目时，此实用程序可以开箱即用；但是，请注意，当您在命令行中通过指定一个 MEX 端点来启动 WCF 服务时，您可以使用该工具来测试它。例如，如果您要启动`MagicEightBallServiceHost.exe`应用程序，您可以在开发人员命令提示符下指定以下命令:

`wcftestclient` `http://localhost:8080/MagicEightBallService`

这样做之后，您可以用类似的方式调用`ObtainAnswerToQuestion()`。

### 使用 SvcConfigEditor.exe 更改配置文件

使用 WCF 服务库项目的另一个好处是，您能够在解决方案浏览器中右键单击`App.config`文件来激活基于 GUI 的服务配置编辑器`SvcConfigEditor.exe`(参见图 [25-10](#Fig10) )。引用了 WCF 服务的客户端应用程序也可以使用同样的技术。

![A978-1-4842-1332-2_25_Fig10_HTML.jpg](img/A978-1-4842-1332-2_25_Fig10_HTML.jpg)

图 25-10。

GUI-based *.config file editing starts here

激活该工具后，您可以使用友好的用户界面更改基于 XML 的数据。使用这样的工具来维护您的`*.config`文件有很多好处。首先(也是最重要的)，您可以放心，生成的标记符合预期的格式，并且没有打字错误。其次，这是查看可以分配给给定属性的有效值的好方法。最后，您不再需要手动创作繁琐的 XML 数据。

图 [25-11](#Fig11) 显示了服务配置编辑器的整体外观。说实话，可以用整整一章来描述所有有趣的选项`SvcConfigEditor.exe`支持。请务必花时间研究这个工具；还要注意，按 F1 可以访问相当详细的帮助系统。

![A978-1-4842-1332-2_25_Fig11_HTML.jpg](img/A978-1-4842-1332-2_25_Fig11_HTML.jpg)

图 25-11。

Working with the WCF Service Configuration Editor Note

即使您没有选择初始的 WCF 服务库项目，`SvcConfigEditor.exe`实用程序也可以编辑(或创建)配置文件。使用开发者命令窗口启动该工具，然后使用文件打开菜单选项加载现有的`*.config`文件进行编辑。

您无需进一步配置您的 WCF`MathService`；此时，您可以继续构建自定义主机的任务。

## 在 Windows 服务中托管 WCF 服务

从控制台应用程序(或者 GUI 桌面应用程序)中托管 WCF 服务对于生产级服务器来说并不是一个理想的选择，因为主机必须在后台可见地运行以服务客户端。即使您将宿主应用程序最小化到 Windows 任务栏，也很容易意外关闭主机，从而终止与任何客户端应用程序的连接。

Note

虽然桌面 Windows 应用程序不需要显示主窗口，但典型的`*.exe`确实需要用户交互来加载可执行文件。但是，即使当前没有用户登录到工作站，您也可以配置 Windows 服务(如下所述)来运行。

如果您构建一个内部的 WCF 应用程序，另一种选择是在一个专用的 Windows 服务中托管您的 WCF 服务库。这样做的一个好处是，您可以将 Windows 服务配置为在目标计算机启动时自动启动。另一个好处是 Windows 服务在后台不可见地运行(不像您的控制台应用程序)，并且不需要用户交互(并且您不需要在主机上安装 IIS)。

接下来，您将学习如何构建这样的主机。首先创建一个名为 MathWindowsServiceHost 的新 Windows 服务项目(参见图 [25-12](#Fig12) )。这样做之后，使用解决方案资源管理器将初始的`Service1.cs`文件重命名为`MathWinService.cs`。

![A978-1-4842-1332-2_25_Fig12_HTML.jpg](img/A978-1-4842-1332-2_25_Fig12_HTML.jpg)

图 25-12。

Creating a Windows service to host your WCF service

### 在代码中指定 ABC

现在假设您已经设置了对您的`MathServiceLibrary.dll`和`System.ServiceModel.dll`程序集的引用。你所需要做的就是在你的 Windows 服务类型的`OnStart()`和`OnStop()`方法中使用`ServiceHost`类型。打开服务主机类的代码文件(通过右键单击设计器并选择“查看代码”)，并添加以下逻辑:

`// Be sure to import these namespaces:`

`using MathServiceLibrary;`

`using System.ServiceModel;`

`namespace MathWindowsServiceHost`

`{`

`public partial class MathWinService: ServiceBase`

`{`

`// A member variable of type ServiceHost.`

`private ServiceHost myHost;`

`public MathWinService()`

`{`

`InitializeComponent();`

`}`

`protected override void OnStart(string[] args)`

`{`

`// Just to be really safe.`

`if (myHost != null)`

`{`

`myHost.Close();`

`myHost = null;`

`}`

`// Create the host.`

`myHost = new ServiceHost(typeof(MathService));`

`// The ABCs in code!`

`Uri address = new Uri("``http://localhost:8080/MathServiceLibrary`T2】

`WSHttpBinding binding = new WSHttpBinding();`

`Type contract = typeof(IBasicMath);`

`// Add this endpoint.`

`myHost.AddServiceEndpoint(contract, binding, address);`

`// Open the host.`

`myHost.Open();`

`}`

`protected override void OnStop()`

`{`

`// Shut down the host.`

`if(myHost != null)`

`myHost.Close();`

`}`

`}`

`}`

虽然在为 WCF 服务构建 Windows 服务主机时没有什么可以阻止您使用配置文件，但是这里(为了改变一下节奏)，您可以使用`Uri`、`WSHttpBinding`和`Type`类以编程方式建立端点，而不是使用`*.config`文件。在创建了 ABC 的每个方面之后，通过调用`AddServiceEndpoint()`以编程方式通知主机。

如果希望通知运行库您希望获得对存储在。NET 4.6 `machine.config`文件，您可以通过在调用`ServiceHost`的构造函数时指定基址来简化您的编程逻辑。在这种情况下，您不需要在代码中手动指定 ABC 或调用`AddServiceEndpoint()`；而是你叫`AddDefaultEndpoints()`。考虑以下更新:

`protected override void OnStart(string[] args)`

`{`

`if (myHost != null)`

`{`

`myHost.Close();`

`}`

`// Create the host and specify a URL for an HTTP binding.`

`myHost = new ServiceHost(typeof(MathService),`

`new Uri("``http://localhost:8080/MathServiceLibrary`T2】

`// Opt in for the default endpoints!`

`myHost.AddDefaultEndpoints();`

`// Open the host.`

`myHost.Open();`

`}`

### 启用墨西哥

虽然您也可以通过编程来启用 MEX，但是这里您将选择一个配置文件。将`App.config`文件修改到包含以下默认 MEX 设置的 Windows 服务项目中:

`<?xml version = "1.0" encoding = "utf-8" ?>`

`<configuration>`

`<system.serviceModel>`

`<services>`

`<service name = "MathServiceLibrary.MathService">`

`</service>`

`</services>`

`<behaviors>`

`<serviceBehaviors>`

`<behavior>`

`<serviceMetadata httpGetEnabled = "true"/>`

`</behavior>`

`</serviceBehaviors>`

`</behaviors>`

`</system.serviceModel>`

`</configuration>`

### 创建 Windows 服务安装程序

若要向操作系统注册 Windows 服务，您需要向项目中添加一个安装程序，其中包含允许您注册该服务的必要代码。为此，右键单击 Windows 服务设计器界面并选择添加安装程序(参见图 [25-13](#Fig13) )。

![A978-1-4842-1332-2_25_Fig13_HTML.jpg](img/A978-1-4842-1332-2_25_Fig13_HTML.jpg)

图 25-13。

Adding an installer for the Windows service

完成此操作后，您可以看到两个组件已经添加到表示安装程序的新设计器图面中。第一个组件(默认命名为`serviceProcessInstaller1`)表示可以在目标机器上安装新的 Windows 服务的项目。在设计器上选择此项，并使用属性窗口将`Account`属性设置为`LocalSystem`(参见图 [25-14](#Fig14) )。

![A978-1-4842-1332-2_25_Fig14_HTML.jpg](img/A978-1-4842-1332-2_25_Fig14_HTML.jpg)

图 25-14。

Be sure to run the Windows service as a local system account

第二个组件(名为`serviceInstaller1`)表示将安装您的特定 Windows 服务的类型。同样，使用属性窗口将`ServiceName`属性更改为`MathService`，将`StartType`属性设置为`Automatic`，并使用`Description`属性添加对您的 Windows 服务的友好描述(参见图 [25-15](#Fig15) )。

![A978-1-4842-1332-2_25_Fig15_HTML.jpg](img/A978-1-4842-1332-2_25_Fig15_HTML.jpg)

图 25-15。

Configuring installer details

此时，您可以编译您的应用程序了。

### 安装 Windows 服务

可以使用传统的安装程序(如`*.msi`安装程序)或通过`installutil.exe`命令行工具在主机上安装 Windows 服务。

Note

要使用`installutil.exe`安装 Windows 服务，您必须在管理权限下启动开发者命令提示符。为此，右键单击开发人员命令提示符图标，然后选择以管理员身份运行。

使用命令提示符，切换到 MathWindowsServiceHost 项目的`\bin\Debug`文件夹。现在，输入以下命令(确保您是以管理员身份运行的！):

`installutil MathWindowsServiceHost.exe`

假设安装成功，您现在可以打开位于控制面板的管理工具文件夹下的服务小程序。您应该会看到按字母顺序列出的 Windows 服务的友好名称。找到之后，确保使用启动链接在本地机器上启动服务(参见图 [25-16](#Fig16) )。

![A978-1-4842-1332-2_25_Fig16_HTML.jpg](img/A978-1-4842-1332-2_25_Fig16_HTML.jpg)

图 25-16。

Viewing your Windows service, which hosts your WCF service

既然服务已经启动，最后一步就是构建一个客户端应用程序来使用它的服务。

Source Code

你可以在 [`Chapter 25`](25.html) 子目录中找到 MathWindowsServiceHost 项目。

## 从客户端异步调用服务

创建一个名为 MathClient 的新控制台应用程序项目，并使用 Visual Studio 的“添加服务引用”选项设置对正在运行的 WCF 服务(当前由后台运行的 Windows 服务托管)的服务引用(您需要在“地址”框中键入 URL，应该是`http://localhost:8080/MathServiceLibrary`)。但是，先不要点击 OK 按钮！注意添加服务参考对话框的左下角有一个高级按钮(见图 [25-17](#Fig17) )。

![A978-1-4842-1332-2_25_Fig17_HTML.jpg](img/A978-1-4842-1332-2_25_Fig17_HTML.jpg)

图 25-17。

Referencing your MathService and getting ready to configure advanced settings

现在点击此按钮查看其他代理配置设置(参见图 [25-18](#Fig18) )。如果选中“生成异步运算符”单选选项，则可以使用此对话框生成允许以异步方式调用远程方法的代码。继续，暂时选中这个选项。

![A978-1-4842-1332-2_25_Fig18_HTML.jpg](img/A978-1-4842-1332-2_25_Fig18_HTML.jpg)

图 25-18。

Advanced client-side proxy configuration options

在这一点上，代理代码包含了额外的方法，这些方法允许您使用预期的`Begin` / `End`异步调用模式来调用服务契约的每个成员，这在[第 19 章](19.html)中有描述。下面是一个简单的实现，它使用了 lambda 表达式，而不是强类型的`AsyncCallback`委托:

`using System;`

`using MathClient.ServiceReference1;`

`...`

`namespace MathClient`

`{`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** The Async Math Client *****\n");`

`using (BasicMathClient proxy = new BasicMathClient())`

`{`

`proxy.Open();`

`// Add numbers in an async manner, using a lambda expression.`

`IAsyncResult result = proxy.BeginAdd(2, 3,`

`ar =>`

`{`

`Console.WriteLine("2 + 3 = {0}", proxy.EndAdd(ar));`

`},`

`null);`

`while (!result.IsCompleted)`

`{`

`Thread.Sleep(200);`

`Console.WriteLine("Client working...");`

`}`

`}`

`Console.ReadLine();`

`}`

`}`

`}`

Source Code

你可以在 [`Chapter 25`](25.html) 子目录中找到 MathClient 项目。

## 设计 WCF 数据契约

本章的最后一个例子向您展示了如何构建 WCF 数据契约。以前的 WCF 服务定义了操作原始 CLR 数据类型的简单方法。当您使用任何 HTTP 绑定类型(例如，`basicHttpBinding`和`wsHttpBinding`)时，传入和传出的简单数据类型会自动格式化为 XML 元素。另外，如果您使用基于 TCP 的绑定(如`netTcpBinding`)，简单数据类型的参数和返回值将使用紧凑的二进制格式进行传输。

Note

WCF 运行时还会自动对任何标有`[Serializable]`属性的类型进行编码；但是，这不是定义 WCF 协定的首选方式，它只是为了向后兼容而包含在内。

但是，当您定义使用自定义类作为参数或返回值的服务协定时，最佳实践是使用 WCF 数据协定对此类数据进行建模。简单地说，数据契约是一种带有`[DataContract]`属性的类型。同样，您必须用`[DataMember]`属性标记您期望用作提议契约的一部分的每个字段。

Note

在早期版本的。NET 平台，必须使用`[DataContract]`和`[DataMember]`来确保定制数据类型被正确表示。微软此后放宽了这一要求；从技术上讲，您不需要在自定义数据类型上使用这些属性；但是，这被认为是. NET 最佳实践。

### 使用以 Web 为中心的 WCF 服务项目模板

下一个 WCF 服务将允许外部调用程序与你在第 21 章中创建的`AutoLot`数据库进行交互。此外，这个最终的 WCF 服务将使用基于 web 的 WCF 服务模板创建，并托管在 IIS 下。

首先，启动 Visual Studio(具有管理员权限)并访问文件➤新➤网站菜单选项。选择 WCF 服务项目类型，并确保 Web 位置下拉列表设置为 HTTP(这将在 IIS 下安装服务)。从以下 URI 公开服务:

`http://localhost/AutoLotWCFService`

图 [25-19](#Fig19) 显示了配置的项目。

![A978-1-4842-1332-2_25_Fig19_HTML.jpg](img/A978-1-4842-1332-2_25_Fig19_HTML.jpg)

图 25-19。

Creating a web-centric WCF service

完成后，设置你在第 21 章[中创建的`AutoLotDAL.dll`组件的引用(使用➤网站的添加引用菜单选项)。您已经得到了一些示例启动代码(位于`App_Code`文件夹下)，您想要删除它们。首先将初始的`IService.cs`文件重命名为`IAutoLotService.cs`，然后在新命名的文件中定义初始服务契约，如下所示:](21.html)

`[ServiceContract]`

`public interface IAutoLotService`

`{`

`[OperationContract]`

`void InsertCar(int id, string make, string color, string petname);`

`[OperationContract]`

`void InsertCar(InventoryRecord car);`

`[OperationContract]`

`InventoryRecord[] GetInventory();`

`}`

该接口定义了三个方法，其中一个方法返回一个(尚待创建)`InventoryRecord`类型的数组。您可能还记得，`InventoryDAL`的`GetInventory()`方法只是返回了一个`DataTable`对象，这可能会让您想知道为什么您的服务的`GetInventory()`方法没有做同样的事情。

虽然从 WCF 服务方法返回一个`DataTable`是可行的，但是回想一下，WCF 是为了尊重 SOA 原则的使用而构建的，其中一个原则是针对合同而不是实现进行编程。

因此，您不会返回。NET 特定的`DataTable`类型传递给外部调用方；相反，您将返回一个自定义数据契约(`InventoryRecord`)，它将以不可知的方式在包含的 WSDL 文档中正确表达。

还要注意，前面列出的接口定义了一个名为`InsertCar()`的重载方法。第一个版本接受四个传入参数，而第二个版本接受一个`InventoryRecord`类型作为输入。您可以如下定义`InventoryRecord`数据契约:

`[DataContract]`

`public class InventoryRecord`

`{`

`[DataMember]`

`public int ID;`

`[DataMember]`

`public string Make;`

`[DataMember]`

`public string Color;`

`[DataMember]`

`public string PetName;`

`}`

如果您要实现目前的`IAutoLotService`接口，然后构建一个主机并尝试从客户端调用这些方法，您可能会惊讶地发现您会得到一个运行时异常。原因是:WSDL 描述的一个要求是，从给定端点公开的每个方法必须唯一命名。因此，虽然就 C#而言方法重载工作得很好，但是当前的 web 服务规范不允许两个同名的`InsertCar()`方法。

幸运的是，`[OperationContract]`属性支持一个命名属性(`Name`)，允许您指定如何在 WSDL 描述中表示 C#方法。鉴于此，你可以更新第二版`InsertCar()`如下:

`public interface IAutoLotService`

`{`

`...`

`[OperationContract(Name = "InsertCarWithDetails")]`

`void InsertCar(InventoryRecord car);`

`}`

### 实施服务合同

现在把`Service.cs`改名为`AutoLotService.cs`。`AutoLotService`类型如下实现了`IAutoLotService`接口(确保将`AutoLotConnectedLayer`和`System.Data`名称空间导入到该代码文件中，并在需要时更新您的连接字符串):

`using AutoLotDAL.ConnectedLayer;`

`using System.Data;`

`public class AutoLotService : IAutoLotService`

`{`

`private const string ConnString =`

`@"Data Source=(local)\SQLEXPRESS;Initial Catalog=AutoLot"+`

`";Integrated Security=True";`

`public void InsertCar(int id, string make, string color, string petname)`

`{`

`InventoryDAL d = new InventoryDAL();`

`d.OpenConnection(ConnString);`

`d.InsertAuto(id, color, make, petname);`

`d.CloseConnection();`

`}`

`public void InsertCar(InventoryRecord car)`

`{`

`InventoryDAL d = new InventoryDAL();`

`d.OpenConnection(ConnString);`

`d.InsertAuto(car.ID, car.Color, car.Make, car.PetName);`

`d.CloseConnection();`

`}`

`public InventoryRecord[] GetInventory()`

`{`

`// First, get the DataTable from the database.`

`InventoryDAL d = new InventoryDAL();`

`d.OpenConnection(ConnString);`

`DataTable dt = d.GetAllInventoryAsDataTable();`

`d.CloseConnection();`

`// Now make a List<T> to contain the records.`

`List<InventoryRecord> records = new List<InventoryRecord>();`

`// Copy the data table into List<> of custom contracts.`

`DataTableReader reader = dt.CreateDataReader();`

`while (reader.Read())`

`{`

`InventoryRecord r = new InventoryRecord();`

`r.ID = (int)reader["CarID"];`

`r.Color = ((string)reader["Color"]);`

`r.Make = ((string)reader["Make"]);`

`r.PetName = ((string)reader["PetName"]);`

`records.Add(r);`

`}`

`// Transform List<T> to array of InventoryRecord types.`

`return (InventoryRecord[])records.ToArray();`

`}`

`}`

前面的代码就不多说了。为了简单起见，您硬编码连接字符串值(您可能需要根据您的机器设置进行调整)，而不是将其存储在您的`Web.config`文件中。假设您的数据访问库完成了与`AutoLot`数据库通信的所有实际工作，那么您需要做的就是将传入参数传递给`InventoryDAL`类类型的`InsertAuto()`方法。另一个有趣的地方是将`DataTable`对象的值映射到一个通用的`InventoryRecord`类型列表中(使用一个`DataTableReader`)，然后将`List<T>`转换成一个`InventoryRecord`类型的数组。

### *的作用。svc 文件

当您创建一个以 web 为中心的 WCF 服务时，您会发现您的项目包含一个带有`*` `.svc`文件扩展名的特定文件。IIS 承载的任何 WCF 服务都需要此特定文件；它描述了安装点中服务实现的名称和位置。因为您已经更改了启动文件和 WCF 类型的名称，所以现在您必须更新`Service.svc`文件的内容，如下所示:

`<%@ ServiceHost Language="C#" Debug="true"`

`Service="AutoLotService" CodeBehind="∼/App_Code/AutoLotService.cs" %>`

### 检查 Web.config 文件

在 HTTP 下创建的 WCF 服务的`Web.config`文件将使用本章前面讨论过的许多 WCF 简化。在本书后面对 ASP.NET 的研究中将会有更详细的描述，`Web.config`文件的作用与可执行文件的`*.config`文件相似；但是，它也控制许多特定于 web 的设置。对于这个例子，请注意 MEX 是启用的，您不需要手动指定一个定制的`<endpoint>`。

`<configuration>`

`...`

`<system.serviceModel>`

`<behaviors>`

`<serviceBehaviors>`

`<behavior>`

`<!-- To avoid disclosing metadata information,`

`set the value below to false and remove the`

`metadata endpoint above before deployment -->`

`<serviceMetadata httpGetEnabled="true" httpsGetEnabled="true" />`

`<!-- To receive exception details in faults for debugging purposes,`

`set the value below to true.`

`Set to false before deployment to avoid`

`disclosing exception information -->`

`<serviceDebug includeExceptionDetailInFaults="false"/>`

`</behavior>`

`</serviceBehaviors>`

`</behaviors>`

`<serviceHostingEnvironment aspNetCompatibilityEnabled="true"`

`multipleSiteBindingsEnabled="true" />`

`</system.serviceModel>`

`...`

`</configuration>`

### 测试服务

现在您可以自由地构建任何类型的客户端来测试您的服务，包括将`*.svc`文件的端点传递给`WcfTestClient.exe`应用程序。

`WcfTestClient` `http://localhost/AutoLotWCFService/Service.svc`

如果要生成自定义客户端应用程序，可以使用“添加服务引用”对话框，就像本章前面对 MagicEightBallServiceClient 和 MathClient 项目示例所做的那样。

Source Code

您可以在 [`Chapter 25`](25.html) 子目录中找到 AutoLotService 项目。

这就结束了您对 Windows Communication Foundation API 的了解。当然，关于 WCF 的内容远不止这一章介绍的内容；然而，如果你理解了这里介绍的材料，你就可以找到更多你认为合适的细节。请务必查阅。NET Framework 4.6 SDK 文档，如果您想了解有关 WCF 的更多信息。

## 摘要

本章向您介绍了 Windows 通信基础(WCF)，它代表了。NET 平台。正如本章所解释的，WCF 背后的主要动机是提供一个统一的对象模型，在一个保护伞下公开许多(以前不相关的)分布式计算 API。此外，WCF 服务由指定的地址、绑定和契约(您可以通过友好的缩写 ABC 轻松记住)来表示。

您还了解了典型的 WCF 应用程序涉及到三个相关程序集的使用。第一个集合定义了代表服务功能的服务契约和服务类型。然后，此程序集由自定义可执行文件、IIS 虚拟目录或 Windows 服务承载。最后，客户端程序集使用生成的代码文件来与远程类型通信，该文件定义了代理类型(以及应用程序配置文件中的设置)。

本章还研究了如何使用许多 WCF 编程工具，例如`SvcConfigEditor.exe`(允许您修改`*.config`文件)、`WcfTestClient.exe`应用程序(快速测试 WCF 服务)和各种 Visual Studio WCF 项目模板。您还了解了许多配置简化，包括默认端点和行为。