# 8.使用界面

本章通过研究基于接口的编程主题，建立在您当前对面向对象开发的理解之上。在这里，您将学习如何定义和实现接口，并逐渐理解构建支持多种行为的类型的好处。在这个过程中，您还将研究许多相关的主题，例如获取接口引用、显式接口实现以及接口层次结构的构造。您还将研究在。NET 基础类库。正如您将看到的，您的自定义类和结构可以自由地实现这些预定义的接口，以支持许多有用的行为，如对象克隆、对象枚举和对象排序。

## 了解接口类型

在开始这一章时，请允许我提供一个接口类型的正式定义。接口只不过是一组命名的抽象成员。回想一下第 6 章的抽象方法是纯协议，因为它们不提供默认的实现。接口定义的具体成员取决于它所建模的确切行为。换句话说，接口表达了给定的类或结构可能选择支持的行为。此外，正如你将在本章看到的，一个类或结构可以支持任意多的接口，从而支持(本质上)多种行为。

正如您可能猜到的那样。NET 基础类库附带了许多由各种类和结构实现的预定义接口类型。例如，正如您将在第 21 章中看到的，ADO.NET 提供了多个数据提供者，允许您与特定的数据库管理系统进行通信。因此，在 ADO.NET 下，您有许多连接对象可供选择(`SqlConnection`、`OleDbConnection`、`OdbcConnection`等)。).此外，第三方数据库供应商(以及众多开源项目)提供。NET 库与大量其他数据库(MySQL、Oracle 等)进行通信。)，所有这些都包含实现这些接口的对象。

尽管每个连接类都有惟一的名称，在不同的名称空间中定义，并且(在某些情况下)捆绑在不同的程序集中，但所有连接类都实现了一个名为`IDbConnection`的公共接口。

`// The IDbConnection interface defines a common`

`// set of members supported by all connection objects.`

`public interface IDbConnection : IDisposable`

`{`

`// Methods`

`IDbTransaction BeginTransaction();`

`IDbTransaction BeginTransaction(IsolationLevel il);`

`void ChangeDatabase(string databaseName);`

`void Close();`

`IDbCommand CreateCommand();`

`void Open();`

`// Properties`

`string ConnectionString { get; set;}`

`int ConnectionTimeout { get; }`

`string Database { get; }`

`ConnectionState State { get; }`

`}`

Note

按照惯例，。NET 接口的前缀是大写字母 I。当您创建自己的自定义接口时，最好也这样做。

此时，不要关心这些成员实际做什么的细节。简单地理解一下，`IDbConnection`接口定义了一组所有 ADO.NET 连接类共有的成员。鉴于此，可以保证每个连接对象都支持诸如`Open()`、`Close()`、`CreateCommand()`等成员。此外，由于接口成员总是抽象的，每个连接对象都可以以自己独特的方式自由实现这些方法。

在阅读本书的剩余部分时，您将会接触到。NET 基础类库。正如您将看到的，这些接口可以在您自己的定制类和结构上实现，以定义与框架紧密集成的类型。同样，一旦你理解了接口类型的有用性，你肯定会找到构建你自己的接口类型的理由。

### 接口类型与抽象基类

鉴于你在第 6 章中的工作，接口类型可能看起来有点类似于抽象基类。回想一下，当一个类被标记为抽象时，它可以定义任意数量的抽象成员来为所有派生类型提供多态接口。然而，即使一个类定义了一组抽象成员，它也可以自由定义任意数量的构造函数、字段数据、非抽象成员(带实现)等等。另一方面，接口只包含成员定义。

由抽象父类建立的多态接口有一个主要限制，即只有派生类型支持由抽象父类定义的成员。然而，在更大的软件系统中，开发多个除了`System.Object`之外没有公共父类的类层次结构是很常见的。假设抽象基类中的抽象成员只适用于派生类型，您就没有办法在不同的层次结构中配置类型来支持相同的多态接口。举例来说，假设您已经定义了以下抽象类:

`public abstract class CloneableType`

`{`

`// Only derived types can support this`

`// "polymorphic interface." Classes in other`

`// hierarchies have no access to this abstract`

`// member.`

`public abstract object Clone();`

`}`

根据这个定义，只有扩展了`CloneableType`的成员才能支持`Clone()`方法。如果你创建了一组新的类，但没有扩展这个基类，你就不能获得这个多态接口。此外，您可能还记得 C#不支持类的多重继承。因此，如果你想创建一个`MiniVan`，它既是一个`Car`，又是一个`CloneableType`，你无法这样做。

`// Nope! Multiple inheritance is not possible in C#`

`// for classes.`

`public class MiniVan : Car, CloneableType`

`{`

`}`

正如你可能猜到的那样，接口类型来帮忙了。定义接口后，它可以由任何类或结构、任何层次结构、任何命名空间或任何程序集(用任何。NET 编程语言)。如你所见，接口是高度多态的。考虑标准。NET 接口命名为`ICloneable`，在`System`命名空间中定义。这个接口定义了一个名为`Clone()`的方法:

`public interface ICloneable`

`{`

`object Clone();`

`}`

如果你检查。NET Framework 4.6 SDK 文档，你会发现大量看似不相关的类型(`System.Array`、`System.Data.SqlClient.SqlConnection`、`System.OperatingSystem`、`System.String`等。)都实现了这个接口。尽管这些类型没有共同的父类型(除了`System.Object`，但是您可以通过`ICloneable`接口类型对它们进行多态处理。

例如，如果您有一个名为`CloneMe()`的方法，该方法采用了一个`ICloneable`接口参数，那么您可以将实现该接口的任何对象传递给该方法。考虑在名为 ICloneableExample 的控制台应用项目中定义的以下简单的`Program`类:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** A First Look at Interfaces *****\n");`

`// All of these classes support the ICloneable interface.`

`string myStr = "Hello";`

`OperatingSystem unixOS = new OperatingSystem(PlatformID.Unix, new Version());`

`System.Data.SqlClient.SqlConnection sqlCnn =`

`new System.Data.SqlClient.SqlConnection();`

`// Therefore, they can all be passed into a method taking ICloneable.`

`CloneMe(myStr);`

`CloneMe(unixOS);`

`CloneMe(sqlCnn);`

`Console.ReadLine();`

`}`

`private static void CloneMe(ICloneable c)`

`{`

`// Clone whatever we get and print out the name.`

`object theClone = c.Clone();`

`Console.WriteLine("Your clone is a: {0}",`

`theClone.GetType().Name);`

`}`

`}`

当您运行这个应用时，每个类的类名通过您从`System.Object`继承的`GetType()`方法打印到控制台。正如[第 15 章](15.html)中所解释的，这种方法(和。NET 反射服务)允许你在运行时理解任何类型的组成。无论如何，上一个程序的输出如下所示:

`***** A First Look at Interfaces *****`

`Your clone is a: String`

`Your clone is a: OperatingSystem`

`Your clone is a: SqlConnection`

Source Code

ICloneableExample 项目位于 [`Chapter 8`](08.html) 子目录下。

抽象基类的另一个限制是，每个派生类型都必须与一组抽象成员竞争，并提供一个实现。为了解决这个问题，回想一下你在第 6 章的[中定义的形状层次。假设您在名为`GetNumberOfPoints()`的`Shape`基类中定义了一个新的抽象方法，它允许派生类型返回呈现形状所需的点数。](06.html)

`abstract class Shape`

`{`

`...`

`// Every derived class must now support this method!`

`public abstract byte GetNumberOfPoints();`

`}`

显然，唯一有分数的职业是`Hexagon`。然而，有了这次更新，每个派生类(`Circle`、`Hexagon`和`ThreeDCircle`)现在都必须提供这个函数的具体实现，即使这样做毫无意义。同样，接口类型提供了一个解决方案。如果你定义了一个代表“拥有点”行为的接口，你可以简单地把它插入到`Hexagon`类型中，而不去碰`Circle`和`ThreeDCircle`。

## 定义自定义界面

现在，您已经更好地理解了接口类型的总体作用，让我们来看一个定义和实现定制接口的例子。首先，创建一个名为 CustomInterface 的新控制台应用项目。使用项目➤添加现有项目菜单选项，插入包含您在`Shapes`示例中[第 6 章](06.html)中创建的形状类型定义(本书的解决方案代码中的`Shapes.cs`)的文件。完成之后，将定义以形状为中心的类型的名称空间重命名为`CustomInterface`(只是为了避免在新项目中导入名称空间定义)。

`namespace CustomInterface`

`{`

`// Your shape types defined here...`

`}`

现在，使用项目➤的 Add New Item 菜单选项将一个新接口插入到名为`IPointy`的项目中，如图 [8-1](#Fig1) 所示。

![A978-1-4842-1332-2_8_Fig1_HTML.jpg](img/A978-1-4842-1332-2_8_Fig1_HTML.jpg)

图 8-1。

Interfaces, like classes, can be defined in any *.cs file

在语法层面，接口是使用 C# `interface`关键字定义的。与类不同，接口从不指定基类(甚至不指定`System.Object`；然而，正如你将在本章后面看到的，一个接口可以指定基本接口。此外，接口成员从不指定访问修饰符(因为所有接口成员都是隐式公共和抽象的)。为了让球滚动起来，这里有一个用 C#定义的自定义接口:

`// This interface defines the behavior of "having points."`

`public interface IPointy`

`{`

`// Implicitly public and abstract.`

`byte GetNumberOfPoints();`

`}`

请记住，当您定义接口成员时，您并没有为正在讨论的成员定义实现范围。接口是纯协议，因此从不定义实现(这取决于支持的类或结构)。因此，以下版本的`IPointy`会导致各种编译器错误:

`// Ack! Errors abound!`

`public interface IPointy`

`{`

`// Error! Interfaces cannot have data fields!`

`public int numbOfPoints;`

`// Error! Interfaces do not have constructors!`

`public IPointy() { numbOfPoints = 0;}`

`// Error! Interfaces don’t provide an implementation of members!`

`byte GetNumberOfPoints() { return numbOfPoints; }`

`}`

无论如何，这个初始的`IPointy`接口定义了一个方法。然而，。NET 接口类型也能够定义任意数量的属性原型。例如，让我们更新`IPointy`接口以使用只读属性，而不是传统的访问器方法。

`// The pointy behavior as a read-only property.`

`public interface IPointy`

`{`

`// A read-write property in an interface would look like:`

`// retType PropName { get; set; }`

`//`

`// while a write-only property in an interface would be:`

`// retType PropName { set; }`

`byte Points { get; }`

`}`

Note

接口类型也可以包含事件(见[第十章](10.html))和索引器(见[第十一章](11.html))定义。

接口类型本身毫无用处，因为它们只不过是抽象成员的命名集合。例如，不能像分配类或结构那样分配接口类型。

`// Ack! Illegal to allocate interface types.`

`static void Main(string[] args)`

`{`

`IPointy p = new IPointy(); // Compiler error!`

`}`

在被类或结构实现之前，接口不会带来太多好处。这里，`IPointy`是一个表示“有积分”行为的接口。这个想法很简单:形状层次结构中的一些类有点(如`Hexagon`)，而另一些类(如`Circle`)没有点。

## 实现接口

当一个类(或结构)选择通过支持接口来扩展其功能时，它会在类型定义中使用逗号分隔的列表。请注意，直接基类必须是冒号运算符后列出的第一项。当您的类类型直接从`System.Object`派生时，您可以简单地列出该类支持的接口(或多个接口),因为如果您没有另外说明，C#编译器将从`System.Object`扩展您的类型。与此相关的一点是，鉴于结构总是从`System.ValueType`派生而来(参见[第 4 章](04.html)，只需在结构定义后直接列出每个接口。思考下面的例子:

`// This class derives from System.Object and`

`// implements a single interface.`

`public class Pencil : IPointy`

`{...}`

`// This class also derives from System.Object`

`// and implements a single interface.`

`public class SwitchBlade : object, IPointy`

`{...}`

`// This class derives from a custom base class`

`// and implements a single interface.`

`public class Fork : Utensil, IPointy`

`{...}`

`// This struct implicitly derives from System.ValueType and`

`// implements two interfaces.`

`public struct PitchFork : ICloneable, IPointy`

`{...}`

理解实现一个接口是一个要么全有要么全无的命题。支持类型不能有选择地选择它将实现哪些成员。鉴于`IPointy`接口定义了一个只读属性，这并不是太大的负担。然而，如果你正在实现一个定义了 10 个成员的接口(比如前面显示的`IDbConnection`接口)，那么这个类型现在负责充实所有 10 个抽象成员的细节。

对于这个例子，插入一个名为`Triangle`的新类类型，它是-a `Shape`并支持`IPointy`。注意，只读`Points`属性的实现只是返回正确的点数(3)。

`// New Shape derived class named Triangle.`

`class Triangle : Shape, IPointy`

`{`

`public Triangle() { }`

`public Triangle(string name) : base(name) { }`

`public override void Draw()`

`{ Console.WriteLine("Drawing {0} the Triangle", PetName); }`

`// IPointy implementation.`

`public byte Points`

`{`

`get { return 3; }`

`}`

`}`

现在，更新您现有的`Hexagon`类型来支持`IPointy`接口类型。

`// Hexagon now implements IPointy.`

`class Hexagon : Shape, IPointy`

`{`

`public Hexagon(){ }`

`public Hexagon(string name) : base(name){ }`

`public override void Draw()`

`{ Console.WriteLine("Drawing {0} the Hexagon", PetName); }`

`// IPointy implementation.`

`public byte Points`

`{`

`get { return 6; }`

`}`

`}`

综上所述，图 [8-2](#Fig2) 所示的 Visual Studio 类图使用流行的“棒棒糖”符号说明了与`IPointy`兼容的类。再次注意，`Circle`和`ThreeDCircle`没有实现`IPointy`，因为这种行为对这些特定的类没有意义。

![A978-1-4842-1332-2_8_Fig2_HTML.jpg](img/A978-1-4842-1332-2_8_Fig2_HTML.jpg)

图 8-2。

The shapes hierarchy, now with interfaces Note

若要在类设计器中显示或隐藏接口名称，请右键单击接口图标，然后选择折叠或展开选项。

## 在对象级别调用接口成员

既然已经有了一些支持`IPointy`接口的类，下一个问题就是如何与新功能交互。与给定接口提供的功能进行交互的最直接方式是直接从对象级别调用成员(假设接口成员没有显式实现；您可以在“显式接口实现”一节中找到更多的细节。例如，考虑下面的`Main()`方法:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Interfaces *****\n");`

`// Call Points property defined by IPointy.`

`Hexagon hex = new Hexagon();`

`Console.WriteLine("Points: {0}", hex.Points);`

`Console.ReadLine();`

`}`

这种方法在这种特殊情况下工作得很好，假设您很清楚`Hexagon`类型已经实现了正在讨论的接口，因此有一个`Points`属性。但是，其他时候，您可能无法确定给定类型支持哪些接口。例如，假设您有一个包含 50 个`Shape`兼容类型的数组，其中只有一部分支持`IPointy`。显然，如果你试图在一个没有实现`IPointy`的类型上调用`Points`属性，你会收到一个错误。那么，如何动态地确定一个类或结构是否支持正确的接口呢？

在运行时确定类型是否支持特定接口的一种方法是使用显式强制转换。如果类型不支持请求的接口，您会收到一个`InvalidCastException`。若要妥善处理这种可能性，请使用结构化异常处理，如下例所示:

`static void Main(string[] args)`

`{`

`...`

`// Catch a possible InvalidCastException.`

`Circle c = new Circle("Lisa");`

`IPointy itfPt = null;`

`try`

`{`

`itfPt = (IPointy)c;`

`Console.WriteLine(itfPt.Points);`

`}`

`catch (InvalidCastException e)`

`{`

`Console.WriteLine(e.Message);`

`}`

`Console.ReadLine();`

`}`

虽然您可以使用`try` / `catch`逻辑并抱乐观态度，但是在调用接口成员之前确定支持哪些接口是最理想的。让我们看看这样做的两种方法。

### 获取接口引用:as 关键字

你可以通过使用第 6 章的[中介绍的`as`关键字来确定一个给定的类型是否支持一个接口。如果对象可以被视为指定的接口，则返回一个对相关接口的引用。如果没有，您将收到一个`null`参考。因此，在继续之前，一定要检查`null`值。](06.html)

`static void Main(string[] args)`

`{`

`...`

`// Can we treat hex2 as IPointy?`

`Hexagon hex2 = new Hexagon("Peter");`

`IPointy itfPt2 = hex2 as IPointy;`

`if(itfPt2 != null)`

`Console.WriteLine("Points: {0}", itfPt2.Points);`

`else`

`Console.WriteLine("OOPS! Not pointy...");`

`Console.ReadLine();`

`}`

请注意，当您使用`as`关键字时，您不需要使用`try` / `catch`逻辑，因为如果引用不是`null`，您知道您正在调用一个有效的接口引用。

### 获取接口引用:is 关键字

你也可以使用关键字`is`检查一个实现的接口(也是在[第 6 章](06.html)中首次讨论的)。如果有问题的对象与指定的接口不兼容，则返回值`false`。另一方面，如果类型与正在讨论的接口兼容，您可以安全地调用成员，而不需要使用`try` / `catch`逻辑。

举例来说，假设您有一个包含一些实现了`IPointy`的成员的`Shape`类型数组。注意如何使用`is`关键字来确定数组中的哪些项支持这个接口，如这个改进的`Main()`方法所示:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Interfaces *****\n");`

`// Make an array of Shapes.`

`Shape[] myShapes = { new Hexagon(), new Circle(),`

`new Triangle("Joe"), new Circle("JoJo")} ;`

`for(int i = 0; i < myShapes.Length; i++)`

`{`

`// Recall the Shape base class defines an abstract Draw()`

`// member, so all shapes know how to draw themselves.`

`myShapes[i].Draw();`

`// Who’s pointy?`

`if(myShapes[i] is IPointy)`

`Console.WriteLine("-> Points: {0}", ((IPointy) myShapes[i]).Points);`

`else`

`Console.WriteLine("-> {0}\’s not pointy!", myShapes[i].PetName);`

`Console.WriteLine();`

`}`

`Console.ReadLine();`

`}`

输出如下所示:

`***** Fun with Interfaces *****`

`Drawing NoName the Hexagon`

`-> Points: 6`

`Drawing NoName the Circle`

`-> NoName’s not pointy!`

`Drawing Joe the Triangle`

`-> Points: 3`

`Drawing JoJo the` `Circle`

`-> JoJo’s not pointy!`

## 作为参数的接口

假设接口是有效的。NET 类型，您可以构造将接口作为参数的方法，如本章前面的`CloneMe()`方法所示。对于当前的例子，假设您已经定义了另一个名为`IDraw3D`的接口。

`// Models the ability to render a type in stunning 3D.`

`public interface IDraw3D`

`{`

`void Draw3D();`

`}`

接下来，假设您的三个形状中的两个(`ThreeDCircle`和`Hexagon`)已经被配置为支持这个新行为。

`// Circle supports IDraw3D.`

`class ThreeDCircle : Circle, IDraw3D`

`{`

`...`

`public void Draw3D()`

`{ Console.WriteLine("Drawing Circle in 3D!"); }`

`}`

`// Hexagon supports IPointy and IDraw3D.`

`class Hexagon : Shape, IPointy, IDraw3D`

`{`

`...`

`public void Draw3D()`

`{ Console.WriteLine("Drawing Hexagon in 3D!"); }`

`}`

图 [8-3](#Fig3) 展示了更新后的 Visual Studio 类图。

![A978-1-4842-1332-2_8_Fig3_HTML.jpg](img/A978-1-4842-1332-2_8_Fig3_HTML.jpg)

图 8-3。

The updated shapes hierarchy

如果您现在定义了一个将`IDraw3D`接口作为参数的方法，那么您可以有效地发送任何实现`IDraw3D`的对象。(如果试图传入不支持必要接口的类型，会收到编译时错误。)考虑在您的`Program`类中定义的以下方法:

`// I’ll draw anyone supporting IDraw3D.`

`static void DrawIn3D(IDraw3D itf3d)`

`{`

`Console.WriteLine("-> Drawing IDraw3D compatible type");`

`itf3d.Draw3D();`

`}`

您现在可以测试`Shape`数组中的一个项目是否支持这个新接口，如果支持，就将其传递给`DrawIn3D()`方法进行处理。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Interfaces *****\n");`

`Shape[] myShapes = { new Hexagon(), new Circle(),`

`new Triangle("Joe"), new Circle("JoJo") } ;`

`for(int i = 0; i < myShapes.Length; i++)`

`{`

`...`

`// Can I draw you in 3D?`

`if(myShapes[i] is IDraw3D)`

`DrawIn3D((IDraw3D)myShapes[i]);`

`}`

`}`

下面是更新后的应用的输出。注意，只有`Hexagon`对象在 3D 中打印出来，因为`Shape`数组的其他成员没有实现`IDraw3D`接口。

`***** Fun with Interfaces *****`

`Drawing NoName the Hexagon`

`-> Points: 6`

`-> Drawing IDraw3D compatible type`

`Drawing Hexagon in 3D!`

`Drawing NoName the Circle`

`-> NoName’s not pointy!`

`Drawing Joe the Triangle`

`-> Points: 3`

`Drawing JoJo the Circle`

`-> JoJo’s not pointy!`

## 作为返回值的接口

接口也可以用作方法返回值。例如，您可以编写一个方法，该方法采用一组`Shape`对象，并返回对第一个支持`IPointy`的项的引用。

`// This method returns the first object in the`

`// array that implements IPointy.`

`static IPointy FindFirstPointyShape(Shape[] shapes)`

`{`

`foreach (Shape s in shapes)`

`{`

`if (s is IPointy)`

`return s as IPointy;`

`}`

`return null;`

`}`

您可以按如下方式与此方法交互:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Interfaces *****\n");`

`// Make an array of Shapes.`

`Shape[] myShapes = { new Hexagon(), new Circle(),`

`new Triangle("Joe"), new Circle("JoJo")};`

`// Get first pointy item.`

`// To be safe, you’d want to check firstPointyItem for null before proceeding.`

`IPointy firstPointyItem = FindFirstPointyShape(myShapes);`

`Console.WriteLine("The item has {0} points", firstPointyItem.Points);`

`...`

`}`

## 接口类型数组

回想一下，同一个接口可以由许多类型实现，即使它们不在同一个类层次结构中，并且没有超过`System.Object`的公共父类。这可以产生一些强大的编程结构。例如，假设您已经在您当前的项目中开发了三个新的类类型来建模厨房用具(通过`Knife`和`Fork`类)和另一个建模园艺设备(à la `PitchFork`)。考虑图 [8-4](#Fig4) 。

![A978-1-4842-1332-2_8_Fig4_HTML.jpg](img/A978-1-4842-1332-2_8_Fig4_HTML.jpg)

图 8-4。

Recall that interfaces can be “plugged into” any type in any part of a class hierarchy

如果您定义了`PitchFork`、`Fork`和`Knife`类型，那么您现在可以定义一个`IPointy`兼容对象的数组。假设这些成员都支持相同的接口，那么您可以遍历数组并将每一项视为一个`IPointy`兼容的对象，而不管类层次结构的总体多样性。

`static void Main(string[] args)`

`{`

`...`

`// This array can only contain types that`

`// implement the IPointy interface.`

`IPointy[] myPointyObjects = {new Hexagon(), new Knife(),`

`new Triangle(), new Fork(), new PitchFork()};`

`foreach(IPointy i in myPointyObjects)`

`Console.WriteLine("Object has {0} points.", i.Points);`

`Console.ReadLine();`

`}`

为了强调这个例子的重要性，请记住:当你有一个给定接口的数组时，这个数组可以包含任何实现这个接口的类或结构。

Source Code

CustomInterface 项目位于 [`Chapter 8`](08.html) 子目录下。

## 使用 Visual Studio 实现接口

尽管基于接口的编程是一种强大的技术，但是实现接口可能需要大量的输入。假设接口是一组命名的抽象成员，您需要为支持该行为的每个类型的每个接口方法键入定义和实现。因此，如果您想要支持一个总共定义了五个方法和三个属性的接口，您需要考虑所有八个成员(否则您将会收到编译器错误)。

正如您所希望的，Visual Studio 支持各种工具，这些工具可以减轻实现接口的负担。通过一个简单的测试，将一个 final 类插入到当前名为`PointyTestClass`的项目中。当您向一个类类型添加一个接口，比如`IPointy`(或者任何接口)，您可能已经注意到，当您完成输入接口的名称时(或者当您在代码窗口中将鼠标光标放在接口名称上时)，第一个字母会加下划线(正式名称为智能标记)。当你点击智能标记时，会出现一个下拉列表，允许你实现接口(见图 [8-5](#Fig5) )。

![A978-1-4842-1332-2_8_Fig5_HTML.jpg](img/A978-1-4842-1332-2_8_Fig5_HTML.jpg)

图 8-5。

Implementing interfaces using Visual Studio

注意，您有两个选择，第二个(显式接口实现)将在下一节中讨论。暂时选择第一个选项，你会看到 Visual Studio 已经生成了存根代码供你更新(注意默认实现抛出一个`System.NotImplementedException`，显然可以删除)。

`namespace CustomInterface`

`{`

`class PointyTestClass : IPointy`

`{`

`public byte Points`

`{`

`get { throw new NotImplementedException(); }`

`}`

`}`

`}`

Note

Visual Studio 还支持提取接口重构，可从“快速操作”菜单的“提取接口”选项中获得。这允许您从现有的类定义中提取新的接口定义。例如，您可能正在编写一个类，这时您突然意识到可以将行为一般化到一个接口中(从而打开了替代实现的可能性)。

## 显式接口实现

如本章前面所示，一个类或结构可以实现任意数量的接口。考虑到这一点，您总是有可能实现包含相同成员的接口，因此有名称冲突要处理。为了说明解决此问题的各种方式，请创建一个名为 InterfaceNameClash 的新控制台应用项目。现在设计三个接口，表示实现类型可以将其输出呈现到的不同位置。

`// Draw image to a form.`

`public interface IDrawToForm`

`{`

`void Draw();`

`}`

`// Draw to buffer in memory.`

`public interface IDrawToMemory`

`{`

`void Draw();`

`}`

`// Render to the printer.`

`public interface IDrawToPrinter`

`{`

`void Draw();`

`}`

注意，每个接口都定义了一个名为`Draw()`的方法，具有相同的签名(碰巧没有参数)。如果您现在想要在名为`Octagon`的单个类类型上支持这些接口，编译器将允许以下定义:

`class Octagon : IDrawToForm, IDrawToMemory, IDrawToPrinter`

`{`

`public void Draw()`

`{`

`// Shared drawing logic.`

`Console.WriteLine("Drawing the Octagon...");`

`}`

`}`

尽管代码可以干净地编译，但是您可能会遇到一个问题。简单地说，提供`Draw()`方法的单一实现并不允许您根据从`Octagon`对象获得的接口采取独特的行动。例如，下面的代码将调用相同的`Draw()`方法，而不管您获得哪个接口:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Interface Name Clashes *****\n");`

`// All of these invocations call the`

`// same Draw() method!`

`Octagon oct = new Octagon();`

`IDrawToForm itfForm = (IDrawToForm)oct;`

`itfForm.Draw();`

`IDrawToPrinter itfPriner = (IDrawToPrinter)oct;`

`itfPriner.Draw();`

`IDrawToMemory itfMemory = (IDrawToMemory)oct;`

`itfMemory.Draw();`

`Console.ReadLine();`

`}`

显然，将图像呈现到窗口所需的代码与将图像呈现到网络打印机或内存区域所需的代码完全不同。当您实现几个具有相同成员的接口时，可以使用显式接口实现语法来解决这种名称冲突。考虑以下对`Octagon`类型的更新:

`class Octagon : IDrawToForm, IDrawToMemory, IDrawToPrinter`

`{`

`// Explicitly bind Draw() implementations`

`// to a given interface.`

`void IDrawToForm.Draw()`

`{`

`Console.WriteLine("Drawing to form...");`

`}`

`void IDrawToMemory.Draw()`

`{`

`Console.WriteLine("Drawing to memory...");`

`}`

`void IDrawToPrinter.Draw()`

`{`

`Console.WriteLine("Drawing to a printer...");`

`}`

`}`

如您所见，当显式实现接口成员时，一般模式可以分解为:

`returnType InterfaceName.MethodName(params){}`

请注意，使用此语法时，不需要提供访问修饰符；显式实现的成员自动是私有的。例如，以下是非法语法:

`// Error! No access modifier!`

`public void IDrawToForm.Draw()`

`{`

`Console.WriteLine("Drawing to form...");`

`}`

因为显式实现的成员总是隐式私有的，所以这些成员在对象级别不再可用。事实上，如果您将点运算符应用于一个`Octagon`类型，您会发现 IntelliSense 不会向您显示任何`Draw()`成员。正如所料，您必须使用显式转换来访问所需的功能。这里有一个例子:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Interface Name Clashes *****\n");`

`Octagon oct = new Octagon();`

`// We now must use casting to access the Draw()`

`// members.`

`IDrawToForm itfForm = (IDrawToForm)oct;`

`itfForm.Draw();`

`// Shorthand notation if you don’t need`

`// the interface variable for later use.`

`((IDrawToPrinter)oct).Draw();`

`// Could also use the "is" keyword.`

`if(oct is IDrawToMemory)`

`((IDrawToMemory)oct).Draw();`

`Console.ReadLine();`

`}`

虽然当您需要解决名称冲突时，这种语法非常有用，但是您可以使用显式接口实现来简单地隐藏对象级别的更多“高级”成员。这样，当对象用户应用点运算符时，用户将只能看到该类型整体功能的一个子集。但是，那些需要更高级行为的人可以通过显式强制转换提取所需的接口。

Source Code

InterfaceNameClash 项目位于 [`Chapter 8`](08.html) 子目录中。

## 设计界面层次结构

接口可以排列在接口层次结构中。像类层次结构一样，当一个接口扩展一个现有的接口时，它继承了由父类定义的抽象成员。当然，与基于类的继承不同，派生接口从不继承真正的实现。相反，派生接口只是用额外的抽象成员扩展了它自己的定义。

当您希望在不破坏现有代码库的情况下扩展现有接口的功能时，接口层次结构会很有用。为了进行说明，创建一个名为 InterfaceHierarchy 的新控制台应用项目。现在，让我们设计一组新的以渲染为中心的界面，这样`IDrawable`就是家谱的根。

`public interface IDrawable`

`{`

`void Draw();`

`}`

鉴于`IDrawable`定义了一个基本的绘制行为，您现在可以创建一个派生接口，用修改后的格式来扩展这个接口。这里有一个例子:

`public interface IAdvancedDraw : IDrawable`

`{`

`void DrawInBoundingBox(int top, int left, int bottom, int right);`

`void DrawUpsideDown();`

`}`

根据这种设计，如果一个类要实现`IAdvancedDraw`，那么它现在需要实现继承链中定义的每个成员(特别是`Draw()`、`DrawInBoundingBox()`和`DrawUpsideDown()`方法)。

`public class BitmapImage : IAdvancedDraw`

`{`

`public void Draw()`

`{`

`Console.WriteLine("Drawing...");`

`}`

`public void DrawInBoundingBox(int top, int left, int bottom, int right)`

`{`

`Console.WriteLine("Drawing in a box...");`

`}`

`public void DrawUpsideDown()`

`{`

`Console.WriteLine("Drawing upside down!");`

`}`

`}`

现在，当您使用`BitmapImage`时，您能够在对象级别调用每个方法(因为它们都是`public`)，以及通过强制转换提取对每个支持的接口的引用。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Simple Interface Hierarchy *****");`

`// Call from object level.`

`BitmapImage myBitmap = new BitmapImage();`

`myBitmap.Draw();`

`myBitmap.DrawInBoundingBox(10, 10, 100, 150);`

`myBitmap.DrawUpsideDown();`

`// Get IAdvancedDraw explicitly.`

`IAdvancedDraw iAdvDraw = myBitmap as IAdvancedDraw;`

`if(iAdvDraw != null)`

`iAdvDraw.DrawUpsideDown();`

`Console.ReadLine();`

`}`

Source Code

InterfaceHierarchy 项目位于 [`Chapter 8`](08.html) 子目录中。

### 接口类型的多重继承

与类类型不同，一个接口可以扩展多个基本接口，允许您设计一些强大而灵活的抽象。创建一个名为 MIInterfaceHierarchy 的新控制台应用项目。这是另一个接口集合，对各种渲染和形状抽象进行建模。注意，`IShape`接口同时扩展了`IDrawable`和`IPrintable`。

`// Multiple inheritance for interface types is a-okay.`

`interface IDrawable`

`{`

`void Draw();`

`}`

`interface IPrintable`

`{`

`void Print();`

`void Draw(); // <-- Note possible name clash here!`

`}`

`// Multiple interface inheritance. OK!`

`interface IShape : IDrawable, IPrintable`

`{`

`int GetNumberOfSides();`

`}`

图 [8-6](#Fig6) 显示了当前的接口层次。

![A978-1-4842-1332-2_8_Fig6_HTML.jpg](img/A978-1-4842-1332-2_8_Fig6_HTML.jpg)

图 8-6。

Unlike classes, interfaces can extend multiple interface types

此时，最大的问题是，如果你有一个支持`IShape`的类，需要实现多少个方法？答案是:视情况而定。如果你想提供一个简单的`Draw()`方法的实现，你只需要提供三个成员，如下面的`Rectangle`类型所示:

`class Rectangle : IShape`

`{`

`public int GetNumberOfSides()`

`{ return 4; }`

`public void Draw()`

`{ Console.WriteLine("Drawing..."); }`

`public void Print()`

`{ Console.WriteLine("Printing..."); }`

`}`

如果您希望每个`Draw()`方法都有特定的实现(在这种情况下最有意义)，您可以使用显式接口实现来解决名称冲突，如下面的`Square`类型所示:

`class Square : IShape`

`{`

`// Using explicit implementation to handle member name clash.`

`void IPrintable.Draw()`

`{`

`// Draw to printer ...`

`}`

`void IDrawable.Draw()`

`{`

`// Draw to screen ...`

`}`

`public void Print()`

`{`

`// Print ...`

`}`

`public int GetNumberOfSides()`

`{ return 4; }`

`}`

理想情况下，此时您会对使用 C#语法定义和实现自定义接口的过程感到更加舒适。老实说，基于接口的编程可能需要一段时间才能适应，所以如果你实际上仍然有点挠头，这是完全正常的反应。

但是，请注意，接口是。NET 框架。不管你开发的应用是什么类型(基于网络的，桌面图形用户界面，数据访问库，等等)。)，使用接口将是这个过程的一部分。总结一下到目前为止的情况，记住接口在以下情况下非常有用

*   您有一个单一的层次结构，其中只有派生类型的子集支持一个公共行为。
*   您需要对一个常见的行为进行建模，这个行为存在于多个层次结构中，除了`System.Object`之外没有共同的父类。

既然您已经深入研究了构建和实现自定义接口的细节，本章的剩余部分将研究。NET 基础类库。正如您将看到，您可以实现标准。NET 接口，以确保它们无缝集成到框架中。

Source Code

MIInterfaceHierarchy 项目位于 [`Chapter 8`](08.html) 子目录中。

## IEnumerable 和 IEnumerator 接口

开始检查实现现有。NET 接口，我们先来看看`IEnumerable`和`IEnumerator`的作用。回想一下，C#支持一个名为`foreach`的关键字，它允许你迭代任何数组类型的内容。

`// Iterate over an array of items.`

`int[] myArrayOfInts = {10, 20, 30, 40};`

`foreach(int i in myArrayOfInts)`

`{`

`Console.WriteLine(i);`

`}`

虽然看起来只有数组类型可以使用这个构造，但事实是任何支持名为`GetEnumerator()`的方法的类型都可以被`foreach`构造求值。举例来说，首先创建一个名为 CustomEnumerator 的新控制台应用项目。接下来，添加[第 7 章](07.html)的 SimpleException 示例中定义的`Car.cs`和`Radio.cs`文件(通过项目➤添加现有项菜单选项)。

Note

您可能希望将包含`Car`和`Radio`类型的名称空间重命名为`CustomEnumerator`，以避免必须在这个新项目中导入`CustomException`名称空间。

现在，插入一个名为`Garage`的新类，它在一个`System.Array`中存储一组`Car`对象。

`// Garage contains a set of Car objects.`

`public class Garage`

`{`

`private Car[] carArray = new Car[4];`

`// Fill with some Car objects upon startup.`

`public Garage()`

`{`

`carArray[0] = new Car("Rusty", 30);`

`carArray[1] = new Car("Clunker", 55);`

`carArray[2] = new Car("Zippy", 30);`

`carArray[3] = new Car("Fred", 30);`

`}`

`}`

理想情况下，使用`foreach`构造遍历`Garage`对象的子项会很方便，就像数据值数组一样。

`// This seems reasonable ...`

`public class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with IEnumerable / IEnumerator *****\n");`

`Garage carLot = new Garage();`

`// Hand over each car in the collection?`

`foreach (Car c in carLot)`

`{`

`Console.WriteLine("{0} is going {1} MPH",`

`c.PetName, c.CurrentSpeed);`

`}`

`Console.ReadLine();`

`}`

`}`

遗憾的是，编译器通知您,`Garage`类没有实现名为`GetEnumerator()`的方法。这个方法由隐藏在`System.Collections`名称空间中的`IEnumerable`接口形式化。

Note

在[第 9 章](09.html)中，你将学习泛型的角色和`System.Collections.Generic`名称空间。正如您将看到的，这个名称空间包含了通用版本的`IEnumerable/IEnumerator`，它提供了一种更加类型安全的方式来迭代条目。

支持这种行为的类或结构宣称它们能够向调用者公开所包含的项目(在本例中，是关键字`foreach`本身)。下面是这个标准的定义。网络接口:

`// This interface informs the caller`

`// that the object’s items can be enumerated.`

`public interface IEnumerable`

`{`

`IEnumerator GetEnumerator();`

`}`

如您所见，`GetEnumerator()`方法返回了对另一个名为`System.Collections.IEnumerator`的接口的引用。该接口提供了允许调用者遍历兼容`IEnumerable`的容器所包含的内部对象的基础设施。

`// This interface allows the caller to`

`// obtain a container’s items.`

`public interface IEnumerator`

`{`

`bool MoveNext ();        // Advance the internal position of the cursor.`

`object Current { get;}   // Get the current item (read-only property).`

`void Reset ();           // Reset the cursor before the first member.`

`}`

如果您想更新`Garage`类型来支持这些接口，您可以走很长的路，手动实现每个方法。虽然你当然可以自由地提供定制版本的`GetEnumerator()`、`MoveNext()`、`Current`和`Reset()`，但是有一个更简单的方法。由于`System.Array`类型(以及许多其他集合类)已经实现了`IEnumerable`和`IEnumerator`，您可以简单地将请求委托给`System.Array`，如下所示(注意，您需要将`System.Collections`名称空间导入到您的代码文件中):

`using System.Collections;`

`...`

`public class Garage : IEnumerable`

`{`

`// System.Array already implements IEnumerator!`

`private Car[] carArray = new Car[4];`

`public Garage()`

`{`

`carArray[0] = new Car("FeeFee", 200);`

`carArray[1] = new Car("Clunker", 90);`

`carArray[2] = new Car("Zippy", 30);`

`carArray[3] = new Car("Fred", 30);`

`}`

`public IEnumerator GetEnumerator()`

`{`

`// Return the array object’s IEnumerator.`

`return carArray.GetEnumerator();`

`}`

`}`

在您更新了您的`Garage`类型之后，您可以在 C# `foreach`构造中安全地使用该类型。此外，鉴于`GetEnumerator()`方法已经被公开定义，对象用户也可以与`IEnumerator`类型交互。

`// Manually work with IEnumerator.`

`IEnumerator i = carLot.GetEnumerator();`

`i.MoveNext();`

`Car myCar = (Car)i.Current;`

`Console.WriteLine("{0} is going {1} MPH", myCar.PetName, myCar.CurrentSpeed);`

然而，如果您喜欢在对象级隐藏`IEnumerable`的功能，只需使用显式接口实现。

`IEnumerator IEnumerable.GetEnumerator()`

`{`

`// Return the array object’s IEnumerator.`

`return carArray.GetEnumerator();`

`}`

通过这样做，偶然的对象用户将不会发现`Garage`的`GetEnumerator()`方法，而`foreach`构造将在必要时在后台获得接口。

Source Code

CustomEnumerator 项目位于 [`Chapter 8`](08.html) 子目录中。

### 用 yield 关键字构建迭代器方法

有一种替代方法可以通过迭代器构建与`foreach`循环一起工作的类型。简单地说，迭代器是一个成员，它指定容器的内部项在被`foreach`处理时应该如何返回。举例来说，创建一个名为 CustomEnumeratorWithYield 的新控制台应用项目，并插入上一个示例中的`Car`、`Radio`和`Garage`类型(同样，如果愿意，可以将名称空间定义重命名为当前项目)。现在，对当前的`Garage`型进行如下改装:

`public class Garage : IEnumerable`

`{`

`private Car[] carArray = new Car[4];`

`...`

`// Iterator method.`

`public IEnumerator GetEnumerator()`

`{`

`foreach (Car c in carArray)`

`{`

`yield return c;`

`}`

`}`

`}`

注意，`GetEnumerator()`的这个实现使用内部`foreach`逻辑遍历子项，并使用`yield return`语法将每个`Car`返回给调用者。`yield`关键字用于指定返回给调用者的`foreach`结构的值。当到达`yield return`语句时，存储容器中的当前位置，下次调用迭代器时从这个位置重新开始执行。

迭代器方法不需要使用`foreach`关键字来返回其内容。也可以将这个迭代器方法定义如下:

`public IEnumerator GetEnumerator()`

`{`

`yield return carArray[0];`

`yield return carArray[1];`

`yield return carArray[2];`

`yield return carArray[3];`

`}`

在这个实现中，注意到`GetEnumerator()`方法在每次传递时都显式地向调用者返回一个新值。在这个例子中这样做没有什么意义，因为如果您要向`carArray`成员变量添加更多的对象，那么您的`GetEnumerator()`方法现在将会不同步。然而，当您想从一个方法返回本地数据以便用`foreach`语法处理时，这个语法会很有用。

### 构建命名迭代器

有趣的是，`yield`关键字在技术上可以用在任何方法中，不管它的名字是什么。这些方法(技术上称为命名迭代器)的独特之处还在于它们可以接受任意数量的参数。当构建一个命名迭代器时，要注意该方法将返回`IEnumerable`接口，而不是预期的`IEnumerator`兼容类型。举例来说，您可以将下面的方法添加到`Garage`类型中:

`public IEnumerable GetTheCars(bool ReturnRevesed)`

`{`

`// Return the items in reverse.`

`if (ReturnRevesed)`

`{`

`for (int i = carArray.Length; i != 0; i--)`

`{`

`yield return carArray[i-1];`

`}`

`}`

`else`

`{`

`// Return the items as placed in the array.`

`foreach (Car c in carArray)`

`{`

`yield return c;`

`}`

`}`

`}`

注意，如果传入参数的值为`true`，新方法允许调用者以顺序和逆序获取子项。现在，您可以按如下方式与新方法进行交互:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with the Yield Keyword *****\n");`

`Garage carLot = new Garage();`

`// Get items using GetEnumerator().`

`foreach (Car c in carLot)`

`{`

`Console.WriteLine("{0} is going {1} MPH",`

`c.PetName, c.CurrentSpeed);`

`}`

`Console.WriteLine();`

`// Get items (in reverse!) using named iterator.`

`foreach (Car c in carLot.GetTheCars(true))`

`{`

`Console.WriteLine("{0} is going {1} MPH",`

`c.PetName, c.CurrentSpeed);`

`}`

`Console.ReadLine();`

`}`

您可能同意，命名迭代器是有用的构造，因为单个定制容器可以定义多种方式来请求返回的集合。

所以，总结一下构建可枚举对象，记住，对于使用 C# `foreach`关键字的自定义类型，容器必须定义一个名为`GetEnumerator()`的方法，该方法已经由`IEnumerable`接口类型形式化。此方法的实现通常通过简单地将它委托给持有子对象的内部成员来实现；然而，也可以使用`yield return`语法来提供多个“命名迭代器”方法。

Source Code

CustomEnumeratorWithYield 项目位于 [`Chapter 8`](08.html) 子目录中。

## 可克隆的接口

您可能还记得第六章中的[，`System.Object`定义了一个名为`MemberwiseClone()`的方法。此方法用于获取当前对象的浅表副本。对象用户不直接调用此方法，因为它是受保护的。但是，在克隆过程中，给定的对象可能会调用此方法本身。举例来说，创建一个名为 CloneablePoint 的新控制台应用项目，它定义了一个名为`Point`的类。](06.html)

`// A class named Point.`

`public class Point`

`{`

`public int X {get; set;}`

`public int Y {get; set;}`

`public Point(int xPos, int yPos) { X = xPos; Y = yPos;}`

`public Point(){}`

`// Override Object.ToString().`

`public override string ToString()`

`{ return string.Format("X = {0}; Y = {1}", X, Y ); }`

`}`

考虑到你已经知道的引用类型和值类型(见第四章)，你知道如果你把一个引用变量赋给另一个，你会有两个引用指向内存中的同一个对象。因此，下面的赋值操作导致对堆上同一个`Point`对象的两次引用；使用任一引用的修改都会影响堆上的同一对象:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Object Cloning *****\n");`

`// Two references to same object!`

`Point p1 = new Point(50, 50);`

`Point p2 = p1;`

`p2.X = 0;`

`Console.WriteLine(p1);`

`Console.WriteLine(p2);`

`Console.ReadLine();`

`}`

当您想让您的自定义类型能够向调用者返回其自身的相同副本时，您可以实现标准的`ICloneable`接口。如本章开头所示，该类型定义了一个名为`Clone()`的方法。

`public interface ICloneable`

`{`

`object Clone();`

`}`

显然，`Clone()`方法的实现因类而异。但是，基本功能是相同的:将成员变量的值复制到一个相同类型的新对象实例中，并将其返回给用户。为了说明这一点，请考虑下面对`Point`类的更新:

`// The Point now supports "clone-ability."`

`public class Point : ICloneable`

`{`

`public int X { get; set; }`

`public int Y { get; set; }`

`public Point(int xPos, int yPos) { X = xPos; Y = yPos; }`

`public Point() { }`

`// Override Object.ToString().`

`public override string ToString()`

`{ return string.Format("X = {0}; Y = {1}", X, Y); }`

`// Return a copy of the current object.`

`public object Clone()`

`{ return new Point(this.X, this.Y); }`

`}`

这样，您可以创建`Point`类型的精确独立副本，如以下代码所示:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Object Cloning *****\n");`

`// Notice Clone() returns a plain object type.`

`// You must perform an explicit cast to obtain the derived type.`

`Point p3 = new Point(100, 100);`

`Point p4 = (Point)p3.Clone();`

`// Change p4.X (which will not change p3.X).`

`p4.X = 0;`

`// Print each object.`

`Console.WriteLine(p3);`

`Console.WriteLine(p4);`

`Console.ReadLine();`

`}`

虽然当前的`Point`实现符合要求，但是您可以稍微简化一下。因为`Point`类型不包含任何内部引用类型变量，您可以将`Clone()`方法的实现简化如下:

`public object Clone()`

`{`

`// Copy each field of the Point member by member.`

`return this.MemberwiseClone();`

`}`

但是，请注意，如果`Point`确实包含任何引用类型成员变量，`MemberwiseClone()`将复制对这些对象的引用(即浅层复制)。如果您想要支持真正的深度复制，您将需要在克隆过程中创建任何引用类型变量的新实例。接下来我们来看一个例子。

### 一个更复杂的克隆例子

现在假设`Point`类包含一个`PointDescription`类型的引用类型成员变量。这个类维护一个点的友好名称以及一个标识号，表示为一个`System.Guid`(一个全局唯一标识符【GUID】是一个统计上唯一的 128 位数字)。下面是实现过程:

`// This class describes a point.`

`public class PointDescription`

`{`

`public string PetName {get; set;}`

`public Guid PointID {get; set;}`

`public PointDescription()`

`{`

`PetName = "No-name";`

`PointID = Guid.NewGuid();`

`}`

`}`

对`Point`类本身的初始更新包括修改`ToString()`来说明这些新的状态数据，以及定义和创建`PointDescription`引用类型。为了让外界给`Point`起一个昵称，还需要更新传递给重载构造函数的参数。

`public class Point : ICloneable`

`{`

`public int X { get; set; }`

`public int Y { get; set; }`

`public PointDescription desc = new PointDescription();`

`public Point(int xPos, int yPos, string petName)`

`{`

`X = xPos; Y = yPos;`

`desc.PetName = petName;`

`}`

`public Point(int xPos, int yPos)`

`{`

`X = xPos; Y = yPos;`

`}`

`public Point() { }`

`// Override Object.ToString().`

`public override string ToString()`

`{`

`return string.Format("X = {0}; Y = {1}; Name = {2};\nID = {3}\n",`

`X, Y, desc.PetName, desc.PointID);`

`}`

`// Return a copy of the current object.`

`public object Clone()`

`{ return this.MemberwiseClone(); }`

`}`

注意，您还没有更新您的`Clone()`方法。因此，当对象用户请求使用当前实现进行克隆时，将获得浅层(逐个成员)拷贝。举例来说，假设您已经如下更新了`Main()`:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Object Cloning *****\n");`

`Console.WriteLine("Cloned p3 and stored new Point in p4");`

`Point p3 = new Point(100, 100, "Jane");`

`Point p4 = (Point)p3.Clone();`

`Console.WriteLine("Before modification:");`

`Console.WriteLine("p3: {0}", p3);`

`Console.WriteLine("p4: {0}", p4);`

`p4.desc.PetName = "My new Point";`

`p4.X = 9;`

`Console.WriteLine("\nChanged p4.desc.petName and p4.X");`

`Console.WriteLine("After modification:");`

`Console.WriteLine("p3: {0}", p3);`

`Console.WriteLine("p4: {0}", p4);`

`Console.ReadLine();`

`}`

请注意，在下面的输出中，虽然值类型确实已经更改，但是内部引用类型保持相同的值，因为它们“指向”内存中相同的对象(具体来说，请注意这两个对象的昵称现在都是“My new Point”)。

`***** Fun with Object Cloning *****`

`Cloned p3 and stored new Point in p4`

`Before modification:`

`p3: X = 100; Y = 100; Name = Jane;`

`ID = 133d66a7-0837-4bd7-95c6-b22ab0434509`

`p4: X = 100; Y = 100; Name = Jane;`

`ID = 133d66a7-0837-4bd7-95c6-b22ab0434509`

`Changed p4.desc.petName  and p4.X`

`After modification:`

`p3: X = 100; Y = 100; Name = My new Point;`

`ID = 133d66a7-0837-4bd7-95c6-b22ab0434509`

`p4: X = 9; Y = 100; Name = My new Point;`

`ID = 133d66a7-0837-4bd7-95c6-b22ab0434509`

为了让您的`Clone()`方法对内部引用类型进行完整的深度复制，您需要配置由`MemberwiseClone()`返回的对象，以说明当前点的名称(`System.Guid`类型实际上是一个结构，因此数字数据确实被复制了)。下面是一个可能的实现:

`// Now we need to adjust for the PointDescription member.`

`public object Clone()`

`{`

`// First get a shallow copy.`

`Point newPoint = (Point)this.MemberwiseClone();`

`// Then fill in the gaps.`

`PointDescription currentDesc = new PointDescription();`

`currentDesc.PetName = this.desc.PetName;`

`newPoint.desc = currentDesc;`

`return newPoint;`

`}`

如果您再次运行应用并查看输出(如下所示)，您会看到从`Clone()`返回的`Point`确实复制了它的内部引用类型成员变量(注意宠物名称现在对于`p3`和`p4`都是惟一的)。

`***** Fun with Object Cloning *****`

`Cloned p3 and stored new Point in p4`

`Before modification:`

`p3: X = 100; Y = 100; Name = Jane;`

`ID = 51f64f25-4b0e-47ac-ba35-37d263496406`

`p4: X = 100; Y = 100; Name = Jane;`

`ID = 0d3776b3-b159-490d-b022-7f3f60788e8a`

`Changed p4.desc.petName  and p4.X`

`After modification:`

`p3: X = 100; Y = 100; Name = Jane;`

`ID = 51f64f25-4b0e-47ac-ba35-37d263496406`

`p4: X = 9; Y = 100; Name = My new Point;`

`ID = 0d3776b3-b159-490d-b022-` `7f3f60788e8a`

总结一下克隆过程，如果你有一个只包含值类型的类或结构，使用`MemberwiseClone()`实现你的`Clone()`方法。但是，如果您有一个维护其他引用类型的自定义类型，您可能希望创建一个新的对象，该对象考虑每个引用类型成员变量，以便获得“深层副本”

Source Code

CloneablePoint 项目位于 [`Chapter 8`](08.html) 子目录中。

## IComparable 接口

`System.IComparable`接口指定了一种行为，允许基于某个指定的键对对象进行排序。以下是正式的定义:

`// This interface allows an object to specify its`

`// relationship between other like objects.`

`public interface IComparable`

`{`

`int CompareTo(object o);`

`}`

Note

这个接口的通用版本(`IComparable<T>`)提供了一种更加类型安全的方式来处理对象之间的比较。你将在第 9 章中研究泛型。

让我们假设您有一个名为 ComparableCar 的新控制台应用项目，它从第 7 章的[中更新了`Car`类(请注意，您基本上只是添加了一个新属性来表示每辆汽车的唯一 ID 和一个修改后的构造函数):](07.html)

`public class Car`

`{`

`...`

`public int CarID {get; set;}`

`public Car(string name, int currSp, int id)`

`{`

`CurrentSpeed = currSp;`

`PetName = name;`

`CarID = id;`

`}`

`...`

`}`

现在假设您有一个如下的`Car`对象数组:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Object Sorting *****\n");`

`// Make an array of Car objects.`

`Car[] myAutos = new Car[5];`

`myAutos[0] = new Car("Rusty", 80, 1);`

`myAutos[1] = new Car("Mary", 40, 234);`

`myAutos[2] = new Car("Viper", 40, 34);`

`myAutos[3] = new Car("Mel", 40, 4);`

`myAutos[4] = new Car("Chucky", 40, 5);`

`Console.ReadLine();`

`}`

`System.Array`类定义了一个名为`Sort()`的静态方法。当您对一组内部类型(`int`、`short`、`string`等)调用此方法时。)，您可以按照数字/字母顺序对数组中的项目进行排序，因为这些固有的数据类型实现了`IComparable`。然而，如果您将一个`Car`类型的数组发送到`Sort()`方法中，情况会怎样呢？

`// Sort my cars? Not yet!`

`Array.Sort(myAutos);`

如果您运行这个测试，您会得到一个运行时异常，因为`Car`类不支持必要的接口。当您构建定制类型时，您可以实现`IComparable`来允许您的类型的数组被排序。当你充实了`CompareTo()`的细节后，将由你来决定订购操作的基线是什么。对于`Car`型，内部的`CarID`似乎是合乎逻辑的候选。

`// The iteration of the Car can be ordered`

`// based on the CarID.`

`public class Car : IComparable`

`{`

`...`

`// IComparable implementation.`

`int IComparable.CompareTo(object obj)`

`{`

`Car temp = obj as Car;`

`if (temp != null)`

`{`

`if (this.CarID > temp.CarID)`

`return 1;`

`if (this.CarID < temp.CarID)`

`return -1;`

`else`

`return 0;`

`}`

`else`

`throw new ArgumentException("Parameter is not a Car!");`

`}`

`}`

如您所见，`CompareTo()`背后的逻辑是根据特定的数据点，针对当前实例测试传入的对象。`CompareTo()`的返回值用于发现该类型是小于、大于还是等于与之比较的对象(见表 [8-1](#Tab1) )。

表 8-1。

CompareTo() Return Values

<colgroup><col> <col></colgroup> 
| CompareTo()返回值 | 描述 |
| --- | --- |
| 任何小于零的数字 | 在排序顺序中，此实例位于指定对象之前。 |
| 零 | 此实例等于指定的对象。 |
| 任何大于零的数字 | 在排序顺序中，此实例位于指定对象之后。 |

假设 C# `int`数据类型(这只是 CLR `System.Int32`的简写符号)实现了`IComparable`，那么您可以简化前面的`CompareTo()`实现。您可以如下实现`Car`的`CompareTo()`:

`int IComparable.CompareTo(object obj)`

`{`

`Car temp = obj as Car;`

`if (temp != null)`

`return this.CarID.CompareTo(temp.CarID);`

`else`

`throw new ArgumentException("Parameter is not a Car!");`

`}`

在这两种情况下，为了让您的`Car`类型理解如何将自己与相似的对象进行比较，您可以编写以下用户代码:

`// Exercise the IComparable interface.`

`static void Main(string[] args)`

`{`

`// Make an array of Car objects.`

`...`

`// Display current array.`

`Console.WriteLine("Here is the unordered set of cars:");`

`foreach(Car c in myAutos)`

`Console.WriteLine("{0} {1}", c.CarID, c.PetName);`

`// Now, sort them using IComparable!`

`Array.Sort(myAutos);`

`Console.WriteLine();`

`// Display sorted array.`

`Console.WriteLine("Here is the ordered set of cars:");`

`foreach(Car c in myAutos)`

`Console.WriteLine("{0} {1}", c.CarID, c.PetName);`

`Console.ReadLine();`

`}`

下面是前面的`Main()`方法的输出:

`***** Fun with Object Sorting *****`

`Here is the unordered set of cars:`

`1 Rusty`

`234 Mary`

`34 Viper`

`4 Mel`

`5 Chucky`

`Here is the ordered set of cars:`

`1 Rusty`

`4 Mel`

`5 Chucky`

`34 Viper`

`234 Mary`

### 使用 IComparer 指定多个排序顺序

在这个版本的`Car`类型中，您使用汽车的 ID 作为排序顺序的基础。另一种设计可能使用汽车的昵称作为排序算法的基础(按字母顺序列出汽车)。现在，如果您想构建一个既可以按 ID 排序也可以按昵称排序的`Car`会怎么样呢？如果这是您感兴趣的行为类型，您需要与另一个名为`IComparer`的标准接口交朋友，该接口在`System.Collections`名称空间中定义如下:

`// A general way to compare two objects.`

`interface IComparer`

`{`

`int Compare(object o1, object o2);`

`}`

Note

这个接口的通用版本(`IComparer<T>`)提供了一种更加类型安全的方式来处理对象之间的比较。你将在第 9 章中研究泛型。

与`IComparable`接口不同，`IComparer`通常不会在您试图排序的类型(即`Car`)上实现。相反，您可以在任意数量的助手类上实现这个接口，每个助手类对应一个排序顺序(昵称、汽车 ID 等)。).目前，`Car`型已经知道如何根据内部汽车 ID 与其他汽车进行比较。因此，允许对象用户按昵称对一组`Car`对象进行排序将需要一个额外的实现`IComparer`的助手类。下面是代码(确保在代码文件中导入`System.Collections`名称空间):

`// This helper class is used to sort an array of Cars by pet name.`

`public class PetNameComparer : IComparer`

`{`

`// Test the pet name of each object.`

`int IComparer.Compare(object o1, object o2)`

`{`

`Car t1 = o1 as Car;`

`Car t2 = o2 as Car;`

`if(t1 != null && t2 != null)`

`return String.Compare(t1.PetName, t2.PetName);`

`else`

`throw new ArgumentException("Parameter is not a Car!");`

`}`

`}`

对象用户代码能够使用这个助手类。`System.Array`有许多重载的`Sort()`方法，其中一个恰好接受一个实现`IComparer`的对象。

`static void Main(string[] args)`

`{`

`...`

`// Now sort by pet name.`

`Array.Sort(myAutos, new PetNameComparer());`

`// Dump sorted array.`

`Console.WriteLine("Ordering by pet name:");`

`foreach(Car c in myAutos)`

`Console.WriteLine("{0} {1}", c.CarID, c.PetName);`

`...`

`}`

### 自定义属性和自定义排序类型

值得指出的是，当按照特定的数据点对`Car`类型进行排序时，可以使用定制的静态属性来帮助对象用户。假设`Car`类已经添加了一个名为`SortByPetName`的静态只读属性，该属性返回实现`IComparer`接口的对象实例(在本例中为`PetNameComparer`);一定要导入`System.Collections`。

`// We now support a custom property to return`

`// the correct IComparer interface.`

`public class Car : IComparable`

`{`

`...`

`// Property to return the PetNameComparer.`

`public static IComparer SortByPetName`

`{ get { return (IComparer)new PetNameComparer(); } }`

`}`

对象用户代码现在可以使用强关联属性按昵称排序，而不是“必须知道”才能使用独立的`PetNameComparer`类类型。

`// Sorting by pet name made a bit cleaner.`

`Array.Sort(myAutos, Car.SortByPetName);`

Source Code

ComparableCar 项目位于 [`Chapter 8`](08.html) 子目录下。

理想情况下，在这一点上，你不仅理解如何定义和实现你自己的接口，而且理解它们的有用性。可以肯定的是，每个专业都有接口。NET 命名空间，您将在本书的剩余部分继续使用各种标准接口。

## 摘要

接口可以定义为抽象成员的命名集合。因为接口不提供任何实现细节，所以通常将接口视为给定类型可能支持的行为。当两个或多个类实现同一个接口时，即使类型是在唯一的类层次结构中定义的，也可以用相同的方式对待每种类型(基于接口的多态性)。

C#提供了关键字`interface`来允许你定义一个新的接口。如您所见，使用逗号分隔的列表，一个类型可以支持任意多的接口。此外，允许构建从多个基本接口派生的接口。

除了构建自定义接口之外。NET 库定义了许多标准(即框架提供的)接口。正如您所看到的，您可以自由地构建实现这些预定义接口的自定义类型，以获得许多想要的特征，如克隆、排序和枚举。