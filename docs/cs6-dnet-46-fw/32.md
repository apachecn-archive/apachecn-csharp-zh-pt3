# 32.ASP.NET Web 控件、母版页和主题

前一章集中讨论了 Web 表单页面的一般组成和`Page`类的作用。这一章将深入到构成页面用户界面的 web 控件的细节。在研究了 Web 窗体控件的整体性质之后，您将学习如何使用几个 UI 元素，包括验证控件和各种数据绑定技术。

本章的主要部分将研究母版页的作用，并展示它们如何提供一种简化的方法来建立一个通用的 UI 框架，该框架将在您的网站中的页面之间复制。与母版页主题密切相关的是使用站点导航控件(和相关的`*.sitemap`文件),以便通过服务器端 XML 文件定义多页面站点的导航结构。

最后，您将了解 Web 窗体主题的作用。从概念上讲，主题与级联样式表(CSS)的作用相同；但是，web 窗体主题是在 Web 服务器上应用的(而不是在客户端浏览器中)，因此可以访问服务器端资源。

## 理解 Web 控件的本质

Web 表单的一个主要好处是能够使用在`System.Web.UI.WebControls`名称空间中定义的类型来组装页面的 UI。正如您所看到的，这些控件(称为服务器控件、web 控件或 web 表单控件)非常有用，因为它们自动为请求浏览器生成必要的 HTML，并公开一组可以在 Web 服务器上处理的事件。此外，因为每个 Web 表单控件在`System.Web.UI.WebControls`名称空间中都有一个对应的类，所以可以用面向对象的方式操作它。

当您使用 Visual Studio 属性窗口配置 web 控件的属性时，您的编辑会作为一系列名称/值对记录在`*.aspx`文件中给定元素的开始控件标记中。因此，如果您向给定的`*.aspx`文件的设计器添加一个新的`TextBox`，并更改`ID`、`BorderStyle`、`BorderWidth`、`BackColor`和`Text`属性，那么开始的`<asp:TextBox>`标记也会相应地修改(但是，请注意，`Text`值将成为`TextBox`范围的内部文本)。

`<asp:TextBox ID="txtNameTextBox" runat="server" BackColor="#C0FFC0"`

`BorderStyle="Dotted" BorderWidth="3px">Enter Your Name</asp:TextBox>`

假设一个 web 控件的声明最终变成了一个来自`System.Web.UI.WebControls`名称空间的成员变量(通过第 31 章中[提到的动态编译循环)，你可以在一个服务器端`<script>`块中或者更常见的通过页面的代码隐藏文件与这种类型的成员进行交互。因此，如果您要向一个`*.aspx`文件添加一个新的`Button`控件，您可以处理`Click`事件并编写一个服务器端处理程序来改变`TextBox`的背景颜色，如下所示:](31.html)

`partial class _Default : System.Web.UI.Page`

`{`

`protected void btnChangeTextBoxColor_Click(object sender, EventArgs e)`

`{`

`// Change color of text box object in code.`

`this.txtNameTextBox.BackColor = System.Drawing.Color.DarkBlue;`

`}`

`}`

所有 Web 表单控件最终都是从一个名为`System.Web.UI.WebControls.WebControl`的公共基类中派生出来的。反过来，`WebControl`来源于`System.Web.UI.Control`(后者来源于`System.Object`)。`Control`和`WebControl`分别定义了许多所有服务器端控件共有的属性。在研究继承的功能之前，让我们形式化一下处理服务器端事件意味着什么。

### 了解服务器端事件处理

鉴于万维网的现状，避免浏览器/web 服务器交互的基本特性是不可能的。每当这两个实体进行通信时，总会有一个底层的无状态 HTTP 请求-响应循环。虽然 Web 窗体服务器控件在很大程度上为您屏蔽了原始 HTTP 协议的细节，但请始终记住，将 Web 视为事件驱动的实体只是。它不同于基于 Windows 的桌面 GUI 框架(如 WPF)的事件驱动模型。

例如，尽管以 WPF 为中心的`System.Windows.Controls`命名空间和 Web 表单`System.Web.UI.WebControls`命名空间都用相同的简单名称(`Button`、`TextBox`、`Label`等等)定义了类，但是它们并不公开一组相同的属性、方法或事件。例如，当用户将光标移到 Web 表单`Button`控件上时，无法处理服务器端`MouseMove`事件。

底线是给定的 web 窗体控件将公开一组有限的事件，所有这些事件最终都会导致回发到 Web 服务器。任何必要的客户端事件处理都需要您创作客户端 JavaScript/VBScript 脚本代码的简介，以供请求浏览器的脚本引擎处理。鉴于 Web 表单主要是一种服务器端技术，我将不讨论创作客户端脚本的主题。

Note

使用 Visual Studio 处理给定 web 控件的事件的方式与处理 Windows GUI 控件的方式相同。只需从设计器中选择小部件，然后在属性窗口中单击闪电图标。

### AutoPostBack 属性

值得指出的是，许多 Web 表单控件支持名为`AutoPostBack`的属性(最值得注意的是`CheckBox`、`RadioButton`和`TextBox`控件，以及任何从抽象`ListControl`类型派生的小部件)。默认情况下，该属性设置为`false`，这将禁止向服务器即时回发(即使您确实在代码隐藏文件中处理了该事件)。在大多数情况下，这正是您需要的行为，因为 UI 元素(如复选框)通常不需要回发功能。换句话说，您不希望在用户选中或取消选中复选框后立即回发到服务器，因为页面对象可以在更自然的`Button Click`事件处理程序中获得小部件的状态。

但是，如果您想让这些小部件立即回发到服务器端事件处理程序，只需将`AutoPostBack`的值设置为`true`。如果您想让一个小部件的状态自动填充同一页面上另一个小部件中的另一个值，这种技术会很有帮助。举例来说，假设您有一个包含单个`TextBox`(名为`txtAutoPostback`)和单个`ListBox`控件(名为`lstTextBoxData`)的网页。以下是相关的标记:

`<form id="form1" runat="server">`

`<asp:TextBox ID="txtAutoPostback" runat="server"></asp:TextBox>`

`<br/>`

`<asp:ListBox ID="lstTextBoxData" runat="server"></asp:ListBox>`

`</form>`

现在，如果您要处理`TextBox`的`TextChanged`事件，服务器端事件处理程序可以尝试用`TextBox`中的当前值填充`ListBox`，如下所示:

`partial class _Default : System.Web.UI.Page`

`{`

`protected void txtAutoPostback_TextChanged(object sender, EventArgs e)`

`{`

`lstTextBoxData.Items.Add(txtAutoPostback.Text);`

`}`

`}`

如果您照原样运行应用程序，您会发现当您键入`TextBox`时，什么也没有发生。

此外，如果您键入`TextBox`并跳转到下一个控件，什么也不会发生。原因是`TextBox`的`AutoPostBack`属性默认设置为`false`。但是，如果您将该属性设置为`true`，如

`<asp:TextBox ID="txtAutoPostback" runat="server"`

`AutoPostBack="true" ... >`

`</asp:TextBox>`

您会发现，当您离开`TextBox`(或按回车键)时，`ListBox`会自动填充上`TextBox`中的当前值。当然，除了需要根据一个小部件的值填充另一个小部件的项目之外，通常不需要改变小部件的`AutoPostBack`属性的状态(即使这样，有时这也可以完全在客户端脚本中完成，完全不需要服务器交互)。

## Control 和 WebControl 基类

`System.Web.UI.Control`基类定义了各种属性、方法和事件，这些属性、方法和事件提供了与 web 控件的核心(通常是非 GUI)方面进行交互的能力。表 [32-1](#Tab1) 记录了一些但不是全部感兴趣的成员。

表 32-1。

Select Members of `System.Web.UI.Control`

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `Controls` | 该属性获取一个代表当前控件中子控件的`ControlCollection`对象。 |
| `DataBind()` | 此方法将数据源绑定到调用的服务器控件及其所有子控件。 |
| `EnableTheming` | 该属性确定控件是否支持主题功能(默认为`true`)。 |
| `HasControls()` | 此方法确定服务器控件是否包含任何子控件。 |
| `ID` | 此属性获取或设置分配给服务器控件的编程标识符。 |
| `Page` | 该属性获取对包含服务器控件的`Page`实例的引用。 |
| `Parent` | 此属性获取对页面控件层次结构中服务器控件的父控件的引用。 |
| `SkinID` | 该属性获取或设置应用于控件的`skin`，这允许您使用服务器端资源设置外观。 |
| `Visible` | 此属性获取或设置一个值，该值指示服务器控件是否呈现为页面上的 UI 元素。 |

### 枚举包含的控件

您将检查的`System.Web.UI.Control`的第一个方面是所有 web 控件(包括`Page`本身)都继承了一个自定义控件集合(通过`Controls`属性访问)。很像在 Windows 窗体应用程序中，`Controls`属性提供了对`WebControl-`派生类型的强类型集合的访问。像其他人一样。NET 集合，您能够在运行时动态添加、插入和移除项。

虽然在技术上可以将 web 控件直接添加到`Page`派生的类型中，但是使用`Panel`控件更容易(也更健壮)。`Panel`类表示一个小部件容器，这些小部件对最终用户来说可能可见，也可能不可见(基于其`Visible`和`BorderStyle`属性的值)。

举例来说，创建一个名为 DynamicCtrls 的新的空网站，并向项目中添加一个新的 web 窗体。使用 Visual Studio 页面设计器，添加一个`Panel`控件(名为`myPanel`)，该控件包含一个`TextBox`、`Button`和`HyperLink`小部件，其名称由您选择(注意设计器要求您在`Panel`类型的 UI 中拖动内部项目)。接下来，在`Panel`(名为`lblControlInfo`)的范围之外放置一个`Label`小部件来保存呈现的输出。下面是一个可能的 HTML 描述:

`<html xmlns="`[`http://www.w3.org/1999/xhtml`](http://www.w3.org/1999/xhtml)T2】

`<head runat="server">`

`<title>Dynamic Control Test</title>`

`</head>`

`<body>`

`<form id="form1" runat="server">`

`<div>`

`<hr />`

`<h1>Dynamic Controls</h1>`

`<asp:Label ID="lblTextBoxText" runat="server"></asp:Label>`

`<hr />`

`</div>`

`<!--``The Panel has three contained controls`T2】

`<asp:Panel ID="myPanel" runat="server" Width="200px"`

`BorderColor="Black" BorderStyle="Solid" >`

`<asp:TextBox ID="TextBox1" runat="server"></asp:TextBox><br/>`

`<asp:Button ID="Button1" runat="server" Text="Button"/><br/>`

`<asp:HyperLink ID="HyperLink1" runat="server">HyperLink`

`</asp:HyperLink>`

`</asp:Panel>`

`<br />`

`<br />`

`<asp:Label ID="lblControlInfo" runat="server"></asp:Label>`

`</form>`

`</body>`

`</html>`

有了这个标记，你的页面设计者看起来会如图 [32-1](#Fig1) 所示。

![A978-1-4842-1332-2_32_Fig1_HTML.jpg](img/A978-1-4842-1332-2_32_Fig1_HTML.jpg)

图 32-1。

The UI of the Dynamic Controls web page

假设在`Page_Load()`事件中，您想要获得关于包含在`Panel`中的控件的详细信息，并将该信息分配给`Label`控件(名为`lblControlInfo`)。考虑下面的 C#代码:

`public partial class _Default : System.Web.UI.Page`

`{`

`protected void Page_Load(object sender, System.EventArgs e)`

`{`

`ListControlsInPanel();`

`}`

`private void ListControlsInPanel()`

`{`

`var theInfo = "";`

`theInfo = $"<b>Does the panel have controls? {myPanel.HasControls()} </b><br/>";`

`// Get all controls in the panel.`

`foreach (Control c in myPanel.Controls)`

`{`

`if (!object.ReferenceEquals(c.GetType(), typeof(System.Web.UI.LiteralControl)))`

`{`

`theInfo += "***************************<br/>";`

`theInfo += $"Control Name? {c} <br/>";`

`theInfo += $"ID? {c.ID} <br>";`

`theInfo += $"Control Visible? {c.Visible} <br/>";`

`theInfo += $"ViewState? {c.EnableViewState} <br/>";`

`}`

`}`

`lblControlInfo.Text = theInfo;`

`}`

`}`

这里，您迭代维护在`Panel`上的每个`WebControl`，并检查当前类型是否属于类型`System.Web.UI.LiteralControl`，如果是，则跳过它。这个类用来表示文字 HTML 标签和内容(比如`<br>`，文本文字等)。).如果您不进行这种健全性检查，您可能会惊讶地发现在`Panel`的范围内有更多的控件(给定前面看到的`*.aspx`声明)。假设控件不是文字 HTML 内容，然后打印出一些关于小部件的各种统计数据。图 [32-2](#Fig2) 显示了输出。

![A978-1-4842-1332-2_32_Fig2_HTML.jpg](img/A978-1-4842-1332-2_32_Fig2_HTML.jpg)

图 32-2。

Enumerating controls at runtime

### 动态添加和移除控件

现在，如果你想在运行时修改一个`Panel`的内容呢？让我们更新当前页面，以支持一个额外的`Button`(名为`btnAddWidgets`)，该页面将三个新的`TextBox`控件动态添加到`Panel`中，另一个`Button`(名为`btnClearPanel`)将清除所有控件的`Panel`小部件。每个事件的`Click`事件处理程序如下所示:

`protected void btnClearPanel_Click(object sender, System.EventArgs e)`

`{`

`// Clear all content from the panel, then relist items.`

`myPanel.Controls.Clear();`

`ListControlsInPanel();`

`}`

`protected void btnAddWidgets_Click(object sender, System.EventArgs e)`

`{`

`for (int i = 0; i < 3; i++)`

`{`

`// Assign an ID so we can get`

`// the text value out later`

`// using the incoming form data.`

`TextBox t = new TextBox {ID = $"newTextBox{i}"};`

`myPanel.Controls.Add(t);`

`ListControlsInPanel();`

`}`

`}`

请注意，您为每个`TextBox`(例如`newTextBox0`、`newTextBox1`等等)分配了一个惟一的 ID。如果您运行您的页面，您应该能够向`Panel`控件添加新项目，并清除所有内容的`Panel`。

### 与动态创建的控件交互

现在，如果您想要获得这些动态生成的`TextBox` es 中的值，您可以通过多种方式来实现。首先，用一个额外的`Button`(名为`btnGetTextData`)、一个名为`lblTextBoxData` `,`的最终`Label`控件来更新您的 UI，并处理`Button`的`Click`事件。

要访问动态创建的文本框中的数据，有几种选择。一种方法是遍历包含在传入 HTML 表单数据(通过`HttpRequest.Form`访问)中的每一项，并将文本信息连接到一个本地范围的`System.String`。一旦你完成了这个集合，将这个字符串分配给新的`Label`控件的`Text`属性，就像这样:

`protected void btnGetTextData_Click(object sender, System.EventArgs e)`

`{`

`string textBoxValues = "";`

`for (int i = 0; i < Request.Form.Count; i++)`

`{`

`textBoxValues += $"<li>{ Request.Form[i]}</li><br/>";`

`}`

`lblTextBoxData.Text = textBoxValues;`

`}`

当您运行应用程序时，您会发现您能够查看每个文本框的内容，包括一些相当长(不可读)的字符串数据。该字符串包含页面上每个控件的视图状态。你将在第 33 章中了解视图状态的作用。

为了清理输出，您可以取出唯一命名的项目的文本数据(`newTextBox0`、`newTextBox1`和`newTextBox2`)。考虑以下更新:

`protected void btnGetTextData_Click(object sender, System.EventArgs e)`

`{`

`// Get each text box by name.`

`string lableData = $"<li>{Request.Form.Get("newTextBox0")}</li><br/>";`

`lableData += $"<li>{Request.Form.Get("newTextBox1")}</li><br/>";`

`lableData += $"<li>{Request.Form.Get("newTextBox2")}</li><br/>";`

`lblTextBoxData.Text = lableData;`

`}`

无论使用哪种方法，您都会注意到，一旦请求得到处理，文本框就会消失。同样，原因与 HTTP 的无状态特性有关。如果你想在回发之间维护这些动态创建的对象，你需要使用 Web 表单状态编程技术来持久化这些对象(同样，参见第 33 章)。

Source Code

DynamicCtrls 网站包含在 [`Chapter 32`](32.html) 子目录中。

### WebControl 基类的功能

正如您所看到的，`Control`类型提供了许多与 GUI 无关的行为(控件集合、autopostback 支持等。).另一方面，`WebControl`基类为所有 web 小部件提供了一个图形化的多态接口，如表 [32-2](#Tab2) 所示。

表 32-2。

Select Properties of the `WebControl` Base Class

<colgroup><col> <col></colgroup> 
| 财产 | 生命的意义 |
| --- | --- |
| `BackColor` | 获取或设置 web 控件的背景色 |
| `BorderColor` | 获取或设置 web 控件的边框颜色 |
| `BorderStyle` | 获取或设置 web 控件的边框样式 |
| `BorderWidth` | 获取或设置 web 控件的边框宽度 |
| `Enabled` | 获取或设置一个值，该值指示 web 控件是否已启用 |
| `CssClass` | 允许您将级联样式表中定义的类分配给 web 小部件 |
| `Font` | 获取 web 控件的字体信息 |
| `ForeColor` | 获取或设置 web 控件的前景色(通常是文本的颜色) |
| `Height`，`Width` | 获取或设置 web 控件的高度和宽度 |
| `TabIndex` | 获取或设置 web 控件的选项卡索引 |
| `ToolTip` | 获取或设置当光标位于控件上时要显示的 web 控件的工具提示 |

几乎所有这些属性都是不言自明的，所以与其一个一个地钻研它们的用法，不如让我们来看看许多实际使用的 ASP.NET Web 窗体控件。

## Web 窗体控件的主要类别

Web Forms 控件库可以分为几大类，所有这些都可以在 Visual Studio 工具箱中查看(假设您有一个打开的`*.aspx`页面用于设计)(参见图 [32-3](#Fig3) )。

![A978-1-4842-1332-2_32_Fig3_HTML.jpg](img/A978-1-4842-1332-2_32_Fig3_HTML.jpg)

图 32-3。

The categories of Web Forms controls

在工具箱的标准区域下，您会找到最常用的控件，包括`Button`、`Label`、`TextBox`和`ListBox`。除了这些香草味的 UI 元素，标准区还列出了更多异国情调的 web 控件，比如`Calendar`、`Wizard`、`AdRotator`(见图 [32-4](#Fig4) )。

![A978-1-4842-1332-2_32_Fig4_HTML.jpg](img/A978-1-4842-1332-2_32_Fig4_HTML.jpg)

图 32-4。

The standard Web Forms controls

在数据部分，您可以找到一组用于数据绑定操作的控件，包括 Web Forms `Chart`控件，它允许您呈现通常作为数据绑定操作结果的图形图表数据(饼图、折线图)(参见图 [32-5](#Fig5) )。

![A978-1-4842-1332-2_32_Fig5_HTML.jpg](img/A978-1-4842-1332-2_32_Fig5_HTML.jpg)

图 32-5。

Data-centric Web Forms controls

Web 窗体验证控件(位于工具箱的验证区域)非常有趣，因为它们可以被配置为发送回客户端 JavaScript 块，这些块将测试输入字段中的有效数据。如果发生验证错误，用户将会看到一条错误消息，并且在错误得到纠正之前，不允许回发到 web 服务器。

工具箱的导航节点是一小组控件(`Menu`、`SiteMapPath`和`TreeView`)，它们通常与`*.sitemap`文件一起工作。正如本章前面简要提到的，这些导航控件允许您使用 XML 描述来描述多页站点的结构。

最奇特的 Web 表单控件应该是登录控件(见图 [32-6](#Fig6) )。

![A978-1-4842-1332-2_32_Fig6_HTML.jpg](img/A978-1-4842-1332-2_32_Fig6_HTML.jpg)

图 32-6。

Security Web Forms controls

这些控制可以从根本上简化如何整合基本的安全功能(密码恢复、登录屏幕等)。)到您的 web 应用程序中。事实上，这些控件非常强大，如果您还没有特定的安全数据库，它们甚至会动态创建一个专用数据库来存储凭证(保存在您网站的`App_Data`文件夹下)。

Note

Visual Studio 工具箱中显示的其余类别的 web 控件(如 WebParts、AJAX 扩展和动态数据)是针对更专门的编程需求的，这里将不进行分析。

### 简单说一下系统。网页界面控件

说实话，web 窗体附带了两个不同的 Web 控件工具包。除了 Web 窗体控件(在`System.Web.UI.WebControls`命名空间内)，基类库还提供了`System.Web.UI.HtmlControls`控件库。

HTML 控件是允许您在 Web 窗体页上使用传统 HTML 控件的类型集合。但是，与简单的 HTML 标记不同，HTML 控件是面向对象的实体，可以配置为在服务器上运行，因此支持服务器端事件处理。与 Web 表单控件不同，HTML 控件本质上非常简单，除了标准的 HTML 标签(`HtmlButton`、`HtmlInputControl`、`HtmlTable`等)之外，几乎不提供任何功能。).

如果您的团队在构建 HTML UIs 的人员和构建 HTML UIs 的人员之间有明确的分工，HTML 控件会很有用。NET 开发人员。HTML 人员可以使用他们选择的 web 编辑器，使用熟悉的标记标签，并将 HTML 文件传递给开发团队。此时，开发人员可以配置这些 HTML 控件作为服务器控件运行(通过右键单击 Visual Studio 中的 HTML 小部件)。这将允许开发人员处理服务器端事件，并以编程方式使用 HTML 小部件。

HTML 控件提供了一个模仿标准 HTML 属性的公共接口。例如，要获得输入区域内的信息，可以使用`Value`属性，而不是以 web 控件为中心的`Text`属性。鉴于 HTML 控件不像 Web 窗体控件那样功能丰富，我不会在本文中进一步提及它们。

### Web 控件文档

在本书的剩余部分，你将有机会使用一些 Web 窗体控件；但是，您应该花点时间搜索。名称空间的. NET Framework 4.6 SDK 文档。在这里，你可以找到名称空间每个成员的解释和代码示例(见图 [32-7](#Fig7) )。

![A978-1-4842-1332-2_32_Fig7_HTML.jpg](img/A978-1-4842-1332-2_32_Fig7_HTML.jpg)

图 32-7。

All Web Forms controls are documented in the .NET Framework 4.6 SDK documentation

## 构建 Web 窗体汽车网站

考虑到许多“简单”的控件看起来和感觉上与它们的 Windows GUI 对应控件非常接近，我就不赘述基本窗口小部件的细节了(`Button` s，`Label` s，`TextBox` es，等等)。).相反，让我们构建一个新的网站，演示如何使用几个更奇特的控件，以及 web 窗体母版页模型和数据绑定引擎的各个方面。具体来说，下一个示例将说明以下技术:

*   使用母版页
*   使用站点地图导航
*   使用`GridView`控件
*   使用`Wizard`控件

首先，创建一个名为 AspNetCarsSite 的空网站项目。请注意，您还没有创建一个新的完整的 ASP.NET 网站项目，因为这将向组合中添加一些我们还没有检查过的启动文件。对于这个项目，您将手动添加您需要的内容。

### 使用 Web 窗体母版页

许多网站在多个页面上提供一致的外观和感觉(通用的菜单导航系统、通用的页眉和页脚内容、公司徽标等)。).母版页只不过是一个带有`*.master`文件扩展名的 Web 表单页面。母版页本身无法从客户端浏览器中查看(事实上，ASP.NET 运行时不会提供这种风格的 web 内容)。相反，母版页定义了站点中所有页面(或页面子集)共享的公共 UI 布局。

另外，`*.master`页面将定义各种内容占位符区域，这些区域建立了其他`*.aspx`文件可以插入的 UI 区域。正如您将看到的，`*.aspx`文件将其内容插入到主文件中，看起来和感觉上与您一直在检查的`*.aspx`文件有点不同。具体来说，这种类型的`*.aspx`文件被称为内容页面。内容页面是没有定义 HTML `<form>`元素的`*.aspx`文件(这是母版页的工作)。

然而，就最终用户而言，请求是针对给定的`*.aspx`文件的。在 web 服务器上，相关的`*.master`文件和任何相关的`*.aspx`内容页面被混合成一个统一的 HTML 页面声明。

为了说明母版页和内容页的使用，首先通过网站添加新项目菜单选项将一个新的母版页插入到您的网站中(图 [32-8](#Fig8) 显示了结果对话框)。

![A978-1-4842-1332-2_32_Fig8_HTML.jpg](img/A978-1-4842-1332-2_32_Fig8_HTML.jpg)

图 32-8。

Inserting a new `*.master` file

`MasterPage.master`文件的初始标记如下所示:

`<%@ Master Language="C#" AutoEventWireup="true" CodeFile="MasterPage.master.cs" Inherits="MasterPage" %>`

`<!DOCTYPE html>`

`<html xmlns="`[`http://www.w3.org/1999/xhtml`](http://www.w3.org/1999/xhtml)T2】

`<head runat="server">`

`<title></title>`

`<asp:ContentPlaceHolder id="head" runat="server">`

`</asp:ContentPlaceHolder>`

`</head>`

`<body>`

`<form id="form1" runat="server">`

`<div>`

`<asp:ContentPlaceHolder id="ContentPlaceHolder1" runat="server">`

`</asp:ContentPlaceHolder>`

`</div>`

`</form>`

`</body>`

`</html>`

第一个有趣的地方是新的`<%@Master%>`指令。在很大程度上，该指令支持与[第 31 章](31.html)中描述的`<%@Page%>`指令相同的属性。像`Page`类型一样，一个母版页派生自一个特定的基类，在本例中是`MasterPage`。如果您打开相关的代码文件，您会发现下面的类定义:

`public partial class MasterPage : System.Web.UI.MasterPage`

`{`

`protected void Page_Load(object sender, EventArgs e)`

`{`

`}`

`}`

母版标记中另一个有趣的地方是`<asp:ContentPlaceHolder>`定义。母版页的这个区域表示相关`*.aspx`内容文件的 UI 小部件可以插入的母版区域，而不是由母版页本身定义的内容。

如果你确实想在这个区域插入一个`*.aspx`文件，那么`<asp:ContentPlaceHolder>`和`</asp:ContentPlaceHolder>`标签内的范围通常会保持为空。但是，您可以用各种 web 控件填充这个区域，这些控件在站点中的某个给定的`*.aspx`文件不提供特定内容的情况下作为默认 UI 使用。对于这个例子，假设你的站点中的每个`*.aspx`页面都将提供自定义内容，因此，你的`<asp:ContentPlaceHolder>`元素将是空的。

Note

一个页面可以根据需要定义多个内容占位符。同样，一个单独的`*.master`页面可以嵌套另外的`*.master`页面。

您可以使用用于构建`*.aspx`文件的相同 Visual Studio 设计器来构建`*.master`文件的通用 UI。对于这个站点，您将添加一个描述性的`Label`(作为一个通用的欢迎消息)、一个`AdRotator`控件(将随机显示两个图像文件中的一个)和一个`TreeView`控件(允许用户导航到站点的其他区域)。以下是我通过 IDE 设计母版页后的标记:

`<html xmlns="`[`http://www.w3.org/1999/xhtml`](http://www.w3.org/1999/xhtml)T2】

`<head runat="server">`

`<title> </title>`

`<asp:ContentPlaceHolder id="head" runat="server">`

`</asp:ContentPlaceHolder>`

`</head>`

`<body>`

`<form id="form1" runat="server">`

`<div>`

`<hr />`

`<asp:Label ID="Label1" runat="server" Font-Size="XX-Large"`

`Text="Welcome to the ASP.NET Cars Super Site!"></asp:Label>`

`<asp:AdRotator ID="myAdRotator" runat="server"/>`

`<br />`

`<br />`

`<asp:TreeView ID="navigationTree" runat="server">`

`</asp:TreeView>`

`<hr />`

`</div>`

`<div>`

`<asp:ContentPlaceHolder id="ContentPlaceHolder1" runat="server">`

`</asp:ContentPlaceHolder>`

`</div>`

`</form>`

`</body>`

`</html>`

图 [32-9](#Fig9) 显示了当前母版页的设计时视图(注意`AdRotator`控件的显示区域暂时为空)。

![A978-1-4842-1332-2_32_Fig9_HTML.jpg](img/A978-1-4842-1332-2_32_Fig9_HTML.jpg)

图 32-9。

The `*.master` file’s shared UI

通过使用控件的内联编辑器并选择自动格式化链接，您可以随意增强您的`TreeView`控件的外观。同样，您也可以使用属性编辑器来丰富其余控件的显示。当你对结果满意时，进入下一部分。

### 配置 TreeView 控件站点导航逻辑

Web 表单附带了几个 web 控件，允许您处理站点导航:`SiteMapPath`、`TreeView`和`Menu`。如您所料，这些 web 部件可以通过多种方式进行配置。例如，这些控件中的每一个都可以通过外部 XML 文件(或基于 XML 的`*.sitemap`文件)动态生成其节点，以编程方式在代码中生成节点，或者使用 Visual Studio 的设计器通过标记生成节点。

您的导航系统将使用一个`*.sitemap`文件动态填充。这种方法的好处是，你可以在一个外部文件中定义网站的整体结构，然后动态地将它绑定到一个`TreeView`(或`Menu`)控件。这样，如果网站的导航结构发生变化，您只需修改`*.sitemap`文件并重新加载页面。首先，使用➤网站的添加新项目菜单选项将一个新的`Web.sitemap`文件插入到您的项目中，以弹出如图 [32-10](#Fig10) 所示的对话框。

![A978-1-4842-1332-2_32_Fig10_HTML.jpg](img/A978-1-4842-1332-2_32_Fig10_HTML.jpg)

图 32-10。

Inserting a new `Web.sitemap` file

如您所见，初始的`Web.sitemap`文件定义了一个包含两个子节点的顶层项目，如下所示:

`<?xml version="1.0" encoding="utf-8" ?>`

`<siteMap xmlns="`[`http://schemas.microsoft.com/AspNet/SiteMap-File-1.0`](http://schemas.microsoft.com/AspNet/SiteMap-File-1.0)T2】

`<siteMapNode url="" title="" description="">`

`<siteMapNode url="" title="" description="" />`

`<siteMapNode url="" title="" description="" />`

`</siteMapNode>`

`</siteMap>`

如果你将这个结构绑定到一个`Menu`控件，你会发现一个最顶层的项目有两个子项目。因此，当您想要定义子项时，只需在现有的`<siteMapNode>`的范围内定义新的`<siteMapNode>`元素。在任何情况下，目标都是在一个使用各种`<siteMapNode>`元素的`Web.sitemap`文件中定义网站的整体结构。这些元素中的每一个都可以定义标题和 URL 属性。URL 属性表示当用户单击一个给定的菜单项(或一个`TreeView`的节点)时，导航到哪个`*.aspx`文件。您的站点地图将包含三个站点地图节点(在顶级站点地图节点下)，如下所示:

*   首页:`Default.aspx`
*   造车:`BuildCar.aspx`
*   查看库存:`Inventory.aspx`

在接下来的页面中，您将把这三个新的 Web 窗体页面添加到项目中。目前，您将简单地配置站点地图文件。

您的导航系统有一个包含三个子元素的最顶层欢迎项。因此，您可以如下更新`Web.sitemap`文件，但是要注意每个`url`值必须是唯一的(否则，您将收到一个运行时错误):

`<?xml version="1.0" encoding="utf-8" ?>`

`<siteMap xmlns="`[`http://schemas.microsoft.com/AspNet/SiteMap-File-1.0`](http://schemas.microsoft.com/AspNet/SiteMap-File-1.0)T2】

`<siteMapNode url="" title="Welcome!" description="">`

`<siteMapNode url="∼/Default.aspx" title="Home"`

`description="The Home Page" />`

`<siteMapNode url="∼/BuildCar.aspx" title="Build a car"`

`description="Create your dream car" />`

`<siteMapNode url="∼/Inventory.aspx" title="View Inventory"`

`description="See what is in stock" />`

`</siteMapNode>`

`</siteMap>`

Note

在`url`属性中每个页面前的`∼/`前缀是一个表示网站根的符号。

现在，不管你怎么想，你不能使用给定的属性将一个`Web.sitemap`文件直接关联到一个`Menu`或`TreeView`控件。相反，包含将显示`Web.sitemap`文件的 UI 小部件的`*.master`或`*.aspx`文件必须包含一个`SiteMapDataSource`组件。当页面被请求时，这个组件会自动将`Web.sitemap`文件加载到它的对象模型中。然后`Menu`和`TreeView`类型设置它们的`DataSourceID`属性指向`SiteMapDataSource`实例。

要向您的`*.master`文件添加一个新的`SiteMapDataSource`并自动设置`DataSourceID`属性，您可以使用 Visual Studio 设计器。激活`TreeView`控件的内嵌编辑器(即点击`TreeView`右上角的小箭头)，展开选择数据源下拉列表，选择新建数据源，如图 [32-11](#Fig11) 所示。

![A978-1-4842-1332-2_32_Fig11_HTML.jpg](img/A978-1-4842-1332-2_32_Fig11_HTML.jpg)

图 32-11。

Adding a new `SiteMapDataSource`

从出现的对话框中，选择站点地图图标。这将设置`Menu`或`TreeView`控件的`DataSourceID`属性，并向页面添加一个新的`SiteMapDataSource`组件。这就是你所需要做的配置你的`TreeView`控件来导航到你站点上的附加页面。如果您想在用户选择给定菜单项时执行额外的处理，您可以通过处理`TreeView`控件上的`SelectedNodeChanged`事件来实现。在这个例子中不需要这样做，但是请注意，您可以使用传入的事件参数来确定选择了哪个菜单项。

### 使用 SiteMapPath 类型建立面包屑

在移动到`AdRotator`控件之前，添加一个`SiteMapPath`类型(位于工具箱的导航标签中)到你的`*.master`文件中。这个小部件将根据菜单系统的当前选择自动调整其内容。正如您可能知道的，这可以为最终用户提供有用的视觉提示(正式地说，这种 UI 技术被称为面包屑)。完成这个示例后，您会注意到当您选择 Welcome Build a Car 菜单项时，`SiteMapPath`小部件会相应地自动更新。

### 配置 AdRotator 控件

Web Forms `AdRotator`小部件的作用是在浏览器的某个位置随机显示给定的图像。此时，`AdRotator`显示一个空的占位符。直到你指定`AdvertisementFile`属性指向描述每张图片的源文件，这个控件才能发挥它的魔力。对于这个例子，数据源将是一个名为`Ads.xml`的简单 XML 文件。

要将 XML 文件添加到网站，请转到网站添加新项目菜单选项，然后选择 XML 文件。将文件命名为`Ads.xml`，并为您想要显示的每个图像指定一个唯一的`<Ad>`元素。至少，每个`<Ad>`元素指定要显示的图像(`ImageUrl`)、图像被选中时要导航到的 URL(`TargetUrl`)、鼠标悬停文本(`AlternateText`)以及广告的权重(`Impressions`)。

`<Advertisements>`

`<Ad>`

`<ImageUrl>SlugBug.jpg</ImageUrl>`

`<TargetUrl>``http://www.Cars.com</TargetUrl`T2】

`<AlternateText>Your new Car?</AlternateText>`

`<Impressions>80</Impressions>`

`</Ad>`

`<Ad>`

`<ImageUrl>car.gif</ImageUrl>`

`<TargetUrl>``http://www.CarSuperSite.com</TargetUrl`T2】

`<AlternateText>Like this Car?</AlternateText>`

`<Impressions>80</Impressions>`

`</Ad>`

`</Advertisements>`

这里，您指定了两个图像文件(`slugbug.jpg`和`car.gif`)。因此，您需要确保这些文件位于网站的根目录下(这些文件已经包含在本书的代码下载中)。要将它们添加到当前项目中，请选择网站添加现有项目菜单选项。此时，您可以通过`AdvertisementFile`属性(在属性窗口中)将您的 XML 文件关联到`AdRotator`控件，如下所示:

`<asp:AdRotator ID="myAdRotator" runat="server"`

`AdvertisementFile="∼/Ads.xml"/>`

稍后，当您运行该应用程序并回发到页面时，您将随机看到两个图像文件中的一个。

### 定义默认内容页面

现在您已经建立了一个母版页，您可以开始设计单个的`*.aspx`页面，这些页面将定义要合并到母版页的`<asp:ContentPlaceHolder>`标签中的 UI 内容。在母版页中合并的`*.aspx`文件被称为内容页面，与普通的独立 Web 表单页面有一些关键的不同。

简而言之，`*.master`文件定义了最终 HTML 页面的`<form>`部分。因此，`*.aspx`文件中现有的`<form>`区域需要替换为`<asp:Content>`范围。虽然您可以手动更新初始`*.aspx`文件的标记，但是您可以向项目中插入新的内容页面。首先，删除现有的`Default.aspx`文件，然后右键单击`*.master`文件设计器表面的任意位置，并选择添加内容页面菜单选项(参见图 [32-12](#Fig12) )。

![A978-1-4842-1332-2_32_Fig12_HTML.jpg](img/A978-1-4842-1332-2_32_Fig12_HTML.jpg)

图 32-12。

Adding a new content page to the master page

这将生成一个新的`*.aspx`文件，具有以下初始标记:

`<%@ Page Language="C#" MasterPageFile="∼/MasterPage.master"`

`AutoEventWireup="true" CodeFile="Default.aspx.cs"`

`Inherits="_Default" Title="" %>`

`<asp:Content ID="Content1"`

`ContentPlaceHolderID="head" Runat="Server">`

`</asp:Content>`

`<asp:Content ID="Content2"`

`ContentPlaceHolderID="ContentPlaceHolder1" Runat="Server">`

`</asp:Content>`

首先，请注意,`<%@Page%>`指令已经用一个新的`MasterPageFile`属性进行了更新，这个属性被分配给了您的`*.master`文件。还要注意，不是有一个`<form>`元素，而是有一个`<asp:Content>`作用域(目前为空),它设置了与主文件中的`<asp:ContentPlaceHolder>`组件相同的`ContentPlaceHolderID`值。

有了这些关联，内容页面就知道在哪里插入它的内容，而主控形状的内容以只读方式显示在内容页面上。没有必要为您的`Default.aspx`内容区域构建复杂的 UI。对于这个例子，简单地添加一些文字文本，提供一些基本的站点说明，如图 [32-13](#Fig13) 所示(还要注意在设计器中内容页面的右上角有一个链接，可以切换到相关的主文件)。

![A978-1-4842-1332-2_32_Fig13_HTML.jpg](img/A978-1-4842-1332-2_32_Fig13_HTML.jpg)

图 32-13。

Authoring the first content page

现在，如果您运行您的项目，您会发现`*.master`和`Default.aspx`文件的 UI 内容已经被合并到一个 HTML 流中。正如你在图 [32-14](#Fig14) 中看到的，浏览器(或最终用户)甚至不知道母版页的存在(注意浏览器只是显示来自`Default.aspx`的 HTML)。同样，当你刷新页面时(通过 F5 键)，你应该看到`AdRotator`随机显示两个图像中的一个。

![A978-1-4842-1332-2_32_Fig14_HTML.jpg](img/A978-1-4842-1332-2_32_Fig14_HTML.jpg)

图 32-14。

At runtime, master files and content pages render back a single form

### 设计清单内容页面

要将`Inventory.aspx`内容页面插入到当前项目中，请在 IDE 中打开`*.master`页面，选择网站添加内容页面，并使用解决方案资源管理器将该文件重命名为`Inventory.aspx`。库存内容页面的作用是在`GridView`控件内显示自动批次数据库的`Inventory`表的内容。然而，与前一章不同的是，这个`GridView`将被配置为使用一些内置的数据绑定支持和来自第 30 章的更新的自动分配装配来与自动分配数据库交互。

虽然 Web Forms `GridView`控件能够在标记中表示连接字符串数据和 SQL `Select`、`Update`和`Delete`语句(或者存储过程),但首选方法是使用数据访问层(DAL)。这促进了关注点的分离，并将对数据存储的更改与前端代码隔离开来。

通过一些简单的属性和最少的代码(假设您已经构建了一个 DAL)，您可以配置`GridView`来自动选择、更新和删除底层数据存储的记录。这极大地简化了样板代码的数量，并通过 ASP.NET 4.5 中引入的`SelectMethod`、`DeleteMethod`和`UpdateMethod`属性(以及列表视图控件的附加特性)得以实现。

### 将 AutoLotDAL 和实体框架添加到 AspNetCarsSite

使用 Windows 资源管理器从[第 31 章](31.html)(或从本章的下载目录)中复制`AutoLotDAL`组件。右键单击`AspNetCarsSite`项目中的 references 节点，在 Add References 对话框中单击 Browse，导航到并选择`AutoLotDAL.dll`，添加对`AutoLotDAL`程序集的引用。

接下来，通过右键单击项目并选择 Manage NuGet Packages for Solution，将实体框架添加到 web 项目中。您还需要更新`Web.config`文件来添加连接字符串。对`Web.config`文件的更改如下所示(根据您安装 SQL Server Express 的方式，您的连接字符串可能会有所不同):

`<connectionStrings>`

`<add name="AutoLotConnection"`

`connectionString="data source=.\SQLEXPRESS2014;initial catalog=AutoLot;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework"`

`providerName="System.Data.SqlClient"/>`

`</connectionStrings>`

### 用数据填充 GridView

为了说明如何以声明的方式使用`GridView`，首先用一个`GridView`控件更新`Inventory.aspx`内容页面。表 [32-3](#Tab3) 列出了您将在接下来的几节中添加的属性以及每个属性的用途。

表 32-3。

Select Attributes of List Controls

<colgroup><col> <col></colgroup> 
| 属性 | 生命的意义 |
| --- | --- |
| `DataKeyNames` | 指定表的主键。 |
| `ItemType` | 为列表控件启用强类型。 |
| `SelectMethod` | 指示代码隐藏中用于填充表的方法。每次呈现列表控件时都会调用它。 |
| `DeleteMethod` | 指示将用于从表的数据源中删除记录的方法。 |
| `UpdateMethod` | 指示当编辑回发到服务器时将用于更新记录的方法。 |

你将从使用`ItemType`和`SelectMethod`属性开始(正如你在[第 31 章](31.html)中所做的)。将`GridView`声明(在第二个`<asp:Content>`元素中)更新如下:

`<asp:GridView ID="GridView2" runat="server" CellPadding="4" AutoGenerateColumns="False"`

`ItemType="AutoLotDAL.Models.Inventory" SelectMethod="GetData"`

`EmptyDataText="There are no data records to display." ForeColor="#333333"`

`GridLines="None">`

接下来，添加下列条目(现在不要介意`SortExpressions`):

`<Columns>`

`<asp:BoundField DataField="CarID" HeaderText="CarID" ReadOnly="True"`

`SortExpression="CarID" />`

`<asp:BoundField DataField="Make" HeaderText="Make" SortExpression="Make" />`

`<asp:BoundField DataField="Color" HeaderText="Color" SortExpression="Color" />`

`<asp:BoundField DataField="PetName" HeaderText="PetName" SortExpression="PetName" />`

`</Columns>`

确保结束`GridView`标签在结束`Columns`标签之后:

`</asp:GridView>`

打开`Inventory.aspx.cs`并添加`GetData`方法。`GetData`方法不带任何参数，需要返回一个`IEnumerable<Inventory>`。因为您已经创建了 DAL，所以这变得微不足道。确保为`AutoLotDAL.Models`和`AutoLotDAL.Repos`添加`using`语句，并更新`GetData`方法如下:

`public IEnumerable<Inventory> GetData() => new InventoryRepo().GetAll();`

此时，您可以运行您的 web 程序了。点击查看库存菜单项，查看您的数据，如图 [32-15](#Fig15) 所示。(注意，我使用内嵌设计器用独特的外观更新了我的`GridView`。)

![A978-1-4842-1332-2_32_Fig15_HTML.jpg](img/A978-1-4842-1332-2_32_Fig15_HTML.jpg)

图 32-15。

The Inventory page with data

### 启用就地编辑

下一步是启用`GridView`控件对就地激活的支持。您将从使用`DataKeyNames`、`DeleteMethod,`和`UpdateMethod`属性开始。将`GridView`声明标记更新如下:

`<asp:GridView ID="GridView2" runat="server" CellPadding="4" AutoGenerateColumns=”False”`

`DataKeyNames="CarID, Timestamp" ItemType="AutoLotDAL.Models.Inventory"`

`SelectMethod="GetData" DeleteMethod="Delete" UpdateMethod="Update"`

`EmptyDataText="There are no data records to display." ForeColor="#333333"`

`GridLines="None">`

`CarId`是主键，所以在`DataKeyNames`属性中是有意义的。将`Timestamp`字段添加为`DataKeyName`，这样它将被传递到`Update`和`Delete`方法中。将以下`CommandField`条目添加到`Columns`条目中。这将在每行中添加编辑和删除链接。更新后的标记如下所示:

`<Columns>`

`<asp:CommandField ShowDeleteButton="True" ShowEditButton="True" />`

`<asp:BoundField DataField="CarID" HeaderText="CarID" ReadOnly="True"`

`SortExpression="CarID" />`

`<asp:BoundField DataField="Make" HeaderText="Make" SortExpression="Make" />`

`<asp:BoundField DataField="Color" HeaderText="Color" SortExpression="Color" />`

`<asp:BoundField DataField="PetName" HeaderText="PetName" SortExpression="PetName" />`

`</Columns>`

打开`Inventory.aspx.cs`，添加`Delete`和`Update`方法。`Delete`方法为`void`，以`int carId`和`byte[] timeStamp`为参数。这两个值都作为参数进入方法，因为它们在标记中被指定为`DataKeyNames`。

`public void Delete(int carId, byte[] timeStamp)`

`{`

`new InventoryRepo().Delete(carId, timeStamp);`

`}`

`Update`方法是无效的，它使用模型绑定，所以它可以将一个`Inventory`类型作为参数。模型绑定是移植到 ASP.NET web forms 4.5 的 ASP.NET MVC 的一个特性。它采用/query string/等所有形式。名称值对，并尝试使用反射重新构造指定的类型。有显式模型绑定和隐式模型绑定。在每种情况下，模型绑定引擎都会尝试将名称/值对(来自提交的表单)中的值分配给所需类型的匹配属性。如果它不能分配一个或多个值(由于数据类型转换问题或验证错误)，它将设置`ModelState.IsValid = false`。如果所有匹配的属性都分配成功，则设置`ModelState.IsValid = true`。

对于显式模型绑定，调用`TryUpdateModel`，传入该类型的一个实例。如果模型绑定失败，`TryUpdateModel`返回`false`。例如，您可以这样编写`Update`方法:

`public async void Update(int carID)`

`{`

`var inv = new Inventory() {CarID = carID};`

`if (TryUpdateModel(inv))`

`{`

`await new InventoryRepo().SaveAsync(inventory);`

`}`

`}`

对于隐式模型绑定，将所需的类型作为方法的参数传入。对`Update`方法执行此操作。在方法体中，首先检查以确保模型状态是有效的(本章后面会详细介绍验证)，然后在`InventoryRepo`上调用`SaveAsync`。因为你在等待`SaveAsync`方法，所以给`Update`方法添加`async`修饰符，就像这样:

`public async void Update(Inventory inventory)`

`{`

`if (ModelState.IsValid)`

`{`

`await new InventoryRepo().SaveAsync(inventory);`

`}`

`}`

当你给`Update`方法添加`async`修饰符时，当调用`Update`方法时你会得到一个错误，因为页面没有被标记为异步。幸运的是，这就像在`Page`指令中添加`Async=”true”`一样简单，就像这样:

`<%@ Page Title="" Language="C#" MasterPageFile="∼/MasterPage.master"`

`AutoEventWireup="true" CodeFile="Inventory.aspx.cs" Inherits="InventoryPage"`

`Async="true" %>`

现在，当你运行应用程序时，你会看到编辑和删除链接。点击编辑链接，可以进行原地编辑，如图 [32-16](#Fig16) 所示。在编辑模式下，链接会变为“更新”或“取消”。

![A978-1-4842-1332-2_32_Fig16_HTML.jpg](img/A978-1-4842-1332-2_32_Fig16_HTML.jpg)

图 32-16。

In-place editing and deleting

### 启用排序和分页

`GridView`控件可以很容易地配置为排序(通过列名超链接)和分页(通过数字或下一个/上一个超链接)。为此，更新`GridView`的标记，添加`AllowPaging`、`PageSize`和`AllowSorting`属性，如下所示:

`<asp:GridView ID="carsGrid" runat="server"`

`AllowPaging="True" PageSize="2"`

`AllowSorting="True" AutoGenerateColumns="False" CellPadding="4"`

`DataKeyNames="CarID" ItemType="AutoLotDAL.Models.Inventory"`

`SelectMethod="GetData" DeleteMethod="Delete" UpdateMethod="Update"`

`EmptyDataText="There are no data records to display." ForeColor="#333333"`

`GridLines="None">`

如果您现在运行该应用程序，您将会看到以下错误:

当 DataBoundControl 启用分页时，SelectMethod 应该返回一个 IQueryable <itemtype>或者应该具有所有这些强制参数:int startRowIndex，int maximumRows，out int totalRowCount</itemtype>

这很容易通过在`InventoryRepo`上的`GetAll`调用后添加`AsQueryable()`，并将该方法的签名更改为`IQueryable`来解决，如下所示:

`public IQueryable<Inventory> GetData() => new InventoryRepo().GetAll().AsQueryable();`

Note

虽然添加`AsQueryable()`解决了这个例子中的问题，但是在存储库本身上公开`GetAll`的`IQueryable`版本会更好。

当您再次运行您的页面时，您将能够通过点击列名并通过分页链接滚动您的数据来对您的数据进行排序(假设您在`Inventory`表中有足够的记录！)，如图 [32-17](#Fig17) 所示。

![A978-1-4842-1332-2_32_Fig17_HTML.jpg](img/A978-1-4842-1332-2_32_Fig17_HTML.jpg)

图 32-17。

Enabling sorting and paging

### 启用过滤

下一步是向清单列表添加过滤。同样，由于 ASP.NET Web Forms 4.5 中添加了额外的功能，这是相当微不足道的。首先添加一个`DropDownList`框，该框将被绑定到 AutoLot 数据库中的不同品牌列表。`DataTextField`(显示的内容)和`DataValueField`(基于所选项目的下拉列表的值)都被设置为`Make`。应该将`SelectMethod`设置为名为`GetMakes`的方法。关键是控件必须有`runat=server`设置。另请参见`<asp:ListItem>`标签。如果没有从数据绑定列表中选择任何内容，则添加`"(All)"`选项。标记如下所示:

`<asp:DropDownList ID="cboMake" SelectMethod="GetMakes"`

`AppendDataBoundItems="true" AutoPostBack="true"`

`DataTextField="Make" DataValueField="Make" runat="server">`

`<asp:ListItem Value="" Text="(All)" />`

`</asp:DropDownList>`

接下来，打开`Inventory.aspx.cs`并创建`GetMakes`方法。在这个方法中，返回一个新的匿名对象列表，这些匿名对象包含来自数据的不同标记。方法如下:

`public IEnumerable GetMakes() =>`

`new InventoryRepo().GetAll().Select(x => new {x.Make}).Distinct();`

如果传入了一个`Make`，也必须更新`GetData`方法来过滤数据。该参数标有`[Control(“cboMake”)]`属性，指定控件的名称。如果控件名与参数名匹配，则不需要控件名，但是由于在本例中它们不匹配，所以需要指定控件名。当表单数据被回发时，该参数将获取控件的值(因此需要`runat=”server”`),如果没有选择任何内容，该参数将为空字符串。这是按如下方式完成的:

`public IQueryable<Inventory> GetData([Control("cboMake")]string make="")`

`{`

`return string.IsNullOrEmpty(make) ?`

`new InventoryRepo().GetAll().AsQueryable() :`

`new InventoryRepo().GetAll().Where(x => x.Make == make).AsQueryable();`

`}`

现在，当你运行应用程序时，你可以选择一个汽车制造商，它将根据所选的值过滤结果集，如图 [32-18](#Fig18) 。

![A978-1-4842-1332-2_32_Fig18_HTML.jpg](img/A978-1-4842-1332-2_32_Fig18_HTML.jpg)

图 32-18。

Filtering data based on the value of a control on the page

### 设计造车内容页面

这个例子的最后一个任务是设计`BuildCar.aspx`内容页面。为此，请确保您已经打开了您的`*.master`文件进行编辑，然后将该文件插入到当前项目中(通过网站添加内容页面菜单选项；这是右键单击项目母版页的替代方法)。使用解决方案资源管理器将这个新文件重命名为`BuildCar.aspx`。

这个新页面将利用 Web Forms `Wizard` web 控件，它提供了一种简单的方法来引导最终用户完成一系列相关的步骤。这里，所讨论的步骤将模拟为购买而制造汽车的行为。

在内容区域放置一个描述性的`Label`和`Wizard`控件。接下来，激活`Wizard`的行内编辑器，并单击添加/删除 WizardSteps 链接。总共添加四个步骤，如图 [32-19](#Fig19) 所示。

![A978-1-4842-1332-2_32_Fig19_HTML.jpg](img/A978-1-4842-1332-2_32_Fig19_HTML.jpg)

图 32-19。

Configuring your wizard

在您定义了这些步骤之后，您会注意到`Wizard`定义了一个空的内容区域，您现在可以在这里为当前选择的步骤拖放控件。对于此示例，使用以下 UI 元素更新每个步骤(确保使用“属性”窗口为每个项目提供一个配件 ID 值):

*   选择你的模型:一个`TextBox`控件
*   选择你的颜色:一个`ListBox`控件
*   给你的车命名:一个`TextBox`控件
*   交货日期:一个`Calendar`控制

`ListBox`控件是`Wizard`中唯一需要额外步骤的 UI 元素。在设计器上选择这个项目(确保您首先选择了选择您的颜色链接)，并使用属性窗口的`Items`属性用一组颜色填充这个小部件。这样做之后，您会发现在`Wizard`定义的范围内有如下标记:

`<asp:ListBox ID="ListBoxColors" runat="server" Width="237px">`

`<asp:ListItem>Purple</asp:ListItem>`

`<asp:ListItem>Green</asp:ListItem>`

`<asp:ListItem>Red</asp:ListItem>`

`<asp:ListItem>Yellow</asp:ListItem>`

`<asp:ListItem>Pea Soup Green</asp:ListItem>`

`<asp:ListItem>Black</asp:ListItem>`

`<asp:ListItem>Lime Green</asp:ListItem>`

`</asp:ListBox>`

现在您已经定义了每个步骤，您可以为自动生成的 Finish 按钮处理`FinishButtonClick`事件。但是，请注意，在设计器上选择向导的最后一步之前，您不会看到这个完成按钮。一旦选择了最后一步，只需双击 Finish 按钮就可以生成事件处理程序。在服务器端事件处理程序中，从每个 UI 元素中获取选择，并构建一个描述字符串，该字符串被分配给名为`lblOrder`的附加`Label`类型的`Text`属性，如下所示:

`public partial class BuildCarPage : System.Web.UI.Page`

`{`

`protected void Page_Load(object sender, EventArgs e)`

`{`

`}`

`protected void carWizard_FinishButtonClick(object sender,`

`WizardNavigationEventArgs e)`

`{`

`// Get each value.`

`string order = $"{txtCarPetName.Text}, your { ListBoxColors.SelectedValue } { txtCarModel.Text } will arrive on { carCalendar.SelectedDate.ToShortDateString()}";`

`// Assign to label.`

`lblOrder.Text = order;`

`}`

`}`

至此，您的 AspNetCarsSite web 应用程序就完成了！图 [32-20](#Fig20) 显示了运行中的向导。

![A978-1-4842-1332-2_32_Fig20_HTML.jpg](img/A978-1-4842-1332-2_32_Fig20_HTML.jpg)

图 32-20。

The `Wizard` control in action

以上是您对各种 web 窗体 Web 控件、母版页、内容页和站点地图导航的初步了解。接下来，让我们看看 Web 窗体验证控件的功能。为了使本章中的主题保持一定的独立性和原子性，您将构建一个新的网站来演示验证技术；但是，您肯定可以将验证控件添加到当前项目中。

Source Code

AspNetCarsSite 网站包含在 [`Chapter 32`](32.html) 子目录中。

## 验证控件的作用

您将研究的下一组 Web 窗体控件统称为验证控件。与您所研究的其他 Web 表单控件不同，验证控件不是用于发出 HTML 以进行呈现，而是用于发出客户端 JavaScript 以进行表单验证。如本章开头所述，客户端表单验证非常有用，因为您可以确保在回发到 web 服务器之前各种约束都已就绪，从而避免了昂贵的往返。表 [32-4](#Tab4) 给出了网络表单验证控件的概要。

表 32-4。

Web Forms Validation Controls

<colgroup><col> <col></colgroup> 
| 控制 | 生命的意义 |
| --- | --- |
| `CompareValidator` | 验证一个输入控件的值是否等于另一个输入控件的给定值或固定常数。 |
| `CustomValidator` | 允许您生成验证给定控件的自定义验证函数。 |
| `RangeValidator` | 确定给定值在预定范围内。 |
| `RegularExpressionValidator` | 检查关联输入控件的值是否与正则表达式的模式匹配。 |
| `RequiredFieldValidator` | 确保给定的输入控件包含值(即不为空)。 |
| `ValidationSummary` | 以列表、项目符号列表或单段格式显示网页的所有验证错误的摘要。错误可以内嵌显示和/或显示在弹出消息框中。 |

所有的验证控件(减去`ValidationSummary`)最终都是从一个名为`System.Web.UI.WebControls.BaseValidator`的公共基类中派生出来的，因此，它们有一组公共特性。表 [32-5](#Tab5) 记录了关键成员。

表 32-5。

Common Properties of the Web Forms Validators

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `ControlToValidate` | 获取或设置要验证的输入控件 |
| `Display` | 获取或设置验证控件中错误信息的显示行为 |
| `EnableClientScript` | 获取或设置一个值，该值指示是否启用客户端验证 |
| `ErrorMessage` | 获取或设置错误信息的文本 |
| `ForeColor` | 获取或设置验证失败时显示的消息的颜色 |

为了演示如何使用这些验证控件，创建一个名为 ValidatorCtrls 的新的空网站项目，并插入一个名为`Default.aspx`的新 web 表单。首先，在页面上放置四个`TextBox`控件(带有四个相应的描述性的`Label`)。接下来，将`RequiredFieldValidator`、`RangeValidator`、`RegularExpressionValidator`和`CompareValidator`控件放置在每个相应的输入字段附近。最后加一个单`Button`和一个终`Label`。图 [32-21](#Fig21) 显示了一种可能的布局。

![A978-1-4842-1332-2_32_Fig21_HTML.jpg](img/A978-1-4842-1332-2_32_Fig21_HTML.jpg)

图 32-21。

Web Forms validation controls will ensure your form data is correct before allowing postback

现在您已经有了一个初始的用户界面，让我们来看看配置每个验证器控件的过程，并看看这样做的最终结果。然而，首先您需要修改当前的`web.config`文件，以允许客户端处理您的验证控件。

### 启用客户端 JavaScript 验证支持

从 ASP.NET 4.5 开始，微软引入了一个新的设置来控制验证控件在运行时如何响应。当您创建一个 ASP.NET web 应用程序并打开`web.config`文件时，您会发现以下设置:

`<appSettings>`

`<add key="ValidationSettings:UnobtrusiveValidationMode" value="WebForms" />`

`</appSettings>`

当您的 web 配置文件中有此设置时，网站将使用各种 HTML 5 数据属性来处理验证，而不是发回客户端 JavaScript 代码的格式回复以供 web 浏览器处理。鉴于这一版本的文本没有深入 HTML 5 的细节，如果您创建了一个 Web Forms 应用程序(而不是一个网站)，您需要注释掉(或删除)这一行，以便当前的验证示例能够正确工作。

### RequiredFieldValidator

配置`RequiredFieldValidator`很简单。只需使用 Visual Studio 属性窗口相应地设置`ErrorMessage`和`ControlToValidate`属性。下面是确保`txtRequiredField`文本框不为空的结果标记:

`<asp:RequiredFieldValidator ID="RequiredFieldValidator1"`

`runat="server" ControlToValidate="txtRequiredField"`

`ErrorMessage="Oops! Need to enter data.">`

`</asp:RequiredFieldValidator>`

`RequiredFieldValidator`支持一个`InitialValue`属性。您可以使用该属性来确保用户在相关的`TextBox`中输入除初始值以外的任何值。例如，当用户第一次发布到一个页面时，您可能希望配置一个`TextBox`来包含值“请输入您的姓名”。现在，如果您没有设置`RequiredFieldValidator`的`InitialValue`属性，运行时将假设字符串“请输入您的姓名”是有效的。因此，为了确保必需的`TextBox`仅在用户输入除“请输入您的姓名”之外的任何内容时才有效，请按如下方式配置您的小部件:

`<asp:RequiredFieldValidator ID="RequiredFieldValidator1"`

`runat="server" ControlToValidate="txtRequiredField"`

`ErrorMessage="Oops! Need to enter data."`

`InitialValue="Please enter your name">`

`</asp:RequiredFieldValidator>`

### 正规的 regularexprrecessionalidator

当您想要对给定输入字段中输入的字符应用模式时，可以使用`RegularExpressionValidator`。为了确保给定的`TextBox`包含有效的美国社会保险号，您可以如下定义小部件:

`<asp:RegularExpressionValidator ID="RegularExpressionValidator1"`

`runat="server" ControlToValidate="txtRegExp"`

`ErrorMessage="Please enter a valid US SSN."`

`ValidationExpression="\d{3}-\d{2}-\d{4}">`

`</asp:RegularExpressionValidator>`

注意`RegularExpressionValidator`是如何定义一个`ValidationExpression`属性的。如果您以前从未使用过正则表达式，那么对于这个示例，您只需要知道它们用于匹配给定的字符串模式。这里，`"\d{3}-\d{2}-\d{4}"`这个表达式捕获了一个标准的美国社会安全号码，格式为`xxx-xx-xxxx`(其中`x`是任意数字)。

这个特殊的正则表达式是不言自明的；但是，假设您想要测试一个有效的日本电话号码。正确的表达现在变得复杂多了:`"(0\d{1,4}-|\(0\d{1,4}\)?)?\d{1,4}-\d{4}"`。好消息是，当您使用属性窗口选择`ValidationExpression`属性时，您可以通过单击椭圆按钮从一组预定义的通用正则表达式中进行选择。

Note

如果您对正则表达式感兴趣，您会很高兴地知道。NET 平台提供了两个名称空间(`System.Text.RegularExpressions`和`System.Web.RegularExpressions`)，专门用于这种模式的编程操作。

### RangeValidator

除了一个`MinimumValue`和`MaximumValue`属性，`RangeValidator` s 还有一个名为`Type`的属性。因为您对测试用户提供的整数范围的输入感兴趣，所以您需要指定`Integer`(这不是缺省值！)，像这样:

`<asp:RangeValidator ID="RangeValidator1"`

`runat="server" ControlToValidate="txtRange"`

`ErrorMessage="Please enter value between 0 and 100."`

`MaximumValue="100" MinimumValue="0" Type="Integer">`

`</asp:RangeValidator>`

`RangeValidator`也可用于测试给定值是否介于货币值、日期、浮点数或字符串数据之间(默认设置)。

### 比较验证器

最后，注意`CompareValidator`支持下面的`Operator`属性:

`<asp:CompareValidator ID="CompareValidator1" runat="server"`

`ControlToValidate="txtComparison"`

`ErrorMessage="Enter a value less than 20." Operator="LessThan"`

`ValueToCompare="20" Type="Integer">`

`</asp:CompareValidator>`

假设这个验证器的作用是使用二元运算符将文本框中的值与另一个值进行比较，那么`Operator`属性可能被设置为诸如`LessThan`、`GreaterThan`、`Equal`和`NotEqual`之类的值就不足为奇了。另请注意，`ValueToCompare`用于建立一个比较值。请注意，`Type`属性被设置为`Integer`。默认情况下，`CompareValidator`将测试字符串值！

Note

还可以使用`ControlToCompare`属性将`CompareValidator`配置为比较另一个 Web 表单控件中的值(而不是硬编码的值)。

为了完成这个页面的代码，处理`Button`控件的`Click`事件，并通知用户他或她已经成功通过了验证逻辑，如下所示:

`public partial class _Default : System.Web.UI.Page`

`{`

`protected void Page_Load(object sender, EventArgs e)`

`{`

`}`

`protected void btnPostback_Click(object sender, EventArgs e)`

`{`

`lblValidationComplete.Text = "You passed validation!";`

`}`

`}`

现在，使用您选择的浏览器导航到此页面。此时，您应该看不到任何明显的变化。但是，当您在输入虚假数据后尝试单击 Submit 按钮时，您的错误消息突然出现。当您输入有效数据时，错误消息将被删除，并发生回发。如果查看浏览器呈现的 HTML，可以看到验证控件生成了一个客户端 JavaScript 函数，该函数利用了自动下载到用户机器的特定 JavaScript 函数库。验证完成后，表单数据被发送回服务器，ASP.NET 运行时将在服务器上执行相同的验证测试(只是为了确保没有发生在线篡改)。

另外，如果 HTTP 请求是由不支持客户端 JavaScript 的浏览器发送的，那么所有的验证都将在服务器上进行。通过这种方式，您可以针对验证控件进行编程，而无需考虑目标浏览器；返回的 HTML 页面将错误处理重定向回 web 服务器。

### 创建验证摘要

下一个以验证为中心的主题是使用`ValidationSummary`小部件。目前，您的每个验证器都在它在设计时所处的确切位置显示它的错误消息。在许多情况下，这可能正是你正在寻找的。然而，在一个有许多输入部件的复杂表单上，您可能不希望弹出随机的红色文本块。使用`ValidationSummary`类型，您可以指示您的所有验证类型在页面上的特定位置显示它们的错误消息。

第一步是简单地在您的`*.aspx`文件中放置一个`ValidationSummary`。您可以有选择地设置这种类型的`HeaderText`属性以及`DisplayMode`，默认情况下，它会将所有错误消息以项目符号列表的形式列出。

`<asp:ValidationSummary id="ValidationSummary1"`

`runat="server" Width="353px"`

`HeaderText="Here are the things you must correct.">`

`</asp:ValidationSummary>`

接下来，您需要为页面上的每个验证器(例如，`RequiredFieldValidator`，`RangeValidator`)将`Display`属性设置为`None`。这将确保您不会看到给定验证失败的重复错误消息(一个在摘要窗格中，另一个在验证器的位置)。图 [32-22](#Fig22) 显示了运行中的汇总窗格。

![A978-1-4842-1332-2_32_Fig22_HTML.jpg](img/A978-1-4842-1332-2_32_Fig22_HTML.jpg)

图 32-22。

Using a validation summary

最后但同样重要的是，如果您希望使用客户端`MessageBox`显示错误消息，请将`ValidationSummary`控件的`ShowMessageBox`属性设置为`true`，将`ShowSummary`属性设置为`false`。

### 定义验证组

也可以定义验证器所属的组。当页面的多个区域作为一个整体工作时，这非常有用。例如，您可以在一个`Panel`对象中有一组控件允许用户输入他或她的邮寄地址，而另一个`Panel`包含 UI 元素来收集信用卡信息。使用组，您可以将每组控件配置为独立进行验证。

在当前项目中插入一个名为`ValidationGroups.aspx`的新页面，该页面定义了两个`Panel`，第一个`Panel`对象期望一个`TextBox`包含某种形式的用户输入(通过一个`RequiredFieldValidator`)，第二个`Panel`期望一个美国 SSN 值(通过一个`RegularExpressionValidator`)。图 [32-23](#Fig23) 显示了一种可能的用户界面。

![A978-1-4842-1332-2_32_Fig23_HTML.jpg](img/A978-1-4842-1332-2_32_Fig23_HTML.jpg)

图 32-23。

These `Panel` objects will independently configure their input areas

为了确保验证器独立运行，只需使用`ValidationGroup`属性将每个验证器和被验证的控件分配给一个唯一命名的组。在以下可能的标记中，注意这里使用的`Click`事件处理程序实际上是代码文件中的空存根:

`<form id="form1" runat="server">`

`<asp:Panel ID="Panel1" runat="server" Height="83px" Width="296px">`

`<asp:TextBox ID="txtRequiredData" runat="server"`

`ValidationGroup="FirstGroup">`

`</asp:TextBox>`

`<asp:RequiredFieldValidator ID="RequiredFieldValidator1" runat="server"`

`ErrorMessage="*Required field!" ControlToValidate="txtRequiredData"`

`ValidationGroup="FirstGroup">`

`</asp:RequiredFieldValidator>`

`<asp:Button ID="bntValidateRequired" runat="server"`

`OnClick="bntValidateRequired_Click"`

`Text="Validate" ValidationGroup="FirstGroup" />`

`</asp:Panel>`

`<asp:Panel ID="Panel2" runat="server" Height="119px" Width="295px">`

`<asp:TextBox ID="txtSSN" runat="server"`

`ValidationGroup="SecondGroup">`

`</asp:TextBox>`

`<asp:RegularExpressionValidator ID="RegularExpressionValidator1"`

`runat="server" ControlToValidate="txtSSN"`

`ErrorMessage="*Need SSN" ValidationExpression="\d{3}-\d{2}-\d{4}"`

`ValidationGroup="SecondGroup">`

`</asp:RegularExpressionValidator>`

`<asp:Button ID="btnValidateSSN" runat="server"`

`OnClick="btnValidateSSN_Click" Text="Validate"`

`ValidationGroup="SecondGroup" />`

`</asp:Panel>`

`</form>`

现在，右键单击该页面的设计器，并选择“在浏览器中查看”菜单选项，以验证每个面板的小部件都以互斥的方式运行。

### 使用数据注释进行验证

除了验证控件之外，ASP.NET Web 窗体还支持使用数据批注进行验证。回想一下[第 23 章](23.html)，您可以用定义模型业务需求的属性来标记模型类(比如 Required)。使用新的`ModelErrorMessage`控件和`ValidationSummary`控件上的一个附加属性，您可以用很少的代码显示数据注释冲突导致的错误。

#### 创建模型

虽然你当然可以使用第 31 章中的`AutoLotDAL`库，但是为了简单起见，创建一个新的`Inventory`类。通过右键单击项目并选择添加 ASP.NET 文件夹➤ App_Code 添加➤，开始添加一个新的`App_Code`目录。在这个文件夹中，添加一个名为`Inventory.` `cs`的新类。在这个类中，添加以下代码(确保为`System.ComponentModel.DataAnnotations`添加一个`using`):

`public class Inventory`

`{`

`[Key,Required]`

`public int CarID { get; set; }`

`[Required(ErrorMessage="Make is required.")]`

`[StringLength(30,ErrorMessage="Make can only be 30 charaters or less")]`

`public string Make { get; set; }`

`[Required, StringLength(30)]`

`public string Color { get; set; }`

`[StringLength(30, ErrorMessage = "Pet Name can only be 30 charaters or less")]`

`public string PetName { get; set; }`

`}`

#### 构建用户界面

接下来，添加一个名为`Annotations.aspx`的新 Web 表单。在这个页面中，在`Form`标签中添加一个`asp:FormView`控件。`FormView`控件可以非常简单地从显示、编辑模式切换到插入模式。首先，如下更新标题属性(在插入模式下，`DefaultMode=Insert`加载`FormView`):

`<asp:FormView runat="server" ID="fvDataBinding" DataKeyNames="CarID"`

`ItemType="Inventory" DefaultMode="Insert" InsertMethod="SaveCar"`

`UpdateMethod="UpdateCar" SelectMethod="GetCar">`

接下来，创建`ItemTemplate`。这是将以只读模式显示的内容。`ItemType`强类型化了`FormView`，并支持`<%# Item.FieldName %>`语法。添加以下标记:

`<ItemTemplate>`

`<table style="width:100%">`

`<tr>`

`<td><asp:Label runat="server" AssociatedControlID="make">Make:</asp:Label></td>`

`<td><asp:Label runat="server" ID="make" Text=’<%# Item.Make %>’ /></td>`

`</tr>`

`<tr>`

`<td><asp:Label runat="server" AssociatedControlID="color">Color:</asp:Label></td>`

`<td><asp:Label runat="server" ID="color" Text=’<%#: Item.Color %>’ /></td>`

`</tr>`

`<tr>`

`<td><asp:Label runat="server" AssociatedControlID="petname">Pet Name:</asp:Label></td>`

`<td><asp:Label runat="server" ID="customerAge" Text=’<%#: Item.PetName %>’ /></td>`

`</tr>`

`<tr>`

`<td colspan="2">`

`<asp:Button ID="EditButton" runat="server" CommandName="Edit" Text="Edit" />`

`</td>`

`</tr>`

`</table>`

`</ItemTemplate>`

`CommandName=”Edit”`表示点击按钮会使`FormView`进入编辑模式。一旦进入编辑模式，就会显示`EditItemTemplate`，这是您接下来要添加的。编辑模板和显示模板的语法有些不同。首先，在编辑模板时，不要使用`<%# Item.FieldName %>`语法，而是使用`<%# BindItem.FieldName %>`。使用`BindItem`设置双向绑定的控制。下一个区别是编辑控件后面的`ModelErrorMessage`控件。`ModelErrorMessage`将显示由`ModelStateKey`标识的属性的任何模型绑定错误。注意，这依赖于使`FormView`成为强类型。

`<EditItemTemplate>`

`<table style="width:100%">`

`<tr>`

`<td><asp:Label runat="server" AssociatedControlID="make">Make: </asp:Label></td>`

`<td>`

`<asp:TextBox runat="server" ID="make" Text=’<%# BindItem.Make %>’ />`

`<asp:ModelErrorMessage ModelStateKey="make" runat="server" ForeColor="Red" />`

`</td>`

`</tr>`

`<tr>`

`<td><asp:Label runat="server" AssociatedControlID="color">Color: </asp:Label></td>`

`<td>`

`<asp:TextBox runat="server" ID="color" Text=’<%#: BindItem.Color %>’ />`

`<asp:ModelErrorMessage ModelStateKey="color" runat="server" ForeColor="Red" />`

`</td>`

`</tr>`

`<tr>`

`<td><asp:Label runat="server" AssociatedControlID="petname">Pet Name: </asp:Label></td>`

`<td>`

`<asp:TextBox ID="petname" runat="server" Text=’<%#: BindItem.PetName %>’ />`

`<asp:ModelErrorMessage ModelStateKey="petname" runat="server" ForeColor="Red" />`

`</td>`

`</tr>`

`<tr>`

`<td colspan="2">`

`<asp:Button runat="server" CommandName="Update" Text="Save" />`

`<asp:Button runat="server" CommandName="Cancel" Text="Cancel"`

`CausesValidation="false" />`

`</td>`

`</tr>`

`</table>`

`</` `EditItemTemplate>`

`InsertItemTemplate`实际上和`EditItemTemplate`一样，唯一的区别(除了标签的名字)是`Button`的`CommandName`是`Insert`。

`<InsertItemTemplate>`

`<table style="width:100%">`

`<tr>`

`<td><asp:Label runat="server" AssociatedControlID="make">Make: </asp:Label></td>`

`<td>`

`<asp:TextBox runat="server" ID="make" Text=’<%#: BindItem.Make %>’ />`

`<asp:ModelErrorMessage ModelStateKey="make" runat="server" ForeColor="Red" />`

`</td>`

`</tr>`

`<tr>`

`<td><asp:Label runat="server" AssociatedControlID="color">Color: </asp:Label></td>`

`<td>`

`<asp:TextBox runat="server" ID="color" Text=’<%#: BindItem.Color %>’ />`

`<asp:ModelErrorMessage ModelStateKey="color" runat="server" ForeColor="Red" />`

`</td>`

`</tr>`

`<tr>`

`<td><asp:Label runat="server" AssociatedControlID="petname">Pet Name: </asp:Label></td>`

`<td>`

`<asp:TextBox ID="petname" runat="server" Text=’<%#: BindItem.PetName %>’ />`

`<asp:ModelErrorMessage ModelStateKey="petname" runat="server" ForeColor="Red" />`

`</td>`

`</tr>`

`<tr>`

`<td colspan="2">`

`<asp:Button runat="server" CommandName="Insert" Text="Save" />`

`</td>`

`</tr>`

`</table>`

`</InsertItemTemplate>`

最后，关闭`FormView`:

`<asp:FormView>`

最后，添加`ValidationSummary`控件。这里与前面例子的不同之处在于将`ShowModelStateErrors`属性设置为`true`。这指示控件显示任何模型绑定错误。在`FormView`的结束标记之后，添加以下标记:

`<asp:ValidationSummary runat="server" ShowModelStateErrors="true"`

`ForeColor="Red" HeaderText="Please check the following errors:" />`

#### 添加代码

您将添加足够的代码来显示验证。在一个实际的应用程序中，你支持`FormView`的方法会涉及到调用一个 DAL，而不仅仅是修补一个局部变量。但是为了保持示例的重点，在`Annotations.aspx.cs`中添加以下代码。您将需要添加 Microsoft。CodeDom . providers . dotnet compiler platform nu get 包以启用 C# 6 功能。注意在`SaveCar`方法上的隐式模型绑定和在`UpdateCar`方法上的显式模型绑定。

`private Inventory _model = null;`

`public void SaveCar(Inventory car)`

`{`

`if (ModelState.IsValid)`

`{`

`_model = car;`

`//Add new record here`

`}`

`}`

`public void UpdateCar(int carID)`

`{`

`Inventory car = new Inventory();`

`if (TryUpdateModel(car))`

`{`

`_model = car;`

`//Update record here`

`}`

`}`

`public Inventory GetCar() => _model;`

#### 测试应用程序

现在，运行应用程序，您将看到类似于图 [32-24](#Fig24) 的页面。

![A978-1-4842-1332-2_32_Fig24_HTML.jpg](img/A978-1-4842-1332-2_32_Fig24_HTML.jpg)

图 32-24。

The `FormView` control in Insert mode

将品牌和颜色留空，添加一个超过 30 个字符的宠物名称，然后单击保存。您应该会看到与图 [32-25](#Fig25) 中相同的错误。

![A978-1-4842-1332-2_32_Fig25_HTML.jpg](img/A978-1-4842-1332-2_32_Fig25_HTML.jpg)

图 32-25。

The FormView control with errors showing

与其他 Web 表单控件一样，`ModelErrorMessage`和`ValidationSummary`控件的样式可以比我在这里做的更好。

Source Code

ValidatorCtrls 网站包含在 [`Chapter 32`](32.html) 子目录中。

## 使用主题

至此，您已经使用了许多 web 窗体 Web 控件。正如您所看到的，每个控件都公开了一组属性(其中许多是由`System.Web.UI.WebControls.WebControl`继承的)，允许您建立给定的 UI 外观(背景颜色、字体大小、边框样式等等)。当然，在多页面 web 站点上，站点作为一个整体为各种类型的小部件定义一个共同的外观是很常见的。例如，所有的`TextBox`都可以被配置为支持给定的字体，所有的`Button`都有自定义的图像，所有的`Calendar`都有浅蓝色的边框。

显然，为网站中每个页面上的每个小部件建立相同的属性设置是非常费力的(并且容易出错)。即使您能够手动更新每个页面上每个 UI 小部件的属性，想象一下当您需要再次更改每个`TextBox`的背景颜色时会有多痛苦。显然，一定有更好的方法来应用站点范围的 UI 设置。

简化通用 UI 外观应用程序的一种方法是定义样式表。如果您有 web 开发背景，您会知道样式表定义了一组应用于浏览器的以 UI 为中心的公共设置。正如您所希望的，可以通过分配`CssStyle`属性为 web 窗体 Web 控件分配给定的样式。

然而，Web 表单附带了一种补充技术来定义一个称为主题的公共 UI。与样式表不同，主题是在 web 服务器(而不是浏览器)上应用的，可以通过编程或声明的方式实现。假设在 web 服务器上应用了一个主题，它可以访问 web 站点上的所有服务器端资源。此外，主题是通过创作与任何`*.aspx`文件中相同的标记来定义的(您可能同意，样式表的语法有点过于简洁)。

回想一下[第 31 章](31.html)，ASP.NET web 应用程序可以定义任意数量的特殊子目录，其中之一是`App_Themes`。这个单独的子目录可以进一步划分为更多的子目录，每个子目录代表您站点上的一个可能的主题。例如，考虑图 [32-26](#Fig26) ，它展示了一个包含三个子目录的`App_Themes`文件夹，每个子目录都有一组组成主题本身的文件。

![A978-1-4842-1332-2_32_Fig26_HTML.jpg](img/A978-1-4842-1332-2_32_Fig26_HTML.jpg)

图 32-26。

A single `App_Theme` folder may define numerous themes

### 理解*。皮肤文件

每个主题子目录肯定都有一个文件是`*.skin`文件。这些文件定义了各种 web 控件的外观。举例来说，创建一个名为 FunWithThemes 的新的空网站，并插入一个新的`Default.aspx` Web 表单。在这个新页面上，添加一个`Calendar`、`TextBox`和`Button`控件。您不需要以任何特殊的方式配置这些控件，并且这些控件的名称与当前示例无关。正如您将看到的，这些控件将成为您的自定义皮肤的目标。

接下来，插入一个名为`BasicGreen.skin`的新`*.skin`文件(使用网站添加新项目菜单选项)，如图 [32-27](#Fig27) 所示。

![A978-1-4842-1332-2_32_Fig27_HTML.jpg](img/A978-1-4842-1332-2_32_Fig27_HTML.jpg)

图 32-27。

Inserting `*.skin` files

Visual Studio 将提示您确认该文件可以添加到一个`App_Themes`文件夹中(这正是您想要的)。如果你查看你的解决方案浏览器，你会发现你的`App_Themes`文件夹中有一个名为`BasicGreen`的子文件夹，包含你的新`BasicGreen.skin`文件。

在一个`*.skin`文件中，您可以使用 Web 表单控件声明语法定义各种小部件的外观。遗憾的是，IDE 没有为`*.skin`文件提供设计器支持。减少输入时间的一种方法是将一个临时的`*.aspx`文件插入到您的程序中(例如`temp.aspx`，该文件可用于使用 Visual Studio 页面设计器构建小部件的 UI。

生成的标记可以复制并粘贴到您的`*.skin`文件中。但是，当您这样做时，您必须删除每个 web 控件的`ID`属性！这应该是有意义的，因为你并没有试图为某个特定的`Button`(例如)定义 UI 外观，而是为所有的`Button`定义

也就是说，下面是为`Button`、`TextBox`和`Calendar`类型定义默认外观的`BasicGreen.skin`标记:

`<asp:Button runat="server" BackColor="#80FF80"/>`

`<asp:TextBox runat="server" BackColor="#80FF80"/>`

`<asp:Calendar runat="server" BackColor="#80FF80"/>`

请注意，每个小部件仍然有`runat="server"`属性(这是必需的)，没有一个小部件被分配了`ID`属性。

现在，让我们定义名为 CrazyOrange 的第二个主题。使用解决方案浏览器，右键单击您的`App_Themes`文件夹并添加一个名为 CrazyOrange 的新主题。这将在您站点的`App_Themes`文件夹下创建一个新的子目录。

接下来，在解决方案资源管理器中右键单击新的`CrazyOrange`文件夹，并选择 Add New Item。从出现的对话框中，添加一个新的`*.skin`文件。更新`CrazyOrange.skin`文件，为相同的 web 控件定义一个独特的 UI 外观，如下所示:

`<asp:Button runat="server" BackColor="#FF8000"/>`

`<asp:TextBox runat="server" BackColor="#FF8000"/>`

`<asp:Calendar BackColor="White" BorderColor="Black"`

`BorderStyle="Solid" CellSpacing="1"`

`Font-Names="Verdana" Font-Size="9pt" ForeColor="Black" Height="250px"`

`NextPrevFormat="ShortMonth" Width="330px" runat="server">`

`<SelectedDayStyle BackColor="#333399" ForeColor="White" />`

`<OtherMonthDayStyle ForeColor="#999999" />`

`<TodayDayStyle BackColor="#999999" ForeColor="White" />`

`<DayStyle BackColor="#CCCCCC" />`

`<NextPrevStyle Font-Bold="True" Font-Size="8pt" ForeColor="White" />`

`<DayHeaderStyle Font-Bold="True" Font-Size="8pt"`

`ForeColor="#333333" Height="8pt" />`

`<TitleStyle BackColor="#333399" BorderStyle="Solid"`

`Font-Bold="True" Font-Size="12pt"`

`ForeColor="White" Height="12pt" />`

`</asp:Calendar>`

此时，您的解决方案浏览器应该如图 [32-28](#Fig28) 所示。

![A978-1-4842-1332-2_32_Fig28_HTML.jpg](img/A978-1-4842-1332-2_32_Fig28_HTML.jpg)

图 32-28。

A single web site with multiple themes

既然您的站点已经定义了一些主题，那么下一个合乎逻辑的步骤就是将它们应用到您的页面上。正如你可能猜到的，有许多方法可以做到这一点。

Note

这些示例主题在设计上相当平淡无奇(为了减少打印页面上的标记数量)。你可以随心所欲地打扮自己。

### 应用站点范围的主题

如果你想确保网站中的每个页面都遵循相同的主题，最简单的方法就是更新你的`web.config`文件。打开当前的`web.config`文件，在`<system.web>`根元素的范围内定义一个`<pages>`元素。如果您向`<pages>`元素添加一个主题属性，这将确保您的 web 站点中的每个页面都被分配了选定的主题(当然，这是`App_Theme`下的一个子目录的名称)。以下是关键更新:

`<configuration>`

`<system.web>`

`...`

`<pages controlRenderingCompatibilityVersion="4.5"`

`theme="BasicGreen">`

`</pages>`

`</system.web>`

`</configuration>`

如果运行这个页面，您会发现每个小部件都有 BasicGreen 的 UI。如果您将主题属性更新为 CrazyOrange 并再次运行该页面，您会发现使用了由该主题定义的 UI。

### 在页面级别应用主题

也可以逐页分配主题。这在各种情况下都会有所帮助。例如，也许您的`web.config`文件定义了一个站点范围的主题(如前一节所述),但是您想为一个特定的页面分配一个不同的主题。为此，您可以简单地更新`<%@Page%>`指令。如果你正在使用 Visual Studio 这样做，你会很高兴地发现，智能感知将显示你的`App_Theme`文件夹中的每个定义的主题。

`<%@ Page Language="C#" AutoEventWireup="true"`

`CodeFile="Default.aspx.cs" Inherits="_Default" Theme ="CrazyOrange" %>`

因为您为这个页面分配了 CrazyOrange 主题，但是`web.config`文件指定了 BasicGreen 主题，所以除了这个页面之外的所有页面都将使用 BasicGreen 来呈现。

### SkinID 属性

有时，您可能需要为单个小部件定义一组可能的 UI 外观场景。例如，假设您想要为 CrazyOrange 主题中的`Button`类型定义两个可能的 ui。您可以使用`*.skin`文件中控件的`SkinID`属性来区分每一种外观和感觉:

`<asp:Button runat="server" BackColor="#FF8000"/>`

`<asp:Button runat="server" SkinID = "BigFontButton"`

`Font-Size="30pt" BackColor="#FF8000"/>`

现在，如果你有一个使用 CrazyOrange 主题的页面，默认情况下，每个`Button`将被分配一个未命名的`Button`皮肤。如果您想让`*.aspx`文件中的各种按钮使用 BigFontButton 皮肤，只需在标记中指定`SkinID`属性，如下所示:

`<asp:Button ID="Button2" runat="server"`

`SkinID="BigFontButton" Text="Button" /><br />`

### 以编程方式分配主题

最后但同样重要的是，在代码中分配主题是可能的。当您希望为最终用户提供一种为他们当前会话选择主题的方式时，这可能会很有帮助。当然，我还没有向您展示如何构建有状态的 web 应用程序，所以当前的主题选择将在回发之间被遗忘。在生产级站点中，您可能希望将用户的当前主题选择存储在会话变量中，或者将主题选择保存到数据库中。

为了说明如何以编程方式分配主题，用三个新的`Button`控件更新你的`Default.aspx`文件的 UI，如图 [32-29](#Fig29) 所示。这样做之后，为每个`Button`处理`Click`事件。

![A978-1-4842-1332-2_32_Fig29_HTML.jpg](img/A978-1-4842-1332-2_32_Fig29_HTML.jpg)

图 32-29。

The updated UI of the themes example

现在，请注意，您只能在页面生命周期的特定阶段以编程方式分配主题。通常，这将在`Page_PreInit`事件中完成。也就是说，按如下方式更新您的代码文件:

`partial class _Default : System.Web.UI.Page`

`{`

`protected void btnNoTheme_Click(object sender, System.EventArgs e)`

`{`

`// Empty strings result in no theme being applied.`

`Session["UserTheme"] = "";`

`// Triggers the PreInit event again.`

`Server.Transfer(Request.FilePath);`

`}`

`protected void btnGreenTheme_Click(object sender, System.EventArgs e)`

`{`

`Session["UserTheme"] = "BasicGreen";`

`// Triggers the PreInit event again.`

`Server.Transfer(Request.FilePath);`

`}`

`protected void btnOrangeTheme_Click(object sender, System.EventArgs e)`

`{`

`Session["UserTheme"] = "CrazyOrange";`

`// Triggers the PreInit event again.`

`Server.Transfer(Request.FilePath);`

`}`

`protected void Page_PreInit(object sender, System.EventArgs e)`

`{`

`try`

`{`

`Theme = Session["UserTheme"].ToString();`

`}`

`catch`

`{`

`Theme = "";`

`}`

`}`

`}`

请注意，您将选择的主题存储在一个名为`UserTheme`的会话变量中(详见[第 33 章](33.html)，该变量在`Page_PreInit()`事件处理程序中正式赋值。还要注意，当用户单击给定的`Button`时，您通过调用`Server.Transfer()`并再次请求当前页面，以编程方式强制触发`PreInit`事件。如果你运行这个页面，你会发现你可以通过各种`Button`点击来建立你的主题。

Source Code

FunWithThemes 网站包含在 [`Chapter 32`](32.html) 子目录中。

## 摘要

本章研究了如何利用各种 web 窗体 Web 控件。您从检查`Control`和`WebControl`基类的角色开始，并且学习了如何动态地与面板的内部控件集合交互。在这个过程中，您接触到了新的站点导航模型(`*.sitemap`文件和`SiteMapDataSource`组件)、新的数据绑定引擎和各种验证控件。

本章的后半部分研究了母版页和主题的作用。回想一下，母版页可以用来为站点上的一组页面定义公共布局。还记得,`*.master`文件定义了任意数量的内容占位符，内容页面可以将它们的定制 UI 内容插入到这些占位符中。最后，正如您所看到的，Web Forms 主题引擎允许您以声明方式或编程方式将通用 UI 外观应用于 Web 服务器上的小部件。