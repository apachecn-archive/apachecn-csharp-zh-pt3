# 19.多线程、并行和异步编程

没有人喜欢使用在执行过程中反应迟钝的应用程序。此外，没有人喜欢在一个应用程序中启动一个任务(可能是通过点击一个工具栏项启动的),这个任务会阻止程序的其他部分尽可能地响应。在发布之前。NET 中，构建能够执行多个任务的应用程序通常需要编写使用 Windows 线程 API 的复杂 C++代码。谢天谢地。NET 平台为您提供了多种方式来构建软件，这些软件可以在独特的执行路径上执行复杂的操作，而棘手的问题要少得多。

本章首先定义了“多线程应用程序”的整体性质接下来，您将重新访问。NET 委托类型来研究它对异步方法调用的内在支持。正如您将看到的，这种技术允许您在执行的辅助线程上调用方法，而不需要手动创建或配置线程本身。

接下来，我们将向您介绍从那时起发布的原始线程名称空间。NET 1.0，具体是`System.Threading`。在这里，您将检查众多类型(`Thread`、`ThreadStart`等)。)允许您显式地创建额外的执行线程并同步您的共享资源，这有助于确保多个线程能够以非易失的方式共享数据。

本章的其余部分将研究三种最新的技术。NET 开发人员可以使用来构建多线程软件，特别是任务并行库(TPL)、并行 LINQ (PLINQ)和 C#新的内在异步关键字(`async`和`await`)。正如您将看到的，这些特性可以极大地简化您构建响应性多线程软件应用程序的方式。

## 进程/AppDomain/上下文/线程关系

在第 17 章中，线程被定义为可执行应用程序中的执行路径。虽然很多人。NET 应用程序可以过着快乐而高效的单线程生活，程序集的主线程(当`Main()`执行时由 CLR 产生)可以随时创建执行的辅助线程来执行额外的工作单元。通过创建额外的线程，您可以构建响应速度更快(但不一定在单核机器上执行得更快)的应用程序。

名称空间`System.Threading`是随。NET 1.0 并提供了一种构建多线程应用程序的方法。`Thread`类可能是核心类型，因为它代表一个给定的线程。如果您想以编程方式获取对当前执行给定成员的线程的引用，只需调用静态的`Thread.CurrentThread`属性，如下所示:

`static void ExtractExecutingThread()`

`{`

`// Get the thread currently`

`// executing this method.`

`Thread currThread = Thread.CurrentThread;`

`}`

在下面。NET 平台，应用程序域和线程之间没有直接的一一对应关系。事实上，一个给定的 AppDomain 在任何时候都可以有许多线程在其中执行。此外，特定的线程在其生命周期中并不局限于单个应用程序域。由于 Windows 操作系统线程调度器和。NET CLR 看适合。

尽管活动线程可以在 AppDomain 边界之间移动，但给定的线程在任何时间点都只能在单个应用程序域中执行(换句话说，单个线程不可能同时在多个 AppDomain 中工作)。当您想以编程方式访问托管当前线程的 AppDomain 时，调用静态的`Thread.GetDomain()`方法，如下所示:

`static void ExtractAppDomainHostingThread()`

`{`

`// Obtain the AppDomain hosting the current thread.`

`AppDomain ad = Thread.GetDomain();`

`}`

单个线程也可以在任何给定的时间被移动到一个特定的上下文中，并且可以在 CLR 的突发奇想中被重新定位到一个新的上下文中。当您想要获得线程正在其中执行的当前上下文时，使用静态的`Thread.CurrentContext`属性(它返回一个`System.Runtime.Remoting.Contexts.Context`对象)，如下所示:

`static void ExtractCurrentThreadContext()`

`{`

`// Obtain the context under which the`

`// current thread is operating.`

`Context ctx = Thread.CurrentContext;`

`}`

同样，CLR 是负责将线程移入(和移出)应用程序域和上下文的实体。作为一名. NET 开发人员，您通常可以幸福地不知道一个给定的线程在哪里结束(或者确切地说，它何时被放入它的新边界)。然而，您应该知道获得底层原语的各种方法。

### 并发的问题

多线程编程的众多“乐趣”(也就是痛苦的方面)之一是，您几乎无法控制底层操作系统或 CLR 如何使用它的线程。例如，如果您创建了一个新的执行线程的代码块，您不能保证该线程立即执行。相反，这些代码只指示 OS/CLR 尽快执行线程(通常是在线程调度程序开始执行时)。

此外，鉴于线程可以根据 CLR 的要求在应用程序和上下文边界之间移动，您必须注意应用程序的哪些方面是线程易变的(例如，受多线程访问的影响),哪些操作是原子的(线程易变的操作是危险的！).

为了说明这个问题，假设一个线程正在调用一个特定对象的方法。现在假设线程调度器指示该线程暂停其活动，以允许另一个线程访问同一对象的同一方法。

如果原始线程没有完全完成其操作，则第二个传入线程可能正在查看处于部分修改状态的对象。在这一点上，第二个线程基本上是在读取假数据，这肯定会让位于极其奇怪(并且难以发现)的错误，这些错误甚至更难复制和调试。

另一方面，原子操作在多线程环境中总是安全的。可悲的是，在美国几乎没有什么行动。NET 基础类库，保证是原子的。甚至给成员变量赋值的行为也不是原子的！除非。NET Framework 4.6 SDK 文档明确指出操作是原子的，您必须假设它是线程易变的，并采取预防措施。

### 线程同步的作用

在这一点上，应该清楚多线程程序本身是非常不稳定的，因为许多线程可以同时(或多或少)在共享资源上操作。为了保护应用程序的资源免受可能的损坏。NET 开发人员必须使用任意数量的线程原语(如锁、监视器和`[` `Synchronization` `]`属性或语言关键字支持)来控制执行线程之间的访问。

虽然。NET 平台并不能使构建健壮的多线程应用程序的困难完全消失，但这个过程已经大大简化了。使用在`System.Threading`名称空间、任务并行库(TPL)以及 C# `async`和`await`语言关键字中定义的类型，您能够以最少的麻烦和麻烦处理多线程。

在深入到`System.Threading`名称空间、TPL、C# `async`和`await`关键字之前，您将首先检查。NET 委托类型可用于以异步方式调用方法。虽然可以肯定的是。NET 4.6 中，新的 C# `async`和`await`关键字为异步委托提供了一种更简单的替代方法，但知道如何使用这种方法与代码交互仍然很重要(相信我；生产中有大量使用异步委托的代码)。

## 的简要回顾。网络代表

回想一下，. NET 委托本质上是一个类型安全、面向对象的函数指针。当您定义一个. NET 委托类型时，C#编译器通过构建一个从`System.MulticastDelegate`派生的密封类来响应(它又从`System.Delegate`派生)。这些基类为每个委托提供了维护方法地址列表的能力，所有这些方法地址都可以在以后调用。考虑下面的`BinaryOp`委托，首先在[第 10 章](10.html)中定义:

`// A C# delegate type.`

`public delegate int BinaryOp(int x, int y);`

根据其定义，`BinaryOp`可以指向任何以两个整数(按值)作为参数并返回一个整数的方法。编译后，定义程序集现在包含一个完整的类定义，它是在您生成项目时根据委托声明动态生成的。在`BinaryOp`的情况下，这个类看起来或多或少像下面这样(用伪代码显示):

`public sealed class``BinaryOp`T2】

`{`

`public``BinaryOp`T2】

`public``int``Invoke(``int x, int y`T4】

`public IAsyncResult BeginInvoke(` `int x, int y,`

`AsyncCallback cb, object state);`

`public int EndInvoke(IAsyncResult result);`

`}`

回想一下，生成的`Invoke()`方法用于以同步方式调用委托对象维护的方法。因此，调用线程(如应用程序的主线程)被迫等待，直到委托调用完成。还记得在 C#中，不需要在代码中直接调用`Invoke()`方法，但是当应用“普通”方法调用语法时，可以在幕后间接触发。

考虑下面的控制台应用程序(SyncDelegateReview)，它以同步(即阻塞)方式调用静态的`Add()`方法(确保将`System.Threading`名称空间导入到 C#代码文件中，因为您将调用`Thread.Sleep()`方法):

`namespace SyncDelegateReview`

`{`

`public delegate int BinaryOp(int x, int y);`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Synch Delegate Review *****");`

`// Print out the ID of the executing thread.`

`Console.WriteLine("Main() invoked on thread {0}.",`

`Thread.CurrentThread.ManagedThreadId);`

`// Invoke Add() in a synchronous manner.`

`BinaryOp b = new BinaryOp(Add);`

`// Could also write b.Invoke(10, 10);`

`int answer = b(10, 10);`

`// These lines will not execute until`

`// the Add() method has completed.`

`Console.WriteLine("Doing more work in Main()!");`

`Console.WriteLine("10 + 10 is {0}.", answer);`

`Console.ReadLine();`

`}`

`static int Add(int x, int y)`

`{`

`// Print out the ID of the executing thread.`

`Console.WriteLine("Add() invoked on thread {0}.",`

`Thread.CurrentThread.ManagedThreadId);`

`// Pause to simulate a lengthy operation.`

`Thread.Sleep(5000);`

`return x + y;`

`}`

`}`

`}`

在`Add()`方法中，您调用静态`Thread.Sleep()`方法来暂停调用线程大约五秒钟，以模拟一个冗长的任务。假设您正在以同步方式调用`Add()`方法，那么在`Add()`方法完成之前，`Main()`方法不会打印出操作的结果。

接下来，请注意，`Main()`方法获得对当前线程的访问(通过`Thread.CurrentThread`)并通过`ManagedThreadId`属性打印线程的 ID。同样的逻辑在静态`Add()`方法中重复。正如您可能会怀疑的那样，假设这个应用程序中的所有工作都是由主线程独占执行的，那么您会发现控制台上显示了相同的 ID 值。

`***** Synch Delegate Review *****`

`Main() invoked on thread 1.`

`Add() invoked on thread 1.`

`Doing more work in Main()!`

`10 + 10 is 20.`

`Press any key to continue . . .`

当您运行这个程序时，您应该注意到在您看到最后的`Console.WriteLine()`逻辑在`Main()`执行之前发生了五秒钟的延迟。尽管许多(如果不是大多数)方法可以被同步调用而不会产生不良影响。如有必要，可以指示. NET 委托异步调用它们的方法。

Source Code

SyncDelegateReview 项目位于 [`Chapter 19`](19.html) 子目录中。

## 委托的异步特性

如果您是多线程主题的新手，您可能想知道异步方法调用到底是怎么回事。毫无疑问，您完全知道，一些编程操作需要时间。尽管前面的`Add()`本质上纯粹是说明性的，但是想象一下，您构建了一个单线程应用程序，该应用程序调用远程 web 服务操作上的方法，调用一个执行长时间运行的数据库查询的方法，下载一个大文档，或者将 500 行文本写入一个外部文件。在执行这些操作时，应用程序可能会挂起一段时间。在处理完手头的任务之前，该程序的所有其他方面(如菜单激活、工具栏点击或控制台输出)都将暂停(这会激怒用户)。

因此，问题是，您如何告诉委托在一个单独的执行线程上调用一个方法来模拟“同时”执行的多个任务？好消息是。NET 委托类型自动具备这种能力。更好的消息是，这样做不需要直接深入到`System.Threading`名称空间的细节中(尽管这些实体可以很自然地协同工作)。

### BeginInvoke()和 EndInvoke()方法

当 C#编译器处理`delegate`关键字时，动态生成的类定义了两个名为`BeginInvoke()`和`EndInvoke()`的方法。给定`BinaryOp`委托的定义，这些方法的原型如下:

`public sealed class BinaryOp : System.MulticastDelegate`

`{`

`...`

`// Used to invoke a method asynchronously.`

`public IAsyncResult BeginInvoke(int x, int y,`

`AsyncCallback cb, object state);`

`// Used to fetch the return value`

`// of the invoked method.`

`public int EndInvoke(IAsyncResult result);`

`}`

传递给`BeginInvoke()`的第一组参数将基于 C#委托的格式(在`BinaryOp`中是两个整数)。最后两个参数总是`System.AsyncCallback`和`System.Object`。您将很快检查这些参数的作用；不过，目前我会为每个版本提供`null`。还要注意的是，`EndInvoke()`的返回值是一个整数，基于`BinaryOp`的返回类型，而这个方法的单个参数总是类型为`IAsyncResult`。

### 系统。IAsyncResult 接口

`BeginInvoke()`方法总是返回一个实现`IAsyncResult`接口的对象，而`EndInvoke()`需要一个兼容`IAsyncResult`的类型作为它唯一的参数。从`BeginInvoke()`返回的兼容`IAsyncResult`的对象基本上是一种耦合机制，允许调用线程在以后通过`EndInvoke()`获得异步方法调用的结果。`IAsyncResult`接口(在`System`名称空间中定义)定义如下:

`public interface IAsyncResult`

`{`

`object AsyncState { get; }`

`WaitHandle AsyncWaitHandle { get; }`

`bool CompletedSynchronously { get; }`

`bool IsCompleted { get; }`

`}`

在最简单的情况下，您可以避免直接调用这些成员。您所要做的就是缓存由`BeginInvoke()`返回的兼容`IAsyncResult`的对象，并在您准备好获取方法调用的结果时将其传递给`EndInvoke()`。正如您将看到的，当您想要“更多地参与”获取方法返回值的过程时，您可以调用与`IAsyncResult`兼容的对象的成员。

Note

如果您异步调用一个提供`void`返回值的方法，您可以简单地“发射并忘记”在这种情况下，您将永远不需要缓存兼容`IAsyncResult`的对象或者首先调用`EndInvoke()`(因为没有要检索的返回值)。

## 异步调用方法

为了指示`BinaryOp`委托异步调用`Add()`，您将修改前面项目中的逻辑(随意向现有项目添加代码；但是，在您的实验下载中，您会发现一个名为 AsyncDelegate 的新控制台应用程序项目。更新之前的`Main()`方法如下:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Async Delegate Invocation *****");`

`// Print out the ID of the executing thread.`

`Console.WriteLine("Main() invoked on thread {0}.",`

`Thread.CurrentThread.ManagedThreadId);`

`// Invoke Add() on a secondary thread.`

`BinaryOp b = new BinaryOp(Add);`

`IAsyncResult iftAR = b.BeginInvoke(10, 10, null, null);`

`// Do other work on primary thread...`

`Console.WriteLine("Doing more work in Main()!");`

`// Obtain the result of the Add()`

`// method when ready.`

`int answer = b.EndInvoke(iftAR);`

`Console.WriteLine("10 + 10 is {0}.", answer);`

`Console.ReadLine();`

`}`

如果您运行这个应用程序，您会发现显示了两个唯一的线程 id，因为实际上在当前 AppDomain 中有多个线程在工作:

`***** Async Delegate Invocation *****`

`Main() invoked on thread 1.`

`Doing more work in Main()!`

`Add() invoked on thread 3.`

`10 + 10 is 20.`

除了唯一的 ID 值之外，您还会注意到，在运行应用程序时，会立即显示`Doing more work in Main()!`消息，而辅助线程则忙于处理自己的事务。

### 同步调用线程

如果您仔细考虑一下当前的`Main()`实现，您可能会意识到调用`BeginInvoke()`和`EndInvoke()`之间的时间间隔明显小于 5 秒。因此，一旦`Doing more work in Main()!`打印到控制台，调用线程现在被阻塞，并在能够获得`Add()`方法的结果之前等待辅助线程完成。因此，您实际上是在进行另一个同步调用。

`static void Main(string[] args)`

`{`

`...`

`BinaryOp b = new BinaryOp(Add);`

`// Once the next statement is processed,`

`// the calling thread is now blocked until`

`// BeginInvoke() completes.`

`IAsyncResult iftAR = b.BeginInvoke(10, 10, null, null);`

`// This call takes far less than five seconds!`

`Console.WriteLine("Doing more work in Main()!");`

`// Now we are waiting again for other thread to complete!`

`int answer = b.EndInvoke(iftAR);`

`...`

`}`

显然，如果调用线程有可能在各种情况下被阻塞，异步委托将失去吸引力。为了允许调用线程发现异步调用的方法是否已经完成了它的工作，`IAsyncResult`接口提供了`IsCompleted`属性。使用这个成员，调用线程能够在调用`EndInvoke()`之前确定异步调用是否确实已经完成。

如果方法没有完成，`IsCompleted`返回`false`，调用线程可以自由地继续工作。如果`IsCompleted`返回`true`，调用线程就能够以“最少阻塞的方式”获得结果。思考下面对`Main()`方法的更新:

`static void Main(string[] args)`

`{`

`...`

`BinaryOp b = new BinaryOp(Add);`

`IAsyncResult iftAR = b.BeginInvoke(10, 10, null, null);`

`// This message will keep printing until`

`// the Add() method is finished.`

`while(!iftAR.IsCompleted)`

`{`

`Console.WriteLine("Doing more work in Main()!");`

`Thread.Sleep(1000);`

`}`

`// Now we know the Add() method is complete.`

`int answer = b.EndInvoke(iftAR);`

`...`

`}`

这里，您进入一个循环，该循环将继续处理`Console.WriteLine()`语句，直到辅助线程完成。在这发生之后，您可以获得`Add()`方法的结果，完全知道该方法确实已经完成。对于这个特定的应用程序来说，调用`Thread.Sleep(1000)`并不是正确运行所必需的；但是，通过强制主线程在每次迭代中等待大约一秒钟，可以防止同一条消息打印数百次。下面是输出(根据机器的速度和线程激活的时间，您的输出可能略有不同):

`***** Async Delegate Invocation *****`

`Main() invoked on thread 1.`

`Doing more work in Main()!`

`Add() invoked on thread 3.`

`Doing more work in Main()!`

`Doing more work in Main()!`

`Doing more work in Main()!`

`Doing more work in Main()!`

`Doing more work in Main()!`

`10 + 10 is 20.`

除了`IsCompleted`属性之外，`IAsyncResult`接口还提供了`AsyncWaitHandle`属性，用于更灵活的等待逻辑。该属性返回一个`WaitHandle`类型的实例，该实例公开了一个名为`WaitOne()`的方法。`WaitHandle.WaitOne()`的好处是可以指定最大等待时间。如果超过了指定的时间量，`WaitOne()`返回`false`。思考下面更新的`while`循环，它不再使用对`Thread.Sleep()`的调用:

`while (!iftAR.AsyncWaitHandle.WaitOne(1000, true))`

`{`

`Console.WriteLine("Doing more work in Main()!");`

`}`

虽然`IAsyncResult`的这些属性确实提供了一种同步调用线程的方法，但它们并不是最有效的方法。在许多方面，`IsCompleted`属性很像一个非常烦人的经理(或同学)，他不停地问:“你做完了吗？”幸运的是，委托提供了许多额外的(也更优雅的)技术来获得异步调用的方法的结果。

Source Code

AsyncDelegate 项目位于 [`Chapter 19`](19.html) 子目录中。

### AsyncCallback 委托的角色

与其轮询委托来确定异步调用的方法是否已完成，不如让辅助线程在任务完成时通知调用线程，这样会更有效。当您想要启用这个行为时，您将需要提供一个`System.` `AsyncCallback`委托的实例作为`BeginInvoke()`的参数，到目前为止它一直是`null`。然而，当你提供一个`AsyncCallback`对象时，当异步调用完成时，委托将自动调用指定的方法。

Note

回调方法将在辅助线程上调用，而不是在主线程上调用。当在图形用户界面(WPF 或 Windows 窗体)中使用线程时，这具有重要的意义，因为控件具有线程相关性，这意味着它们只能由创建它们的线程来操作。在本章的后面，在检查任务并行库(TPL)和 C# `async`和`await`关键字的过程中，您将看到一些从 GUI 处理线程的例子。

像任何委托一样，`AsyncCallback`可以调用仅匹配特定模式的方法，在本例中，该方法将`IAsyncResult`作为唯一参数，不返回任何内容。

`// Targets of AsyncCallback must match the following pattern.`

`void MyAsyncCallbackMethod(IAsyncResult itfAR)`

假设您有另一个控制台应用程序项目(AsyncCallbackDelegate)使用了`BinaryOp`委托。然而，这一次，您将不会轮询委托来确定`Add()`方法是否已经完成。相反，您将定义一个名为`AddComplete()`的静态方法来接收异步调用完成的通知。同样，这个例子使用了一个类级别的静态`bool`字段，它将用于保持`Main()`中的主线程运行一个任务，直到辅助线程完成。

Note

严格地说，在这个例子中使用这个布尔变量不是线程安全的，因为有两个不同的线程可以访问它的值。这对于当前的例子是允许的；然而，作为一个很好的经验法则，您必须确保可以在多个线程之间共享的数据被锁定。在本章的后面你会看到如何去做。

`namespace AsyncCallbackDelegate`

`{`

`public delegate int BinaryOp(int x, int y);`

`class Program`

`{`

`private static bool isDone = false;`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** AsyncCallbackDelegate Example *****");`

`Console.WriteLine("Main() invoked on thread {0}.",`

`Thread.CurrentThread.ManagedThreadId);`

`BinaryOp b = new BinaryOp(Add);`

`IAsyncResult iftAR = b.BeginInvoke(10, 10,`

`new AsyncCallback(AddComplete), null);`

`// Assume other work is performed here...`

`while (!isDone)`

`{`

`Thread.Sleep(1000);`

`Console.WriteLine("Working....");`

`}`

`Console.ReadLine();`

`}`

`static int Add(int x, int y)`

`{`

`Console.WriteLine("Add() invoked on thread {0}.",`

`Thread.CurrentThread.ManagedThreadId);`

`Thread.Sleep(5000);`

`return x + y;`

`}`

`static void AddComplete(IAsyncResult itfAR)`

`{`

`Console.WriteLine("AddComplete() invoked on thread {0}.",`

`Thread.CurrentThread.ManagedThreadId);`

`Console.WriteLine("Your addition is complete");`

`isDone = true;`

`}`

`}`

`}`

同样，当`Add()`方法完成时，静态的`AddComplete()`方法将被`AsyncCallback`委托调用。如果您运行这个程序，您可以确认辅助线程是调用`AddComplete()`回调的线程。

`***** AsyncCallbackDelegate Example *****`

`Main() invoked on thread 1.`

`Add() invoked on thread 3.`

`Working....`

`Working....`

`Working....`

`Working....`

`Working....`

`AddComplete() invoked on thread 3.`

`Your addition is complete`

与本章中的其他示例一样，您的输出可能会略有不同。事实上，你可能会看到最后一个“工作中……”添加完成后打印输出。这只是`Main()`中强制延迟一秒的副产品。

### iasyncresult 类的角色

目前，`AddComplete()`方法没有打印操作的实际结果(两个数相加)。原因是`AsyncCallback`委托的目标(在这个例子中是`AddComplete()`)不能访问在`Main()`范围内创建的原始`BinaryOp`委托，因此，您不能从`AddComplete()`内部调用`EndInvoke()`！

虽然您可以简单地将`BinaryOp`变量声明为类中的静态成员变量，以允许两种方法访问同一个对象，但更好的解决方案是使用传入的`IAsyncResult`参数。

传入到`AsyncCallback`委托的目标中的传入的`IAsyncResult`参数实际上是在`System.Runtime.Remoting.Messaging`名称空间中定义的`AsyncResult`类的一个实例(注意没有前缀`I`)。属性返回对在别处创建的原始异步委托的引用。

因此，如果您想获得对在`Main()`内分配的`BinaryOp`委托对象的引用，只需将`AsyncDelegate`属性返回的`System.Object`转换为类型`BinaryOp`。此时，就可以按预期触发`EndInvoke()`了。

`// Don’t forget to import`

`// System.Runtime.Remoting.Messaging!`

`static void AddComplete(IAsyncResult itfAR)`

`{`

`Console.WriteLine("AddComplete() invoked on thread {0}.",`

`Thread.CurrentThread.ManagedThreadId);`

`Console.WriteLine("Your addition is complete");`

`// Now get the result.`

`AsyncResult ar = (AsyncResult)itfAR;`

`BinaryOp b = (BinaryOp)ar.AsyncDelegate;`

`Console.WriteLine("10 + 10 is {0}.", b.EndInvoke(itfAR));`

`isDone = true;`

`}`

### 传递和接收自定义状态数据

异步委托需要解决的最后一个方面是`BeginInvoke()`方法的最后一个参数(到目前为止是`null`)。此参数允许您将附加状态信息从主线程传递给回调方法。因为这个参数的原型是一个`System.Object`，所以您可以传入任何类型的数据，只要回调方法知道会发生什么。为了便于演示，假设主线程想要向`AddComplete()`方法传递一个定制的文本消息，如下所示:

`static void Main(string[] args)`

`{`

`...`

`IAsyncResult iftAR = b.BeginInvoke(10, 10,`

`new AsyncCallback(AddComplete),`

`"Main() thanks you for adding these numbers.");`

`...`

`}`

为了在`AddComplete()`的范围内获得这个数据，使用传入的`IAsyncResult`参数的`AsyncState`属性。请注意，将需要显式强制转换；因此，主线程和次线程必须在从`AsyncState`返回的底层类型上达成一致。

`static void AddComplete(IAsyncResult itfAR)`

`{`

`...`

`// Retrieve the informational object and cast it to string.`

`string msg = (string)itfAR.AsyncState;`

`Console.WriteLine(msg);`

`isDone = true;`

`}`

下面是最终迭代的输出:

`***** AsyncCallbackDelegate Example *****`

`Main() invoked on thread 1.`

`Add() invoked on thread 3.`

`Working....`

`Working....`

`Working....`

`Working....`

`Working....`

`AddComplete() invoked on thread 3.`

`Your addition is complete`

`10 + 10 is 20.`

`Main() thanks you for adding these numbers.`

既然您已经了解了如何使用. NET 委托来自动分离执行的辅助线程以处理异步方法调用，那么您可以将注意力转向使用`System.Threading`名称空间直接与线程交互。回想一下，这个名称空间是原始的。从 1.0 版开始提供的. NET 线程 API。

Source Code

AsyncCallbackDelegate 项目位于 [`Chapter 19`](19.html) 子目录中。

## 系统。线程命名空间

在下面。NET 平台中，`System.Threading`命名空间提供了许多类型，支持多线程应用程序的直接构造。除了提供允许您与特定 CLR 线程交互的类型之外，该命名空间还定义了允许访问 CLR 维护的线程池的类型、一个简单的(非基于 GUI 的)`Timer`类，以及许多用于提供对共享资源的同步访问的类型。表 [19-1](#Tab1) 列出了这个名称空间的一些重要成员。(请务必查阅。NET Framework 4.6 SDK 文档以了解完整的详细信息。)

表 19-1。

Core Types of the System.Threading Namespace

<colgroup><col> <col></colgroup> 
| 类型 | 生命的意义 |
| --- | --- |
| `Interlocked` | 这种类型为由多个线程共享的变量提供原子操作。 |
| `Monitor` | 这种类型使用锁和等待/信号来提供线程对象的同步。C# `lock`关键字使用了一个`Monitor`对象。 |
| `Mutex` | 这个同步原语可用于应用程序域边界之间的同步。 |
| `ParameterizedThreadStart` | 此委托允许线程调用接受任意数量参数的方法。 |
| `Semaphore` | 这种类型允许您限制可以同时访问资源或特定类型资源的线程数量。 |
| `Thread` | 此类型表示在 CLR 中执行的线程。使用这种类型，您可以在原始 AppDomain 中生成额外的线程。 |
| `ThreadPool` | 此类型允许您在给定的进程中与 CLR 维护的线程池进行交互。 |
| `ThreadPriority` | 该枚举表示线程的优先级(`Highest`、`Normal`等)。). |
| `ThreadStart` | 此委托用于指定给定线程要调用的方法。与`ParameterizedThreadStart`委托不同，`ThreadStart`的目标必须总是有相同的原型。 |
| `ThreadState` | 该枚举指定了线程可能采用的有效状态(`Running`、`Aborted`等)。). |
| `Timer` | 这种类型提供了一种以指定间隔执行方法的机制。 |
| `TimerCallback` | 该委托类型与`Timer`类型一起使用。 |

## 系统。线程.线程类

在`System.Threading`名称空间的所有类型中，最原始的是`Thread`。此类表示特定 AppDomain 中给定执行路径周围的面向对象包装。此类型还定义了许多方法(静态的和实例级的)，允许您在当前 AppDomain 中创建新线程，以及挂起、停止和销毁特定线程。考虑表 [19-2](#Tab2) 中的核心静态成员列表。

表 19-2。

Key Static Members of the Thread Type

<colgroup><col> <col></colgroup> 
| 静态构件 | 生命的意义 |
| --- | --- |
| `CurrentContext` | 此只读属性返回线程当前运行的上下文。 |
| `CurrentThread` | 此只读属性返回对当前运行线程的引用。 |
| `GetDomain() GetDomainID()` | 这些方法返回对当前 AppDomain 或当前线程正在其中运行的域的 ID 的引用。 |
| `Sleep()` | 此方法将当前线程挂起一段指定的时间。 |

`Thread`类还支持几个实例级成员，其中一些如表 [19-3](#Tab3) 所示。

表 19-3。

Select Instance-Level Members of the Thread Type

<colgroup><col> <col></colgroup> 
| 实例级成员 | 生命的意义 |
| --- | --- |
| `IsAlive` | 返回一个 Boolean 值，指示该线程是否已启动(尚未终止或中止)。 |
| `IsBackground` | 获取或设置一个值，该值指示此线程是否为“后台线程”(稍后将提供更多详细信息)。 |
| `Name` | 允许您建立线程的友好文本名称。 |
| `Priority` | 获取或设置线程的优先级，可以从`ThreadPriority`枚举中为其赋值。 |
| `ThreadState` | 获取该线程的状态，可以从`ThreadState`枚举中为其赋值。 |
| `Abort()` | 指示 CLR 尽快终止线程。 |
| `Interrupt()` | 从合适的等待周期中断(例如唤醒)当前线程。 |
| `Join()` | 阻塞调用线程，直到指定的线程(调用`Join()`的线程)退出。 |
| `Resume()` | 恢复先前挂起的线程。 |
| `Start()` | 指示 CLR 尽快执行线程。 |
| `Suspend()` | 挂起线程。如果线程已经被挂起，调用`Suspend()`没有任何效果。 |

Note

中止或挂起一个活动线程通常被认为是一个坏主意。当您这样做时，线程在受到干扰或终止时有可能会“泄漏”其工作负载(尽管可能性很小)。

### 获取当前执行线程的统计信息

回想一下，可执行程序集的入口点(即`Main()`方法)运行在执行的主线程上。为了说明`Thread`类型的基本用法，假设您有一个名为 ThreadStats 的新控制台应用程序项目。如您所知，静态的`Thread.CurrentThread`属性检索一个代表当前执行线程的`Thread`对象。一旦获得了当前线程，就可以打印出各种统计数据，如下所示:

`// Be sure to import the System.Threading namespace.`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Primary Thread stats *****\n");`

`// Obtain and name the current thread.`

`Thread primaryThread = Thread.CurrentThread;`

`primaryThread.Name = "ThePrimaryThread";`

`// Show details of hosting AppDomain/Context.`

`Console.WriteLine("Name of current AppDomain: {0}",`

`Thread.GetDomain().FriendlyName);`

`Console.WriteLine("ID of current Context: {0}",`

`Thread.CurrentContext.ContextID);`

`// Print out some stats about this thread.`

`Console.WriteLine("Thread Name: {0}",`

`primaryThread.Name);`

`Console.WriteLine("Has thread started?: {0}",`

`primaryThread.IsAlive);`

`Console.WriteLine("Priority Level: {0}",`

`primaryThread.Priority);`

`Console.WriteLine("Thread State: {0}",`

`primaryThread.ThreadState);`

`Console.ReadLine();`

`}`

以下是当前输出:

`***** Primary Thread stats *****`

`Name of current AppDomain: ThreadStats.exe`

`ID of current Context: 0`

`Thread Name: ThePrimaryThread`

`Has thread started?: True`

`Priority Level: Normal`

`Thread State: Running`

### 名称属性

虽然这段代码或多或少是不言自明的，但是请注意，`Thread`类支持一个名为`Name`的属性。如果不设置这个值，`Name`将返回一个空的`string`。然而，一旦你给一个给定的`Thread`对象分配了一个友好的字符串名字，你就可以大大简化你的调试工作。如果您使用的是 Visual Studio，则可以在调试会话期间访问“线程”窗口(选择“调试➤ Windows ➤线程”)。从图 [19-1](#Fig1) 可以看出，可以快速识别出想要诊断的线程。

![A978-1-4842-1332-2_19_Fig1_HTML.jpg](A978-1-4842-1332-2_19_Fig1_HTML.jpg)

图 19-1。

Debugging a thread with Visual Studio

### 优先属性

接下来，请注意，`Thread`类型定义了一个名为`Priority`的属性。默认情况下，所有线程的优先级都是`Normal`。然而，你可以在线程生命周期的任何时候使用`ThreadPriority`属性和相关的`System.Threading.ThreadPriority`枚举来改变它，就像这样:

`public enum ThreadPriority`

`{`

`Lowest,`

`BelowNormal,`

`Normal, // Default value.`

`AboveNormal,`

`Highest`

`}`

如果你要给一个线程的优先级指定一个不同于默认值(`ThreadPriority.Normal`)的值，要知道你不能直接控制线程调度器何时在线程间切换。实际上，线程的优先级向 CLR 提供了关于线程活动重要性的提示。因此，具有值`ThreadPriority.Highest`的线程不一定保证被给予最高优先级。

同样，如果线程调度器全神贯注于给定的任务(例如，同步对象、切换线程或移动线程)，则优先级很可能会相应地改变。然而，在所有条件相同的情况下，CLR 将读取这些值，并指示线程调度器如何最好地分配时间片。具有相同线程优先级的每个线程应该获得相同的时间来执行它们的工作。

在大多数情况下，您很少(如果有的话)需要直接改变线程的优先级。理论上，可以提高一组线程的优先级，从而阻止优先级较低的线程在它们需要的级别上执行(所以要小心)。

Source Code

ThreadStats 项目位于 [`Chapter 19`](19.html) 子目录中。

## 手动创建辅助线程

当您想要以编程方式创建额外的线程来执行某个工作单元时，请在使用`System.Threading`名称空间的类型时遵循这个可预测的过程:

Create a method to be the entry point for the new thread.   Create a new `ParameterizedThreadStart` (or `ThreadStart`) delegate, passing the address of the method defined in step 1 to the constructor.   Create a `Thread` object, passing the `ParameterizedThreadStart/ThreadStart` delegate as a constructor argument.   Establish any initial thread characteristics (name, priority, etc.).   Call the `Thread.Start()` method. This starts the thread at the method referenced by the delegate created in step 2 as soon as possible.  

如步骤 2 所述，您可以使用两种不同的委托类型来“指向”辅助线程将执行的方法。委托可以指向任何不带参数且不返回任何内容的方法。当方法被设计为只在后台运行而不需要进一步交互时，此委托会很有帮助。

`ThreadStart`的明显限制是您不能传入参数进行处理。然而，`ParameterizedThreadStart`委托类型允许类型为`System.Object`的单个参数。鉴于任何东西都可以表示为一个`System.Object`，您可以通过一个定制的类或结构传入任意数量的参数。但是，请注意，`ParameterizedThreadStart`委托只能指向返回`void`的方法。

### 使用 ThreadStart 委托

为了说明构建多线程应用程序的过程(以及演示这样做的有用性)，假设您有一个控制台应用程序项目(SimpleMultiThreadApp ),该项目允许最终用户选择应用程序是使用单个主线程来执行其任务，还是使用两个单独的执行线程来分担其工作负载。

假设您已经导入了`System.Threading`名称空间，您的第一步是定义一个方法来执行(可能的)辅助线程的工作。为了将重点放在构建多线程程序的机制上，该方法将简单地在控制台窗口中打印出一系列数字，每次大约暂停两秒钟。下面是`Printer`类的完整定义:

`public class Printer`

`{`

`public void PrintNumbers()`

`{`

`// Display Thread info.`

`Console.WriteLine("-> {0} is executing PrintNumbers()",`

`Thread.CurrentThread.Name);`

`// Print out numbers.`

`Console.Write("Your numbers: ");`

`for(int i = 0; i < 10; i++)`

`{`

`Console.Write("{0}, ", i);`

`Thread.Sleep(2000);`

`}`

`Console.WriteLine();`

`}`

`}`

现在，在`Main()`中，您将首先提示用户确定是使用一个还是两个线程来执行应用程序的工作。如果用户请求单个线程，您只需在主线程中调用`PrintNumbers()`方法。但是，如果用户指定了两个线程，您将创建一个指向`PrintNumbers()`的`ThreadStart`委托，将这个委托对象传递给一个新的`Thread`对象的构造函数，并调用`Start()`来通知 CLR 这个线程已经准备好进行处理了。

首先，设置一个对`System.Windows.Forms.dll`程序集的引用(并导入`System.Windows.Forms`名称空间)并使用`MessageBox.Show()`在`Main()`中显示一条消息(运行程序后，您将会看到这样做的意义)。下面是`Main()`的完整实现:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** The Amazing Thread App *****\n");`

`Console.Write("Do you want [1] or [2] threads? ");`

`string threadCount = Console.ReadLine();`

`// Name the current thread.`

`Thread primaryThread = Thread.CurrentThread;`

`primaryThread.Name = "Primary";`

`// Display Thread info.`

`Console.WriteLine("-> {0} is executing Main()",`

`Thread.CurrentThread.Name);`

`// Make worker class.`

`Printer p = new Printer();`

`switch(threadCount)`

`{`

`case "2":`

`// Now make the thread.`

`Thread backgroundThread =`

`new Thread(new ThreadStart(p.PrintNumbers));`

`backgroundThread.Name = "Secondary";`

`backgroundThread.Start();`

`break;`

`case "1":`

`p.PrintNumbers();`

`break;`

`default:`

`Console.WriteLine("I don’t know what you want...you get 1 thread.");`

`goto case "1";`

`}`

`// Do some additional work.`

`MessageBox.Show("I’m busy!", "Work on main thread...");`

`Console.ReadLine();`

`}`

现在，如果您用单线程运行这个程序，您会发现最终的消息框不会显示消息，直到整个数字序列打印到控制台。由于在打印每个数字后，您会明显地暂停大约两秒钟，这将导致不太好的最终用户体验。但是，如果您选择两个线程，消息框会立即显示，因为有一个唯一的`Thread`对象负责将数字打印到控制台。

Source Code

SimpleMultiThreadApp 项目包含在 [`Chapter 19`](19.html) 子目录中。

### 使用 ParameterizedThreadStart 委托

回想一下，`ThreadStart`委托只能指向返回`void`且不带参数的方法。虽然在某些情况下这可能符合要求，但是如果您想将数据传递给在辅助线程上执行的方法，您将需要使用`ParameterizedThreadStart`委托类型。为了说明，让我们重新创建本章前面创建的 AsyncCallbackDelegate 项目的逻辑，这次使用的是`ParameterizedThreadStart`委托类型。

首先，创建一个名为 AddWithThreads 的新控制台应用程序项目，并导入`System.Threading`名称空间。现在，假设`ParameterizedThreadStart`可以指向任何带`System.Object`参数的方法，您将创建一个包含要添加的数字的自定义类型，如下所示:

`class AddParams`

`{`

`public int a, b;`

`public AddParams(int numb1, int numb2)`

`{`

`a = numb1;`

`b = numb2;`

`}`

`}`

接下来，在`Program`类中创建一个静态方法，该方法将接受一个`AddParams`参数并打印所涉及的两个数字的总和，如下所示:

`static void Add(object data)`

`{`

`if (data is AddParams)`

`{`

`Console.WriteLine("ID of thread in Add(): {0}",`

`Thread.CurrentThread.ManagedThreadId);`

`AddParams ap = (AddParams)data;`

`Console.WriteLine("{0} + {1} is {2}",`

`ap.a, ap.b, ap.a + ap.b);`

`}`

`}`

`Main()`中的代码很简单。简单地使用`ParameterizedThreadStart`而不是`ThreadStart`，就像这样:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Adding with Thread objects *****");`

`Console.WriteLine("ID of thread in Main(): {0}",`

`Thread.CurrentThread.ManagedThreadId);`

`// Make an AddParams object to pass to the secondary thread.`

`AddParams ap = new AddParams(10, 10);`

`Thread t = new Thread(new ParameterizedThreadStart(Add));`

`t.Start(ap);`

`// Force a wait to let other thread finish.`

`Thread.Sleep(5);`

`Console.ReadLine();`

`}`

### AutoResetEvent 类

在前面的几个例子中，您使用了一些简单的方法来通知主线程等待，直到辅助线程完成。在检查异步委托的过程中，您使用了一个简单的`bool`变量作为开关；但是，这不是推荐的解决方案，因为两个线程可以访问相同的数据点，这可能导致数据损坏。一种更安全但仍不可取的替代方法是在固定时间内调用`Thread.Sleep()`。这里的问题是你不想等待不必要的时间。

一种简单且线程安全的强制线程等待另一个线程完成的方法是使用`AutoResetEvent`类。在需要等待的线程中(比如一个`Main()`方法)，创建这个类的一个实例，并将`false`传递给构造函数，以表示您还没有得到通知。然后，在你愿意等待的点上，调用`WaitOne()`方法。下面是对`Program`类的更新，它将使用静态级别的`AutoResetEvent`成员变量来做这件事:

`class Program`

`{`

`private static AutoResetEvent waitHandle = new AutoResetEvent(false);`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Adding with Thread objects *****");`

`Console.WriteLine("ID of thread in Main(): {0}",`

`Thread.CurrentThread.ManagedThreadId);`

`AddParams ap = new AddParams(10, 10);`

`Thread t = new Thread(new ParameterizedThreadStart(Add));`

`t.Start(ap);`

`// Wait here until you are notified!`

`waitHandle.WaitOne();`

`Console.WriteLine("Other thread is done!");`

`Console.ReadLine();`

`}`

`...`

`}`

当另一个线程完成其工作负载时，它将在同一个`AutoResetEvent`类型的实例上调用`Set()`方法。

`static void Add(object data)`

`{`

`if (data is AddParams)`

`{`

`Console.WriteLine("ID of thread in Add(): {0}",`

`Thread.CurrentThread.ManagedThreadId);`

`AddParams ap = (AddParams)data;`

`Console.WriteLine("{0} + {1} is {2}",`

`ap.a, ap.b, ap.a + ap.b);`

`// Tell other thread we are done.`

`waitHandle.Set();`

`}`

`}`

Source Code

AddWithThreads 项目包含在 [`Chapter 19`](19.html) 子目录中。

### 前台线程和后台线程

既然您已经看到了如何使用`System.Threading`名称空间以编程方式创建新的执行线程，那么让我们正式区分前台线程和后台线程。

*   前台线程有能力阻止当前应用程序终止。在所有前台线程结束之前，CLR 不会关闭应用程序(也就是说，卸载宿主 AppDomain)。
*   后台线程(有时称为守护线程)被 CLR 视为可消耗的执行路径，可以在任何时间点忽略(即使它们当前正在处理某个工作单元)。因此，如果所有前台线程都已终止，当应用程序域卸载时，任何和所有后台线程都会自动终止。

值得注意的是，前台和后台线程与主线程和工作线程不是同义词。默认情况下，通过`Thread.Start()`方法创建的每个线程都自动成为前台线程。同样，这意味着 AppDomain 不会卸载，直到所有执行线程都完成了它们的工作单元。在大多数情况下，这正是您需要的行为。

然而，为了便于讨论，假设您想要在一个应该作为后台线程的辅助线程上调用`Printer.PrintNumbers()`。同样，这意味着由`Thread`类型(通过`ThreadStart`或`ParameterizedThreadStart`委托)指向的方法应该能够在所有前台线程完成它们的工作后安全地暂停。配置这样一个线程就像将`IsBackground`属性设置为`true`一样简单，就像这样:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Background Threads *****\n");`

`Printer p = new Printer();`

`Thread bgroundThread =`

`new Thread(new ThreadStart(p.PrintNumbers));`

`// This is now a background thread.`

`bgroundThread.IsBackground = true;`

`bgroundThread.Start();`

`}`

请注意，这个`Main()`方法并没有调用`Console.ReadLine()`来强制控制台保持可见，直到您按下 Enter 键。因此，当您运行应用程序时，它会立即关闭，因为`Thread`对象已经被配置为后台线程。鉴于`Main()`方法触发了主前台线程的创建，一旦`Main()`中的逻辑完成，AppDomain 就会在次线程能够完成其工作之前卸载。

但是，如果您注释掉设置`IsBackground`属性的行，您会发现每个数字都会打印到控制台，因为所有前台线程都必须在 AppDomain 从宿主进程中卸载之前完成它们的工作。

在很大程度上，当相关的工作线程正在执行程序的主任务完成后不再需要的非关键任务时，配置线程作为后台类型运行会很有帮助。例如，您可以构建一个应用程序，每隔几分钟就向电子邮件服务器发送一次新邮件，更新当前的天气状况，或者执行一些其他非关键任务。

## 并发性的问题

当您构建多线程应用程序时，您的程序需要确保任何共享数据都受到保护，以防大量线程更改其值。假设 AppDomain 中的所有线程都可以并发访问应用程序的共享数据，想象一下如果多个线程访问同一点数据会发生什么。由于线程调度器会强制线程随机暂停它们的工作，如果线程 A 在完全完成工作之前就被踢出去了呢？线程 B 现在正在读取不稳定的数据。

为了说明并发性问题，让我们构建另一个名为 MultiThreadedPrinting 的控制台应用程序项目。这个应用程序将再次使用之前创建的`Printer`类，但是这次`PrintNumbers()`方法将强制当前线程暂停一段随机生成的时间。

`public class Printer`

`{`

`public void PrintNumbers()`

`{`

`...`

`for (int i = 0; i < 10; i++)`

`{`

`// Put thread to sleep for a random amount of time.`

`Random r = new Random();`

`Thread.Sleep(1000 * r.Next(5));`

`Console.Write("{0}, ", i);`

`}`

`Console.WriteLine();`

`}`

`}`

`Main()`方法负责创建一个由十个(唯一命名的)`Thread`对象组成的数组，每个对象都调用`Printer`对象的同一个实例，如下所示:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("*****Synchronizing Threads *****\n");`

`Printer p = new Printer();`

`// Make 10 threads that are all pointing to the same`

`// method on the same object.`

`Thread[] threads = new Thread[10];`

`for (int i = 0; i < 10; i++)`

`{`

`threads[i] =`

`new Thread(new ThreadStart(p.PrintNumbers));`

`threads[i].Name = string.Format("Worker thread #{0}", i);`

`}`

`// Now start each one.`

`foreach (Thread t in threads)`

`t.Start();`

`Console.ReadLine();`

`}`

`}`

在查看一些测试运行之前，让我们回顾一下这个问题。这个 AppDomain 中的主线程通过产生十个辅助工作线程而开始存在。每个工作线程被告知在同一个`Printer`实例上调用`PrintNumbers()`方法。假设您没有采取任何预防措施来锁定该对象的共享资源(控制台)，那么在`PrintNumbers()`方法能够打印完整的结果之前，当前线程很有可能会被踢出去。因为你不知道这种情况何时(或是否)会发生，所以你一定会得到不可预知的结果。例如，您可能会发现如下所示的输出:

`*****``Synchronizing Threads`T2】

`-> Worker thread #1 is executing PrintNumbers()`

`Your numbers: -> Worker thread #0 is executing PrintNumbers()`

`-> Worker thread #2 is executing PrintNumbers()`

`Your numbers: -> Worker thread #3 is executing PrintNumbers()`

`Your numbers: -> Worker thread #4 is executing PrintNumbers()`

`Your numbers: -> Worker thread #6 is executing PrintNumbers()`

`Your numbers: -> Worker thread #7 is executing PrintNumbers()`

`Your numbers: -> Worker thread #8 is executing PrintNumbers()`

`Your numbers: -> Worker thread #9 is executing PrintNumbers()`

`Your numbers: Your numbers: -> Worker thread #5 is executing PrintNumbers()`

`Your numbers: 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3, 2, 1, 0, 0, 4, 3,`

`4, 1, 2, 4, 5, 5, 5, 6, 6, 6, 2, 7, 7, 7, 3, 4, 0, 8, 4, 5, 1, 5, 8, 8, 9,`

`2, 6, 1, 0, 9, 1,`

`6, 2, 7, 9,`

`2, 1, 7, 8, 3, 2, 3, 3, 9,`

`8, 4, 4, 5, 9,`

`4, 3, 5, 5, 6, 3, 6, 7, 4, 7, 6, 8, 7, 4, 8, 5, 5, 6, 6, 8, 7, 7, 9,`

`8, 9,`

`8, 9,`

`9,`

`9,`

现在再运行几次应用程序。这里有另一种可能性(你的结果肯定会不同):

`*****Synchronizing Threads *****`

`-> Worker thread #0 is executing PrintNumbers()`

`-> Worker thread #1 is executing PrintNumbers()`

`-> Worker thread #2 is executing PrintNumbers()`

`Your numbers: -> Worker thread #4 is executing PrintNumbers()`

`Your numbers: -> Worker thread #5 is executing PrintNumbers()`

`Your numbers: Your numbers: -> Worker thread #6 is executing PrintNumbers()`

`Your numbers: -> Worker thread #7 is executing PrintNumbers()`

`Your numbers: Your numbers: -> Worker thread #8 is executing PrintNumbers()`

`Your numbers: -> Worker thread #9 is executing PrintNumbers()`

`Your numbers: -> Worker thread #3 is executing PrintNumbers()`

`Your numbers: 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2,`

`2, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4,`

`4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7`

`, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 9,`

`9,`

`9,`

`9,`

`9,`

`9,`

`9,`

`9,`

`9,`

`9,`

Note

如果您无法生成不可预测的输出，那么将线程数量从 10 增加到 100(例如),或者在您的程序中引入另一个对`Thread.Sleep()`的调用。最终，您会遇到并发问题。

这里显然存在一些问题。当每个线程告诉`Printer`打印数字数据时，线程调度器很高兴地在后台交换线程。结果是输出不一致。您需要的是一种以编程方式强制同步访问共享资源的方法。正如您所猜测的，`System.Threading`名称空间提供了许多以同步为中心的类型。C#编程语言还为多线程应用程序中同步共享数据的任务提供了特定的关键字。

### 使用 C# lock 关键字进行同步

第一个可以用来同步访问共享资源的技术是 C# `lock`关键字。该关键字允许您定义必须在线程间同步的语句范围。通过这样做，传入线程不能中断当前线程，从而阻止它完成工作。`lock`关键字要求您指定一个令牌(一个对象引用),线程必须获取该令牌才能进入锁范围。当您试图锁定私有实例级方法时，可以简单地传入对当前类型的引用，如下所示:

`private void SomePrivateMethod()`

`{`

`// Use the current object as the thread token.`

`lock(this)`

`{`

`// All code within this scope is thread safe.`

`}`

`}`

然而，如果您在一个公共成员中锁定一个代码区域，那么声明一个私有的`object`成员变量作为锁标记会更安全(也是一个最佳实践),如下所示:

`public class Printer`

`{`

`// Lock token.`

`private object threadLock = new object();`

`public void PrintNumbers()`

`{`

`// Use the lock token.`

`lock (threadLock)`

`{`

`...`

`}`

`}`

`}`

在任何情况下，如果您检查`PrintNumbers()`方法，您可以看到线程竞争访问的共享资源是控制台窗口。因此，如果您将所有与`Console`类型的交互限定在一个锁范围内，如下所示:

`public void PrintNumbers()`

`{`

`// Use the private object lock token.`

`lock (threadLock)`

`{`

`// Display Thread info.`

`Console.WriteLine("-> {0} is executing PrintNumbers()",`

`Thread.CurrentThread.Name);`

`// Print out numbers.`

`Console.Write("Your numbers: ");`

`for (int i = 0; i < 10; i++)`

`{`

`Random r = new Random();`

`Thread.Sleep(1000 * r.Next(5));`

`Console.Write("{0}, ", i);`

`}`

`Console.WriteLine();`

`}`

`}`

您已经有效地设计了一个方法，该方法将允许当前线程完成其任务。一旦线程进入锁范围，其他线程就无法访问锁令牌(在这种情况下，是对当前对象的引用)，直到在锁范围退出后释放锁。因此，如果线程 A 已经获得锁令牌，其他线程就不能进入使用相同锁令牌的`any scope`,直到线程 A 放弃锁令牌。

Note

如果您试图锁定静态方法中的代码，只需声明一个私有静态对象成员变量作为锁标记。

如果您现在运行应用程序，您可以看到每个线程都有足够的机会来完成它的任务。

`*****Synchronizing Threads *****`

`-> Worker thread #0 is executing PrintNumbers()`

`Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,`

`-> Worker thread #1 is executing PrintNumbers()`

`Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,`

`-> Worker thread #3 is executing PrintNumbers()`

`Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,`

`-> Worker thread #2 is executing PrintNumbers()`

`Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,`

`-> Worker thread #4 is executing PrintNumbers()`

`Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,`

`-> Worker thread #5 is executing PrintNumbers()`

`Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,`

`-> Worker thread #7 is executing PrintNumbers()`

`Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,`

`-> Worker thread #6 is executing PrintNumbers()`

`Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,`

`-> Worker thread #8 is executing PrintNumbers()`

`Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,`

`-> Worker thread #9 is executing PrintNumbers()`

`Your numbers: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,`

Source Code

MultiThreadedPrinting 项目包含在 [`Chapter 19`](19.html) 子目录中。

### 使用系统进行同步。线程。监视器类型

C# `lock`语句实际上只是使用`System.Threading.Monitor`类的简写符号。一旦被 C#编译器处理，锁的作用域实际上解析为如下内容(可以使用`ildasm.exe`来验证):

`public void PrintNumbers()`

`{`

`Monitor.Enter(threadLock);`

`try`

`{`

`// Display Thread info.`

`Console.WriteLine("-> {0} is executing PrintNumbers()",`

`Thread.CurrentThread.Name);`

`// Print out numbers.`

`Console.Write("Your numbers: ");`

`for (int i = 0; i < 10; i++)`

`{`

`Random r = new Random();`

`Thread.Sleep(1000 * r.Next(5));`

`Console.Write("{0}, ", i);`

`}`

`Console.WriteLine();`

`}`

`finally`

`{`

`Monitor.Exit(threadLock);`

`}`

`}`

首先，请注意，`Monitor.Enter()`方法是您指定为`lock`关键字参数的线程令牌的最终接收者。接下来，锁范围内的所有代码都被包装在一个`try`块中。相应的`finally`子句确保线程令牌被释放(通过`Monitor.Exit()`方法)，不管任何可能的运行时异常。如果您要修改多线程打印程序以直接使用`Monitor`类型(如上所示)，您会发现输出是相同的。

现在，鉴于`lock`关键字似乎比显式使用`System.Threading.Monitor`类型需要更少的代码，您可能想知道直接使用`Monitor`类型的好处。简单的答案是控制。如果您使用`Monitor`类型，您可以指示活动线程等待一段时间(通过静态`Monitor.Wait()`方法)，当当前线程完成时通知等待线程(通过静态`Monitor.Pulse()`和`Monitor.PulseAll()`方法)，等等。

如您所料，在大多数情况下，C# `lock`关键字将符合要求。但是，如果您对检查`Monitor`类的其他成员感兴趣，请参考。NET Framework 4.6 SDK 文档。

### 使用系统进行同步。螺纹.互锁型

尽管直到你看了底层的 CIL 代码才相信，赋值和简单的算术运算不是原子的。出于这个原因，`System.Threading`名称空间提供了一种类型，允许您以比`Monitor`类型更少的开销原子地操作单点数据。`Interlocked`类定义了下面的关键静态成员，如表 [19-4](#Tab4) 所示。

表 19-4。

Select Static Members of the System.Threading.Interlocked Type

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `CompareExchange()` | 安全地测试两个值是否相等，如果相等，将其中一个值与第三个值交换 |
| `Decrement()` | 安全地将值递减 1 |
| `Exchange()` | 安全地交换两个值 |
| `Increment()` | 安全地将值递增 1 |

虽然从一开始看起来不像，但是在多线程环境中原子地改变单个值的过程是很常见的。假设您有一个名为`AddOne()`的方法，它递增一个名为`intVal`的整数成员变量。而不是编写如下的同步代码:

`public void AddOne()`

`{`

`lock(myLockToken)`

`{`

`intVal++;`

`}`

`}`

你可以通过静态的`Interlocked.Increment()`方法来简化你的代码。只需通过引用传递要递增的变量。请注意，`Increment()`方法不仅调整传入参数的值，还返回新值。

`public void AddOne()`

`{`

`int newVal = Interlocked.Increment(ref intVal);`

`}`

除了`Increment()`和`Decrement()`之外，`Interlocked`类型允许你原子地分配数字和对象数据。例如，如果您想将成员变量的值赋给值`83`，您可以避免使用显式的`lock`语句(或显式的`Monitor`逻辑),而使用`Interlocked.Exchange()`方法，如下所示:

`public void SafeAssignment()`

`{`

`Interlocked.Exchange(ref myInt, 83);`

`}`

最后，如果您想测试两个值是否相等，并以线程安全的方式改变比较点，您可以利用下面的`Interlocked.CompareExchange()`方法:

`public void CompareAndExchange()`

`{`

`// If the value of i is currently 83, change i to 99.`

`Interlocked.CompareExchange(ref i, 99, 83);`

`}`

### 使用[Synchronization]属性进行同步

这里检查的最后一个同步原语是`[Synchronization]`属性，它是`System.Runtime.Remoting.Contexts`名称空间的成员。本质上，为了线程安全，这个类级属性有效地锁定了对象的所有实例成员代码。当 CLR 分配带有`[Synchronization]`属性的对象时，它会将对象放在一个同步的上下文中。你可能还记得第 17 章中的[，不应该从上下文边界中移除的对象应该从`ContextBoundObject`中派生出来。因此，如果您想使`Printer`类类型线程安全(不在类成员中显式编写线程安全代码)，您可以如下更新定义:](17.html)

`using System.Runtime.Remoting.Contexts;`

`...`

`// All methods of Printer are now thread safe!`

`[Synchronization]`

`public class Printer : ContextBoundObject`

`{`

`public void PrintNumbers()`

`{`

`...`

`}`

`}`

在某些方面，这种方法可以被视为编写线程安全代码的懒惰方式，因为您不需要深入了解类型的哪些方面真正在操作线程敏感的数据。然而，这种方法的主要缺点是，即使给定的方法没有使用线程敏感的数据，CLR 仍然会锁定对该方法的调用。显然，这可能会降低该类型的整体功能，所以要小心使用这种技术。

## 用定时器回调编程

许多应用程序需要在固定的时间间隔内调用特定的方法。例如，您可能有一个应用程序需要通过给定的助手函数在状态栏上显示当前时间。作为另一个例子，您可能希望让您的应用程序偶尔调用一个 helper 函数来执行非关键的后台任务，例如检查新的电子邮件。对于这样的情况，您可以将`System.Threading.Timer`类型与名为`TimerCallback`的相关委托结合使用。

举例来说，假设您有一个控制台应用程序项目(TimerApp ),它将每秒打印一次当前时间，直到用户按下一个键来终止应用程序。第一个明显的步骤是编写将由`Timer`类型调用的方法(确保将`System.Threading`导入到您的代码文件中)。

`class Program`

`{`

`static void PrintTime(object state)`

`{`

`Console.WriteLine("Time is: {0}",`

`DateTime.Now.ToLongTimeString());`

`}`

`static void Main(string[] args)`

`{`

`}`

`}`

注意，`PrintTime()`方法有一个类型为`System.Object`的单一参数，并返回`void`。这不是可选的，因为`TimerCallback`委托只能调用匹配这个签名的方法。传递到您的`TimerCallback`委托的目标中的值可以是任何类型的对象(在电子邮件示例中，该参数可能表示在该过程中要与之交互的 Microsoft Exchange server 的名称)。还要注意，假设这个参数确实是一个`System.Object`，那么您可以使用一个`System.Array`或者定制的类/结构来传递多个参数。

下一步是配置一个`TimerCallback`委托的实例，并将其传递给`Timer`对象。除了配置一个`TimerCallback`委托之外，`Timer`构造函数还允许您指定传递给委托目标的可选参数信息(定义为一个`System.Object`)、轮询方法的时间间隔以及在进行第一次调用之前等待的时间(以毫秒为单位)。这里有一个例子:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Working with Timer type *****\n");`

`// Create the delegate for the Timer type.`

`TimerCallback timeCB = new TimerCallback(PrintTime);`

`// Establish timer settings.`

`Timer t = new Timer(`

`timeCB,     // The TimerCallback delegate object.`

`null,       // Any info to pass into the called method (null for no info).`

`0,          // Amount of time to wait before starting (in milliseconds).`

`1000);      // Interval of time between calls (in milliseconds).`

`Console.WriteLine("Hit key to terminate...");`

`Console.ReadLine();`

`}`

在这种情况下，`PrintTime()`方法将大约每秒被调用一次，并且不会向该方法传递任何附加信息。以下是输出:

`***** Working with Timer type *****`

`Hit key to terminate...`

`Time is: 6:51:48 PM`

`Time is: 6:51:49 PM`

`Time is: 6:51:50 PM`

`Time is: 6:51:51 PM`

`Time is: 6:51:52 PM`

`Press any key to continue . . .`

如果您确实想发送一些信息供委托目标使用，只需用适当的信息替换第二个构造函数参数的`null`值，如下所示:

`// Establish timer settings.`

`Timer t = new Timer(timeCB, "Hello From Main", 0, 1000);`

然后，您可以按如下方式获取传入数据:

`static void PrintTime(object state)`

`{`

`Console.WriteLine("Time is: {0}, Param is: {1}",`

`DateTime.Now.ToLongTimeString(), state.ToString());`

`}`

Source Code

TimerApp 项目包含在 [`Chapter 19`](19.html) 子目录中。

## 了解 CLR 线程池

你将在本章研究的下一个以线程为中心的主题是 CLR 线程池的角色。当您使用委托类型(通过`BeginInvoke()`方法)异步调用一个方法时，CLR 不会真的创建一个新线程。为了提高效率，委托的`BeginInvoke()`方法利用了由运行时维护的工作线程池。为了允许您与这个等待线程池进行交互，`System.Threading`名称空间提供了`ThreadPool`类类型。

如果您想让一个方法调用在池中排队由一个工作线程处理，您可以使用`ThreadPool.QueueUserWorkItem()`方法。这个方法已经被重载，允许你为自定义状态数据指定一个可选的`System.Object`以及一个`WaitCallback`委托的实例。

`public static class ThreadPool`

`{`

`...`

`public static bool QueueUserWorkItem(WaitCallback callBack);`

`public static bool QueueUserWorkItem(WaitCallback callBack,`

`object state);`

`}`

`WaitCallback`委托可以指向任何将`System.Object`作为其唯一参数(代表可选的状态数据)并且不返回任何内容的方法。请注意，如果在调用`QueueUserWorkItem()`时没有提供`System.Object`，CLR 会自动传递一个空值。为了说明供 CLR 线程池使用的排队方法，请思考下面的程序，它再次使用了`Printer`类型。然而，在这种情况下，您不是手动创建一个`Thread`对象的数组；相反，您是在将池中的成员分配给`PrintNumbers()`方法。

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with the CLR Thread Pool *****\n");`

`Console.WriteLine("Main thread started. ThreadID = {0}",`

`Thread.CurrentThread.ManagedThreadId);`

`Printer p = new Printer();`

`WaitCallback workItem = new WaitCallback(PrintTheNumbers);`

`// Queue the method ten times.`

`for (int i = 0; i < 10; i++)`

`{`

`ThreadPool.QueueUserWorkItem(workItem, p);`

`}`

`Console.WriteLine("All tasks queued");`

`Console.ReadLine();`

`}`

`static void PrintTheNumbers(object state)`

`{`

`Printer task = (Printer)state;`

`task.PrintNumbers();`

`}`

`}`

此时，您可能想知道使用 CLR 维护的线程池是否比显式创建`Thread`对象更有利。考虑利用线程池的这些好处:

*   线程池通过最小化必须创建、启动和停止的线程数量来有效地管理线程。
*   通过使用线程池，您可以专注于您的业务问题，而不是应用程序的线程基础设施。

但是，在某些情况下，最好使用手动线程管理。这里有一个例子:

*   如果需要前台线程或者必须设置线程优先级。池化线程始终是具有默认优先级的后台线程(`ThreadPriority.Normal`)。
*   如果您需要一个具有固定标识的线程来中止它、挂起它或通过名称发现它。

Source Code

ThreadPoolApp 项目包含在 [`Chapter 19`](19.html) 子目录中。

这就完成了对`System.Threading`名称空间的研究。可以肯定的是，在创建多线程应用程序时，理解本章到目前为止介绍的主题(尤其是在您研究并发性问题的过程中)是非常有价值的。有了这个基础，现在您将把注意力转向许多新的以线程为中心的主题，这些主题仅在中可用。NET 4.0 及以上。首先，您将研究另一种线程模型(称为 TPL)的作用。

## 使用任务并行库的并行编程

在本章的这一点上，你已经研究了两种编程技术(使用异步委托和通过`System.Threading`的成员),它们允许你构建多线程软件。回想一下，这两种方法都可以在。NET 平台。

从发布。在. NET 4.0 中，微软引入了一种新的多线程应用程序开发方法，该方法使用一个称为任务并行库(TPL)的并行编程库。使用`System.Threading.Tasks`的类型，您可以构建细粒度的、可伸缩的并行代码，而不必直接使用线程或线程池。

然而，这并不是说当你使用 TPL 时，你不会使用`System.Threading`的类型。实际上，这两个线程工具包可以很自然地一起工作。尤其是因为`System.Threading`名称空间仍然提供了您之前检查过的大多数同步原语(`Monitor`、`Interlocked`等等)。也就是说，你很可能会发现你更喜欢使用 TPL 而不是原来的`System.Threading`名称空间，因为同样的任务可以用更简单的方式执行。

Note

注意，C# `async`和`await`关键字使用了`System.Threading.Tasks`名称空间的不同成员。

### 系统。线程.任务命名空间

总的来说，`System.Threading.Tasks`的类型被称为任务并行库。TPL 将使用 CLR 线程池，在可用的 CPU 之间动态地自动分配应用程序的工作负载。TPL 处理工作的划分、线程调度、状态管理和其他底层细节。最终结果是您可以最大限度地发挥。NET 应用程序，同时避免了许多直接使用线程的复杂性(见图 [19-2](#Fig2) )。

![A978-1-4842-1332-2_19_Fig2_HTML.jpg](A978-1-4842-1332-2_19_Fig2_HTML.jpg)

图 19-2。

Members of the System.Threading.Tasks namespace

### 并行类的作用

第三方物流的一个关键类别是`System.Threading.Tasks.` `Parallel`。这个类支持许多方法，这些方法允许你以并行的方式迭代一组数据(特别是一个实现了`IEnumerable<T>`的对象)。如果您要在。NET Framework 4.6 SDK 文档，你会看到这个类支持两个主要的静态方法，`Parallel.For()`和`Parallel.ForEach()`，每个方法都定义了许多重载版本。

这些方法允许您创作将以并行方式处理的代码语句体。从概念上讲，这些语句与您在普通循环结构中编写的逻辑是相同的(通过`for`或`foreach` C#关键字)。好处是`Parallel`类将代表您从线程池中挑选线程(并管理并发性)。

这两种方法都要求您指定一个兼容`IEnumerable`或`IEnumerable<T>`的容器，该容器保存您需要以并行方式处理的数据。容器可以是一个简单的数组、一个非泛型集合(比如`ArrayList`)、一个泛型集合(比如`List<T>`)或者一个 LINQ 查询的结果。

此外，您将需要使用`System.Func<T>`和`System.Action<T>`委托来指定将被调用来处理数据的目标方法。你已经在[第十二章](12.html)中遇到了`Func<T>`代表，在你调查 LINQ 地对象期间。回想一下，`Func<T>`表示一个可以有给定返回值和不同数量参数的方法。`Action<T>`委托类似于`Func<T>`，因为它允许你指向一个带一些参数的方法。但是，`Action<T>`指定了一个只能返回`void`的方法。

虽然您可以调用`Parallel.For()`和`Parallel.ForEach()`方法并传递强类型的`Func<T>`或`Action<T>`委托对象，但是您可以通过使用合适的 C#匿名方法或 lambda 表达式来简化您的编程。

### 并行类的数据并行性

使用 TPL 的第一种方法是执行数据并行。简单地说，这个术语指的是使用`Parallel.For()`或`Parallel.ForEach()`方法以并行方式迭代数组或集合的任务。假设您需要执行一些劳动密集型的文件 I/O 操作。具体来说，你需要将大量的`*.jpg`文件加载到内存中，翻转过来，将修改后的图像数据保存到新的位置。

那个。NET Framework 4.6 SDK 文档提供了这种情况的基于控制台的示例；但是，您将看到如何使用图形用户界面来执行相同的总体任务，因此您可以检查“匿名委托”的使用，以允许辅助线程更新主用户界面线程(也称为 UI 线程)。

Note

当您构建多线程图形用户界面(GUI)应用程序时，辅助线程永远不能直接访问用户界面控件。原因是控件(按钮、文本框、标签、进度条等。)与创建它们的线程有线程关联。在下面的例子中，我将说明一种允许辅助线程以线程安全的方式访问 UI 项的方法。当您检查 C# `async`和`await`关键字时，您会看到一个更简化的方法。

举例来说，创建一个名为 DataParallelismWithForEach 的 Windows 窗体应用程序，并使用解决方案资源管理器将`Form1.cs`重命名为`MainForm.cs`。完成此操作后，将以下命名空间导入您的主要代码文件中:

`// Be sure you have these namespaces!`

`using System.Threading.Tasks;`

`using System.Threading;`

`using System.IO;`

应用程序的 GUI 由多行`TextBox`和单个`Button`(名为`btnProcessImages`)组成。文本区域的目的是允许您在后台执行工作时输入数据，从而说明并行任务的非阻塞性质。这个`Button`的`Click`事件最终会使用 TPL，但是现在，编写下面的代码。

Note

您应该更新传递到下面的`Directory.GetFiles()`方法调用中的字符串，以指向您的计算机上有一些图像文件的路径(比如家庭照片的个人文件夹)。为了方便起见，我在`Solution`目录中包含了一些示例图像(Windows 操作系统附带的)。

`public partial class MainForm : Form`

`{`

`public MainForm()`

`{`

`InitializeComponent();`

`}`

`private void btnProcessImages_Click(object sender, EventArgs e)`

`{`

`ProcessFiles();`

`}`

`private void ProcessFiles()`

`{`

`// Load up all *.jpg files, and make a new folder for the modified data.`

`string[] files = Directory.GetFiles`

`(@"C:\TestPictures", "*.jpg",`

`SearchOption.AllDirectories);`

`string newDir = @"C:\ModifiedPictures";`

`Directory.CreateDirectory(newDir);`

`// Process the image data in a blocking manner.`

`foreach (string currentFile in files)`

`{`

`string filename = Path.GetFileName(currentFile);`

`using (Bitmap bitmap = new Bitmap(currentFile))`

`{`

`bitmap.RotateFlip(RotateFlipType.Rotate180FlipNone);`

`bitmap.Save(Path.Combine(newDir, filename));`

`// Print out the ID of the thread processing the current image.`

`this.Text = string.Format("Processing {0} on thread {1}", filename,`

`Thread.CurrentThread.ManagedThreadId);`

`}`

`}`

`}`

`}`

请注意，`ProcessFiles()`方法将在指定的目录下轮换每个`*.jpg`文件，该目录当前包含 37 个文件(同样，确保根据需要更新发送到`Directory.GetFiles()`的路径)。目前，所有的工作都发生在可执行文件的主线程上。因此，如果单击该按钮，程序将显示为挂起。此外，窗口的标题还将报告同一个主线程正在处理文件，因为我们只有一个执行线程。

为了在尽可能多的 CPU 上处理文件，您可以重写当前的`foreach`循环来使用`Parallel.ForEach()`。回想一下，这个方法已经被重载了无数次；然而，在最简单的形式中，您必须指定包含要处理的项目的与`IEnumerable<T>`兼容的对象(那将是`files`字符串数组)和一个指向将执行工作的方法的`Action<T>`委托。

下面是相关的更新，使用 C# lambda 操作符代替文字`Action<T>`委托对象。请注意，您当前正在注释掉显示执行当前图像文件的线程 ID 的代码行。见下一节找出原因。

`// Process the image data in a parallel manner!`

`Parallel.ForEach(files, currentFile =>`

`{`

`string filename = Path.GetFileName(currentFile);`

`using (Bitmap bitmap = new Bitmap(currentFile))`

`{`

`bitmap.RotateFlip(RotateFlipType.Rotate180FlipNone);`

`bitmap.Save(Path.Combine(newDir, filename));`

`// This code statement is now a problem! See next section.`

`// this.Text = string.Format("Processing {0} on thread {1}", filename,`

`// Thread.CurrentThread.ManagedThreadId);`

`}`

`}`

`);`

### 访问辅助线程上的 UI 元素

您会注意到，我已经注释掉了用当前执行线程的 ID 更新主窗口标题的前一行代码。如前所述，GUI 控件与创建它的线程有“线程亲缘关系”。如果辅助线程试图访问它们没有直接创建的控件，那么在调试软件时，您肯定会遇到运行时错误。另一方面，如果您要运行应用程序(通过 Ctrl+F5)，您可能永远不会发现原始代码有任何问题。

Note

让我重申之前的观点:当您调试(F5)多线程应用程序时，Visual Studio 通常能够捕捉到当辅助线程“接触”在主线程上创建的控件时出现的错误。然而，当您运行(Ctrl+F5)应用程序时，应用程序可能看起来运行正常(或者可能立即出错)。除非您采取预防措施(接下来将讨论)，否则在这种情况下，您的应用程序有可能引发运行时错误。

允许这些辅助线程以线程安全的方式访问控件的一种方法是另一种以委托为中心的技术，特别是匿名委托。Windows Forms API 的`Control`父类定义了一个名为`Invoke()`的方法，该方法将一个`System.Delegate`作为输入。当您处于涉及辅助线程的编码上下文中时，可以调用此方法，以提供线程安全的方式来更新给定控件的 UI。现在，虽然您可以直接编写所有必需的委托代码，但大多数开发人员使用匿名委托作为简单的替代方法。以下是对先前注释掉的代码语句内容的相关更新:

`using (Bitmap bitmap = new Bitmap(currentFile))`

`{`

`bitmap.RotateFlip(RotateFlipType.Rotate180FlipNone);`

`bitmap.Save(Path.Combine(newDir, filename));`

`// Eek! This will not work anymore!`

`//this.Text = string.Format("Processing {0} on thread {1}", filename,`

`//  Thread.CurrentThread.ManagedThreadId);`

`// Invoke on the Form object, to allow secondary threads to access controls`

`// in a thread-safe manner.`

`this.Invoke((Action)delegate`

`{`

`this.Text = string.Format("Processing {0} on thread {1}", filename,`

`Thread.CurrentThread.ManagedThreadId);`

`}`

`);`

`}`

Note

`this.Invoke()`方法是 Windows 窗体 API 所独有的。当您构建一个 WPF 应用程序时，您会出于同样的目的编写`this.Dispatcher.Invoke()`。

现在，如果您运行 program，TPL 将会使用尽可能多的 CPU 将工作负载分配给线程池中的多个线程。但是，您将不会看到窗口的标题显示每个唯一线程的名称，并且如果您在文本框中键入内容，直到所有图像都被处理完毕，您也不会看到任何内容！原因是主 UI 线程仍然被阻塞，等待所有其他线程完成它们的任务。

### 任务类

`Task`类允许您轻松地调用辅助线程上的方法，并且可以作为使用异步委托的简单替代方法。更新`Button`控件的`Click`处理程序，如下所示:

`private void btnProcessImages_Click(object sender, EventArgs e)`

`{`

`// Start a new "task" to process the files.`

`Task.Factory.StartNew(() =>`

`{`

`ProcessFiles();`

`});`

`}`

`Task`的`Factory`属性返回一个`TaskFactory`对象。当您调用它的`StartNew()`方法时，您传入一个`Action<T>`委托(这里，用一个合适的 lambda 表达式隐藏起来)，该委托指向要以异步方式调用的方法。通过这个小小的更新，您会发现窗口的标题将显示线程池中的哪个线程正在处理给定的文件，更好的是，文本区域能够接收输入，因为 UI 线程不再被阻塞。

### 处理取消请求

您可以对当前示例进行的一个改进是，通过第二个(恰当命名的)Cancel 按钮，为用户提供一种停止处理图像数据的方法。幸运的是，`Parallel.For()`和`Parallel.ForEach()`方法都通过使用取消令牌来支持取消。当您调用`Parallel`上的方法时，您可以传入一个`ParallelOptions`对象，该对象又包含一个`CancellationTokenSource`对象。

首先，在名为`cancelToken`的`CancellationTokenSource`类型的`Form`派生类中定义以下新的私有成员变量:

`public partial class MainForm : Form`

`{`

`// New Form-level variable.`

`private CancellationTokenSource cancelToken =`

`new CancellationTokenSource();`

`...`

`}`

现在，假设您已经在您的设计器上添加了一个新的`Button`(名为`btnCancel`)，处理`Click`事件并如下实现处理程序:

`private void btnCancel_Click(object sender, EventArgs e)`

`{`

`// This will be used to tell all the worker threads to stop!`

`cancelToken.Cancel();`

`}`

现在，真正的修改需要发生在`ProcessFiles()`方法中。考虑最终的实现:

`private void ProcessFiles()`

`{`

`// Use ParallelOptions instance to store the CancellationToken.`

`ParallelOptions parOpts = new ParallelOptions();`

`parOpts.CancellationToken = cancelToken.Token;`

`parOpts.MaxDegreeOfParallelism = System.Environment.ProcessorCount;`

`// Load up all *.jpg files, and make a new folder for the modified data.`

`string[] files = Directory.GetFiles`

`(@"C:\Users\Public\Pictures\Sample Pictures", "*.jpg",`

`SearchOption.AllDirectories);`

`string newDir = @"C:\ModifiedPictures";`

`Directory.CreateDirectory(newDir);`

`try`

`{`

`// Process the image data in a parallel manner!`

`Parallel.ForEach(files, parOpts, currentFile =>`

`{`

`parOpts.CancellationToken.ThrowIfCancellationRequested();`

`string filename = Path.GetFileName(currentFile);`

`using (Bitmap bitmap = new Bitmap(currentFile))`

`{`

`bitmap.RotateFlip(RotateFlipType.Rotate180FlipNone);`

`bitmap.Save(Path.Combine(newDir, filename));`

`this.Invoke((Action)delegate`

`{`

`this.Text = string.Format("Processing {0} on thread {1}", filename,`

`Thread.CurrentThread.ManagedThreadId);`

`}`

`);`

`}`

`}`

`);`

`this.Invoke((Action)delegate`

`{`

`this.Text = "Done!";`

`});`

`}`

`catch (OperationCanceledException ex)`

`{`

`this.Invoke((Action)delegate`

`{`

`this.Text = ex.Message;`

`});`

`}`

`}`

注意，这个方法是通过配置一个`ParallelOptions`对象开始的，设置`CancellationToken`属性来使用`CancellationTokenSource`令牌。还要注意，当您调用`Parallel.ForEach()`方法时，您将把`ParallelOptions`对象作为第二个参数传入。

在循环逻辑的范围内，您调用令牌上的`ThrowIfCancellationRequested()`,这将确保如果用户单击 Cancel 按钮，所有线程都将停止，并且您将通过运行时异常得到通知。当您捕捉到`OperationCanceledException`错误时，您将把主窗口的文本设置为错误消息。

Source Code

DataParallelismWithForEach 项目包含在 [`Chapter 19`](19.html) 子目录中。

### 使用并行类的任务并行性

除了数据并行性之外，TPL 还可以使用`Parallel.Invoke()`方法轻松地启动任意数量的异步任务。这种方法比使用来自`System.Threading`的代表或成员更简单；然而，如果您需要对任务的执行方式有更多的控制，您可以放弃使用`Parallel.Invoke()`而直接使用`Task`类，就像您在前面的例子中所做的那样。

为了说明任务并行性，创建一个名为 MyEBookReader 的新 Windows 窗体应用程序，并确保导入了`System.Threading.Tasks`和`System.Net`名称空间。这个范例是对中一个有用范例的修改。NET Framework 4.6 SDK 文档。在这里，你将从古腾堡计划( [`www.gutenberg.org`](http://www.gutenberg.org/) )获取一本公开可用的电子书，然后并行执行一系列冗长的任务。

GUI 由一个多行`TextBox`控件(名为`txtBook`)和两个`Button`控件(`btnDownload`和`btnGetStats`)组成。设计好 UI 后，为每个`Button`处理`Click`事件，并在表单的代码文件中声明一个名为`theEBook`的类级`string`变量。将`btnDownload`的`Click`手柄操作如下:

`private void btnDownload_Click(object sender, EventArgs e)`

`{`

`WebClient wc = new WebClient();`

`wc.DownloadStringCompleted += (s, eArgs) =>`

`{`

`theEBook = eArgs.Result;`

`txtBook.Text = theEBook;`

`};`

`// The Project Gutenberg EBook of A Tale of Two Cities, by Charles Dickens`

`wc.DownloadStringAsync(new Uri("`[`http://www.gutenberg.org/files/98/98-8.txt`](http://www.gutenberg.org/files/98/98-8.txt)T2】

`}`

`WebClient`类是`System.Net`的成员。该类提供了许多向 URI 标识的资源发送数据和从该资源接收数据的方法。事实证明，这些方法中有很多都有异步版本，比如`DownloadStringAsync()`。此方法将自动从 CLR 线程池中启动一个新线程。当`WebClient`完成获取数据时，它将触发`DownloadStringCompleted`事件，这里使用 C# lambda 表达式处理该事件。如果您调用这个方法的同步版本(`DownloadString()`)，表单将会在相当长的时间内没有响应。

实现了`btnGetStats Button`控件的`Click`事件处理程序，以提取包含在`theEBook`变量中的单个单词，然后将字符串数组传递给几个辅助函数进行处理，如下所示:

`private void btnGetStats_Click(object sender, EventArgs e)`

`{`

`// Get the words from the e-book.`

`string[] words = theEBook.Split(new char[]`

`{ ’ ’, ’\u000A’, ’,’, ’.’, ’;’, ’:’, ’-’, ’?’, ’/’ },`

`StringSplitOptions.RemoveEmptyEntries);`

`// Now, find the ten most common words.`

`string[] tenMostCommon = FindTenMostCommon(words);`

`// Get the longest word.`

`string longestWord = FindLongestWord(words);`

`// Now that all tasks are complete, build a string to show all`

`// stats in a message box.`

`StringBuilder bookStats = new StringBuilder("Ten Most Common Words are:\n");`

`foreach (string s in tenMostCommon)`

`{`

`bookStats.AppendLine(s);`

`}`

`bookStats.AppendFormat("Longest word is: {0}", longestWord);`

`bookStats.AppendLine();`

`MessageBox.Show(bookStats.ToString(), "Book info");`

`}`

`FindTenMostCommon()`方法使用 LINQ 查询来获得在`string`数组中最常出现的`string`对象的列表，而`FindLongestWord()`则定位最长的单词。

`private string[] FindTenMostCommon(string[] words)`

`{`

`var frequencyOrder = from word in words`

`where word.Length > 6`

`group word by word into g`

`orderby g.Count() descending`

`select g.Key;`

`string[] commonWords = (frequencyOrder.Take(10)).ToArray();`

`return commonWords;`

`}`

`private string FindLongestWord(string[] words)`

`{`

`return (from w in words orderby w.Length descending select w).FirstOrDefault();`

`}`

如果您要运行这个项目，根据您的机器的 CPU 数量和整体处理器速度，执行所有任务的时间可能会很长。最终，您应该会看到如图 [19-3](#Fig3) 所示的输出。

![A978-1-4842-1332-2_19_Fig3_HTML.jpg](A978-1-4842-1332-2_19_Fig3_HTML.jpg)

图 19-3。

Stats about the downloaded e-book

通过并行调用`FindTenMostCommon()`和`FindLongestWord()`方法，可以帮助确保您的应用程序使用主机上所有可用的 CPU。为此，将您的`btnGetStats_Click()`方法修改如下:

`private void btnGetStats_Click(object sender, EventArgs e)`

`{`

`// Get the words from the e-book.`

`string[] words = theEBook.Split(`

`new char[] { ’ ’, ’\u000A’, ’,’, ’.’, ’;’, ’:’, ’-’, ’?’, ’/’ },`

`StringSplitOptions.RemoveEmptyEntries);`

`string[] tenMostCommon = null;`

`string longestWord = string.Empty;`

`Parallel.Invoke(`

`() =>`

`{`

`// Now, find the ten most common words.`

`tenMostCommon = FindTenMostCommon(words);`

`},`

`() =>`

`{`

`// Get the longest word.`

`longestWord = FindLongestWord(words);`

`});`

`// Now that all tasks are complete, build a string to show all`

`// stats in a message box.`

`...`

`}`

`Parallel.Invoke()`方法需要一个`Action<>`委托的参数数组，这是您使用 lambda 表达式间接提供的。同样，虽然输出是相同的，但好处是 TPL 现在将使用机器上所有可能的处理器来尽可能并行地调用每个方法。

Source Code

MyEBookReader 项目包含在 [`Chapter 19`](19.html) 子目录中。

## 并行 LINQ 查询(PLINQ)

总结一下您对 TPL 的看法，要知道还有另一种方法可以将并行任务合并到您的。NET 应用程序。如果您愿意，可以使用一组扩展方法，这允许您构造一个并行执行其工作负载的 LINQ 查询(如果可能的话)。相应地，设计为并行运行的 LINQ 查询被称为 PLINQ 查询。

像使用`Parallel`类创作的并行代码一样，如果需要，PLINQ 可以选择忽略您并行处理集合的请求。PLINQ 框架已经在许多方面进行了优化，包括确定一个查询实际上是否会以同步方式执行得更快。

在运行时，PLINQ 分析查询的整体结构，如果查询可能受益于并行化，它将并发运行。但是，如果并行化查询会损害性能，PLINQ 只会按顺序运行查询。如果 PLINQ 可以在潜在昂贵的并行算法或便宜的顺序算法之间进行选择，默认情况下它会选择顺序算法。

必要的扩展方法可以在名称空间`System.Linq`的`ParallelEnumerable`类中找到。表 [19-5](#Tab5) 记录了一些有用的 PLINQ 扩展。

表 19-5。

Select Members of the ParallelEnumerable Class

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `AsParallel()` | 指定如果可能的话，应该并行处理查询的其余部分。 |
| `WithCancellation()` | 指定 PLINQ 应定期监视所提供的取消令牌的状态，并在收到请求时取消执行。 |
| `WithDegreeOfParallelism()` | 指定 PLINQ 用于并行查询的最大处理器数量。 |
| `ForAll()` | 支持并行处理结果，而无需先合并回消费者线程，这是使用`foreach`关键字枚举 LINQ 结果时的情况。 |

要查看 PLINQ 的运行情况，请创建一个名为 plinqdataprocessingwithcassignation 的最终 Windows 窗体应用程序，并导入`System.Threading`名称空间。这个简单的表单只需要两个名为`btnExecute`和`btnCancel`的`Button`控件。然后点击 Execute 按钮，您将启动一个新的`Task`，它执行一个 LINQ 查询，调查一个大的整数数组，只寻找`x % 3 == 0`为`true`的项目。以下是该查询的非平行版本:

`public partial class MainForm : Form`

`{`

`...`

`private void btnExecute_Click(object sender, EventArgs e)`

`{`

`// Start a new "task" to process the ints.`

`Task.Factory.StartNew(() =>`

`{`

`ProcessIntData();`

`});`

`}`

`private void ProcessIntData()`

`{`

`// Get a very large array of integers.`

`int[] source = Enumerable.Range(1, 10000000).ToArray();`

`// Find the numbers where num % 3 == 0 is true, returned`

`// in descending order.`

`int[] modThreeIsZero = (from num in source where num % 3 == 0`

`orderby num descending select num).ToArray();`

`MessageBox.Show(string.Format("Found {0} numbers that match query!",`

`modThreeIsZero.Count()));`

`}`

`}`

### 选择加入 PLINQ 查询

如果您想要通知 TPL 并行执行这个查询(如果可能的话)，您将想要使用`AsParallel()`扩展方法，如下所示:

`int[] modThreeIsZero = (from num in source.AsParallel() where num % 3 == 0`

`orderby num descending select num).ToArray();`

请注意，LINQ 查询的整体格式与您在前面章节中看到的完全相同。然而，通过包含对`AsParallel()`的调用，TPL 将试图把工作负载传递给一个可用的 CPU。

### 取消 PLINQ 查询

也可以使用`CancellationTokenSource`对象通知 PLINQ 查询在正确的条件下停止处理(通常是因为用户干预)。声明一个名为`cancelToken`的表单级`CancellationTokenSource`对象，并实现`btnCancel`的`Click`处理程序来调用该对象的`Cancel()`方法。以下是相关的代码更新:

`public partial class MainForm : Form`

`{`

`private CancellationTokenSource cancelToken = new CancellationTokenSource();`

`private void btnCancel_Click(object sender, EventArgs e)`

`{`

`cancelToken.Cancel();`

`}`

`...`

`}`

现在，通过链接`WithCancellation()`扩展方法并传入令牌，通知 PLINQ 查询它应该注意一个传入的取消请求。此外，您将希望将这个 PLINQ 查询包装在一个适当的`try` / `catch`范围内，并处理可能的异常。下面是`ProcessIntData()`方法的最终版本:

`private void ProcessIntData()`

`{`

`// Get a very large array of integers.`

`int[] source = Enumerable.Range(1, 10000000).ToArray();`

`// Find the numbers where num % 3 == 0 is true, returned`

`// in descending order.`

`int[] modThreeIsZero = null;`

`try`

`{`

`modThreeIsZero = (from num in`

`source.AsParallel().WithCancellation(cancelToken.Token)`

`where num % 3 == 0 orderby num descending`

`select num).ToArray();`

`MessageBox.Show(string.Format("Found {0} numbers that match query!",`

`modThreeIsZero.Count()));`

`}`

`catch (OperationCanceledException ex)`

`{`

`this.Invoke((Action)delegate`

`{`

`this.Text = ex.Message;`

`});`

`}`

`}`

Source Code

plinqdataprocessingwithseccancellation 项目位于 [`Chapter 19`](19.html) 子目录中。

## 使用 async 关键字的异步调用

在这一章(相当长)中，我已经介绍了许多简明扼要的材料。当然，构建、调试和理解复杂的多线程应用程序在任何框架中都是一个挑战。虽然 TPL、PLINQ 和 delegate 类型可以在某种程度上简化事情(特别是与其他平台和语言相比)，但开发人员仍然需要对各种高级技术的细节相当熟悉。

自从发布以来。NET 4.5 中，C#编程语言(就此而言，还有 VB 编程语言)更新了两个新的关键字，进一步简化了创作异步代码的过程。与本章中的所有例子相比，当你使用新的`async`和`await`关键字时，编译器将使用`System.Threading`和`System.Threading.Tasks`名称空间的众多成员为你生成大量线程代码。

### 首先看看 C# async 和 await 关键字

C#的关键字`async`用于限定方法、lambda 表达式或匿名方法应该以异步方式自动调用。是的，这是真的。只需用`async`修饰符标记一个方法，CLR 就会创建一个新的执行线程来处理手头的任务。此外，当您调用一个`async`方法时，`await`关键字将自动暂停当前线程的任何进一步活动，直到任务完成，让调用线程自由地继续它的快乐之路。

举例来说，创建一个名为 FunWithCSharpAsync 的新 Windows 窗体应用程序，并将名称空间`System.Threading`导入到初始窗体的主要代码文件中(我将初始窗体重命名为`MainForm`)。完成之后，在设计器界面上放置一个`Button`控件(名为`btnCallMethod`)和一个`TextBox`控件(名为`txtInput`),并配置您想要的任何基本 UI 属性(颜色、字体、文本)。现在，处理`Button`控件的`Click`事件，并在事件处理程序中调用一个名为`DoWork()`的私有 helper 方法，该方法强制调用线程等待十秒钟。到目前为止，故事是这样的:

`public partial class MainForm : Form`

`{`

`public MainForm()`

`{`

`InitializeComponent();`

`}`

`private void btnCallMethod_Click(object sender, EventArgs e)`

`{`

`this.Text = DoWork();`

`}`

`private string DoWork()`

`{`

`Thread.Sleep(10000);`

`return "Done with work!";`

`}`

`}`

现在，根据您在本章中所做的工作，您知道如果您要运行程序并单击此按钮，您需要等待 10 秒钟，然后文本框控件才能接收关键字输入。此外，你也不会在十秒钟内看到带有消息`"Done with work!"`的主窗口更新的标题。

如果你要使用本章中介绍的任何一种技术来提高程序的响应能力，你将有大量的工作要做。然而自从。NET 4.5，您可以编写以下 C#代码库:

`public partial class MainForm : Form`

`{`

`public MainForm()`

`{`

`InitializeComponent();`

`}`

`private``async`T2】

`{`

`this.Text =``await`T2】

`}`

`// See below for code walkthrough...`

`private Task<string> DoWork()`

`{`

`return Task.Run(() =>`

`{`

`Thread.Sleep(10000);`

`return "Done with work!";`

`});`

`}`

`}`

首先，注意按钮的`Click`事件句柄已经用`async`关键字标记。这将该方法标记为要以非阻塞方式调用的成员。还要注意，事件处理程序的实现在命名将被调用的方法之前使用了`await`关键字。这一点很重要:如果你用`async`关键字修饰一个方法，但是没有至少一个内部的`await`为中心的方法调用，你实际上已经构建了一个阻塞的、同步的方法调用(事实上，编译器会给出一个这方面的警告)。

现在，请注意，您需要使用来自`System.Threading.Tasks`名称空间的`Task`类来重构我们的`DoWork()`方法，以便按预期工作。基本上，不是直接返回一个特定的返回值(在当前例子中是一个`string`对象)，而是返回一个`Task<T>`对象，其中泛型类型参数`T`是底层的实际返回值(到目前为止？).

`DoWork()`的实现现在直接返回一个`Task<T>`对象，这个对象就是`Task.Run()`的返回值。`Run()`方法接受一个`Func<>`或`Action<>`委托，正如您在本文中所知，您可以通过使用 lambda 表达式来简化您的生活。基本上，你的新版本`DoWork()`本质上是说:

`When you call me, I will run a new task. This task will cause the calling thread to sleep for 10 seconds, and when it is done, it gives me a string return value. I’ll put this string in a new Task<string> object and return it to the caller.`

将`DoWork()`的这个新实现翻译成更自然(诗意)的语言后，您对`await`标记的真正作用有了一些了解。这个关键字将总是修改返回一个`Task`对象的方法。当逻辑流到达`await`标记时，调用线程被挂起，直到调用完成。如果您要运行这个版本的应用程序，您会发现您可以单击按钮，并愉快地立即在文本区域中键入内容。十秒钟后，您的窗口标题将更新为已完成的消息通知。

### 异步方法的命名约定

现在，假设`DoWork()`的新版本和目前显示的一模一样；然而，按钮的`Click`事件处理程序被实现为:

`private async void btnCallMethod_Click(object sender, EventArgs e)`

`{`

`// Oops! No await keyword here!`

`this.Text = DoWork();`

`}`

注意你确实用`async`关键字标记了方法，但是你忽略了在`DoWork()`方法调用之前使用`await`关键字作为修饰。此时，您将遇到编译器错误，因为`DoWork()`的返回值是一个`Task`对象，您试图将它直接赋给`Text`属性(它采用一个`string`数据类型)。记住，`await`标记负责提取包含在`Task`对象中的内部返回值。因为您没有使用这个标记，所以您有一个类型不匹配。

Note

一个“可适应的”方法只是一个返回`Task<T>`的方法。

鉴于返回`Task`对象的方法现在可以通过`async`和`await`标记以非阻塞的方式调用，微软建议(作为最佳实践)任何返回`Task`的方法都用`Async`后缀标记。通过这种方式，知道命名约定的开发人员会收到一个视觉提示，如果他们打算在异步上下文中调用该方法，则需要使用`await`关键字。

Note

使用`async` / `await`关键字的 GUI 控件的事件处理程序(比如你的按钮`Click`处理程序)不遵循这种命名约定(按照约定，请原谅冗余！).

此外，`DoWork()`方法也可以用`async`和`await`标记来修饰(尽管这对于当前的例子并不是严格必需的)。考虑到这几点，下面是对当前示例的最终更新，它符合推荐的命名约定:

`public partial class MainForm : Form`

`{`

`public MainForm()`

`{`

`InitializeComponent();`

`}`

`private async void btnCallMethod_Click(object sender, EventArgs e)`

`{`

`this.Text = await` `DoWorkAsync();`

`}`

`private``async``Task<string>`T3】

`{`

`return``await`T2】

`{`

`Thread.Sleep(10000);`

`return "Done with work!";`

`});`

`}`

`}`

### 异步方法返回 Void

目前，您的`DoWork()`方法正在返回一个`Task`，它包含调用者的“真实数据”，这些数据将通过`await`关键字透明地获得。但是，如果要构建一个返回 void 的异步方法呢？在这种情况下，您使用非通用的`Task`类并省略任何`return`语句，就像这样:

`private async Task MethodReturningVoidAsync()`

`{`

`await Task.Run(() => { /* Do some work here... */`

`Thread.Sleep(4000);`

`});`

`}`

这个方法的调用方，比如第二个按钮`Click`事件处理程序，将使用`await`和`async`关键字，如下所示:

`private async void btnVoidMethodCall_Click(object sender, EventArgs e)`

`{`

`await MethodReturningVoidAsync();`

`MessageBox.Show("Done!");`

`}`

### 具有多个等待的异步方法

一个异步方法在其实现中拥有多个 await 上下文是完全允许的。假设您的应用程序现在有了第三个按钮`Click`事件处理程序，它已经用`async`关键字进行了标记。在这个例子的前几部分中，`Click`处理程序特意调用了一些运行底层`Task`的外部方法；但是，您可以通过一组 lambda 表达式内联这个逻辑，如下所示:

`private async void btnMutliAwaits_Click(object sender, EventArgs e)`

`{`

`await Task.Run(() => { Thread.Sleep(2000); });`

`MessageBox.Show("Done with first task!");`

`await Task.Run(() => { Thread.Sleep(2000); });`

`MessageBox.Show("Done with second task!");`

`await Task.Run(() => { Thread.Sleep(2000); });`

`MessageBox.Show("Done with third task!");`

`}`

同样，这里的每个任务都只是暂停当前线程一段时间；然而，任何工作单元都可以由这些任务来表示(调用 web 服务、读取数据库等等)。无论如何，让我们总结一下这个例子的要点，如下:

*   方法(以及 lambda 表达式或匿名方法)可以用`async`关键字标记，以使方法能够以非阻塞方式工作。
*   标有`async`关键字的方法(以及 lambda 表达式或匿名方法)将以阻塞方式运行，直到遇到`await`关键字。
*   一个`async`方法可以有多个`await`上下文。
*   当遇到`await`表达式时，调用线程被挂起，直到等待的任务完成。同时，控制权将返回给方法的调用方。
*   关键字`await`将从视图中隐藏返回的`Task`对象，看起来像是直接返回底层返回值。没有返回值的方法只是返回 void。
*   作为命名约定，异步调用的方法应该用后缀`Async`标记。

Source Code

FunWithCSharpAsync 项目在 [`Chapter 19`](19.html) 子目录下。

### 使用 Asycn/Await 改进 AddWithThreads 示例

在本章的早些时候，您使用。NET 平台，`System.Threading`。现在，让我们改进这个例子，使用 C# `async`和`await`关键字来展示应用程序逻辑可以变得多么干净。首先，让我提醒您 AddWithThreads 项目最初是如何工作的。

*   您创建了一个名为`AddParams`的定制类，它表示要求和的数据。
*   您使用了`Thread`类和`ParameterizedThreadStart`委托来指向一个接收`AddParams`对象的`Add()`方法。
*   您使用了`AutoResetEvent`类来确保调用线程等待辅助线程完成。

总而言之，在第二个执行线程上简单地计算两个数的相加是一件非常费力的事情！这是同一个项目，现在使用测试中的技术进行了重构(我没有在这里重新打印`AddParams`类，但是回想一下，它只有两个字段`a`和`b`，用来表示要求和的数据):

`class Program`

`{`

`static void Main(string[] args)`

`{`

`AddAsync();`

`Console.ReadLine();`

`}`

`private static async Task AddAsync()`

`{`

`Console.WriteLine("***** Adding with Thread objects *****");`

`Console.WriteLine("ID of thread in Main(): {0}",`

`Thread.CurrentThread.ManagedThreadId);`

`AddParams ap = new AddParams(10, 10);`

`await Sum(ap);`

`Console.WriteLine("Other thread is done!");`

`}`

`static async Task Sum(object data)`

`{`

`await Task.Run(() =>`

`{`

`if (data is AddParams)`

`{`

`Console.WriteLine("ID of thread in Add(): {0}",`

`Thread.CurrentThread.ManagedThreadId);`

`AddParams ap = (AddParams)data;`

`Console.WriteLine("{0} + {1} is {2}",`

`ap.a, ap.b, ap.a + ap.b);`

`}`

`});`

`}`

`}`

我想指出的第一件事是，最初在`Main()`中的代码已经被移到一个名为`AddAsync()`的新方法中。原因不仅是为了符合预期的命名约定，而且这也引出了一个重要的问题。

Note

可执行文件的`Main()`方法不能用`async`关键字标记。

请注意，`AddAsync()`用`async`标记，并定义了一个 await 上下文。同样，`Sum()`方法正在派生出一个新的`Task`来执行工作单元。无论如何，你瞧，当你运行程序时，你会发现 10 加 10 仍然是 20。但是，请注意，您确实有两个唯一的线程 id。

`***** Adding with Thread objects *****`

`ID of thread in Main(): 1`

`ID of thread in Add(): 3`

`10 + 10 is 20`

`Other thread is done!`

Source Code

AddWithThreadsAsync 项目在 [`Chapter 19`](19.html) 子目录下。

因此，如您所见，`async`和`await`关键字可以简化在第二个执行线程上调用方法的过程。虽然您只通过几个例子了解了 C#语言的这一方面，但是您已经为进一步的探索做好了准备。

## 摘要

本章从研究如何开始。NET 委托类型可以配置为以异步方式执行方法。如您所见，`BeginInvoke()`和`EndInvoke()`方法允许您以最少的麻烦和麻烦间接操作一个辅助线程。在这次讨论中，还向您介绍了`IAsyncResult`接口和`AsyncResult`类类型。正如您所了解的，这些类型提供了各种方法来同步调用线程并获得可能的方法返回值。

本章的下一部分研究了`System.Threading`名称空间的作用。正如您所了解的，当应用程序创建额外的执行线程时，结果是相关的程序能够同时(看起来)执行许多任务。您还研究了几种保护线程敏感的代码块的方式，以确保共享资源不会变成不可用的伪数据单元。

然后，本章研究了一些新的模型，用于处理。NET 4.0，特别是任务并行库和 PLINQ。我总结了一下`async`和`await`关键字的作用。正如你所看到的，这些关键字在后台使用了许多类型的 TPL 框架；然而，编译器为您完成了创建复杂线程和同步代码的大部分工作。