# 29.WPF 资源、动画、样式和模板

本章向您介绍了三个重要的(且相互关联的)主题，它们将加深您对 Windows 演示基础(WPF) API 的理解。首要任务是学习逻辑资源的作用。正如您将看到的，逻辑资源(也称为对象资源)系统是一种命名和引用 WPF 应用中常用对象的方式。虽然逻辑资源通常是在 XAML 中编写的，但是它们也可以在过程代码中定义。

接下来，您将学习如何定义、执行和控制动画序列。不管你怎么想，WPF 动画并不局限于视频游戏或多媒体应用。在 WPF API 下，动画可以像让一个按钮在获得焦点时发光一样微妙，或者扩展一个`DataGrid`中选定行的大小。理解动画是构建自定义控件模板的一个关键方面(你将在本章后面看到)。

然后，您将探索 WPF 风格和模板的作用。就像使用 CSS 或 ASP.NET 主题引擎的网页一样，WPF 应用可以为一组控件定义一个共同的外观。您可以在标记中定义这些样式，并将它们存储为对象资源供以后使用，还可以在运行时动态应用它们。最后一个例子将教你如何构建自定义控件模板。

## 了解 WPF 资源系统

您的第一个任务是研究嵌入和访问应用资源的主题。WPF 支持两种类型的资源。第一个是二进制资源，这一类别通常包括大多数程序员认为是传统意义上的资源的项目(嵌入的图像文件或声音剪辑、应用使用的图标等等)。

第二种风格称为对象资源或逻辑资源，代表一种命名的。NET 对象，可以打包并在整个应用中重用。而任何。NET 对象可以打包成对象资源，逻辑资源在处理任何种类的图形数据时特别有用，因为您可以定义常用的图形元素(画笔、钢笔、动画等)。)并在需要时参考它们。

### 使用二进制资源

在我们进入对象资源的主题之前，让我们快速检查一下如何将二进制资源，如图标或图像文件(如公司徽标或动画图像)打包到您的应用中。如果您想继续，使用 Visual Studio 创建一个名为`BinaryResourcesApp`的新 WPF 应用。更新初始窗口的标记，以处理窗口`Loaded`事件，并使用`DockPanel`作为布局根，如下所示:

`<Window x:Class="BinaryResourcesApp.MainWindow"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`xmlns:d="`[`http://schemas.microsoft.com/expression/blend/2008`](http://schemas.microsoft.com/expression/blend/2008)T2】

`xmlns:mc="`[`http://schemas.openxmlformats.org/markup-compatibility/2006`](http://schemas.openxmlformats.org/markup-compatibility/2006)T2】

`xmlns:local="clr-namespace:BinaryResourcesApp"`

`mc:Ignorable="d"`

`Title="Fun with Binary Resources" Height="500" Width="649"`

`Loaded="MainWindow_OnLoaded">`

`<DockPanel LastChildFill="True">`

`</DockPanel>`

`</Window>`

现在，假设您的应用需要根据用户输入在窗口的一部分显示三个图像文件中的一个。WPF `Image`控件不仅可用于显示典型的图像文件(`*.bmp`、`*.gif`、`*.ico`、`*.jpg`、`*.png`、`*.wdp`或`*.tiff`)，还可用于显示`DrawingImage`中的数据(如您在[第 28 章](28.html)中所见)。您可以为您的窗口构建一个支持`DockPanel`的 UI，该 UI 包含一个带有下一个和上一个按钮的简单工具栏。在这个工具栏下面，您可以放置一个`Image`控件，该控件目前没有设置为`Source`属性的值，如下所示:

`<Window x:Class="BinaryResourcesApp.MainWindow"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`xmlns:d="`[`http://schemas.microsoft.com/expression/blend/2008`](http://schemas.microsoft.com/expression/blend/2008)T2】

`xmlns:mc="`[`http://schemas.openxmlformats.org/markup-compatibility/2006`](http://schemas.openxmlformats.org/markup-compatibility/2006)T2】

`xmlns:local="clr-namespace:BinaryResourcesApp"`

`mc:Ignorable="d"`

`Title="Fun with Binary Resources" Height="500" Width="649">`

`Loaded="MainWindow_OnLoaded">`

`<DockPanel LastChildFill="True">`

`<ToolBar Height="60" Name="picturePickerToolbar" DockPanel.Dock="Top">`

`<Button x:Name="btnPreviousImage" Height="40" Width="100" BorderBrush="Black"`

`Margin="5" Content="Previous" Click="btnPreviousImage_Click"/>`

`<Button x:Name="btnNextImage" Height="40" Width="100" BorderBrush="Black"`

`Margin="5" Content="Next" Click="btnNextImage_Click"/>`

`</ToolBar>`

`<!-- We will fill this Image in code. -->`

`<Border BorderThickness="2" BorderBrush="Green">`

`<Image x:Name="imageHolder" Stretch="Fill" />`

`</Border>`

`</DockPanel>`

`</Window>`

请注意，已经为每个`Button`对象处理了`Click`事件。假设您已经使用 IDE 来处理这些事件，那么您的 C#代码文件中将有三个空方法。那么，如何编写`Click`事件处理程序来遍历图像数据呢？更重要的是，您希望图像数据位于用户的硬盘上还是嵌入到您编译的程序集中？让我们来看看你的选择。

#### 在项目中包含松散的资源文件

让我们假设您希望将图像文件作为一组松散的文件放在应用安装路径的子目录中。使用 Visual Studio 的解决方案资源管理器窗口，您可以右键单击您的项目节点并选择“添加➤新文件夹”菜单选项来创建这样一个子目录，您应该将它称为`Images`。

现在，当右键单击该文件夹时，可以选择“添加➤现有项目”菜单选项，将图像文件复制到新的子目录中。在这个项目的可下载源代码中，您会发现三个名为`Deer.jpg`、`Dogs.jpg`和`Welcome.jpg`的图像文件，您可以将它们包含在这个项目中，或者您可以添加三个您选择的图像文件。图 [29-1](#Fig1) 显示了当前的设置。

![A978-1-4842-1332-2_29_Fig1_HTML.jpg](img/A978-1-4842-1332-2_29_Fig1_HTML.jpg)

图 29-1。

A new subdirectory that contains image data in your WPF project

#### 配置松散资源

当您希望 Visual Studio 将项目内容复制到输出目录时，需要使用“属性”窗口调整一些设置。为了确保将`\Images`文件夹的内容复制到`\bin\Debug`文件夹，首先在解决方案浏览器中选择每个图像。现在，在这些图像仍然被选中的情况下，使用“属性”窗口将“构建动作”属性设置为“内容”，将“复制到输出目录”属性设置为“总是复制”(参见图 [29-2](#Fig2) )。

![A978-1-4842-1332-2_29_Fig2_HTML.jpg](img/A978-1-4842-1332-2_29_Fig2_HTML.jpg)

图 29-2。

Configuring the image data to be copied to your output directory Note

您还可以选择“如果较新则复制”，如果您正在构建包含大量内容的大型项目，这将节省您的时间。对于这个例子，复制总是可以的。

如果您重新编译您的程序，您现在可以单击解决方案资源管理器的 Show all Files 按钮，并查看您的`\bin\Debug`目录下复制的`Image`文件夹(您可能需要单击 Refresh 按钮)。见图 [29-3](#Fig3) 。

![A978-1-4842-1332-2_29_Fig3_HTML.jpg](img/A978-1-4842-1332-2_29_Fig3_HTML.jpg)

图 29-3。

The copied data

#### 以编程方式加载图像

WPF 提供了一个名为`BitmapImage`的类，它是`System.Windows.Media.Imaging`名称空间的一部分。这个类允许你从一个图像文件中加载数据，这个图像文件的位置由一个`System.Uri`对象表示。现在该处理你的窗口的`Loaded`事件了，填充`BitmapImages`的`List<T>`如下:

`public partial class MainWindow : Window`

`{`

`// A List of BitmapImage files.`

`List<BitmapImage> _images = new List<BitmapImage>();`

`// Current position in the list.`

`private int _currImage = 0;`

`private const int MAX_IMAGES = 2;`

`private void MainWindow_OnLoaded(object sender, RoutedEventArgs e)`

`{`

`try`

`{`

`string path = Environment.CurrentDirectory;`

`// Load these images when the window loads.`

`_images.Add(new BitmapImage(new Uri($@"{path}\Images\Deer.jpg")));`

`_images.Add(new BitmapImage(new Uri($@"{path}\Images\Dogs.jpg")));`

`_images.Add(new BitmapImage(new Uri($@"{path}\Images\Welcome.jpg")));`

`// Show first image in the List<>.`

`imageHolder.Source = _images[_currImage];`

`}`

`catch (Exception ex)`

`{`

`MessageBox.Show(ex.Message);`

`}`

`}`

`...`

`}`

注意，这个类还定义了一个`int`成员变量(_ `currImage`)，它将允许`Click`事件处理程序遍历`List<T>`中的每一项，并通过设置`Source`属性将其显示在`Image`控件中。(这里，您的`Loaded`事件处理程序将`Source`属性设置为`List<T>`中的第一幅图像。)此外，您的`MAX_IMAGES`常量将允许您在遍历列表时测试上限和下限。下面是做这件事的`Click`处理程序:

`private void btnPreviousImage_Click(object sender, RoutedEventArgs e)`

`{`

`if (--_currImage < 0)`

`_currImage = MAX_IMAGES;`

`imageHolder.Source = _images[_currImage];`

`}`

`private void btnNextImage_Click(object sender, RoutedEventArgs e)`

`{`

`if (++_currImage > MAX_IMAGES)`

`_currImage = 0;`

`imageHolder.Source = _images[_currImage];`

`}`

此时，你可以运行你的程序，浏览每张图片。

#### 嵌入应用资源

如果您想将图像文件配置为直接编译到。NET 程序集作为二进制资源，在解决方案资源管理器中选择图像文件(在`\Images`文件夹中，而不是在`\bin\Debug\Images`文件夹中)。然后将“构建动作”属性更改为“资源”，并将“复制到输出目录”属性更改为“不要复制”(参见图 [29-4](#Fig4) )。

![A978-1-4842-1332-2_29_Fig4_HTML.jpg](img/A978-1-4842-1332-2_29_Fig4_HTML.jpg)

图 29-4。

Configuring the images to be embedded resources

现在，使用 Visual Studio 的 Build 菜单，选择 Clean Solution 选项清除`\bin\Debug\Images`的当前内容，然后重新构建您的项目。刷新解决方案资源管理器，观察您的`\bin\Debug\Images`目录中缺少数据。使用当前的构建选项，您的图形数据不再被复制到输出文件夹中，而是嵌入到程序集本身中。

通过这种调整，您现在需要修改代码，通过从已编译的程序集中提取图像来加载这些图像:

`private void MainWindow_OnLoaded(object sender, RoutedEventArgs e)`

`{`

`try`

`{`

`_images.Add(new BitmapImage(new Uri(img/Deer.jpg", UriKind.Relative)));`

`_images.Add(new BitmapImage(new Uri(img/Dogs.jpg", UriKind.Relative)));`

`_images.Add(new BitmapImage(new Uri(img/Welcome.jpg", UriKind.Relative)));`

`imageHolder.Source = _images[_currImage];`

`}`

`catch (Exception ex)`

`{`

`MessageBox.Show(ex.Message);`

`}`

`}`

在这种情况下，您不再需要确定安装路径，只需按名称列出资源，这将考虑原始子目录的名称。还要注意，当你创建你的`Uri`对象时，你指定了一个`Relative`的`UriKind`值。在任何情况下，此时您的可执行文件是一个独立的实体，可以从机器上的任何位置运行，因为所有编译的数据都在二进制文件中。图 [29-5](#Fig5) 显示了完成的申请。

![A978-1-4842-1332-2_29_Fig5_HTML.jpg](img/A978-1-4842-1332-2_29_Fig5_HTML.jpg)

图 29-5。

Your simple picture viewer Source Code

BinaryResourcesApp 可以在 [`Chapter 29`](29.html) 子目录中找到。

## 使用对象(逻辑)资源

在构建 WPF 应用时，通常会定义一个 XAML 的简介，在一个窗口的多个位置使用，或者跨多个窗口或项目使用。例如，假设您已经创建了完美的线性渐变画笔，它由十行标记组成。现在，您想使用该笔刷作为项目中每个`Button`控件的背景色(包含 8 个窗口),总共 16 个`Button`。

最糟糕的事情是将 XAML 复制并粘贴到每个控件中。很明显，这将是一场维护的噩梦，因为你需要在任何时候调整画笔的外观和感觉时进行大量的修改。

幸运的是，对象资源允许您定义一个 XAML 的 blob，给它一个名称，并将其存储在一个 fitting 字典中以备后用。像二进制资源一样，对象资源通常被编译到需要它们的程序集中。但是，这样做并不需要修改构建操作属性。只要你把你的 XAML 放到正确的位置，编译器会处理剩下的事情。

使用对象资源是 WPF 开发的一大部分。正如你将看到的，对象资源可能比自定义画笔复杂得多。您可以定义基于 XAML 的动画、3D 呈现、自定义控件样式、数据模板、控件模板等，并将每个模板打包为可重用的资源。

### 资源属性的作用

如前所述，对象资源必须放在 fitting dictionary 对象中，以便在应用中使用。目前，`FrameworkElement`的每个后代都支持一个`Resources`属性。该属性封装了一个包含已定义对象资源的`ResourceDictionary`对象。`ResourceDictionary`可以保存任何类型的项目，因为它在`System.Object`类型上操作，并且可以通过 XAML 或程序代码进行操作。

在 WPF，所有的控件、`Window`、`Page`(在构建导航应用或 XBAP 程序时使用)和`UserControl`都扩展了`FrameworkElement`，所以几乎所有的小部件都提供了对`ResourceDictionary`的访问。此外，`Application`类虽然没有扩展`FrameworkElement`，但出于同样的目的，它支持一个同名的`Resources`属性。

### 定义窗口范围的资源

要开始探索对象资源的角色，使用 Visual Studio 创建一个名为 ObjectResourcesApp 的新 WPF 应用，并将最初的`Grid`更改为水平对齐的`StackPanel`布局管理器。进入这个`StackPanel`，像这样定义两个`Button`控件(你真的不需要太多说明对象资源的作用，这样就行了):

`<Window x:Class="ObjectResourcesApp.MainWindow"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`xmlns:d="`[`http://schemas.microsoft.com/expression/blend/2008`](http://schemas.microsoft.com/expression/blend/2008)T2】

`xmlns:mc="`[`http://schemas.openxmlformats.org/markup-compatibility/2006`](http://schemas.openxmlformats.org/markup-compatibility/2006)T2】

`xmlns:local="clr-namespace:ObjectResourcesApp"`

`mc:Ignorable="d"`

`Title="Fun with Object Resources" Height="350" Width="525">`

`<StackPanel Orientation="Horizontal">`

`<Button Margin="25" Height="200" Width="200" Content="OK" FontSize="20"/>`

`<Button Margin="25" Height="200" Width="200" Content="Cancel" FontSize="20"/>`

`</StackPanel>`

`</Window>`

现在，选择 OK 按钮，使用集成笔刷编辑器将`Background`颜色属性设置为自定义笔刷类型(在第 28 章的[中讨论)。完成后，注意画笔是如何嵌入到`<Button>`和`</Button>`标签的范围内的，如下所示:](28.html)

`<Button Margin="25" Height="200" Width="200" Content="OK" FontSize="20">`

`<Button.Background>`

`<RadialGradientBrush>`

`<GradientStop Color="#FFC44EC4" Offset="0" />`

`<GradientStop Color="#FF829CEB" Offset="1" />`

`<GradientStop Color="#FF793879" Offset="0.669" />`

`</RadialGradientBrush>`

`</Button.Background>`

`</Button>`

为了让 Cancel 按钮也使用这个画笔，您应该将`<RadialGradientBrush>`的范围提升到父元素的资源字典。例如，如果你把它移动到`<StackPanel>`，两个按钮可以使用相同的笔刷，因为它们是布局管理器的子元素。更好的是，你可以将画笔打包到 w `indow`本身的资源字典中，这样窗口内容的所有方面(嵌套面板，等等)。)可以自由利用。

当需要定义资源时，可以使用 property 元素语法来设置所有者的`Resources`属性。您还为资源项赋予了一个`x:Key`值，当窗口的其他部分想要引用对象资源时，将会使用这个值。要知道`x:Key`和`x:Name`是不一样的！`x:Name`属性允许您访问代码文件中作为成员变量的对象，而`x:Key`属性允许您引用资源字典中的一个项目。

Visual Studio 允许您使用资源各自的属性窗口将资源提升到更高的范围。要做到这一点，首先要确定包含要打包为资源的复杂对象的属性(在本例中是`Background`属性)。属性旁边是一个白色小方块，单击它将打开一个弹出菜单。从中选择转换为新资源选项(参见图 [29-6](#Fig6) )。

![A978-1-4842-1332-2_29_Fig6_HTML.jpg](img/A978-1-4842-1332-2_29_Fig6_HTML.jpg)

图 29-6。

Moving a complex object into a resource container

要求您命名您的资源(`myBrush`)并指定放置它的位置。对于本例，保留当前文件的默认选择(见图 [29-7](#Fig7) )。

![A978-1-4842-1332-2_29_Fig7_HTML.jpg](img/A978-1-4842-1332-2_29_Fig7_HTML.jpg)

图 29-7。

Naming the object resource

完成后，标记的结构将如下所示:

`<Window x:Class="ObjectResourcesApp.MainWindow"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`xmlns:d="`[`http://schemas.microsoft.com/expression/blend/2008`](http://schemas.microsoft.com/expression/blend/2008)T2】

`xmlns:mc="`[`http://schemas.openxmlformats.org/markup-compatibility/2006`](http://schemas.openxmlformats.org/markup-compatibility/2006)T2】

`xmlns:local="clr-namespace:ObjectResourcesApp"`

`mc:Ignorable="d"`

`Title="Fun with Object Resources" Height="350" Width="525">`

`<Window.Resources>`

`<RadialGradientBrush x:Key="myBrush">`

`<GradientStop Color="#FFC44EC4" Offset="0" />`

`<GradientStop Color="#FF829CEB" Offset="1" />`

`<GradientStop Color="#FF793879" Offset="0.669" />`

`</RadialGradientBrush>`

`</Window.Resources>`

`<StackPanel Orientation="Horizontal">`

`<Button Margin="25" Height="200" Width="200" Content="OK"`

`FontSize="20" Background="{DynamicResource myBrush}"/>`

`<Button Margin="25" Height="200" Width="200" Content="Cancel" FontSize="20"/>`

`</StackPanel>`

`</Window>`

注意新的`<Window.Resources>`范围，它现在包含了`RadialGradientBrush`对象，该对象有一个键值`myBrush`。创建资源向导将新资源创建为 DynamicResource。您将在本文的后面了解 DynamicResources，但是现在，请将其更改为 StaticResource，如下所示:

`<Button Margin="25" Height="200" Width="200" Content="OK"`

`FontSize="20" Background="{StaticResource myBrush}"/>`

`<Button Margin="25" Height="200" Width="200" Content="Cancel" FontSize="20"/>`

### {StaticResource}标记扩展

提取对象资源时发生的另一个变化是，作为提取目标的属性(同样，`Background`)现在使用了`{` `StaticResource` `}`标记扩展。如您所见，键名被指定为一个参数。现在，如果取消按钮选择使用相同的画笔来绘制背景，它可以自由地这样做。或者，如果取消按钮有一些复杂的内容，那么`Button`的任何子元素也可以使用窗口级资源，例如`Ellipse`的`Fill`属性。

`<StackPanel Orientation="Horizontal">`

`<Button Margin="25" Height="200" Width="200" Content="OK" FontSize="20"`

`Background="{StaticResource myBrush}">`

`</Button>`

`<Button Margin="25" Height="200" Width="200" FontSize="20">`

`<StackPanel>`

`<Label HorizontalAlignment="Center" Content= "No Way!"/>`

`<Ellipse Height="100" Width="100" Fill="{StaticResource myBrush}"/>`

`</StackPanel>`

`</Button>`

`</StackPanel>`

### {DynamicResource}标记扩展

当连接到键控资源时，属性也可以使用`{` `DynamicResource` `}`标记扩展。为了理解其中的区别，将你的 OK 按钮命名为`btnOK`并处理`Click`事件。在这个事件处理程序中，使用`Resources`属性获取自定义画笔，然后更改它的某些方面，如下所示:

`private void btnOK_Click(object sender, RoutedEventArgs e)`

`{`

`// Get the brush and make a change.`

`var b = (RadialGradientBrush)Resources["myBrush"];`

`b.GradientStops[1] = new GradientStop(Colors.Black, 0.0);`

`}`

Note

在这里，您使用`Resources`索引器通过名称来定位资源。但是，请注意，如果找不到资源，这将引发运行时异常。您也可以使用`TryFindResource()`方法，它不会抛出运行时错误；如果找不到指定的资源，它将简单地返回`null`。

如果你运行这个应用并点击 OK 按钮，你会看到笔刷的改变被考虑在内，并且每个按钮都会更新来渲染修改后的笔刷。但是，如果你完全改变了由`myBrush`键指定的笔刷类型会怎么样呢？例如，

`private void btnOK_Click(object sender, RoutedEventArgs e)`

`{`

`// Put a totally new brush into the myBrush slot.`

`Resources["myBrush"] = new SolidColorBrush(Colors.Red);`

`}`

这一次，当您单击按钮时，两者都不会像预期的那样更新。这是因为`{StaticResource}`标记扩展只应用资源一次，并在应用的生命周期中保持与原始对象的“连接”。然而，如果你在你的标记中把每次出现的`{StaticResource}`改为`{DynamicResource}`，你会发现你的自定义画笔已经被预期的纯红色画笔所替换。

本质上，`{DynamicResource}`标记扩展能够检测底层键控对象是否已经被新对象替换。正如您可能猜到的，这需要一些额外的运行时基础设施，所以您通常应该坚持使用`{StaticResource}`，除非您知道您有一个对象资源将在运行时与另一个对象交换，并且您希望使用该资源的所有项目都得到通知。

### 应用级资源

当窗口的资源字典中有对象资源时，窗口中的所有项都可以自由使用它，但应用中的其他窗口不能。将取消按钮命名为`btnCancel`，并处理`Click`事件。在当前项目(名为`TestWindow.xaml`)中插入一个包含单个`Button`的新窗口，单击它将关闭窗口。

`public partial class TestWindow : Window`

`{`

`public TestWindow()`

`{`

`InitializeComponent();`

`}`

`private void btnClose_Click(object sender, RoutedEventArgs e)`

`{`

`Close();`

`}`

`}`

现在，在第一个 w `indow`上的取消按钮的`Click`处理程序中，加载并显示这个新窗口，就像这样:

`private void btnCancel_Click(object sender, RoutedEventArgs e)`

`{`

`var w = new TestWindow();`

`w.Owner = this;`

`w.WindowStartupLocation = WindowStartupLocation.CenterOwner;`

`w.ShowDialog();`

`}`

因此，如果新窗口想要使用`myBrush`，它目前不能使用，因为它不在正确的“范围”内。解决方案是在应用级别定义对象资源，而不是在特定窗口的级别。在 Visual Studio 中没有办法实现自动化，所以只需将当前的 brush 对象从`<Windows.Resources>`范围中剪切出来，并将其放在`App.xaml`文件的`<Application.Resources>`范围中。

`<Application x:Class="ObjectResourcesApp.App"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x=`[`http://schemas.microsoft.com/winfx/2006/xaml`T3】](http://schemas.microsoft.com/winfx/2006/xaml)

`xmlns:local="clr-namespace:ObjectResourcesApp"`

`StartupUri="MainWindow.xaml">`

`<Application.Resources>`

`<RadialGradientBrush x:Key="myBrush">`

`<GradientStop Color="#FFC44EC4" Offset="0" />`

`<GradientStop Color="#FF829CEB" Offset="1" />`

`<GradientStop Color="#FF793879" Offset="0.669" />`

`</RadialGradientBrush>`

`</Application.Resources>`

`</Application>`

现在你的`TestWindow`可以自由地使用这个笔刷来绘制背景了。如果你想为这个新的`Window`找到`Background`属性，点击笔刷资源标签(一直在右边)来查看你的应用级资源(见图 [29-8](#Fig8) )。

![A978-1-4842-1332-2_29_Fig8_HTML.jpg](img/A978-1-4842-1332-2_29_Fig8_HTML.jpg)

图 29-8。

Applying application-level resources

### 定义合并的资源词典

应用级资源是一个很好的起点，但是如果您需要定义一组复杂(或不太复杂)的资源，并且需要在多个 WPF 项目中重用，该怎么办呢？在这种情况下，您需要定义一个合并的资源字典。这只不过是一个包含对象资源集合的`.xaml`文件。单个项目可以根据需要拥有多个这样的文件(一个用于画笔，一个用于动画，等等)，每个文件都可以通过项目菜单激活的添加新项目对话框插入(见图 [29-9](#Fig9) )。

![A978-1-4842-1332-2_29_Fig9_HTML.jpg](img/A978-1-4842-1332-2_29_Fig9_HTML.jpg)

图 29-9。

Inserting a new merged resource dictionary

在新的`MyBrushes.xaml`文件中，剪切`Application.Resources`范围中的当前资源，并将它们移动到您的字典中，如下所示:

`<ResourceDictionary xmlns=`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`T3】](http://schemas.microsoft.com/winfx/2006/xaml/presentation)

`xmlns:local="clr-namespace:ObjectResourcesApp"`

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`<RadialGradientBrush x:Key="myBrush">`

`<GradientStop Color="#FFC44EC4" Offset="0" />`

`<GradientStop Color="#FF829CEB" Offset="1" />`

`<GradientStop Color="#FF793879" Offset="0.669" />`

`</RadialGradientBrush>`

`</ResourceDictionary>`

现在，即使这个资源字典是项目的一部分，也会出现运行时错误。原因是所有的资源字典必须合并(通常在应用级别)到一个现有的资源字典中。为此，在`App.xaml`文件中使用以下格式(注意，可以通过在`<ResourceDictionary.MergedDictionaries>`范围内添加多个`<ResourceDictionary>`元素来合并多个资源字典):

`<Application x:Class="ObjectResourcesApp.App"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x=`[`http://schemas.microsoft.com/winfx/2006/xaml`T3】](http://schemas.microsoft.com/winfx/2006/xaml)

`xmlns:local="clr-namespace:ObjectResourcesApp"`

`StartupUri="MainWindow.xaml">`

`<!-- Bring in the logical resources`

`from the MyBrushes.xaml file. -->`

`<Application.Resources>`

`<ResourceDictionary>`

`<ResourceDictionary.MergedDictionaries>`

`<ResourceDictionary Source = "MyBrushes.xaml"/>`

`</ResourceDictionary.MergedDictionaries>`

`</ResourceDictionary>`

`</Application.Resources>`

`</Application>`

### 定义仅资源程序集

最后但同样重要的是，创造是可能的。只包含对象资源字典的. NET 类库。如果您已经定义了一组需要在机器级别上使用的主题，这将非常有用。您可以将对象资源打包到一个专用的程序集中，然后需要使用它们的应用可以将它们加载到内存中。

生成纯资源程序集的最简单方法是从 WPF 用户控件库项目开始。通过 Visual Studio 的“添加➤新项目”菜单选项，将这样一个项目(名为 mybrusheslibrary)添加到您当前的解决方案中(参见图 [29-10](#Fig10) )。

![A978-1-4842-1332-2_29_Fig10_HTML.jpg](img/A978-1-4842-1332-2_29_Fig10_HTML.jpg)

图 29-10。

Adding a User Control Library as a starting point for a resource-only library

现在，从项目中完全删除`UserControl1.xaml`文件(您真正想要的只是被引用的 WPF 程序集)。接下来，将`MyBrushes.xaml`文件拖放到您的`MyBrushesLibrary`项目中，并将其从`ObjectResourcesApp`项目中删除。最后，打开`MyBrushesLibrary`项目中的`MyBrushes.xaml`，将文件中的`x:local`命名空间改为`clr-namespace:MyBrushesLibrary`。您的解决方案资源管理器现在应该如图 [29-11](#Fig11) 所示。

![A978-1-4842-1332-2_29_Fig11_HTML.jpg](img/A978-1-4842-1332-2_29_Fig11_HTML.jpg)

图 29-11。

Moving the `MyBrushes.xaml` file into your new library project

编译您的用户控件库项目。接下来，使用添加引用对话框从`ObjectResourcesApp`项目中引用这个库。现在，将这些二进制资源合并到`ObjectResourcesApp`项目的应用级资源字典中。然而，这样做需要一些相当时髦的语法，如下所示:

`<Application.Resources>`

`<ResourceDictionary>`

`<ResourceDictionary.MergedDictionaries>`

`<!-- The syntax is /NameOfAssembly;Component/NameOfXamlFileInAssembly.xaml -->`

`<ResourceDictionary Source = "/MyBrushesLibrary;Component/MyBrushes.xaml"/>`

`</ResourceDictionary.MergedDictionaries>`

`</ResourceDictionary>`

`</Application.Resources>`

首先，要知道这个字符串是空间敏感的。如果分号或正斜杠周围有多余的空格，将会产生运行时错误。字符串的第一部分是外部库的友好名称(没有文件扩展名)。在分号后，键入单词`Component`，后跟编译后的二进制资源的名称，这将与原始的 XAML 资源字典相同。

这就结束了我们对 WPF 资源管理系统的研究。您将在大多数应用中很好地利用这些技术。接下来，我们来考察一下 Windows Presentation Foundation 的集成动画 API。

Source Code

ObjectResourcesApp 项目可以在 [`Chapter 29`](29.html) 子目录中找到。

## 了解 WPF 的动画服务

除了你在第 28 章中研究的图形渲染服务，WPF 还提供了一个编程接口来支持动画服务。动画一词可能会使人想起旋转的公司徽标、一系列旋转的图像资源(以提供运动的错觉)、屏幕上跳动的文本或特定类型的程序(如视频游戏或多媒体应用)。

虽然 WPF 的动画 API 肯定可以用于这种目的，但如果你想给应用增添一些特色，随时都可以使用动画。例如，您可以为屏幕上的按钮创建一个动画，当鼠标光标悬停在其边界内时，该动画会稍微放大(当鼠标光标移动到边界之外时，动画会缩小)。或者，您可以制作窗口动画，使其以特定的视觉外观关闭，例如慢慢淡入透明。事实上，WPF 的动画支持可以用于任何类型的应用(商业应用、多媒体程序、视频游戏等)。)每当您想要提供更吸引人的用户体验时。

正如 WPF 的许多其他方面一样，制作动画的概念并不新鲜。新的是，与您过去可能使用的其他 API(包括 Windows 窗体)不同，开发人员不需要手动创作必要的基础结构。在 WPF 下，不需要创建用于推进动画序列的后台线程或计时器，不需要定义自定义类型来表示动画，不需要擦除和重绘图像，也不需要进行繁琐的数学计算。像 WPF 的其他方面一样，我们可以完全使用 XAML、完全使用 C#代码或者两者结合来制作动画。

Note

Visual Studio 不支持使用 GUI 动画工具创作动画。如果您使用 Visual Studio 创作动画，您可以通过直接键入 XAML 来完成。然而，Blend for Visual Studio(Visual Studio 2015 附带的配套产品)确实有一个内置的动画编辑器，可以大大简化您的生活。

### 动画类的角色类型

为了理解 WPF 的动画支持，您必须从检查`PresentationCore.dll`的`System.Windows.Media.Animation`名称空间中的动画类开始。在这里，您会发现超过 100 种不同的类类型是使用`Animation`标记命名的。

所有这些类别都可以归为三大类之一。第一，任何遵循命名惯例`DataType` `Animation` ( `ByteAnimation`、`ColorAnimation`、`DoubleAnimation`、`Int32Animation`等)的类。)允许您使用线性插值动画。这使您能够随着时间的推移平稳地将值从起始值更改为最终值。

接下来，遵循命名约定的类`DataType` `AnimationUsingKeyFrames` ( `StringAnimationUsingKeyFrames`、`DoubleAnimationUsingKeyFrames`、`PointAnimationUsingKeyFrames`等。)表示“关键帧动画”，它允许您在一段时间内循环通过一组定义的值。例如，您可以通过在一系列单个字符之间循环，使用关键帧来更改按钮的标题。

最后，遵循`DataType` `AnimationUsingPath`命名约定的类(`DoubleAnimationUsingPath`、`PointAnimationUsingPath`等等)是基于路径的动画，允许你动画化对象沿着你定义的路径移动。举例来说，如果您正在构建一个 GPS 应用，您可以使用基于路径的动画来沿着最快的旅行路线将项目移动到用户的目的地。

现在，很明显，这些类并不用于以某种方式直接向特定数据类型的变量提供动画序列(毕竟，如何使用`Int32Animation`来制作值“9”的动画呢？).

例如，考虑一下`Label`类型的`Height`和`Width`属性，这两个属性都是包装了`double`的依赖属性。如果你想定义一个在一段时间内增加标签高度的动画，你可以将一个`DoubleAnimation`对象连接到`Height`属性，并允许 WPF 处理实际动画本身的细节。作为另一个例子，如果你想在五秒钟内将画笔类型的颜色从绿色转换为黄色，你可以使用`ColorAnimation`类型来完成。

非常清楚的是，这些`Animation`类可以连接到与底层类型匹配的给定对象的任何依赖属性。正如第 27 章中所解释的，依赖属性是许多 WPF 服务所需要的一种特殊形式的属性，包括动画、数据绑定和样式。

按照惯例，依赖属性被定义为类的静态只读字段，并通过在普通属性名后面加上单词`Property`来命名。例如，在代码中使用`Button.HeightProperty`可以访问`Button`的`Height`属性的依赖属性。

### “收件人”、“发件人”和“依据”属性

所有的`Animation`类都定义了以下几个关键属性，这些属性控制用于执行动画的开始和结束值:

*   `To`:该属性表示动画的结束值。
*   `From`:该属性表示动画的起始值。
*   `By`:该属性表示动画改变其起始值的总量。

尽管所有的`Animation`类都支持`To`、`From`和`By`属性，但它们并不通过基类的虚拟成员接收这些属性。原因是这些属性所包装的底层类型差异很大(整数、颜色、`Thickness`对象等)。)，并且使用单个基类来表示所有的可能性会导致非常复杂的编码结构。

另一方面，你可能也想知道为什么。NET 泛型不用于定义具有单一类型参数(例如，`Animate<T>`)的单一泛型动画类。同样，假设有如此多的底层数据类型(颜色、向量、整型、字符串等)。)习惯了动态的依赖属性，它不会像你期望的那样是一个干净的解决方案(更不用说 XAML 对泛型类型的支持是有限的)。

### 时间轴基类的角色

尽管没有使用单个基类来定义虚拟的`To`、`From`和`By`属性，但是`Animation`类确实共享一个公共基类:`System.Windows.Media.Animation.Timeline`。这种类型提供了许多控制动画步调的附加属性，如表 [29-1](#Tab1) 所述。

表 29-1。

Key Members of the `Timeline` Base Class

<colgroup><col> <col></colgroup> 
| 性能 | 生命的意义 |
| --- | --- |
| `AccelerationRatio`、`DecelerationRatio`、`SpeedRatio` | 这些属性可用于控制动画序列的整体速度。 |
| `AutoReverse` | 该属性获取或设置一个值，该值指示时间轴在完成正向迭代后是否反向播放(默认值为`false`)。 |
| `BeginTime` | 此属性获取或设置此时间线的开始时间。默认值为 0，表示立即开始播放动画。 |
| `Duration` | 此属性允许您设置播放时间线的持续时间。 |
| `FillBehavior`，`RepeatBehavior` | 这些属性用于控制时间轴完成后应该发生的事情(重复动画，什么都不做，等等)。). |

### 用 C#代码创作动画

具体来说，您将构建一个包含一个`Button`的`Window`，每当鼠标进入它的表面区域时，它就会有一个奇怪的旋转行为(基于左上角)。首先使用 Visual Studio 创建一个名为`SpinningButtonAnimationApp`的新 WPF 应用。将初始标记更新为以下内容(注意，您正在处理按钮的`MouseEnter`事件):

`<Window x:Class="SpinningButtonAnimationApp.MainWindow"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`xmlns:d="`[`http://schemas.microsoft.com/expression/blend/2008`](http://schemas.microsoft.com/expression/blend/2008)T2】

`xmlns:mc="`[`http://schemas.openxmlformats.org/markup-compatibility/2006`](http://schemas.openxmlformats.org/markup-compatibility/2006)T2】

`xmlns:local="clr-namespace:SpinningButtonanimationApp"`

`mc:Ignorable="d"`

`Title="Animations in C# code" Height="350"`

`Width="525" WindowStartupLocation="CenterScreen">`

`<Grid>`

`<Button x:Name="btnSpinner" Height="50" Width="100" Content="I Spin!"`

`MouseEnter="btnSpinner_MouseEnter"/>`

`</Grid>`

`</Window>`

现在，导入`System.Windows.Media.Animation`名称空间，并在窗口的 C#代码文件中添加以下代码:

`public partial class MainWindow : Window`

`{`

`private bool _isSpinning = false;`

`private void btnSpinner_MouseEnter(object sender, MouseEventArgs e)`

`{`

`if (!_isSpinning)`

`{`

`_isSpinning = true;`

`// Make a double animation object, and register`

`// with the Completed event.`

`var dblAnim = new DoubleAnimation();`

`dblAnim.Completed += (o, s) => { _isSpinning = false; };`

`// Set the start value and end value.`

`dblAnim.From = 0;`

`dblAnim.To = 360;`

`// Now, create a RotateTransform object, and set`

`// it to the RenderTransform property of our`

`// button.`

`var rt = new RotateTransform();`

`btnSpinner.RenderTransform = rt;`

`// Now, animation the RotateTransform object.`

`rt.BeginAnimation(RotateTransform.AngleProperty, dblAnim);`

`}`

`}`

`}`

这个方法的第一个主要任务是配置一个`DoubleAnimation`对象，它将从值`0`开始，到值`360`结束。请注意，您也正在处理该对象上的`Completed`事件，以切换一个类级别的`bool`变量，该变量用于确保如果一个动画当前正在执行，您不会“重置”它以重新开始。

接下来，您创建一个连接到您的`Button`控件(`btnSpinner`)的`RenderTransform`属性的`RotateTransform`对象。最后但同样重要的是，您通知`RenderTransform`对象使用您的`DoubleAnimation`对象开始制作其`Angle`属性的动画。当您在代码中创作动画时，通常通过调用`BeginAnimation()`来实现，并传入您想要制作动画的底层依赖属性(记住，按照惯例，这是类上的一个静态字段)，后跟一个相关的动画对象。

让我们在程序中添加另一个动画，这个动画会导致按钮在被点击时淡入不可见状态。首先，处理`btnSpinner`对象的`Click`事件，然后在结果事件处理程序中添加以下代码:

`private void btnSpinner_Click(object sender, RoutedEventArgs e)`

`{`

`var dblAnim = new DoubleAnimation`

`{`

`From = 1.0,`

`To = 0.0`

`};`

`btnSpinner.BeginAnimation(Button.OpacityProperty, dblAnim);`

`}`

这里，您正在更改`Opacity`属性值，以使按钮淡出视图。然而，目前这很难做到，因为按钮旋转得非常快！那么，你如何控制动画的节奏呢？很高兴你问了。

### 控制动画的速度

默认情况下，动画在分配给`From`和`To`属性的值之间转换大约需要一秒钟。因此，你的按钮有一秒钟的时间旋转 360 度，而按钮将在一秒钟内消失(当被点击时)。

如果您想要为动画的过渡定义一个自定义的时间量，您可以通过动画对象的`Duration`属性来实现，该属性可以设置为一个`Duration`对象的实例。通常，时间跨度是通过将一个`TimeSpan`对象传递给`Duration`的构造函数来建立的。考虑下面的更新，它将为按钮提供整整四秒的旋转时间:

`private void btnSpinner_MouseEnter(object sender, MouseEventArgs e)`

`{`

`if (!_isSpinning)`

`{`

`_isSpinning = true;`

`// Make a double animation object, and register`

`// with the Completed event.`

`var dblAnim = new DoubleAnimation();`

`dblAnim.Completed += (o, s) => { _isSpinning = false; };`

`// Button has four seconds to finish the spin!`

`dblAnim.Duration = new Duration(TimeSpan.FromSeconds(4));`

`...`

`}`

`}`

通过这种调整，你应该有机会在按钮旋转时点击它，此时它会逐渐消失。

Note

一个`Animation`类的`BeginTime`属性也接受一个`TimeSpan`对象。回想一下，可以设置该属性来建立开始动画序列之前的等待时间。

### 反转和循环播放动画

还可以通过将`AutoReverse`属性设置为`true`来告诉`Animation`对象在动画序列完成时反向播放动画。例如，如果您想让按钮在消失后重新出现，您可以编写以下代码:

`private void btnSpinner_Click(object sender, RoutedEventArgs e)`

`{`

`DoubleAnimation dblAnim = new DoubleAnimation`

`{`

`From = 1.0,`

`To = 0.0`

`};`

`// Reverse when done.`

`dblAnim.AutoReverse = true;`

`btnSpinner.BeginAnimation(Button.OpacityProperty, dblAnim);`

`}`

如果你想让一个动画重复一定次数(或者一旦激活就永不停止)，你可以使用所有`Animation`类共有的`RepeatBehavior`属性。如果向构造函数传递一个简单的数值，可以指定硬编码的重复次数。另一方面，如果你将一个`TimeSpan`对象传递给构造函数，你可以确定动画应该重复的时间。最后，如果您希望动画无限循环，您可以简单地指定`RepeatBehavior.Forever`。考虑以下方法，您可以更改本例中使用的任一`DoubleAnimation`对象的重复行为:

`// Loop forever.`

`dblAnim.RepeatBehavior = RepeatBehavior.Forever;`

`// Loop three times.`

`dblAnim.RepeatBehavior = new RepeatBehavior(3);`

`// Loop for 30 seconds.`

`dblAnim.RepeatBehavior = new RepeatBehavior(TimeSpan.FromSeconds(30));`

这就结束了关于如何使用 C#代码和 WPF 动画 API 来制作对象动画的研究。接下来，您将学习如何使用 XAML 做同样的事情。

Source Code

SpinningButtonAnimationApp 项目可以在 [`Chapter 29`](29.html) 子目录中找到。

## 在 XAML 创作动画

在标记中创作动画类似于在代码中创作动画，至少对于简单、直接的动画序列是如此。当您需要捕获更复杂的动画时，这可能涉及到一次更改许多属性的值，标记的数量可能会大大增加。即使您使用工具来生成基于 XAML 的动画，了解动画在 XAML 的基本表现方式也很重要，因为这将使您更容易修改和调整工具生成的内容。

Note

您会在可下载源代码的`XamlAnimations`文件夹中找到许多 XAML 文件。在接下来的几页中，将这些标记文件复制到您的自定义 XAML 编辑器或 Kaxaml 编辑器中，以查看结果。

在很大程度上，创建一个动画类似于你已经看到的。您仍然需要配置一个`Animation`对象，并将它与一个对象的属性相关联。然而，一个很大的区别是 WPF 不是函数调用友好的。因此，您使用故事板作为间接层，而不是调用`BeginAnimation()`。

让我们看一个用 XAML 定义的动画的完整例子，然后是一个详细的分解。下面的 XAML 定义将显示一个包含单个标签的窗口。一旦`Label`对象加载到内存中，它就开始一个动画序列，其中字体大小在 4 秒内从 12 磅增加到 100 磅。只要`Window`对象加载到内存中，动画就会重复播放。您可以在`GrowLabelFont.xaml`文件中找到这个标记，因此将它复制到您的`MyXamlPad.exe`应用(或 Kaxaml)中并观察其行为:

`<Window`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`Height="200" Width="600" WindowStartupLocation="CenterScreen" Title="Growing Label Font!">`

`<StackPanel>`

`<Label Content = "Interesting...">`

`<Label.Triggers>`

`<EventTrigger RoutedEvent = "Label.Loaded">`

`<EventTrigger.Actions>`

`<BeginStoryboard>`

`<Storyboard TargetProperty = "FontSize">`

`<DoubleAnimation From = "12" To = "100" Duration = "0:0:4"`

`RepeatBehavior = "Forever"/>`

`</Storyboard>`

`</BeginStoryboard>`

`</EventTrigger.Actions>`

`</EventTrigger>`

`</Label.Triggers>`

`</Label>`

`</StackPanel>`

`</Window>`

现在，让我们一点一点地分解这个例子。

### 故事板的作用

从最里面的元素开始，您首先会遇到`<DoubleAnimation>`元素，它利用了您在过程代码中设置的相同属性(`From`、`To`、`Duration`和`RepeatBehavior`)。

`<DoubleAnimation From = "12" To = "100" Duration = "0:0:4"`

`RepeatBehavior = "Forever"/>`

如上所述，`Animation`元素被放置在一个`<Storyboard>`元素中，该元素用于通过`TargetProperty`属性将动画对象映射到父类型上的给定属性，在本例中是`FontSize`。一个`<Storyboard>`总是被包装在一个名为`<BeginStoryboard>`的父元素中。

`<BeginStoryboard>`

`<Storyboard TargetProperty = "FontSize">`

`<DoubleAnimation From = "12" To = "100" Duration = "0:0:4"`

`RepeatBehavior = "Forever"/>`

`</Storyboard>`

`</BeginStoryboard>`

### 事件触发器的作用

在定义了`<BeginStoryboard>`元素之后，您需要指定某种动作来使动画开始执行。WPF 有几种不同的方式来响应标记中的运行时条件，其中一种被称为触发器。从高层次来看，您可以将触发器视为一种响应 XAML 事件条件的方式，而不需要过程代码。

通常，当您在 C#中响应事件时，您创作的自定义代码将在事件发生时执行。然而，触发器只是一种通知的方式，告诉你某个事件条件已经发生(“我被载入内存”，“鼠标在我上面！”，“我有重点了！”).

一旦你被通知一个事件条件已经发生，你就可以开始故事板。在本例中，您正在响应加载到内存中的`Label`。因为您感兴趣的是`Label`的`Loaded`事件，所以`<EventTrigger>`被放在`Label`的触发集合中。

`<Label Content = "Interesting...">`

`<Label.Triggers>`

`<EventTrigger RoutedEvent = "Label.Loaded">`

`<EventTrigger.Actions>`

`<BeginStoryboard>`

`<Storyboard TargetProperty = "FontSize">`

`<DoubleAnimation From = "12" To = "100" Duration = "0:0:4"`

`RepeatBehavior = "Forever"/>`

`</Storyboard>`

`</BeginStoryboard>`

`</EventTrigger.Actions>`

`</EventTrigger>`

`</Label.Triggers>`

`</Label>`

让我们看另一个在 XAML 定义动画的例子，这次使用关键帧动画。

### 使用离散关键帧的动画

与只能在起点和终点之间移动的线性插值动画对象不同，关键帧对应对象允许您为应该在特定时间发生的动画创建特定值的集合。

为了说明离散关键帧类型的用法，假设您想要构建一个`Button`控件，它可以使其内容动画化，这样在三秒钟的时间内，值“OK！”一次显示一个字符。您将在`AnimateString.xaml`文件中找到以下标记。将这个标记复制到您的`MyXamlPad.exe`程序(或 Kaxaml)中，并查看结果:

`<Window xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`Height="100" Width="300"`

`WindowStartupLocation="CenterScreen" Title="Animate String Data!">`

`<StackPanel>`

`<Button Name="myButton" Height="40"`

`FontSize="16pt" FontFamily="Verdana" Width = "100">`

`<Button.Triggers>`

`<EventTrigger RoutedEvent="Button.Loaded">`

`<BeginStoryboard>`

`<Storyboard>`

`<StringAnimationUsingKeyFrames RepeatBehavior = "Forever"`

`Storyboard.TargetProperty="Content"`

`Duration="0:0:3">`

`<DiscreteStringKeyFrame Value="" KeyTime="0:0:0" />`

`<DiscreteStringKeyFrame Value="O" KeyTime="0:0:1" />`

`<DiscreteStringKeyFrame Value="OK" KeyTime="0:0:1.5" />`

`<DiscreteStringKeyFrame Value="OK!" KeyTime="0:0:2" />`

`</StringAnimationUsingKeyFrames>`

`</Storyboard>`

`</BeginStoryboard>`

`</EventTrigger>`

`</Button.Triggers>`

`</Button>`

`</StackPanel>`

`</Window>`

首先，请注意，您已经为按钮定义了一个事件触发器，以确保当按钮加载到内存中时故事板会执行。`StringAnimationUsingKeyFrames`类负责通过`Storyboard.TargetProperty`值改变按钮的内容。

在`<StringAnimationUsingKeyFrames>`元素的范围内，您定义了四个`DiscreteStringKeyFrame`元素，它们在两秒钟的时间内改变按钮的`Content`属性(注意，`StringAnimationUsingKeyFrames`建立的持续时间总共是三秒钟，所以您会看到在最后一个“！”之间有一个轻微的停顿并且循环“O”)。

既然您对如何用 C#代码和 XAML 构建动画有了更好的感觉，让我们看看 WPF 风格的作用，它大量使用图形、对象资源和动画。

Source Code

这些松散的 XAML 文件可以在第 29 章的[子目录中找到。](29.html)

## 了解 WPF 风格的作用

当您构建 WPF 应用的用户界面时，一系列控件需要共享的外观并不罕见。例如，您可能希望所有按钮类型的字符串内容具有相同的高度、宽度、背景颜色和字体大小。虽然您可以通过将每个按钮的单个属性设置为相同的值来解决这个问题，但这种方法很难实现后续的更改，因为每次更改都需要在多个对象上重置相同的属性集。

令人欣慰的是，WPF 提供了一种简单的方法来使用样式约束相关控件的外观。简单地说，WPF 样式是维护属性/值对集合的对象。从编程的角度来说，使用`System.Windows.Style`类来表示一个单独的样式。这个类有一个名为`Setters`的属性，它公开了一个`Setter`对象的强类型集合。是`Setter`对象允许您定义属性/值对。

除了`Setters`集合之外，`Style`类还定义了一些其他重要的成员，这些成员允许您合并触发器，限制可以应用样式的位置，甚至基于现有的样式创建新的样式(可以将其视为“样式继承”)。特别要注意`Style`类的以下成员:

*   `Triggers`:公开一组触发器对象，允许你在一个样式中捕捉各种事件条件。
*   `BasedOn`:允许您在现有样式的基础上构建新样式。
*   `TargetType`:允许您限制样式的应用位置。

### 定义和应用样式

几乎在每种情况下，一个`Style`对象都会被打包成一个对象资源。像任何对象资源一样，您可以在窗口或应用级别打包它，以及在一个专用的资源字典中打包(这很好，因为它使`Style`对象在整个应用中很容易被访问)。现在回想一下，目标是定义一个用一组属性/值对填充(至少)集合的`Style`对象。

使用 Visual Studio 创建一个名为 WpfStyles 的新 WPF 应用。让我们构建一个样式，它可以捕获应用中控件的基本字体特征。打开您的`App.xaml`文件并定义以下命名样式:

`<Application x:Class="WpfStyles.App"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`xmlns:d="`[`http://schemas.microsoft.com/expression/blend/2008`](http://schemas.microsoft.com/expression/blend/2008)T2】

`xmlns:mc="`[`http://schemas.openxmlformats.org/markup-compatibility/2006`](http://schemas.openxmlformats.org/markup-compatibility/2006)T2】

`xmlns:local="clr-namespace:WpfStyles"`

`mc:Ignorable="d"`

`StartupUri="MainWindow.xaml">`

`<Application.Resources>`

`<Style x:Key ="BasicControlStyle">`

`<Setter Property = "Control.FontSize" Value ="14"/>`

`<Setter Property = "Control.Height" Value = "40"/>`

`<Setter Property = "Control.Cursor" Value = "Hand"/>`

`</Style>`

`</Application.Resources>`

`</Application>`

注意，您的`BasicControlStyle`向内部集合添加了三个`Setter`对象。现在，让我们将这种风格应用到主窗口中的几个控件上。因为这个样式是一个对象资源，想要使用它的控件仍然需要使用`{` `StaticResource` `}`或者`{` `DynamicResource` `}`标记扩展来定位样式。(正如您从前面关于静态和动态资源的讨论中所了解的那样，静态资源的效率要高一些，但是在更新方式上有所限制，所以请选择最符合您需求的资源。)当他们找到样式时，他们会将资源项设置为同名的`Style`属性。考虑以下`<Window>`定义:

`<Window x:Class="WpfStyles.MainWindow"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`xmlns:d="`[`http://schemas.microsoft.com/expression/blend/2008`](http://schemas.microsoft.com/expression/blend/2008)T2】

`xmlns:mc="`[`http://schemas.openxmlformats.org/markup-compatibility/2006`](http://schemas.openxmlformats.org/markup-compatibility/2006)T2】

`xmlns:local="clr-namespace:WpfStyles"`

`mc:Ignorable="d"`

`Title="A Window with Style!" Height="229"`

`Width="525" WindowStartupLocation="CenterScreen">`

`<StackPanel>`

`<Label x:Name="lblInfo" Content="This style is boring..."`

`Style="{StaticResource BasicControlStyle}" Width="150"/>`

`<Button x:Name="btnTestButton" Content="Yes, but we are reusing settings!"`

`Style="{StaticResource BasicControlStyle}" Width="250"/>`

`</StackPanel>`

`</Window>`

如果您运行这个应用，您会发现两个控件都支持相同的光标、高度和字体大小。

### 覆盖样式设置

这里有一个`Button`和`Label`，它们都选择了你的风格所强加的约束。当然，如果一个控件想要应用一个样式，然后改变一些已定义的设置，那也没问题。例如，`Button`现在将使用`Help`光标(而不是样式中定义的`Hand`光标):

`<Button x:Name="btnTestButton" Content="Yes, but we are reusing settings!"`

`Cursor="Help" Style="{StaticResource BasicControlStyle}" Width="250" />`

在使用样式的控件的单个属性设置之前处理样式；因此，控件可以根据具体情况“覆盖”设置。

### 使用 TargetType 限制样式的应用

目前，你的风格是以这样一种方式定义的，任何控件都可以采用它(并且必须通过设置控件的`Style`属性来显式地这样做)，假设每个属性都由`Control`类限定。对于一个定义了许多设置的程序来说，这需要大量的重复代码。稍微清理一下这种风格的一种方法是使用`TargetType`属性。当您将该属性添加到`Style`的开始元素时，您可以准确地标记一次它可以应用的位置(在本例中，在`App.XAML`)。

`<Style x:Key ="BasicControlStyle" TargetType="Control">`

`<Setter Property = "FontSize" Value ="14"/>`

`<Setter Property = "Height" Value = "40"/>`

`<Setter Property = "Cursor" Value = "Hand"/>`

`</Style>`

Note

当您生成使用基类类型的样式时，您不必担心是否将值赋给了派生类型不支持的依赖属性。如果派生类型不支持给定的依赖项属性，则忽略该属性。

这在一定程度上是有帮助的，但是您仍然有一种可以应用于任何控件的样式。当您想要定义一个只能应用于特定类型控件的样式时,`TargetType`属性会更有用。将以下新样式添加到应用的资源字典中:

`<Style x:Key ="BigGreenButton" TargetType="Button">`

`<Setter Property = "FontSize" Value ="20"/>`

`<Setter Property = "Height" Value = "100"/>`

`<Setter Property = "Width" Value = "100"/>`

`<Setter Property = "Background" Value = "DarkGreen"/>`

`<Setter Property = "Foreground" Value = "Yellow"/>`

`</Style>`

这种风格只适用于`Button`控件(或`Button`的子类)。如果将它应用于不兼容的元素，将会出现标记和编译器错误。如果`Button`号使用这种新样式，

`<Button x:Name="btnTestButton" Content="OK!"`

`Cursor="Help" Style="{StaticResource BigGreenButton}" Width="250" />`

您将看到如图 [29-12](#Fig12) 所示的输出。

![A978-1-4842-1332-2_29_Fig12_HTML.jpg](img/A978-1-4842-1332-2_29_Fig12_HTML.jpg)

图 29-12。

Controls with different styles

`TargetType`的另一个作用是，只要`x:Key`属性不存在，样式就会应用到样式定义范围内该类型的所有元素。稍后会有更多内容。

### 使用 TargetType 自动应用样式

假设您需要确保所有的`TextBox`控件具有相同的外观和感觉。现在假设您已经将一个样式定义为应用级别的资源，因此程序中的所有窗口都可以访问它。虽然这是朝着正确方向迈出的一步，但是如果你有许多带有大量`TextBox`控件的窗口，你将需要多次设置`Style`属性！

WPF 样式可以隐式应用于给定 XAML 范围内的所有控件。为了创建这样的样式，您使用了`TargetType`属性，但是没有给`Style`资源分配一个`x:Key`值。这种“未命名样式”现在适用于正确类型的所有控件。下面是另一个应用级样式，它将自动应用于当前应用中的所有`TextBox`控件:

`<!-- The default style for all text boxes. -->`

`<Style TargetType="TextBox">`

`<Setter Property = "FontSize" Value ="14"/>`

`<Setter Property = "Width" Value = "100"/>`

`<Setter Property = "Height" Value = "30"/>`

`<Setter Property = "BorderThickness" Value = "5"/>`

`<Setter Property = "BorderBrush" Value = "Red"/>`

`<Setter Property = "FontStyle" Value = "Italic"/>`

`</Style>`

您现在可以定义任意数量的`TextBox`控件，它们将自动获得定义的外观。如果给定的`TextBox`不想要这个默认的外观，它可以通过将`Style`属性设置为`{x:Null}`来退出。例如，`txtTest`将获得默认的未命名样式，而`txtTest2`则以自己的方式做事:

`<TextBox x:Name="txtTest"/>`

`<TextBox x:Name="txtTest2" Style="{x:Null}" BorderBrush="Black"`

`BorderThickness="5" Height="60" Width="100" Text="Ha!"/>`

### 子类化现有样式

您还可以通过`BasedOn`属性使用现有的样式构建新的样式。您正在扩展的样式必须在字典中有一个合适的`x:Key`，因为派生的样式将使用`{StaticResource} or {DynamicResource}`标记扩展通过名称引用它。下面是基于`BigGreenButton`的新样式，将按钮元素旋转 20 度:

`<!-- This style is based on BigGreenButton. -->`

`<Style x:Key ="TiltButton" TargetType="Button" BasedOn = "{StaticResource BigGreenButton}">`

`<Setter Property = "Foreground" Value = "White"/>`

`<Setter Property = "RenderTransform">`

`<Setter.Value>`

`<RotateTransform Angle = "20"/>`

`</Setter.Value>`

`</Setter>`

`</Style>`

这次输出如图 [29-13](#Fig13) 所示。

![A978-1-4842-1332-2_29_Fig13_HTML.jpg](img/A978-1-4842-1332-2_29_Fig13_HTML.jpg)

图 29-13。

Using a derived style

### 使用触发器定义样式

通过将`Trigger`对象打包到`Style`对象的`Triggers`集合中，WPF 样式也可以包含触发器。在一个样式中使用触发器允许您定义某些`<Setter>`元素，使得它们只有在给定的触发条件为`true`时才会被应用。例如，当鼠标停留在按钮上时，您可能想要增加字体的大小。或者，您可能希望确保具有当前焦点的文本框以给定的颜色突出显示。触发器对于这类情况非常有用，因为它们允许您在属性更改时采取特定的操作，而无需在代码隐藏文件中编写显式 C#代码。

下面是对`TextBox`样式的更新，确保当`TextBox`拥有输入焦点时，它将获得黄色背景:

`<!-- The default style for all text boxes. -->`

`<Style TargetType="TextBox">`

`<Setter Property = "FontSize" Value ="14"/>`

`<Setter Property = "Width" Value = "100"/>`

`<Setter Property = "Height" Value = "30"/>`

`<Setter Property = "BorderThickness" Value = "5"/>`

`<Setter Property = "BorderBrush" Value = "Red"/>`

`<Setter Property = "FontStyle" Value = "Italic"/>`

`<!-- The following setter will be applied only when the text box is`

`in focus. -->`

`<Style.Triggers>`

`<Trigger Property = "IsFocused" Value = "True">`

`<Setter Property = "Background" Value = "Yellow"/>`

`</Trigger>`

`</Style.Triggers>`

`</Style>`

如果你测试这种风格，你会发现当你在不同的`TextBox`对象之间切换时，当前选中的`TextBox`有一个亮黄色的背景(假设它没有通过将`{x:Null}`分配给`Style`属性而退出)。

属性触发器也非常智能，因为当触发器的条件不为真时，属性会自动接收默认的赋值。因此，一旦`TextBox`失去焦点，它也会自动变成默认颜色，无需您做任何工作。相反，事件触发器(在你看 WPF 动画时检查过)不会自动回复到先前的状态。

### 使用多个触发器定义样式

触发器也可以设计成当多个条件为真时应用定义的`<Setter>`元素。假设您想将一个`TextBox`的背景设置为`Yellow`，只要它有活动的焦点并且鼠标在它的边界内悬停。为此，您可以利用`<MultiTrigger>`元素来定义每个条件，如下所示:

`<!--``The default style for all text boxes.`T2】

`<Style TargetType="TextBox">`

`<Setter Property = "FontSize" Value ="14"/>`

`<Setter Property = "Width" Value = "100"/>`

`<Setter Property = "Height" Value = "30"/>`

`<Setter Property = "BorderThickness" Value = "5"/>`

`<Setter Property = "BorderBrush" Value = "Red"/>`

`<Setter Property = "FontStyle" Value = "Italic"/>`

`<!--` `The following setter will be applied only when the text box is`

`in focus AND the mouse is over the text box.` `-->`

`<Style.Triggers>`

`<MultiTrigger>`

`<MultiTrigger.Conditions>`

`<Condition Property = "IsFocused" Value = "True"/>`

`<Condition Property = "IsMouseOver" Value = "True"/>`

`</MultiTrigger.Conditions>`

`<Setter Property = "Background" Value = "Yellow"/>`

`</MultiTrigger>`

`</Style.Triggers>`

`</Style>`

### 动画样式

样式还可以包含启动动画序列的触发器。下面是最后一个样式，当应用于`Button`控件时，当鼠标在按钮的表面区域内时，它将导致控件的大小增大和缩小:

`<!-- The growing button style! -->`

`<Style x:Key = "GrowingButtonStyle" TargetType="Button">`

`<Setter Property = "Height" Value = "40"/>`

`<Setter Property = "Width" Value = "100"/>`

`<Style.Triggers>`

`<Trigger Property = "IsMouseOver" Value = "True">`

`<Trigger.EnterActions>`

`<BeginStoryboard>`

`<Storyboard TargetProperty = "Height">`

`<DoubleAnimation From = "40" To = "200"`

`Duration = "0:0:2" AutoReverse="True"/>`

`</Storyboard>`

`</BeginStoryboard>`

`</Trigger.EnterActions>`

`</Trigger>`

`</Style.Triggers>`

`</Style>`

这里，triggers 集合正在寻找返回`true`的`IsMouseOver`属性。当这种情况发生时，您定义一个`<Trigger.EnterActions>`元素来执行一个简单的故事板，强制按钮在两秒钟内增长到`200`的`Height`值(然后返回到`40`的`Height`)。如果您想要执行其他的属性更改，您也可以定义一个`<Trigger.ExitActions>`范围来定义当`IsMouseOver`更改为`false`时要采取的任何自定义动作。

### 以编程方式分配样式

回想一下，样式也可以在运行时应用。如果您想让最终用户选择他们的 UI 的外观和感觉，或者如果您需要基于安全设置(例如，`DisableAllButton`样式)或您所拥有的东西来加强外观和感觉，这可能会很有帮助。

在这个项目中，您定义了许多样式，其中许多可以应用于`Button`控件。所以，让我们重组主窗口的 UI，让用户通过在`ListBox`中选择名字来选择这些风格。根据用户的选择，您将应用适当的样式。下面是`<Window>`元素的新的(也是最终的)标记:

`<Window x:Class="WpfStyles.MainWindow"`

`xmlns:d="`[`http://schemas.microsoft.com/expression/blend/2008`](http://schemas.microsoft.com/expression/blend/2008)T2】

`xmlns:mc="`[`http://schemas.openxmlformats.org/markup-compatibility/2006`](http://schemas.openxmlformats.org/markup-compatibility/2006)T2】

`xmlns:local="clr-namespace:WpfStyles"`

`mc:Ignorable="d"`

`Height="350" Title="A Window with Style!"`

`Width="525" WindowStartupLocation="CenterScreen">`

`<DockPanel >`

`<StackPanel Orientation="Horizontal" DockPanel.Dock="Top">`

`<Label Content="Please Pick a Style for this Button" Height="50"/>`

`<ListBox x:Name ="lstStyles" Height ="80" Width ="150" Background="LightBlue"`

`SelectionChanged ="comboStyles_Changed" />`

`</StackPanel>`

`<Button x:Name="btnStyle" Height="40" Width="100" Content="OK!"/>`

`</DockPanel>`

`</Window>`

`ListBox`控件(名为`lstStyles`)将在窗口的构造函数中动态填充，如下所示:

`public MainWindow()`

`{`

`InitializeComponent();`

`// Fill the list box with all the Button`

`// styles.`

`lstStyles.Items.Add("GrowingButtonStyle");`

`lstStyles.Items.Add("TiltButton");`

`lstStyles.Items.Add("BigGreenButton");`

`lstStyles.Items.Add("BasicControlStyle");}`

`}`

最后一个任务是处理相关代码文件中的`SelectionChanged`事件。请注意，在下面的代码中，您如何能够使用继承的`TryFindResource()`方法按名称提取当前资源:

`private void comboStyles_Changed(object sender, SelectionChangedEventArgs e)`

`{`

`// Get the selected style name from the list box.`

`var currStyle = (Style)TryFindResource(lstStyles.SelectedValue);`

`if (currStyle == null) return;`

`// Set the style of the button type.`

`this.btnStyle.Style = currStyle;`

`}`

当您运行这个应用时，您可以从这四种按钮样式中选择一种。图 [29-14](#Fig14) 显示了您完成的申请。

![A978-1-4842-1332-2_29_Fig14_HTML.jpg](img/A978-1-4842-1332-2_29_Fig14_HTML.jpg)

图 29-14。

Controls with different styles Source Code

WpfStyles 项目可以在 [`Chapter 29`](29.html) 子目录中找到。

## 逻辑树、可视化树和默认模板

现在您已经了解了样式和资源，在开始学习如何构建自定义控件之前，还有几个准备主题需要研究。具体来说，您需要了解逻辑树、可视化树和默认模板之间的区别。当你在 Visual Studio 或类似`kaxaml.exe`的工具中输入 XAML 时，你的标记就是 XAML 文档的逻辑视图。同样，如果您编写的 C#代码向一个`StackPanel`控件添加了新的条目，那么您就是在向逻辑树中插入新的条目。本质上，一个逻辑视图代表了你的内容在主`Window`(或者另一个根元素，比如`Page`或者`NavigationWindow`)的各种布局管理器中的位置。

然而，在每一个逻辑树的背后都有一个更详细的表示，称为视觉树，WPF 内部使用它来正确地将元素渲染到屏幕上。在任何视觉树中，都有用于呈现每个对象的模板和样式的完整细节，包括任何必要的绘图、形状、视觉效果和动画。

理解逻辑树和可视化树之间的区别非常有用，因为当您生成自定义控件模板时，实际上是替换控件的全部或部分默认可视化树并插入您自己的树。因此，如果您想要将`Button`控件呈现为星形，您可以定义一个新的星形模板，并将其插入到`Button`的可视化树中。从逻辑上讲，`Button`仍然是`Button`类型，它支持所有预期的属性、方法和事件。但在视觉上，它呈现出全新的面貌。鉴于其他工具包会要求您构建一个全新的类来制作星形按钮，仅这一事实就使 WPF 成为一个极其有用的 API。有了 WPF，你只需要定义新的标记。

Note

WPF 控件通常被描述为没有外观。这是指这样一个事实，即 WPF 控件的外观和感觉完全独立于它的行为。

### 以编程方式检查逻辑树

虽然在运行时分析一个窗口的逻辑树并不是一个非常常见的 WPF 编程活动，但是值得一提的是,`System.Windows`名称空间定义了一个名为`LogicalTreeHelper`的类，它允许您在运行时检查逻辑树的结构。为了说明逻辑树、可视化树和控制模板之间的联系，创建一个名为`TreesAndTemplatesApp`的新 WPF 应用。

更新窗口的标记，使其包含两个`Button`控件和一个大的只读`TextBox`，并启用滚动条。确保使用 IDE 来处理每个按钮的`Click`事件。下面的 XAML 会做得很好:

`<Window x:Class="TreesAndTemplatesApp.MainWindow"`

`xmlns:d="`[`http://schemas.microsoft.com/expression/blend/2008`](http://schemas.microsoft.com/expression/blend/2008)T2】

`xmlns:mc="`[`http://schemas.openxmlformats.org/markup-compatibility/2006`](http://schemas.openxmlformats.org/markup-compatibility/2006)T2】

`xmlns:local="clr-namespace:TreesAndTemplatesApp"`

`mc:Ignorable="d"`

`Title="Fun with Trees and Templates" Height="518"`

`Width="836" WindowStartupLocation="CenterScreen">`

`<DockPanel LastChildFill="True">`

`<Border Height="50" DockPanel.Dock="Top" BorderBrush="Blue">`

`<StackPanel Orientation="Horizontal">`

`<Button x:Name="btnShowLogicalTree" Content="Logical Tree of Window"`

`Margin="4" BorderBrush="Blue" Height="40" Click="btnShowLogicalTree_Click"/>`

`<Button x:Name="btnShowVisualTree" Content="Visual Tree of Window"`

`BorderBrush="Blue" Height="40" Click="btnShowVisualTree_Click"/>`

`</StackPanel>`

`</Border>`

`<TextBox x:Name="txtDisplayArea" Margin="10" Background="AliceBlue" IsReadOnly="True"`

`BorderBrush="Red" VerticalScrollBarVisibility="Auto"`

`HorizontalScrollBarVisibility="Auto" />`

`</DockPanel>`

`</Window>`

在 C#代码文件中，定义一个名为 _ `dataToShow`的`string`成员变量。现在，在`btnShowLogicalTree`对象的`Click`处理程序中，调用一个助手函数，该函数递归地调用自身，以便用`Window`的逻辑树填充字符串变量。为此，您将调用`LogicalTreeHelper`的静态`GetChildren()`方法。代码如下:

`private string _dataToShow = string.Empty;`

`private void btnShowLogicalTree_Click(object sender, RoutedEventArgs e)`

`{`

`_dataToShow = "";`

`BuildLogicalTree(0, this);`

`txtDisplayArea.Text = _dataToShow;`

`}`

`void BuildLogicalTree(int depth, object obj)`

`{`

`// Add the type name to the dataToShow member variable.`

`_dataToShow += new string(’ ’, depth) + obj.GetType().Name + "\n";`

`// If an item is not a DependencyObject, skip it.`

`if (!(obj is DependencyObject))`

`return;`

`// Make a recursive call for each logical child.`

`foreach (var child in LogicalTreeHelper.GetChildren(`

`(DependencyObject)obj))`

`{`

`BuildLogicalTree(depth + 5, child);`

`}`

`}`

如果你运行你的应用并点击第一个按钮，你会在文本区域看到一个树打印出来，它几乎是原始 XAML 的精确复制品(见图 [29-15](#Fig15) )。

![A978-1-4842-1332-2_29_Fig15_HTML.jpg](img/A978-1-4842-1332-2_29_Fig15_HTML.jpg)

图 29-15。

Viewing a logical tree at runtime

### 以编程方式检查可视化树

使用`System.Windows.Media`的`VisualTreeHelper`类也可以在运行时检查`Window`的可视化树。下面是第二个`Button`控件(`btnShowVisualTree`)的`Click`实现，它执行类似的递归逻辑来构建视觉树的文本表示:

`private void btnShowVisualTree_Click(object sender, RoutedEventArgs e)`

`{`

`_dataToShow = "";`

`BuildVisualTree(0, this);`

`txtDisplayArea.Text = _dataToShow;`

`}`

`void BuildVisualTree(int depth, DependencyObject obj)`

`{`

`// Add the type name to the dataToShow member variable.`

`_dataToShow += new string(’ ’, depth) + obj.GetType().Name + "\n";`

`// Make a recursive call for each visual child.`

`for (int i = 0; i < VisualTreeHelper.GetChildrenCount(obj); i++)`

`{`

`BuildVisualTree(depth + 1, VisualTreeHelper.GetChild(obj, i));`

`}`

`}`

如图 [29-16](#Fig16) 所示，视觉树公开了一些低级渲染代理，如`ContentPresenter`、`AdornerDecorator`、`TextBoxLineDrawingVisual`等。

![A978-1-4842-1332-2_29_Fig16_HTML.jpg](img/A978-1-4842-1332-2_29_Fig16_HTML.jpg)

图 29-16。

Viewing a visual tree at runtime

### 以编程方式检查控件的默认模板

回想一下，WPF 使用视觉树来理解如何呈现一个`Window`和所有包含的元素。每个 WPF 控件都在其默认模板中存储自己的呈现命令集。从编程的角度来说，任何模板都可以表示为`ControlTemplate`类的一个实例。同样，您可以通过使用名副其实的`Template`属性来获得控件的默认模板，如下所示:

`// Get the default template of the Button.`

`Button myBtn = new Button();`

`ControlTemplate template = myBtn.Template;`

同样，您可以在代码中创建一个新的`ControlTemplate`对象，并将其插入控件的`Template`属性，如下所示:

`// Plug in a new template for the button to use.`

`Button myBtn = new Button();`

`ControlTemplate customTemplate = new ControlTemplate();`

`// Assume this method adds all the code for a star template.`

`MakeStarTemplate(customTemplate);`

`myBtn.Template = customTemplate;`

虽然您可以用代码构建一个新的模板，但在 XAML 这样做要常见得多。但是，在您开始构建自己的模板之前，让我们先完成当前的示例，并添加在运行时查看 WPF 控件的默认模板的功能。这是查看模板整体构成的一种非常有用的方式。首先，用停靠在主控件`DockPanel`左侧的新控件`StackPanel`更新窗口的标记，定义如下(放在`<TextBox>`元素之前):

`<Border DockPanel.Dock="Left" Margin="10" BorderBrush="DarkGreen"`

`BorderThickness="4" Width="358">`

`<StackPanel>`

`<Label Content="Enter Full Name of WPF Control" Width="340" FontWeight="DemiBold" />`

`<TextBox x:Name="txtFullName" Width="340" BorderBrush="Green"`

`Background="BlanchedAlmond" Height="22"`

`Text="System.Windows.Controls.Button" />`

`<Button x:Name="btnTemplate" Content="See Template" BorderBrush="Green"`

`Height="40" Width="100" Margin="5"`

`Click="btnTemplate_Click" HorizontalAlignment="Left" />`

`<Border BorderBrush="DarkGreen" BorderThickness="2" Height="260"`

`Width="301" Margin="10" Background="LightGreen" >`

`<StackPanel x:Name="stackTemplatePanel" />`

`</Border>`

`</StackPanel>`

`</Border>`

务必注意空的`StackPanel`、`stackTemplatePanel`，因为您将在代码中引用它。为`btnTemplate_Click`事件添加一个空的事件处理函数，如下所示:

`private void btnTemplate_Click(object sender, RoutedEventArgs e)`

`{`

`}`

现在你的窗口看起来应该如图 [29-17](#Fig17) 所示。

![A978-1-4842-1332-2_29_Fig17_HTML.jpg](img/A978-1-4842-1332-2_29_Fig17_HTML.jpg)

图 29-17。

The updated UI of your window

左上角的文本区允许你输入位于`PresentationFramework.dll`组件中的 WPF 控件的全限定名。一旦库被加载，您将动态地创建对象的一个实例，并将其显示在左下角的大方框中。最后，控件的默认模板将显示在右边的文本区域。首先，向类型为`Control`的 C#类添加一个新的成员变量，如下所示:

`private Control _ctrlToExamine = null;`

下面是剩余的代码，它要求您导入`System.Reflection`、`System.Xml`和`System.Windows.Markup`名称空间:

`private void btnTemplate_Click(object sender, RoutedEventArgs e)`

`{`

`_dataToShow = "";`

`ShowTemplate();`

`txtDisplayArea.Text = _dataToShow;`

`}`

`private void ShowTemplate()`

`{`

`// Remove the control that is currently in the preview area.`

`if (_ctrlToExamine != null)`

`stackTemplatePanel.Children.Remove(_ctrlToExamine);`

`try`

`{`

`// Load PresentationFramework, and create an instance of the`

`// specified control. Give it a size for display purposes, then add to the`

`// empty StackPanel.`

`Assembly asm = Assembly.Load("PresentationFramework, Version=4.0.0.0," +`

`"Culture=neutral, PublicKeyToken=31bf3856ad364e35");`

`_ctrlToExamine = (Control)asm.CreateInstance(txtFullName.Text);`

`_ctrlToExamine.Height = 200;`

`_ctrlToExamine.Width = 200;`

`_ctrlToExamine.Margin = new Thickness(5);`

`stackTemplatePanel.Children.Add(_ctrlToExamine);`

`// Define some XML settings to preserve indentation.`

`var xmlSettings = new XmlWriterSettings{Indent = true};`

`// Create a StringBuilder to hold the XAML.`

`var strBuilder = new StringBuilder();`

`// Create an XmlWriter based on our settings.`

`var xWriter = XmlWriter.Create(strBuilder, xmlSettings);`

`// Now save the XAML into the XmlWriter object based on the ControlTemplate.`

`XamlWriter.Save(_ctrlToExamine.Template, xWriter);`

`// Display XAML in the text box.`

`_dataToShow = strBuilder.ToString();`

`}`

`catch (Exception ex)`

`{`

`_dataToShow = ex.Message;`

`}`

`}`

大部分工作只是修补已编译的 BAML 资源，将其映射到 XAML `string`。图 [29-18](#Fig18) 显示了你的最终应用，显示了`System.Windows.Controls.DatePicker`控件的默认模板。该图像显示了日历，通过单击控件右侧的按钮可以访问该日历。

![A978-1-4842-1332-2_29_Fig18_HTML.jpg](img/A978-1-4842-1332-2_29_Fig18_HTML.jpg)

图 29-18。

Investigating a `ControlTemplate` at runtime

太好了。希望您对逻辑树、可视化树和控件默认模板如何协同工作有更好的了解。现在，您可以用本章的剩余部分来学习如何构建自定义模板和用户控件。

Source Code

TreesAndTemplatesApp 项目包含在 [`Chapter 29`](29.html) 子目录中。

## 使用触发器框架构建控件模板

当您为控件生成自定义模板时，除了 C#代码之外，您什么都不用做。使用这种方法，您可以将数据添加到一个`ControlTemplate`对象，然后将它分配给一个控件的`Template`属性。然而，大多数时候，您将使用 XAML 定义一个`ControlTemplate`的外观和感觉，并添加一些代码(或者可能相当多的代码)来驱动运行时行为。

在本章的剩余部分，您将研究如何使用 Visual Studio 构建自定义模板。在这个过程中，您将了解 WPF 触发器框架和可视化状态管理器(VSM)，并且您将看到如何使用动画来为最终用户提供可视化提示。单独使用 Visual Studio 来构建复杂的模板可能需要大量的输入和一些繁重的工作。可以肯定的是，生产级模板将受益于 Expression Blend for Visual Studio，这是(现在)Visual Studio 的免费配套安装。然而，鉴于这一版本的文本不包括 Blend 的覆盖范围，是时候卷起袖子敲打一些标记了。

首先，创建一个名为`ButtonTemplate`的新 WPF 应用。对于这个项目，您更感兴趣的是创建和使用模板的机制，所以这个主窗口的标记非常简单。

`<Window x:Class="ButtonTemplate.MainWindow"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`xmlns:d="`[`http://schemas.microsoft.com/expression/blend/2008`](http://schemas.microsoft.com/expression/blend/2008)T2】

`xmlns:mc="`[`http://schemas.openxmlformats.org/markup-compatibility/2006`](http://schemas.openxmlformats.org/markup-compatibility/2006)T2】

`xmlns:local="clr-namespace:ButtonTemplate"`

`mc:Ignorable="d"`

`Title="Fun with Templates" Height="350" Width="525">`

`<StackPanel>`

`<Button x:Name="myButton" Width="100" Height="100"`

`Click="myButton_Click"/>`

`</StackPanel>`

`</Window>`

在`Click`事件处理程序中，简单地显示一个消息框(通过`MessageBox.Show()`),显示一条确认控件点击的消息。请记住，当您构建自定义模板时，控件的行为是不变的，但外观可能会有所不同。

目前，这个`Button`是使用默认模板呈现的，如最后一个示例所示，它是给定 WPF 程序集中的 BAML 资源。当您想要定义自己的模板时，实际上是用您自己的创建来替换这个默认的可视化树。首先，更新`<Button>`元素的定义，使用属性元素语法指定一个新模板。该模板将使控件具有圆形外观。

`<Button x:Name="myButton" Width="100" Height="100"`

`Click="myButton_Click">`

`<Button.Template>`

`<ControlTemplate>`

`<Grid x:Name="controlLayout">`

`<Ellipse x:Name="buttonSurface" Fill = "LightBlue"/>`

`<Label x:Name="buttonCaption" VerticalAlignment = "Center"`

`HorizontalAlignment = "Center"`

`FontWeight = "Bold" FontSize = "20" Content = "OK!"/>`

`</Grid>`

`</ControlTemplate>`

`</Button.Template>`

`</Button>`

这里，您已经定义了一个模板，它由一个名为`Grid`的控件组成，该控件包含一个名为`Ellipse`的控件和一个名为`Label`的控件。因为您的`Grid`没有定义行或列，每个子控件都堆叠在前一个控件的顶部，允许您将内容居中。如果您现在运行您的应用，您会注意到只有当鼠标光标在`Ellipse`的边界内时(即，不在椭圆边缘的拐角处)，才会触发`Click`事件！这是 WPF 模板架构的一个很大的特点:你不需要重新计算命中测试、边界检查或者任何其他底层细节。因此，如果你的模板使用了一个`Polygon`对象来呈现一些奇怪的几何图形，你可以放心，鼠标点击测试的细节是相对于控件的形状，而不是更大的边框。

### 模板作为资源

目前，您的模板被嵌入到一个特定的`Button`控件中，这限制了您的重用选项。理想情况下，您应该将模板放在资源字典中，以便可以在项目之间重用圆形按钮模板，或者至少将它移动到应用资源容器中，以便在该项目中重用。让我们将本地`Button`资源移到应用级别。首先，在属性编辑器中找到您的`Button`的`Template`属性(您可以在杂项部分找到它)。现在，点击黑色小方块图标并选择“转换为新资源”

从出现的对话框中，定义一个名为`RoundButtonTemplate`的新模板，它存储在`Application`级(即在`App.xaml`；参见图 [29-19](#Fig19) 。

![A978-1-4842-1332-2_29_Fig19_HTML.jpg](img/A978-1-4842-1332-2_29_Fig19_HTML.jpg)

图 29-19。

Placing your resource into `App.xaml`

此时，您将在您的`Application`对象的标记中找到以下数据:

`<Application x:Class="ButtonTemplate.App"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`xmlns:local="clr-namespace:ButtonTemplate"`

`StartupUri="MainWindow.xaml">`

`<Application.Resources>`

`<ControlTemplate x:Key="RoundButtonTemplate" TargetType="{x:Type Button}>`

`<Grid x:Name="controlLayout">`

`<Ellipse x:Name="buttonSurface" Fill = "LightBlue"/>`

`<Label x:Name="buttonCaption" VerticalAlignment = "Center"`

`HorizontalAlignment = "Center"`

`FontWeight = "Bold" FontSize = "20" Content = "OK!"/>`

`</Grid>`

`</ControlTemplate>`

`</Application.Resources>`

`</Application>`

现在，因为这个资源可用于整个应用，所以您可以定义任意数量的圆形按钮。创建两个额外的`Button`控件，使用这个模板进行测试(不需要为这些新项目处理`Click`事件)。

`<StackPanel>`

`<Button x:Name="myButton" Width="100" Height="100"`

`Click="myButton_Click"`

`Template="{StaticResource RoundButtonTemplate}"></Button>`

`<Button x:Name="myButton2" Width="100" Height="100"`

`Template="{StaticResource RoundButtonTemplate}"></Button>`

`<Button x:Name="myButton3" Width="100" Height="100"`

`Template="{StaticResource RoundButtonTemplate}"></Button>`

`</StackPanel>`

Visual Studio 2015 和。NET 4.6 默认使用`DynamicResources`。我更喜欢默认为`StaticResources`；有需要时，我会去动力部。对于这些例子，确保将默认的`DynamicResources`改为`StaticResources`。

### 使用触发器整合视觉提示

定义自定义模板时，默认模板的所有可视提示也会被删除。例如，默认的 button 模板包含一些标记，这些标记通知控件在某些 UI 事件发生时如何显示，例如当它获得焦点时、用鼠标单击时、启用(或禁用)时等等。用户非常习惯于这种视觉提示，因为它给了控件某种程度的触觉反应。然而，您的`RoundButtonTemplate`没有定义任何这样的标记，所以无论鼠标活动如何，控件的外观都是相同的。理想情况下，你的控件在被点击时看起来应该有所不同(可能通过颜色变化或阴影)，让用户知道视觉状态已经改变。

当 WPF 第一次发布时，添加这种视觉提示的方法是在模板中添加任意数量的触发器，当触发条件为真时，这些触发器通常会改变对象属性的值或启动故事板动画(或两者兼有)。举例来说，用下面的标记更新您的`RoundButtonTemplate`,当鼠标在表面上时，它将控件的颜色改为蓝色，前景色改为黄色:

`<ControlTemplate x:Key="RoundButtonTemplate" TargetType="Button" >`

`<Grid x:Name="controlLayout">`

`<Ellipse x:Name="buttonSurface" Fill="LightBlue" />`

`<Label x:Name="buttonCaption" Content="OK!" FontSize="20" FontWeight="Bold"`

`HorizontalAlignment="Center" VerticalAlignment="Center" />`

`</Grid>`

`<ControlTemplate.Triggers>`

`<Trigger Property = "IsMouseOver" Value = "True">`

`<Setter TargetName = "buttonSurface" Property = "Fill" Value = "Blue"/>`

`<Setter TargetName = "buttonCaption" Property = "Foreground"`

`Value = "Yellow"/>`

`</Trigger>`

`</ControlTemplate.Triggers>`

`</ControlTemplate>`

如果您再次运行该程序，您应该会发现颜色确实会根据鼠标是否在`Ellipse`区域内而切换。这是另一个触发器，当通过鼠标按下控件时，它将缩小`Grid`(以及所有子元素)的大小。将它添加到您的`<ControlTemplate.Triggers>`收藏中:

`<Trigger Property = "IsPressed" Value="True">`

`<Setter TargetName="controlLayout"`

`Property="RenderTransformOrigin" Value="0.5,0.5"/>`

`<Setter TargetName="controlLayout" Property="RenderTransform">`

`<Setter.Value>`

`<ScaleTransform ScaleX="0.8" ScaleY="0.8"/>`

`</Setter.Value>`

`</Setter>`

`</Trigger>`

### {TemplateBinding}标记扩展的角色

您的模板只能应用于`Button`控件，因此，您可以在`<Button>`元素上设置属性，这将导致模板以独特的方式呈现自己。例如，现在`Ellipse`的`Fill`属性被硬编码为蓝色，而`Label`的`Content`总是被设置为字符串值“OK”。如果您想要不同颜色和文本值的按钮，您可以在主窗口中定义以下按钮:

`<StackPanel>`

`<Button x:Name="myButton" Width="100" Height="100"`

`Background="Red" Content="Howdy!"`

`Click="myButton_Click"`

`Template="{StaticResource RoundButtonTemplate}" />`

`<Button x:Name="myButton2" Width="100" Height="100"`

`Background="LightGreen" Content="Cancel!"`

`Template="{StaticResource RoundButtonTemplate}" />`

`<Button x:Name="myButton3" Width="100" Height="100"`

`Background="Yellow" Content="Format"`

`Template="{StaticResource RoundButtonTemplate}" />`

`</StackPanel>`

然而，尽管每个`Button`都设置了一个唯一的`Background`和`Content`值，你仍然会看到三个包含文本“OK”的蓝色按钮。问题是使用模板`(Button)`的控件的属性与模板上的项目不完全匹配(例如`Ellipse`的`Fill`属性)。同样，尽管`Label`确实有一个`Content`属性，但是在`<Button>`范围中定义的值不会自动路由到模板的内部子模板。

您可以在构建模板时使用`{TemplateBinding}`标记扩展来解决这些问题。这允许您使用模板捕获由控件定义的属性设置，并使用它们来设置模板本身中的值。这是一个修改过的`RoundButtonTemplate`版本，它现在使用这个标记扩展将`Button`的`Background`属性映射到`Ellipse`的`Fill`属性；它还确保了`Button`的`Content`确实被传递给了`Label`的`Content`属性:

`<ControlTemplate x:Key="RoundButtonTemplate" TargetType="Button">`

`<Grid x:Name="controlLayout">`

`<Ellipse x:Name="buttonSurface"``Fill="{TemplateBinding Background}"/`T2】

`<Label x:Name="buttonCaption"``Content="{TemplateBinding Content}`T2】

`FontSize="20" FontWeight="Bold"`

`HorizontalAlignment="Center" VerticalAlignment="Center" />`

`</Grid>`

`<ControlTemplate.Triggers>`

`...`

`</ControlTemplate.Triggers>`

`</ControlTemplate>`

通过此次更新，您现在可以创建各种颜色和文本值的按钮(参见图 [29-20](#Fig20) )。XAML 的例子如下所示:

![A978-1-4842-1332-2_29_Fig20_HTML.jpg](img/A978-1-4842-1332-2_29_Fig20_HTML.jpg)

图 29-20。

Template bindings allow values to pass through to the internal controls

`<Button x:Name="myButton" Width="100" Height="100" Background="Red" Content="Howdy!"`

`Click="myButton_Click" Style="{StaticResource RoundButtonStyle}" />`

`<Button x:Name="myButton2" Width="100" Height="100" Background="LightGreen" Content="Cancel!"`

`Style="{StaticResource RoundButtonStyle}" />`

`<Button x:Name="myButton3" Width="100" Height="100" Background="Yellow" Content="Format"`

`Style="{StaticResource RoundButtonStyle}" />`

### 内容演示者的角色

当你设计你的模板时，你使用了一个`Label`来显示控件的文本值。像`Button`一样，`Label`支持一个`Content`属性。因此，考虑到您对`{TemplateBinding}`的使用，您可以定义一个包含复杂内容的`Button`，而不仅仅是一个简单的字符串。举个例子，

`<Button x:Name="myButton4" Width="100" Height="100" Background="Yellow"`

`Template="{StaticResource RoundButtonTemplate}">`

`<Button.Content>`

`<ListBox Height="50" Width="75">`

`<ListBoxItem>Hello</ListBoxItem>`

`<ListBoxItem>Hello</ListBoxItem>`

`<ListBoxItem>Hello</ListBoxItem>`

`</ListBox>`

`</Button.Content>`

`</Button>`

对于这个特定的控件，事情就像希望的那样工作。但是，如果您需要将复杂的内容传递给没有`Content`属性的模板成员，该怎么办呢？当您想要在模板中定义一个通用的内容显示区域时，您可以使用`ContentPresenter`类，而不是特定类型的控件(`Label`或`TextBlock`)。对于这个例子，没有必要这样做；然而，这里有一些简单的标记说明了如何构建一个使用`ContentPresenter`的定制模板，以显示使用该模板的控件的`Content`属性的值:

`<!-- This button template will display whatever is set`

`to the Content of the hosting button. -->`

`<ControlTemplate x:Key="NewRoundButtonTemplate" TargetType="Button">`

`<Grid>`

`<Ellipse Fill="{TemplateBinding Background}"/>`

`<ContentPresenter HorizontalAlignment="Center"`

`VerticalAlignment="Center"/>`

`</Grid>`

`</ControlTemplate>`

### 将模板并入样式

目前，你的模板仅仅定义了`Button`控件的基本外观。但是，建立控件的基本属性(内容、字体大小、字体粗细等)的过程。)是`Button`本身的责任。

`<!-- Currently the Button must set basic property values, not the template. -->`

`<Button x:Name ="myButton" Foreground ="Black" FontSize ="20" FontWeight ="Bold"`

`Template ="{StaticResource RoundButtonTemplate}" Click ="myButton_Click"/>`

如果您愿意，可以在模板中建立这些值。通过这样做，您可以有效地创建默认的外观。你可能已经意识到了，这是 WPF·斯泰尔斯的工作。当您构建一个样式时(考虑到基本的属性设置)，您可以在样式中定义一个模板！这是您在`App.xaml`的应用资源中更新的应用资源，它已被重设密钥为`RoundButtonStyle:`

`<!-- A style containing a template. -->`

`<Style x:Key ="RoundButtonStyle" TargetType ="Button">`

`<Setter Property ="Foreground" Value ="Black"/>`

`<Setter Property ="FontSize" Value ="14"/>`

`<Setter Property ="FontWeight" Value ="Bold"/>`

`<Setter Property="Width" Value="100"/>`

`<Setter Property="Height" Value="100"/>`

`<!-- Here is the template! -->`

`<Setter Property ="Template">`

`<Setter.Value>`

`<ControlTemplate TargetType ="Button">`

`<Grid x:Name="controlLayout">`

`<Ellipse x:Name="buttonSurface" Fill="{TemplateBinding Background}"/>`

`<Label x:Name="buttonCaption" Content ="{TemplateBinding Content}"`

`HorizontalAlignment="Center" VerticalAlignment="Center" />`

`</Grid>`

`<ControlTemplate.Triggers>`

`<Trigger Property = "IsMouseOver" Value = "True">`

`<Setter TargetName = "buttonSurface" Property = "Fill" Value = "Blue"/>`

`<Setter TargetName = "buttonCaption" Property = "Foreground" Value = "Yellow"/>`

`</Trigger>`

`<Trigger Property = "IsPressed" Value="True">`

`<Setter TargetName="controlLayout"`

`Property="RenderTransformOrigin" Value="0.5,0.5"/>`

`<Setter TargetName="controlLayout" Property="RenderTransform">`

`<Setter.Value>`

`<ScaleTransform ScaleX="0.8" ScaleY="0.8"/>`

`</Setter.Value>`

`</Setter>`

`</Trigger>`

`</ControlTemplate.Triggers>`

`</ControlTemplate>`

`</Setter.Value>`

`</Setter>`

`</Style>`

有了这次更新，您现在可以通过设置`Style`属性来创建按钮控件，如下所示:

`<Button x:Name="myButton" Background="Red" Content="Howdy!"`

`Click="myButton_Click" Style="{StaticResource RoundButtonStyle}"/>`

虽然按钮的呈现和行为是相同的，但是在样式中嵌套模板的好处是您能够为公共属性提供一组固定的值。这就概括了如何使用 Visual Studio 和触发器框架为控件构建自定义模板。虽然关于 Windows Presentation Foundation API 还有很多内容没有在这里讨论，但是您应该已经为进一步的学习打下了坚实的基础。

Source Code

ButtonTemplate 项目可以在 [`Chapter 29`](29.html) 子目录中找到。

## 摘要

本章第一部分考察了 WPF 的资源管理体系。您从如何使用二进制资源开始，然后研究了对象资源的角色。正如您所了解的，对象资源被命名为 XAML 的 blobs，可以存储在不同的位置，以便重用内容。

接下来，你学习了 WPF 的动画框架。在这里，你有机会用 C#代码和 XAML 制作一些动画。您了解到，如果您在标记中定义动画，您将使用`<Storyboard>`元素和触发器来控制执行。然后您看到了 WPF 风格的机制，它大量使用图形、对象资源和动画。

您研究了逻辑树和可视化树之间的关系。逻辑树基本上是您为描述 WPF 根元素而创作的标记的一一对应关系。在这个逻辑树的后面是一个更深的可视化树，它包含了详细的渲染指令。

然后检查默认模板的作用。请记住，当您构建自定义模板时，您实际上是将控件的可视化树全部(或部分)取出，并用您自己的自定义实现替换它。