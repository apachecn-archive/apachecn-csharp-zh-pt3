# 28.WPF 图形渲染服务

在这一章，我们将研究 WPF 的图形渲染能力。正如您将看到的，WPF 提供了三种不同的方式来呈现图形数据:形状、绘图和视觉效果。在你理解了每种方法的优缺点之后，你将开始使用`System.Windows.Shapes`中的类来学习交互式 2D 图形的世界。在此之后，您将看到绘图和几何如何让您以更轻量级的方式渲染 2D 数据。最后但同样重要的是，您将了解可视化层如何为您提供最高级别的功能和性能。

在此过程中，您将探索许多相关的主题，例如自定义画笔和笔的创建，如何将图形转换应用到渲染中，以及如何执行点击测试操作。特别是，您将看到 Visual Studio 的集成工具和一个名为 Inkscape 的附加工具如何简化您的图形编码工作。

Note

图形是 WPF 发展的一个重要方面。即使您不是在构建图形密集型应用(如视频游戏或多媒体应用)，当您使用控件模板、动画和数据绑定自定义等服务时，本章中的主题也是至关重要的。

## 了解 WPF 的图形渲染服务

WPF 使用了一种特殊风格的图形渲染，被称为保留模式图形。简而言之，这意味着既然你正在使用 XAML 或程序代码来生成图形渲染，那么 WPF 的责任就是保存这些可视项目，并确保它们以最佳方式被正确地重绘和刷新。因此，当您呈现图形数据时，它总是存在的，即使最终用户通过调整窗口大小或最小化窗口、用另一个窗口覆盖窗口等方式隐藏图像。

与之形成鲜明对比的是，之前的微软图形渲染 API(包括 Windows Form 的 GDI+)都是即时模式的图形系统。在这个模型中，由程序员来确保渲染的视觉效果在应用的生命周期中被正确地“记住”和更新。例如，在 Windows 窗体应用中，呈现一个形状(如矩形)需要处理`Paint`事件(或覆盖虚拟的`OnPaint()`方法)，获得一个`Graphics`对象来绘制矩形，最重要的是，添加基础设施来确保当用户调整窗口大小时图像是持久的(例如，创建成员变量来表示矩形的位置，并在整个程序中调用`Invalidate()`)。

从即时模式到保留模式图形的转变确实是一件好事，因为程序员要创作和维护的图形代码要少得多。然而，我并不是说 WPF 图形 API 与早期的渲染工具包完全不同。例如，像 GDI+一样，WPF 支持各种画笔类型和笔对象、点击测试技术、剪辑区域、图形转换等等。所以，如果你目前有 GDI+(或基于 C/C++的 GDI)的背景，你已经知道了很多关于如何在 WPF 下执行基本渲染的知识。

### WPF 图形渲染选项

与 WPF 开发的其他方面一样，除了决定通过 XAML 或过程化 C#代码(或者两者的结合)来执行图形呈现之外，关于如何执行图形呈现，您还有许多选择。具体来说，WPF 提供了以下三种不同的方式来呈现图形数据:

*   Shapes: WPF 提供了`System.Windows.Shapes`名称空间，它定义了少量用于渲染 2D 几何对象(矩形、椭圆形、多边形等)的类。).虽然这些类型使用起来非常简单，而且非常强大，但是如果不加考虑地使用，它们确实会带来相当大的内存开销。
*   绘图和几何图形:WPF API 提供了第二种呈现图形数据的方式，使用来自`System.Windows.Media.Drawing`抽象类的后代。使用像`GeometryDrawing`或`ImageDrawing`这样的类(除了各种几何对象之外)，你可以以一种更轻量级(但功能不丰富)的方式呈现图形数据。
*   视觉:在 WPF 下渲染图形数据的最快和最轻量级的方法是使用视觉层，它只能通过 C#代码访问。使用`System.Windows.Media.Visual`的后代，您可以直接与 WPF 图形子系统对话。

提供不同方法来完成完全相同的事情(例如，呈现图形数据)的原因与内存使用以及最终的应用性能有关。因为 WPF 是一个图形密集型系统，所以一个应用在一个窗口的表面上呈现数百甚至数千个不同的图像是合理的，并且实现的选择(形状、绘图或视觉)可能会产生巨大的影响。

请理解，当您构建一个 WPF 应用时，很有可能会用到这三个选项。根据经验，如果您需要适量的可由用户操作的交互式图形数据(接收鼠标输入、显示工具提示等)。)，您将需要使用`System.Windows.Shapes`名称空间中的成员。

相比之下，当您需要使用 XAML 或 C#对复杂的、通常非交互式的、基于矢量的图形数据建模时，绘图和几何图形更合适。虽然绘图和几何图形仍然可以响应鼠标事件、点击测试和拖放操作，但通常需要编写更多的代码来实现这一点。

最后但同样重要的是，如果您需要尽可能最快的方式来呈现大量的图形数据，那么可视化层是一个不错的选择。例如，假设您正在使用 WPF 构建一个科学应用，它可以绘制出成千上万的数据点。使用视觉图层，您可以尽可能以最佳方式渲染地块点。正如你将在本章后面看到的，可视化层只能通过 C#代码访问，并且不是 XAML 友好的。

无论您采用哪种方法(形状、绘图和几何图形，或视觉)，您都将使用常见的图形原语，如画笔(填充内部)、钢笔(绘制外部)和转换对象(转换数据)。为了开始这个旅程，您将开始使用`System.Windows.Shapes`的类。

Note

WPF 还附带了一个成熟的 API，可用于渲染和操作 3D 图形，这在本版本的文本中没有涉及。请参考。NET Framework 4.6 SDK 文档，如果您有兴趣将 3D 图形合并到您的应用中。

## 使用形状呈现图形数据

`System.Windows.Shapes`名称空间的成员提供了最直接、最具交互性、但最占用内存的方式来呈现二维图像。这个名称空间(在`PresentationFramework.dll`汇编中定义)非常小，只包含六个扩展抽象`Shape`基类的密封类:`Ellipse`、`Rectangle`、`Line`、`Polygon`、`Polyline`和`Path`。

创建一个名为 RenderingWithShapes 的新 WPF 应用，并将标题`MainWindow.xaml`改为“有趣的形状！”现在，如果您在 Visual Studio 对象浏览器中找到抽象的`Shape`类(参见图 [28-1](#Fig1) ，并展开每个父节点，您可以看到`Shape`的每个后代在继承链上接收大量的功能。

![A978-1-4842-1332-2_28_Fig1_HTML.jpg](img/A978-1-4842-1332-2_28_Fig1_HTML.jpg)

图 28-1。

The `Shape` base class receives a good deal of functionality from its parent classes

现在，考虑到您在前两章中的工作，这些父类中的一些可能会有印象。回想一下，例如，`UIElement`定义了许多方法来接收鼠标输入和处理拖放事件，而`FrameworkElement`定义了成员来处理大小调整、工具提示、鼠标光标等等。给定这个继承链，请注意当您使用`Shape`派生类来呈现图形数据时，这些对象的功能(就用户交互性而言)就像 WPF 控件一样！

例如，确定用户是否点击了您的渲染图像并不比处理`MouseDown`事件更复杂。举个简单的例子，如果你在你最初的`Window`的`Grid`中创作了这个`Rectangle`对象的 XAML

`<Rectangle x:Name="myRect" Height="30" Width="30"`

`Fill="Green" MouseDown="myRect_MouseDown"/>`

您可以为`MouseDown`事件实现一个 C#事件处理程序，它会在单击时改变矩形的背景颜色，如下所示:

`private void myRect_MouseDown(object sender, MouseButtonEventArgs e)`

`{`

`// Change color of Rectangle when clicked.`

`myRect.Fill = Brushes.Pink;`

`}`

与您可能使用过的其他图形工具包不同，您不需要编写大量的基础结构代码来手动将鼠标坐标映射到几何图形，手动计算点击测试，呈现到屏幕外缓冲区，等等。`System.Windows.Shapes`的成员只是简单地响应你注册的事件，就像一个典型的 WPF 控件(如`Button`等)。).

所有这些开箱即用的功能的缺点是形状确实会占用大量内存。同样，如果您正在构建一个在屏幕上绘制成千上万个点的科学应用，使用形状将是一个糟糕的选择(本质上，它将与渲染成千上万个`Button`对象一样占用大量内存！).然而，当你需要生成一个交互式的 2D 矢量图像时，形状是一个很好的选择。

除了从`UIElement`和`FrameworkElement`父类继承的功能之外，`Shape`为每个子类定义了许多成员；表 [28-1](#Tab1) 中显示了一些更有用的。

表 28-1。

Key Properties of the `Shape` Base Class

<colgroup><col> <col></colgroup> 
| 性能 | 生命的意义 |
| --- | --- |
| `DefiningGeometry` | 返回一个代表当前形状总尺寸的`Geometry`对象。该对象仅包含用于渲染数据的绘图点，没有来自`UIElement`或`FrameworkElement`的功能痕迹。 |
| `Fill` | 允许您指定“笔刷对象”来渲染形状的内部。 |
| `GeometryTransform` | 允许您在形状呈现在屏幕上之前对其应用变换。继承的`RenderTransform`属性(来自`UIElement`)在转换被呈现在屏幕上之后应用它。 |
| `Stretch` | 描述如何在分配给形状的空间内填充形状，如形状在布局管理器中的位置。这是使用相应的`System.Windows.Media.Stretch`枚举来控制的。 |
| `Stroke` | 定义一个画笔对象，或者在某些情况下，定义一个钢笔对象(实际上是一个伪装的画笔),用于绘制形状的边框。 |
| `StrokeDashArray, StrokeEndLineCap, StrokeStartLineCap, StrokeThickness` | 这些(和其他)与笔画相关的属性控制在绘制形状的边框时如何配置线条。在大多数情况下，这些属性将配置用于绘制边框或线条的画笔。 |

Note

如果你忘记设置`Fill`和`Stroke`属性，WPF 会给你“不可见”的笔刷，因此，这个形状在屏幕上是不可见的！

### 将矩形、椭圆和线条添加到画布

在本章的后面，您将学习使用表达式设计来生成图形数据的 XAML 描述。现在，您将构建一个 WPF 应用，该应用可以使用 XAML 和 C#来呈现形状，在这样做的同时，学习一点关于点击测试的过程。首先，删除当前的`Rectangle`描述和 C#事件处理程序逻辑。现在，更新`<Window>`的初始 XAML 来定义一个包含一个(现在为空)`<ToolBar>`和一个`<Canvas>`的`<DockPanel>`。注意，通过`Name`属性，每个包含的项目都有一个配件名称。

`<DockPanel LastChildFill="True">`

`<ToolBar DockPanel.Dock="Top" Name="mainToolBar" Height="50">`

`</ToolBar>`

`<Canvas Background="LightBlue" Name="canvasDrawingArea"/>`

`</DockPanel>`

现在，用一组`<RadioButton>`对象填充`<ToolBar>`，每个对象包含一个特定的`Shape`派生类作为内容。请注意，每个`<RadioButton>`都被分配给同一个`GroupName`(以确保互斥性)，并且还被赋予了一个合适的名称。

`<ToolBar DockPanel.Dock="Top" Name="mainToolBar" Height="50">`

`<RadioButton Name="circleOption" GroupName="shapeSelection">`

`<Ellipse Fill="Green" Height="35" Width="35" />`

`</RadioButton>`

`<RadioButton Name="rectOption" GroupName="shapeSelection">`

`<Rectangle Fill="Red" Height="35"`

`Width="35" RadiusY="10" RadiusX="10" />`

`</RadioButton>`

`<RadioButton Name="lineOption" GroupName="shapeSelection">`

`<Line Height="35" Width="35"`

`StrokeThickness="10" Stroke="Blue"`

`X1="10" Y1="10" Y2="25" X2="25"`

`StrokeStartLineCap="Triangle" StrokeEndLineCap="Round" />`

`</RadioButton>`

`</ToolBar>`

如您所见，在 XAML 声明`Rectangle`、`Ellipse`和`Line`对象非常简单，几乎不需要注释。回想一下，`Fill`属性用于指定画笔来绘制形状的内部。当需要纯色画笔时，只需指定一个已知值的硬编码字符串，底层类型转换器就会生成正确的对象。`Rectangle`类型的一个有趣的特性是它定义了`RadiusX`和`RadiusY`属性来允许你渲染弯曲的角落。

`Line`使用`X1`、`X2`、`Y1`和`Y2`属性表示它的起点和终点(假设高度和宽度在描述线条时没有什么意义)。在这里，您设置了几个附加属性来控制如何呈现`Line`的起点和终点，以及如何配置笔画设置。图 [28-2](#Fig2) 显示了通过 Visual Studio WPF 设计器看到的渲染工具栏。

![A978-1-4842-1332-2_28_Fig2_HTML.jpg](img/A978-1-4842-1332-2_28_Fig2_HTML.jpg)

图 28-2。

Using `Shapes` as content for a set of `RadioButtons`

现在，使用 Visual Studio 的属性窗口，为`Canvas`处理`MouseLeftButtonDown`事件，为每个`RadioButton`处理`Click`事件。在您的 C#文件中，您的目标是当用户在`Canvas`中单击时呈现选定的形状(圆形、正方形或直线)。首先，在您的`Window-`派生类中定义下面的嵌套`enum`(以及相应的成员变量):

`public partial class MainWindow : Window`

`{`

`private enum SelectedShape`

`{ Circle, Rectangle, Line }`

`private SelectedShape _currentShape;`

`...`

`}`

在每个`Click`事件处理程序中，将`currentShape`成员变量设置为正确的`SelectedShape`值。例如，下面是`circleOption RadioButton`的`Click`事件的实现代码。以类似的方式实现剩余的两个`Click`处理程序。

`private void circleOption_Click(object sender, RoutedEventArgs e)`

`{`

`_currentShape = SelectedShape.Circle;`

`}`

`private void rectOption_Click(object sender, RoutedEventArgs e)`

`{`

`_currentShape = SelectedShape.Rectangle;`

`}`

`private void lineOption_Click(object sender, RoutedEventArgs e)`

`{`

`_currentShape = SelectedShape.Line;`

`}`

使用`Canvas`的`MouseLeftButtonDown`事件处理程序，您将使用鼠标光标的 X，Y 位置作为起点，渲染出正确的形状(预定义大小)。下面是完整的实现，分析如下:

`private void canvasDrawingArea_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)`

`{`

`Shape shapeToRender = null;`

`// Configure the correct shape to draw` `.`

`switch (_currentShape)`

`{`

`case SelectedShape.Circle:`

`shapeToRender = new Ellipse() { Fill = Brushes.Green, Height = 35, Width = 35 };`

`break;`

`case SelectedShape.Rectangle:`

`shapeToRender = new Rectangle()`

`{ Fill = Brushes.Red, Height = 35, Width = 35, RadiusX = 10, RadiusY = 10 };`

`break;`

`case SelectedShape.Line:`

`shapeToRender = new Line()`

`{`

`Stroke = Brushes.Blue,`

`StrokeThickness = 10,`

`X1 = 0, X2 = 50, Y1 = 0, Y2 = 50,`

`StrokeStartLineCap= PenLineCap.Triangle,`

`StrokeEndLineCap = PenLineCap.Round`

`};`

`break;`

`default:`

`return;`

`}`

`// Set top/left position to draw in the canvas.`

`Canvas.SetLeft(shapeToRender, e.GetPosition(canvasDrawingArea).X);`

`Canvas.SetTop(shapeToRender, e.GetPosition(canvasDrawingArea).Y);`

`// Draw shape!`

`canvasDrawingArea.Children.Add(shapeToRender);`

`}`

Note

您可能会注意到，在这个方法中创建的`Ellipse`、`Rectangle`和`Line`对象与相应的 XAML 定义具有相同的属性设置！正如你所希望的，你可以简化这段代码，但是这需要理解 WPF 对象资源，这将在第 29 章中讨论。

如您所见，您正在测试`currentShape`成员变量以创建正确的`Shape`派生对象。在这之后，使用传入的`MouseButtonEventArgs`设置`Canvas`中左上角的值。最后但同样重要的是，您将新的`Shape`派生类型添加到由`Canvas`维护的`UIElement`对象集合中。如果您现在运行您的程序，您应该能够单击画布中的任何位置，并看到在鼠标左键单击的位置呈现的所选形状。

### 从画布中移除矩形、椭圆和线条

有了维护对象集合的`Canvas`,您可能想知道如何动态删除一个项目，也许是为了响应用户右击一个形状。您当然可以使用名为`VisualTreeHelper`的`System.Windows.Media`名称空间中的类来实现这一点。第 29 章将详细解释“视觉树”和“逻辑树”的作用。在此之前，您可以处理您的`Canvas`对象上的`MouseRightButtonDown`事件，并实现相应的事件处理程序，如下所示:

`private void canvasDrawingArea_MouseRightButtonDown(object sender, MouseButtonEventArgs e)`

`{`

`// First, get the X,Y location of where the user clicked.`

`Point pt = e.GetPosition((Canvas)sender);`

`// Use the HitTest() method of VisualTreeHelper to see if the user clicked`

`// on an item in the canvas.`

`HitTestResult result = VisualTreeHelper.HitTest(canvasDrawingArea, pt);`

`// If the result is not null, they DID click on a shape!`

`if (result != null)`

`{`

`// Get the underlying shape clicked on, and remove it from`

`// the canvas.`

`canvasDrawingArea.Children.Remove(result.VisualHit as Shape);`

`}`

`}`

该方法首先获取用户在`Canvas`中点击的准确的 X，Y 位置，并通过静态`VisualTreeHelper.HitTest()`方法执行点击测试操作。如果用户没有点击`Canvas`中的`UIElement`，返回值`HitTestResult`对象将被设置为空。如果`HitTestResult`不是`null`，您可以通过`VisualHit`属性获得被点击的底层`UIElement`，您将它转换成一个`Shape-`派生对象(记住，`Canvas`可以保存任何`UIElement`，而不仅仅是形状！).同样，在下一章中你会得到更多关于“视觉树”的细节。

Note

默认情况下，`VisualTreeHelper.HitTest()`返回被点击的最上面的`UIElement`，不提供该项下面的其他对象的信息(例如，按 Z 顺序重叠的对象)。

通过这一修改，您应该能够用鼠标左键在画布上添加一个形状，用鼠标右键从画布上删除一个项目！图 [28-3](#Fig3) 显示了当前示例的功能。

![A978-1-4842-1332-2_28_Fig3_HTML.jpg](img/A978-1-4842-1332-2_28_Fig3_HTML.jpg)

图 28-3。

Fun with shapes

目前为止，一切顺利。在这一点上，您已经使用 XAML 使用了从`Shape`派生的对象来呈现`RadioButtons`上的内容，并使用 C#填充了一个`Canvas`。当您检查画笔和图形转换的作用时，您将向这个示例添加更多的功能。与此相关，本章中的另一个例子将说明在`UIElement`对象上的拖放技术。在那之前，让我们检查一下`System.Windows.Shapes`的剩余成员。

### 使用多段线和多边形

当前的例子只使用了三个`Shape`派生类。剩下的子类(`Polyline`、`Polygon`和`Path`)在没有工具支持(比如 Expression Blend 或者其他可以创建矢量图形的工具)的情况下正确渲染起来极其繁琐，仅仅是因为它们需要大量的绘图点来表示它们的输出。你马上就会了解到表情设计的作用，但是在那之前，这里有一个剩余`Shapes`类型的概述。

`Polyline`类型允许您定义一组(x，y)坐标(通过`Points`属性)来绘制一系列不需要连接端点的线段。`Polygon`型也差不多；但是，它被编程为总是关闭起点和终点，并用指定的画笔填充内部。假设您已经在 Kaxaml 编辑器中编写了下面的`<StackPanel>`，或者更好的是，在您在[第 26 章](26.html)中创建的自定义 xaml 编辑器中:

`<!--``Polylines do not automatically connect the ends.`T2】

`<Polyline Stroke ="Red" StrokeThickness ="20" StrokeLineJoin ="Round"`

`Points ="10,10 40,40 10,90 300,50"/>`

`<!--``A Polygon always closes the end points.`T2】

`<Polygon Fill ="AliceBlue" StrokeThickness ="5" Stroke ="Green"`

`Points ="40,10 70,80 10,50" />`

图 [28-4](#Fig4) 显示了 MyXAMLPad 中的渲染输出。

![A978-1-4842-1332-2_28_Fig4_HTML.jpg](img/A978-1-4842-1332-2_28_Fig4_HTML.jpg)

图 28-4。

Polygons and polylines

### 使用路径

单独使用`Rectangle`、`Ellipse`、`Polygon`、`Polyline`和`Line`类型来绘制详细的 2D 矢量图像会非常复杂，因为这些图元不允许您轻松地捕捉图形数据，如曲线、重叠数据的联合等。最后一个`Shape`派生类`Path`，提供了定义复杂的 2D 图形数据的能力，这些数据被表示为一组独立的几何图形。在您定义了这样的几何图形集合之后，您可以将它们分配给`Path`类的`Data`属性，其中的信息将用于呈现复杂的 2D 图像。

`Data`属性采用一个`System.Windows.Media.Geometry`派生类，包含表 [28-2](#Tab2) 中描述的关键成员。

表 28-2。

Select Members of the `System.Windows.Media.Geometry` Type

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `Bounds` | 建立包含几何图形的当前边框。 |
| `FillContains()` | 确定给定的`Point`(或其他`Geometry`对象)是否在特定的`Geometry`派生类的范围内。这对于点击测试计算很有用。 |
| `GetArea()` | 返回一个`Geometry`派生类型占据的整个区域。 |
| `GetRenderBounds()` | 返回一个`Rect`，它包含可能用于呈现`Geometry`派生类的最小矩形。 |
| `Transform` | 给几何体分配一个`Transform`对象，以改变渲染。 |

扩展`Geometry`的类(见表 [28-3](#Tab3) )看起来非常像它们的`Shape`派生的对应物。例如，`EllipseGeometry`的成员与`Ellipse`相似。最大的区别是`Geometry`-派生类不知道如何直接呈现自己，因为它们不是`UIElements`。更确切地说，`Geometry`-派生类只不过代表了一个绘图点数据的集合，实际上是说“如果一个`Path`使用我的数据，这就是我如何呈现自己。”

表 28-3。

`Geometry`-Derived Classes

<colgroup><col> <col></colgroup> 
| 几何课 | 生命的意义 |
| --- | --- |
| `LineGeometry` | 代表一条直线 |
| `RectangleGeometry` | 表示一个矩形 |
| `EllipseGeometry` | 表示一个椭圆 |
| `GeometryGroup` | 允许您将几个`Geometry`对象组合在一起 |
| `CombinedGeometry` | 允许您将两个不同的`Geometry`对象合并成一个形状 |
| `PathGeometry` | 表示由直线和曲线组成的图形 |

Note

不是 WPF 唯一可以使用几何图形集合的类。例如，`DoubleAnimationUsingPath`、`DrawingGroup`、`GeometryDrawing`，甚至`UIElement`都可以使用几何图形进行渲染，分别使用`PathGeometry`、`ClipGeometry`、`Geometry`和`Clip`属性。

下面是一个使用了一些`Geometry`派生类型的`Path`。请注意，您正在将`Path`的`Data`属性设置为一个`GeometryGroup`对象，该对象包含其他`Geometry`派生的对象，如`EllipseGeometry`、`RectangleGeometry`和`LineGeometry`。图 [28-5](#Fig5) 显示了输出。

![A978-1-4842-1332-2_28_Fig5_HTML.jpg](img/A978-1-4842-1332-2_28_Fig5_HTML.jpg)

图 28-5。

A `Path` containing various `Geometry` objects

`<!--` `A Path contains a set of geometry objects,`

`set with the Data property.` `-->`

`<Path Fill = "Orange" Stroke = "Blue" StrokeThickness = "3">`

`<Path.Data>`

`<GeometryGroup>`

`<EllipseGeometry Center = "75,70"`

`RadiusX = "30" RadiusY = "30" />`

`<RectangleGeometry Rect = "25,55 100 30" />`

`<LineGeometry StartPoint="0,0" EndPoint="70,30" />`

`<LineGeometry StartPoint="70,30" EndPoint="0,30" />`

`</GeometryGroup>`

`</Path.Data>`

`</Path>`

图 [28-5](#Fig5) 中的图像可以使用之前显示的`Line`、`Ellipse`和`Rectangle`类来渲染。然而，这会将各种`UIElement`对象放到内存中。当您使用几何图形对要绘制的绘图点进行建模，然后将几何图形集合放入一个可以呈现数据的容器(在本例中为`Path`)中时，您可以减少内存开销。

现在回想一下，`Path`与`System.Windows.Shapes`的任何其他成员具有相同的继承链，因此能够发送与其他`UIElements`相同的事件通知。因此，如果您要在 Visual Studio 项目中定义这个相同的`<Path>`元素，您可以通过处理鼠标事件来确定用户是否单击了扫描行中的任何位置(记住，Kaxaml 不允许您处理您所创作的标记的事件)。

#### “微型语言”的路径建模

在表 [28-3](#Tab3) 中列出的所有类中，`PathGeometry`在 XAML 或代码方面是最复杂的。这是因为`PathGeometry`的每一段都是由包含各种段和图形的对象组成的(例如:`ArcSegment`、`BezierSegment`、`LineSegment`、`PolyBezierSegment`、`PolyLineSegment`、`PolyQuadraticBezierSegment`等)。).下面是一个`Path`对象的示例，其`Data`属性已被设置为由各种图形和线段组成的`<PathGeometry>`:

`<Path Stroke="Black" StrokeThickness="1" >`

`<Path.Data>`

`<PathGeometry>`

`<PathGeometry.Figures>`

`<PathFigure StartPoint="10,50">`

`<PathFigure.Segments>`

`<BezierSegment`

`Point1="100,0"`

`Point2="200,200"`

`Point3="300,100"/>`

`<LineSegment Point="400,100" />`

`<` `ArcSegment`

`Size="50,50" RotationAngle="45"`

`IsLargeArc="True" SweepDirection="Clockwise"`

`Point="200,100"/>`

`</PathFigure.Segments>`

`</PathFigure>`

`</PathGeometry.Figures>`

`</PathGeometry>`

`</Path.Data>`

`</Path>`

现在，说实话，很少有程序员需要通过直接描述`Geometry`或`PathSegment`派生类来手工构建复杂的 2D 映像。在本章的后面，你将学习如何将矢量图形转换成可以在 XAML 中使用的路径语句。

即使有这些工具的帮助，定义一个复杂的`Path`对象所需的 XAML 量也将是可怕的，因为数据由各种`Geometry`或`PathSegment`派生类的完整描述组成。为了产生更简洁紧凑的标记，`Path`类被设计成能够理解一种专门的“迷你语言”。

例如，与其将`Path`的`Data`属性设置为`Geometry`和`PathSegment`派生类型的集合，不如将`Data`属性设置为包含许多已知符号和定义要呈现的形状的各种值的单个字符串文字。下面是一个简单的例子，结果输出如图 [28-6](#Fig6) 所示:

![A978-1-4842-1332-2_28_Fig6_HTML.jpg](img/A978-1-4842-1332-2_28_Fig6_HTML.jpg)

图 28-6。

The path mini-language allows you to compactly describe a `Geometry`/`PathSegment` object model

`<Path Stroke="Black" StrokeThickness="3"`

`Data="M 10,75 C 70,15 250,270 300,175 H 240" />`

`M`命令(移动的缩写)取一个 X，Y 位置，代表绘图的起点。`C`命令采用一系列绘图点来绘制一条曲线(确切地说是一条三次贝塞尔曲线)，而`H`绘制一条水平线。

现在，老实说，您需要手动构建或解析包含 path 微型语言指令的字符串文字的机会微乎其微。然而，至少，当你看到 XAML 开发的专用工具时，你将不再感到惊讶。如果您有兴趣研究这种特殊语法的细节，请在。NET Framework 4.6 SDK 文档。

## WPF 画笔和钢笔

每个 WPF 图形渲染选项(形状、绘图和几何图形以及视觉效果)都大量使用了画笔，这允许您控制如何填充 2D 表面的内部。WPF 提供了六种不同的笔刷类型，它们都扩展了`System.Windows.Media.Brush`。虽然`Brush`是抽象的，但是表 [28-4](#Tab4) 中描述的后代可以用来填充一个区域，其中几乎包含任何可以想到的选项。

表 28-4。

WPF `Brush`-Derived Types

<colgroup><col> <col></colgroup> 
| 刷型 | 生命的意义 |
| --- | --- |
| `DrawingBrush` | 用从`Drawing`派生的对象(`GeometryDrawing`、`ImageDrawing`或`VideoDrawing`)绘制区域 |
| `ImageBrush` | 用图像绘制一个区域(由一个`ImageSource`对象表示) |
| `LinearGradientBrush` | 用线性渐变绘制区域 |
| `RadialGradientBrush` | 用径向渐变绘制区域 |
| `SolidColorBrush` | 使用`Color`属性设置，绘制单一颜色 |
| `VisualBrush` | 用从`Visual`派生的对象(`DrawingVisual`、`Viewport3DVisual`和`ContainerVisual`)绘制一个区域 |

`DrawingBrush`和`VisualBrush`类允许你基于现有的`Drawing`或`Visual`派生类来构建画笔。当你使用 WPF 的另外两个图形选项(绘图或视觉)时，会用到这些笔刷类，我们将在本章的后面进行讨论。

顾名思义，`ImageBrush`通过设置`ImageSource`属性，让您构建一个显示来自外部文件或嵌入式应用资源的图像数据的画笔。剩下的笔刷类型(`LinearGradientBrush`和`RadialGradientBrush`)很容易使用，尽管输入所需的 XAML 可能有点冗长。幸运的是，Visual Studio 支持集成的画笔编辑器，这使得生成风格化的画笔变得简单。

### 使用 Visual Studio 配置画笔

让我们更新你的 WPF 绘图程序，RenderingWithShapes，使用一些更有趣的笔刷。到目前为止，您用来在工具栏上呈现数据的三个形状都使用简单的纯色，因此您可以使用简单的字符串来获取它们的值。为了增加一点趣味，你现在将使用集成的笔刷编辑器。确保初始窗口的 XAML 编辑器是 IDE 中打开的窗口，并选择`Ellipse`元素。现在，在属性窗口中，定位笔刷类别，然后点击顶部列出的`Fill`属性(参见图 [28-7](#Fig7) )。

![A978-1-4842-1332-2_28_Fig7_HTML.jpg](img/A978-1-4842-1332-2_28_Fig7_HTML.jpg)

图 28-7。

Any property that requires a brush can be configured with the integrated brush editor

在画笔编辑器的顶部，你会看到一组属性，它们都是所选项目的“画笔兼容的”(例如，`Fill`、`Stroke`和`OpacityMask`)。在这下面，你会看到一系列的标签，允许你配置不同类型的画笔，包括当前的纯色画笔。您可以使用颜色选择器工具以及 ARGB (alpha、红色、绿色和蓝色，其中“alpha”控制透明度)编辑器来控制当前画笔的颜色。使用这些滑块和相关的颜色选择区域，您可以创建任何种类的纯色。使用这些工具来改变你的`Ellipse`的`Fill`颜色，并查看生成的 XAML。您会注意到颜色是以十六进制值存储的，例如

`<Ellipse Fill="#FF47CE47" Height="35" Width="35" />`

更有趣的是，这个编辑器允许您配置渐变画笔，用于定义一系列颜色和过渡点。回想一下，这个笔刷编辑器为您提供了一组选项卡，第一个选项卡允许您为无渲染输出设置空笔刷。其他四个允许你设置一个纯色笔刷(你刚刚检查的)，渐变笔刷，拼贴笔刷，或者图像笔刷。

点击渐变画笔按钮，编辑器将显示一些新的选项(见图 [28-8](#Fig8) )。左下方的三个按钮允许您选择线性渐变、径向渐变或反转渐变停止点。最底部的条将显示每个渐变停止点的当前颜色，每个渐变停止点都由条上的“拇指”标记。当您在渐变条周围拖移这些滑块时，您可以控制渐变偏移。此外，当您单击给定的缩略图时，您可以通过颜色选择器更改特定渐变停止点的颜色。最后，如果您直接点按渐变条，您可以添加额外的渐变停止点。

![A978-1-4842-1332-2_28_Fig8_HTML.jpg](img/A978-1-4842-1332-2_28_Fig8_HTML.jpg)

图 28-8。

The Visual Studio brush editor allows you to build basic gradient brushes

花几分钟时间使用这个编辑器来创建一个包含三个渐变停止点的径向渐变画笔，设置为你选择的颜色。图 [28-8](#Fig8) 显示了你刚刚构建的笔刷，使用了三种不同的绿色。

完成后，IDE 将使用自定义画笔更新您的 XAML，使用属性元素语法设置为画笔兼容属性(在本例中为`Ellipse`的`Fill`属性)，例如

`<Ellipse Height="35" Width="35">`

`<Ellipse.Fill>`

`<RadialGradientBrush>`

`<GradientStop Color="#FF87E71B" Offset="0.589" />`

`<GradientStop Color="#FF2BA92B" Offset="0.013" />`

`<GradientStop Color="#FF34B71B" Offset="1" />`

`</RadialGradientBrush>`

`</Ellipse.Fill>`

`</Ellipse>`

### 在代码中配置画笔

现在你已经为你的`Ellipse`的 XAML 定义构建了一个自定义笔刷，相应的 C#代码已经过时了，因为它仍然会渲染一个实心的绿色圆圈。为了同步备份，更新正确的`case`语句来使用你刚刚创建的笔刷。以下是必要的更新，看起来比你想象的要复杂，因为你正在通过`System.Windows.Media.ColorConverter`类将十六进制值转换成一个合适的`Color`对象(修改后的输出见图 [28-9](#Fig9) ):

![A978-1-4842-1332-2_28_Fig9_HTML.jpg](img/A978-1-4842-1332-2_28_Fig9_HTML.jpg)

图 28-9。

Drawing circles with a bit more pizzazz!

`case SelectedShape.Circle:`

`shapeToRender = new Ellipse() { Height = 35, Width = 35 };`

`// Make a RadialGradientBrush in code!`

`RadialGradientBrush brush = new RadialGradientBrush();`

`brush.GradientStops.Add(new GradientStop(`

`(Color)ColorConverter.ConvertFromString("#FF87E71B"), 0.589));`

`brush.GradientStops.Add(new GradientStop(`

`(Color)ColorConverter.ConvertFromString("#FF2BA92B"), 0.013));`

`brush.GradientStops.Add(new GradientStop(`

`(Color)ColorConverter.ConvertFromString("#FF34B71B"), 1));`

`shapeToRender.Fill = brush;`

`break;`

顺便说一下，您可以通过使用`Colors`枚举指定一个简单的颜色作为第一个构造函数参数来构建`GradientStop`对象，这将返回一个已配置的`Color`对象。

`GradientStop g = new GradientStop(Colors.Aquamarine, 1);`

或者，如果您需要更精细的控制，您可以传入一个已配置的`Color`对象，如下所示:

`Color myColor = new Color() { R = 200, G = 100, B = 20, A = 40 };`

`GradientStop g = new GradientStop(myColor, 34);`

当然，`Colors`枚举和`Color`类并不局限于渐变画笔。您可以在任何需要用代码表示颜色值的时候使用它们。

### 配置笔

与画笔相比，钢笔是绘制几何图形边界的对象，或者在`Line`或`PolyLine`类的情况下，是线条几何图形本身。具体来说，`Pen`类允许你绘制一个指定的厚度，用一个`double`值表示。此外，`Pen`可以配置与`Shape`类相同的属性，比如开始和停止笔帽、点划线图案等等。例如，您可以将以下标记添加到形状中，以定义钢笔属性:

`<Pen Thickness="10" LineJoin="Round" EndLineCap="Triangle" StartLineCap="Round" />`

在许多情况下，您不需要直接创建一个`Pen`对象，因为这将在您为属性赋值时间接完成，例如将`StrokeThickness`赋值给一个`Shape`派生的类型(以及其他的`UIElements`)。然而，当使用`Drawing`派生的类型时，构建一个定制的`Pen`对象是非常方便的(将在本章后面描述)。Visual Studio 本身没有笔编辑器，但它允许您使用“属性”窗口配置选定项的所有以笔画为中心的属性。

## 应用图形转换

为了总结我们对使用形状的讨论，让我们来讨论转换的话题。WPF 附带了许多扩展抽象基类的类。表 [28-5](#Tab5) 记录了许多关键的现成的`Transform`派生类。

表 28-5。

Key Descendants of the `System.Windows.Media.Transform` Type

<colgroup><col> <col></colgroup> 
| 类型 | 生命的意义 |
| --- | --- |
| `MatrixTransform` | 创建任意矩阵变换，用于操作 2D 平面中的对象或坐标系 |
| `RotateTransform` | 围绕 2D (x，y)坐标系中的指定点顺时针旋转对象 |
| `ScaleTransform` | 在 2D (x，y)坐标系中缩放对象 |
| `SkewTransform` | 在 2D (x，y)坐标系中倾斜对象 |
| `TranslateTransform` | 在二维(x-y)坐标系中平移(移动)对象 |
| `TransformGroup` | 表示由其他`Transform`对象组成的复合`Transform` |

变换可以应用于任何`UIElement`(例如，`Shape`的后代以及诸如`Buttons`、`TextBoxes`等控件)。使用这些转换类，您可以以给定的角度呈现图形数据，在表面上倾斜图像，并以各种方式扩展、收缩或翻转目标项目。

Note

虽然变换对象可以在任何地方使用，但您会发现它们在处理 WPF 动画和自定义控件模板时最有用。正如您将在本章后面看到的，您可以使用 WPF 动画为自定义控件的最终用户提供视觉提示。

可以将变换(或一整套变换)分配给目标对象(例如，`Button`、`Path`等)。)使用两个共同的属性，`LayoutTransform`和`RenderTransform`。

`LayoutTransform`属性很有帮助，因为转换发生在元素呈现到布局管理器之前，因此转换不会影响 z 排序操作(换句话说，转换后的图像数据不会重叠)。

另一方面,`RenderTransform`属性发生在项目进入它们的容器之后，因此很有可能元素可以根据它们在容器中的排列方式以相互重叠的方式进行转换。

### 转换的初步观察

稍后，您将向 RenderingWithShapes 项目添加一些转换逻辑。然而，要查看运行中的转换对象，打开 Kaxaml(或您的自定义 xaml 编辑器)并在根`<Page>`或`<Window>`中定义一个简单的`<StackPanel>`，并将`Orientation`属性设置为`Horizontal`。现在，添加下面的`<Rectangle>`，它将使用`RotateTransform`对象以 45 度角绘制:

`<!--``A Rectangle with a rotate``transformation``.`T4】

`<Rectangle Height ="100" Width ="40" Fill ="Red">`

`<Rectangle.LayoutTransform>`

`<RotateTransform Angle ="45"/>`

`</Rectangle.LayoutTransform>`

`</Rectangle>`

这里有一个`<Button>`在表面上倾斜了 20 度，使用的是一个`<SkewTransform>`:

`<!--``A Button with a skew``transformation``.`T4】

`<Button Content ="Click Me!" Width="95" Height="40">`

`<Button.LayoutTransform>`

`<SkewTransform AngleX ="20" AngleY ="20"/>`

`</Button.LayoutTransform>`

`</Button>`

为了更好地测量，这里有一个用`ScaleTransform`缩放了 20 度的`<Ellipse>`(注意设置为初始`Height`和`Width`的值)，以及一个应用了一组变换对象的`<TextBox>`:

`<!--``An Ellipse that has been scaled by 20%``.`T3】

`<Ellipse Fill ="Blue" Width="5" Height="5">`

`<Ellipse.LayoutTransform>`

`<ScaleTransform ScaleX ="20" ScaleY ="20"/>`

`</Ellipse.LayoutTransform>`

`</Ellipse>`

`<!--``A TextBox that has been rotated and``skewed``.`T4】

`<TextBox Text ="Me Too!" Width="50" Height="40">`

`<TextBox.LayoutTransform>`

`<TransformGroup>`

`<RotateTransform Angle ="45"/>`

`<SkewTransform AngleX ="5" AngleY ="20"/>`

`</TransformGroup>`

`</TextBox.LayoutTransform>`

`</TextBox>`

请注意，当应用转换时，您不需要执行任何手动计算来正确地响应点击测试、输入焦点等等。WPF 图形引擎代表你处理这样的任务。例如，在图 [28-10](#Fig10) 中，你可以看到`TextBox`仍然对键盘输入有反应。

![A978-1-4842-1332-2_28_Fig10_HTML.jpg](img/A978-1-4842-1332-2_28_Fig10_HTML.jpg)

图 28-10。

The results of graphical transformation objects

### 转换您的画布数据

现在，让我们将一些转换逻辑合并到你的 RenderingWithShapes 示例中。除了将变换对象应用于单个项目(例如，`Rectangle`、`TextBox`等)。)，您也可以将转换对象应用到布局管理器，以便转换所有内部数据。例如，你可以以一个角度渲染主窗口的整个`<DockPanel>`:

`<DockPanel LastChildFill="True">`

`<DockPanel.LayoutTransform>`

`<RotateTransform Angle="45"/>`

`</DockPanel.LayoutTransform>`

`...`

`</DockPanel>`

对于这个例子来说这有点极端，所以让我们添加一个最终的(不太激进的)特性，允许用户翻转整个`Canvas`和所有包含的图形。首先将最后一个`<ToggleButton>`添加到您的`<ToolBar>`中，定义如下:

`<ToggleButton Name="flipCanvas" Click="flipCanvas_Click" Content="Flip Canvas!"/>`

在`Click`事件处理程序中，创建一个`RotateTransform`对象，如果这个新的`ToggleButton`被点击，通过`LayoutTransform`属性将它连接到`Canvas`对象。如果没有点击`ToggleButton`，通过将相同的属性设置为`null`来移除转换。

`private void flipCanvas_Click(object sender, RoutedEventArgs e)`

`{`

`if (flipCanvas.IsChecked == true)`

`{`

`RotateTransform rotate = new RotateTransform(-180);`

`canvasDrawingArea.LayoutTransform = rotate;`

`}`

`else`

`{`

`canvasDrawingArea.LayoutTransform = null;`

`}`

`}`

运行您的应用，并在整个画布区域添加一些图形。如果你点击你的新按钮，你会发现形状数据超出了画布的边界！这是因为你没有定义一个裁剪区域(见图 [28-11](#Fig11) )。

![A978-1-4842-1332-2_28_Fig11_HTML.jpg](img/A978-1-4842-1332-2_28_Fig11_HTML.jpg)

图 28-11。

Oops! Your data is flowing outside of the canvas after the transformation!

解决这个问题很简单。不需要手工编写复杂的裁剪逻辑代码，只需将`<Canvas>`的`ClipToBounds`属性设置为`true`，这样可以防止子元素被呈现在父元素的边界之外。如果你再次运行你的程序，你会发现数据不会从画布边界溢出。

`<Canvas ClipToBounds = "True" ... >`

最后一个微小的修改是，当您通过按下切换按钮来翻转画布，然后单击画布来绘制新的形状时，您单击的点不是应用图形数据的点。相反，数据呈现在鼠标光标上方。

要解决这个问题，请查看这个示例的解决方案代码。关键是添加一个最终的布尔成员变量(`isFlipped`)，它将在呈现发生之前(通过`RenderTransform`)将相同的转换对象应用到正在绘制的形状。代码的关键在于:

`private bool _isFlipped = false;`

`private void canvasDrawingArea_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)`

`{`

`Shape shapeToRender = null;`

`...`

`// isFlipped is a private boolean field. This is toggled when the`

`// toggle button is clicked.`

`if (_isFlipped)`

`{`

`RotateTransform rotate = new RotateTransform(-180);`

`shapeToRender.RenderTransform = rotate;`

`}`

`// Set top/left to draw in the canvas.`

`Canvas.SetLeft(shapeToRender, e.GetPosition(canvasDrawingArea).X);`

`Canvas.SetTop(shapeToRender, e.GetPosition(canvasDrawingArea).Y);`

`// Draw shape!`

`canvasDrawingArea.Children.Add(shapeToRender);`

`}`

`private void flipCanvas_Click(object sender, RoutedEventArgs e)`

`{`

`if (flipCanvas.IsChecked == true)`

`{`

`RotateTransform rotate = new RotateTransform(-180);`

`canvasDrawingArea.LayoutTransform = rotate;`

`}`

`else`

`{`

`canvasDrawingArea.LayoutTransform = null;`

`}`

`}`

这就完成了对`System.Windows.Shapes`、笔刷和变换的检查。在查看使用绘图和几何图形呈现图形的作用之前，让我们看看如何使用 Visual Studio 来简化处理基本图形的方式。

Source Code

RenderingWithShapes 项目可以在 [`Chapter 28`](28.html) 子目录中找到。

## 使用 Visual Studio 转换编辑器

在前面的示例中，您通过手动输入标记和创作一些 C#代码来应用各种转换。虽然这肯定是有用的，但是您会很高兴地知道最新版本的 Visual Studio 附带了一个集成的转换编辑器。它不如 Expression Blend 中的工具强大，但它允许您使用集成工具轻松生成必要的转换标记。回想一下，任何 UI 元素都可以成为转换服务的接受者，包括包含各种 UI 元素的布局系统。为了演示 Visual Studio 的转换编辑器的用法，创建一个名为 FunWithTransforms 的新 WPF 应用。

### 构建初始布局

首先，使用集成的网格编辑器将最初的`Grid`分成两列(具体大小无关紧要)。现在，在你的工具箱中找到`StackPanel`控件，添加这个项目来占据`Grid`第一列的整个空间，就像这样:

`<Grid>`

`<Grid.ColumnDefinitions>`

`<ColumnDefinition Width="*"/>`

`<ColumnDefinition Width="*"/>`

`</Grid.ColumnDefinitions>`

`<StakPanelGrid.Row="0" Grid.Columne="0"></StackPanel>`

`</Grid>`

接下来，在文档轮廓面板中选择新的`StackPanel`，并在`StackPanel`容器中添加三个`Button`控件(参见图 [28-12](#Fig12) )。

![A978-1-4842-1332-2_28_Fig12_HTML.jpg](img/A978-1-4842-1332-2_28_Fig12_HTML.jpg)

图 28-12。

A `StackPanel` of `Button` controls

现在，一次选择一个`Button`，并将`Content`属性(位于属性窗口的公共属性部分)更改为值`Skew`、`Rotate`和`Flip`。同样，使用属性面板的名称区域给每个按钮一个合适的名称，比如`btnSkew`、`btnRotate`和`btnFlip`；使用属性面板的 Events 选项卡，为每个`Button`处理`Click`事件。您将很快实现这些处理程序。

为了完成 UI，创建一个您选择的图形(使用本章中的任何技术)，在`Grid`的第二列中定义。图 [28-13](#Fig13) 显示了最终的布局。这里，两个`Ellipse`控件组合成一个`Canvas`控件，命名为`myCanvas`。

![A978-1-4842-1332-2_28_Fig13_HTML.jpg](img/A978-1-4842-1332-2_28_Fig13_HTML.jpg)

图 28-13。

The layout of your transformation example

示例中使用的标记如下所示:

`<Canvas x:Name="myCanvas" Grid.Column="1" Grid.Row="0">`

`<Ellipse HorizontalAlignment="Left" VerticalAlignment="Top"`

`Height="186"  Width="92" Stroke="Black"`

`Canvas.Left="20" Canvas.Top="31">`

`<Ellipse.Fill>`

`<RadialGradientBrush>`

`<GradientStop Color="#FF951ED8" Offset="0.215"/>`

`<GradientStop Color="#FF2FECB0" Offset="1"/>`

`</RadialGradientBrush>`

`</Ellipse.Fill>`

`</Ellipse>`

`<Ellipse HorizontalAlignment="Left" VerticalAlignment="Top"`

`Height="101" Width="110" Stroke="Black"`

`Canvas.Left="122" Canvas.Top="126">`

`<Ellipse.Fill>`

`<LinearGradientBrush EndPoint="0.5,1" StartPoint="0.5,0">`

`<GradientStop Color="#FFB91DDC" Offset="0.355"/>`

`<GradientStop Color="#FFB0381D" Offset="1"/>`

`</LinearGradientBrush>`

`</Ellipse.Fill>`

`</Ellipse>`

`</Canvas>`

### 在设计时应用转换

如前所述，Visual Studio 提供了一个集成的转换编辑器，它可以在属性面板中找到。找到该区域，并确保展开转换部分以查看编辑器的 RenderTransform 和 LayoutTransform 部分(参见图 [28-14](#Fig14) )。

![A978-1-4842-1332-2_28_Fig14_HTML.jpg](img/A978-1-4842-1332-2_28_Fig14_HTML.jpg)

图 28-14。

The Transform editor

与画笔部分类似，变换部分提供了许多选项卡来配置对当前所选项目的各种类型的图形变换。表 [28-6](#Tab6) 描述了每个转换选项，按照从左到右评估每个选项卡的顺序列出。

表 28-6。

Blend Transformation Options

<colgroup><col> <col></colgroup> 
| 转换选项 | 生命的意义 |
| --- | --- |
| 翻译 | 允许您在 X，Y 位置上偏移项目的位置。 |
| 辐状的 | 允许您将项目旋转 360 度。 |
| 规模 | 允许您在 X 和 Y 方向上放大或缩小项目。 |
| 斜交 | 允许您将包含选定项目的边界框在 X 和 Y 方向上倾斜一个因子。 |
| 中心点 | 旋转或翻转对象时，项目会相对于一个固定点移动，该点称为对象的中心点。默认情况下，对象的中心点位于对象的中心；但是，这种变换允许您更改对象的中心点，以便围绕不同的点旋转或翻转对象。 |
| 翻转 | 基于 X 或 Y 中心点翻转选定项目。 |

我建议您使用您的自定义形状作为目标来测试这些转换中的每一个(只需按 Ctrl+Z 来撤消前面的操作)。像 Transform Properties 面板的许多其他方面一样，每个转换部分都有一组独特的配置选项，当您修改时，这些选项应该变得很容易理解。例如，倾斜变换编辑器允许您设置 X 和 Y 倾斜值，翻转变换编辑器允许您在 X 或 Y 轴上翻转，等等。

### 用代码转换画布

每个`Click`事件处理程序的实现或多或少是相同的。您将配置一个转换对象，并将其分配给`myCanvas`对象。然后，当您运行应用时，您可以单击一个按钮来查看应用转换的结果。以下是每个事件处理程序的完整代码(注意，您正在设置`LayoutTransform`属性，因此形状数据保持相对于父容器的位置):

`private void btnFlip_Click(object sender, System.Windows.RoutedEventArgs e)`

`{`

`myCanvas.LayoutTransform = new ScaleTransform(-1, 1);`

`}`

`private void btnRotate_Click(object sender, System.Windows.RoutedEventArgs e)`

`{`

`myCanvas.LayoutTransform = new RotateTransform(180);`

`}`

`private void btnSkew_Click(object sender, System.Windows.RoutedEventArgs e)`

`{`

`myCanvas.LayoutTransform = new SkewTransform(40, -20);`

`}`

Source Code

FunWithTransformations 项目可以在 [`Chapter 28`](28.html) 子目录中找到。

## 使用绘图和几何图形呈现图形数据

虽然`Shape`类型允许你生成任何类型的交互式二维表面，但是由于它们丰富的继承链，它们需要相当多的内存开销。虽然`Path`类可以使用包含的几何图形(而不是其他形状的大量集合)来帮助消除一些开销，但 WPF 提供了一个复杂的绘图和几何图形编程接口，可以呈现更轻量级的 2D 矢量图像。

这个 API 的入口点是抽象的`System.Windows.Media.Drawing`类(在`PresentationCore.dll`中)，它本身只不过是定义一个边界矩形来保存渲染。图 [28-15](#Fig15) 显示了`Drawing`类的继承链明显比`Shape`更轻量级，因为`UIElement`和`FrameworkElement`都不在继承链中。

![A978-1-4842-1332-2_28_Fig15_HTML.jpg](img/A978-1-4842-1332-2_28_Fig15_HTML.jpg)

图 28-15。

The `Drawing` class is more lightwight than `Shape`

WPF 提供了各种扩展`Drawing`的类，每个类都代表了一种绘制内容的特定方式，如表 [28-7](#Tab7) 中所述。

表 28-7。

WPF `Drawing`-Derived Types

<colgroup><col> <col></colgroup> 
| 类型 | 生命的意义 |
| --- | --- |
| `DrawingGroup` | 用于将一组独立的`Drawing`派生对象合并到一个合成渲染中。 |
| `GeometryDrawing` | 用于以非常轻量级的方式渲染 2D 图形。 |
| `GlyphRunDrawing` | 用于使用 WPF 图形呈现服务呈现文本数据。 |
| `ImageDrawing` | 用于将图像文件或几何体集渲染到边框中。 |
| `VideoDrawing` | 用于播放音频文件或视频文件。只有使用过程代码才能充分利用这种类型。如果你想通过 XAML 播放视频，`MediaPlayer`型是更好的选择。 |

因为它们更轻量级，`Drawing`派生的类型不具有处理输入事件的内在支持，因为它们不是`UIElements`或`FrameworkElements`(尽管有可能以编程方式执行命中测试逻辑)。

从`Drawing`派生的类型和从`Shape`派生的类型之间的另一个关键区别是，从`Drawing`派生的类型没有能力呈现它们自己，因为它们不是从`UIElement`派生的！相反，派生类型必须放在宿主对象中(特别是，`DrawingImage`、`DrawingBrush`或`DrawingVisual`)才能显示它们的内容。

允许你在 WPF 图像控件中放置图形和几何图形，该控件通常用于显示来自外部文件的数据。`DrawingBrush`允许您基于图形及其几何图形构建画笔，以便设置需要画笔的属性。最后，`DrawingVisual`仅用于图形渲染的“视觉”层，完全通过 C#代码驱动。

虽然使用绘图比使用简单形状要复杂一些，但是这种图形合成与图形呈现的分离使得`Drawing`派生类型比`Shape`派生类型更加轻量级，同时仍然保留了关键服务。

### 使用几何图形构建画笔

在本章的前面，您用一组几何图形填充了一个`Path`,就像这样:

`<Path Fill = "Orange" Stroke = "Blue" StrokeThickness = "3">`

`<Path.Data>`

`<GeometryGroup>`

`<EllipseGeometry Center = "75,70"`

`RadiusX = "30" RadiusY = "30" />`

`<RectangleGeometry Rect = "25,55 100 30" />`

`<LineGeometry StartPoint="0,0" EndPoint="70,30" />`

`<LineGeometry StartPoint="70,30" EndPoint="0,30" />`

`</GeometryGroup>`

`</Path.Data>`

`</Path>`

通过这样做，你从`Path`获得了交互性，但是考虑到你的几何形状，仍然是相当轻量级的。但是，如果您想要呈现相同的输出，并且不需要任何(现成的)交互性，您可以将相同的`<GeometryGroup>`放在`DrawingBrush`中，如下所示:

`<DrawingBrush>`

`<DrawingBrush.Drawing>`

`<GeometryDrawing>`

`<GeometryDrawing.Geometry>`

`<GeometryGroup>`

`<EllipseGeometry Center = "75,70"`

`RadiusX = "30" RadiusY = "30" />`

`<RectangleGeometry Rect = "25,55 100 30" />`

`<LineGeometry StartPoint="0,0" EndPoint="70,30" />`

`<LineGeometry StartPoint="70,30" EndPoint="0,30" />`

`</GeometryGroup>`

`</GeometryDrawing.Geometry>`

`<!--``A custom pen to draw the borders.`T2】

`<GeometryDrawing.Pen>`

`<Pen Brush="Blue" Thickness="3"/>`

`</GeometryDrawing.Pen>`

`<!--``A custom brush to fill the interior.`T2】

`<GeometryDrawing.Brush>`

`<SolidColorBrush Color="Orange"/>`

`</GeometryDrawing.Brush>`

`</GeometryDrawing>`

`</DrawingBrush.Drawing>`

`</DrawingBrush>`

当您将一组几何图形放入`DrawingBrush`时，您还需要建立用于绘制边界的`Pen`对象，因为您不再从`Shape`基类继承`Stroke`属性。在这里，您创建了一个`<Pen>`，其设置与上一个`Path`示例中的`Stroke`和`StrokeThickness`值相同。

此外，由于您不再从`Shape`继承一个`Fill`属性，您还需要使用属性元素语法来定义一个用于`<DrawingGeometry>`的笔刷对象，这里是一个纯色的橙色笔刷，就像前面的`Path`设置一样。

### 用画笔画画

现在您有了一个`DrawingBrush`，您可以用它来设置任何需要 brush 对象的属性的值。例如，如果您在 Kaxaml 中创作这个标记，您可以使用属性元素语法在一个`Page`的整个表面上绘制您的图形，如下所示:

`<Page`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`<Page.Background>`

`<!--``Same DrawingBrush as seen above.`T2】

`<DrawingBrush>`

`...`

`</DrawingBrush>`

`</Page.Background>`

`</Page>`

或者，你可以使用这个`<DrawingBrush>`来设置一个不同的画笔兼容属性，比如一个`Button`的`Background`属性:

`<` `Page`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`<Button Height="100" Width="100">`

`<Button.Background>`

`<!--``Same DrawingBrush as seen above.`T2】

`<DrawingBrush>`

`...`

`</DrawingBrush>`

`</Button.Background>`

`</Button>`

`</Page>`

无论你用自定义的`<DrawingBrush>`设置哪个笔刷兼容的属性，底线是你渲染的 2D 矢量图像比用形状渲染的 2D 图像开销要少得多。

### 在绘图图像中包含绘图类型

`DrawingImage`类型允许你将你的绘图几何图形插入到 WPF `<Image>`控件中。请考虑以下几点:

`<Page`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`<Image Height="100" Width="100">`

`<Image.Source>`

`<DrawingImage>`

`<DrawingImage.Drawing>`

`<GeometryDrawing>`

`<GeometryDrawing.Geometry>`

`<GeometryGroup>`

`<EllipseGeometry Center = "75,70"`

`RadiusX = "30" RadiusY = "30" />`

`<RectangleGeometry Rect = "25,55 100 30" />`

`<LineGeometry StartPoint="0,0" EndPoint="70,30" />`

`<LineGeometry StartPoint="70,30" EndPoint="0,30" />`

`</GeometryGroup>`

`</GeometryDrawing.Geometry>`

`<!--``A custom pen to draw the borders.`T2】

`<GeometryDrawing.Pen>`

`<Pen Brush="Blue" Thickness="3"/>`

`</GeometryDrawing.Pen>`

`<!--``A custom brush to fill the interior.`T2】

`<GeometryDrawing.Brush>`

`<SolidColorBrush Color="Orange"/>`

`</GeometryDrawing.Brush>`

`</GeometryDrawing>`

`</DrawingImage.Drawing>`

`</DrawingImage>`

`</Image.Source>`

`</Image>`

`</Page>`

在这种情况下，你的`<GeometryDrawing>`被放入了一个`<DrawingImage>`，而不是一个`<DrawingBrush>`。使用这个`<DrawingImage>`，可以设置`Image`控件的`Source`属性。

## 使用矢量图像

您可能同意，对于图形艺术家来说，使用 Visual Studio 提供的工具和技术来创建复杂的基于矢量的图像是一件非常具有挑战性的事情。图形艺术家有自己的一套工具，可以制作出令人惊叹的矢量图形。无论是 Visual Studio 还是其配套的 Expression Blend for Visual Studio 都不具备这种设计能力。在将矢量图像导入 WPF 应用之前，必须将其转换为路径表达式。此时，您可以使用 Visual Studio 针对生成的对象模型进行编程。

Note

本文的前几版展示了一个名为 Expression Design 的软件包。Expression Design 是 Expression Studio 的产品之一，不幸的是，整个套件不再更新。虽然如果你有 MSDN 订阅，你仍然可以访问该软件，但在这本书的这个版本中，我使用开源软件和打印机技巧将矢量图形转换为 XAML 渲染所需的路径信息。正在使用的图像(`laser_sign.svg`)以及导出的路径(`laser_sign.xaml`)数据包含在下载文件的 [`Chapter 28`](28.html) 文件夹中。图片最初来自维基百科，位于本文: [`https://en.wikipedia.org/wiki/Hazard_symbol`](https://en.wikipedia.org/wiki/Hazard_symbol) 。

### 将样本矢量图形文件转换为 XAML

在将复杂的图形数据(如矢量图形)导入 WPF 应用之前，您需要将图形转换为路径数据。作为如何做到这一点的示例，从一个示例开始。svg 图像文件，例如前面提到的 laser sign。然后下载并安装一个名为 Inkscape 的开源工具(位于 [`www.inkscape.org`](http://www.inkscape.org/) )。使用 Inkscape，从下载一章中打开`laser_sign.svg`文件。你应该会看到类似图 [28-16](#Fig16) 的东西。

![A978-1-4842-1332-2_28_Fig16_HTML.jpg](img/A978-1-4842-1332-2_28_Fig16_HTML.jpg)

图 28-16。

The laser sign sample graphic in InkScape Note

ImageMagick ( [`www.ImageMagick.org`](http://www.imagemagick.org/) )也是一款非常不错的免费图片处理工具。不幸的是，你很快就会学到的技巧在 Windows 10 上的 ImageMagick 上不起作用。

接下来的步骤一开始看起来有点奇怪，但是一旦你克服了这个奇怪的问题，这是一个将矢量图像转换成 XAML 的简单方法。当您得到想要的图像时，选择文件➤打印菜单选项。接下来，选择微软 XPS Document Writer 作为打印机目标，然后点击打印(参见图 [28-17](#Fig17) )。在下一个屏幕上，输入文件名并选择保存文件的位置，然后单击 Save。现在你有了一个完整的`*.xps`(或`*.oxps`)文件。

![A978-1-4842-1332-2_28_Fig17_HTML.jpg](img/A978-1-4842-1332-2_28_Fig17_HTML.jpg)

图 28-17。

Printing the graphic to the Microsoft XPS Document Printer Note

根据系统配置中的变量数量，生成的文件会有`.xps`或`.oxps`扩展名。无论哪种方式，过程都是一样的。

`*.xps`和`*.oxps`格式实际上是一个 zip 文件。将文件的扩展名重命名为`.zip`，就可以在文件资源管理器(或者 7-zip，或者你喜欢的存档工具)中打开文件了。你会看到它包含了如图 [28-18](#Fig18) 所示的层级。

![A978-1-4842-1332-2_28_Fig18_HTML.jpg](img/A978-1-4842-1332-2_28_Fig18_HTML.jpg)

图 28-18。

The folder hierarchy of the printed XPS file

您需要的文件在`Pages`目录(`Documents/1/Pages`)中，并被命名为`1.fpage`。用文本编辑器打开文件，复制除了`<FixedPage>`开始和结束标签之外的所有内容。然后可以将路径数据复制到 MyXAMLPad(您之前编写的)中，并放在主窗口的`Canvas`中。点击查看 XAML 按钮，你会看到你的矢量图形复制在 XAML！图 [28-19](#Fig19) 显示了使用 MyXamlPad 渲染的图像。

![A978-1-4842-1332-2_28_Fig19_HTML.jpg](img/A978-1-4842-1332-2_28_Fig19_HTML.jpg)

图 28-19。

The vector graphic rendered in XAML

### 将图形数据导入 WPF 项目

此时，创建一个名为 InteractiveLaserSign 的新 WPF 应用。将窗口尺寸调整为以下的`height`和`width`，并删除最初的`Grid`控件，替换为`Canvas`:

`<Window x:Class="InteractiveTeddyBear.MainWindow"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`Title="MainWindow" Height="625" Width="675">`

`<Canvas>`

`</Canvas>`

`</Window>`

从 MyXamlPad 中复制整个 XAML(不包括外部的`Canvas`)并粘贴到`MainWindow Canvas`控件中。在设计模式下查看窗口，您将看到在您的应用中复制的标志！

如果您查看文档大纲，您会看到每个 XAML 元素都存在并被考虑在内。这里的目标是找到几行并给每一项取一个名字。虽然您可以手动寻找正确的对象(这将非常繁琐)，但更好的方法是使用可视化设计器单击这些项目。这将在文档大纲编辑器中自动突出显示正确的节点。这个特殊的图形使用两个对象组成每一行，所以单击图形中的一行，查看它在文档编辑器中的位置。检查上面和下面的对象，以发现哪一对是匹配的，然后将它们命名为`Line1_1`和`Line1_2`。对另一条线重复此过程，并将线对命名为 Line2_1 和 Line2_2。为了使交互更容易，将 Line1_1 和 Line2_1 的画笔更改为除黑色之外的另一种颜色，方法是在文档轮廓中选择对象，在属性中选择画笔，然后更改颜色(就像您在本章前面所做的那样)。

### 与标志互动

现在，您将处理对象的单击事件。在设计器上选择 Line1_1 和 Line2_1，激活“属性”窗口的“事件”区域，并根据需要输入事件处理程序名称。对于当前示例，为每个对象处理`MouseLeftButtonDown`事件，每次指定一个惟一的方法名。

下面是一些简单的 C#代码，当单击时会改变每个对象的外观(如果您不想键入这里看到的所有代码，您可以简单地为每个处理程序添加一个`MessageBox.Show()`语句，并显示一条合适的消息):

`private void Line1_1_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)`

`{`

`// Change the color when clicked.`

`Line1_2.Fill = new SolidColorBrush(Colors.Red);`

`}`

`private void Line2_1_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)`

`{`

`// Blur when clicked.`

`System.Windows.Media.Effects.BlurEffect blur =`

`new System.Windows.Media.Effects.BlurEffect();`

`blur.Radius = 10;`

`Line2_1.Effect = blur;`

`}`

现在，运行您的应用。单击线条查看效果。结果应该类似于图 [28-20](#Fig20) 。

![A978-1-4842-1332-2_28_Fig20_HTML.jpg](img/A978-1-4842-1332-2_28_Fig20_HTML.jpg)

图 28-20。

Interacting with complex graphical data

现在，您已经了解了为复杂图形生成路径数据的过程，以及如何在代码中与图形数据进行交互。您可能会同意，专业图形艺术家生成复杂图形数据并将数据导出为 XAML 的能力非常强大。一旦生成了图形数据，开发人员就可以导入标记并针对对象模型进行编程。

Source Code

InteractiveLaserSign 项目可以在 [`Chapter 28`](28.html) 子目录中找到。

## 使用可视层呈现图形数据

使用 WPF 渲染图形数据的最后一个选项称为可视层。如前所述，您只能通过代码访问该层(它对 XAML 不友好)。虽然绝大多数 WPF 应用使用形状、绘图和几何图形都能正常工作，但可视化图层确实提供了渲染大量图形数据的最快方法。奇怪的是，当您需要在非常大的区域上渲染单个图像时，这个非常低级的图形层也很有用。例如，如果您需要用普通的静态图像填充窗口的背景，视觉图层是最快的方法。如果你需要根据用户输入或类似的东西在窗口背景之间快速切换，这也很有用。

我们不会花太多时间深入研究 WPF 编程这方面的细节，但是让我们构建一个小的示例程序来说明基本原理。

### Visual 基类和派生的子类

抽象的`System.Windows.Media.Visual`类类型提供了一个最小的服务集(渲染、点击测试、转换)来渲染图形，但是它不支持额外的非可视服务，这会导致代码膨胀(输入事件、布局服务、样式和数据绑定)。注意图 [28-21](#Fig21) 中所示的`Visual`类型的简单继承链。

![A978-1-4842-1332-2_28_Fig21_HTML.jpg](img/A978-1-4842-1332-2_28_Fig21_HTML.jpg)

图 28-21。

The `Visual` type provides basic hit-testing, coordinate transformation, and bounding box calculations

鉴于`Visual`是一个抽象基类，您需要使用一个派生类型来执行实际的渲染操作。WPF 提供了一些子类，包括`DrawingVisual`、`Viewport3DVisual`和`ContainerVisual`。

在本例中，您将只关注`DrawingVisual`，这是一个轻量级绘图类，用于呈现形状、图像或文本。

### 使用 DrawingVisual 类初探

要使用`DrawingVisual`将数据渲染到表面上，您需要采取以下基本步骤:

*   从`DrawingVisual class`中获取一个`DrawingContext`对象。
*   使用`DrawingContext`渲染图形数据。

这两个步骤代表了将一些数据渲染到表面所需的最少步骤。但是，如果您希望呈现的图形数据能够响应点击测试计算(这对增加用户交互性很重要)，您还需要执行以下附加步骤:

*   更新正在渲染的容器所维护的逻辑树和可视化树。
*   覆盖来自`FrameworkElement`类的两个虚拟方法，允许容器获得您创建的可视数据。

稍后您将检查这最后两个步骤。首先，为了说明如何使用`DrawingVisual`类来呈现 2D 数据，用 Visual Studio 创建一个名为 RenderingWithVisuals 的新 WPF 应用。你的第一个目标是使用一个`DrawingVisual`动态地分配数据给一个 WPF `Image`控件。首先更新窗口的 XAML，就像这样:

`<Window x:Class="RenderingWithVisuals.MainWindow"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`Title=" Fun with the Visual Layer" Height="350" Width="525"`

`Loaded="Window_Loaded" WindowStartupLocation="CenterScreen">`

`<StackPanel Background="AliceBlue" Name="myStackPanel">`

`<Image Name="myImage" Height="80"/>`

`</StackPanel>`

`</Window>`

请注意，您的`<Image>`控件还没有一个`Source`值，因为这将在运行时发生。还要注意，您正在处理窗口的`Loaded`事件，它将使用一个`DrawingBrush`对象完成构建内存中图形数据的工作。下面是`Loaded`事件处理程序的实现:

`private void Window_Loaded(object sender, RoutedEventArgs e)`

`{`

`const int TextFontSize = 30;`

`// Make a System.Windows.Media.FormattedText object.`

`FormattedText text = new FormattedText("Hello Visual Layer!",`

`new System.Globalization.CultureInfo("en-us"),`

`FlowDirection.LeftToRight,`

`new Typeface(this.FontFamily, FontStyles.Italic,`

`FontWeights.DemiBold, FontStretches.UltraExpanded),`

`TextFontSize,`

`Brushes.Green);`

`// Create a DrawingVisual, and obtain the DrawingContext.`

`DrawingVisual drawingVisual = new DrawingVisual();`

`using(DrawingContext drawingContext = drawingVisual.RenderOpen())`

`{`

`// Now, call any of the methods of DrawingContext to render data.`

`drawingContext.DrawRoundedRectangle(Brushes.Yellow, new Pen(Brushes.Black, 5),`

`new Rect(5, 5, 450, 100), 20, 20);`

`drawingContext.DrawText(text, new Point(20, 20));`

`}`

`// Dynamically make a bitmap, using the data in the DrawingVisual.`

`RenderTargetBitmap bmp = new RenderTargetBitmap(500, 100, 100, 90,`

`PixelFormats.Pbgra32);`

`bmp.Render(drawingVisual);`

`// Set the source of the Image control!`

`myImage.Source = bmp;`

`}`

这段代码引入了许多新的 WPF 类，我将在这里对它们进行简单的评论(请务必查看。NET Framework 4.6 SDK 文档以获得完整的详细信息)。该方法首先创建一个新的`FormattedText`对象，表示您正在构建的内存图像的文本部分。如您所见，构造函数允许您指定许多属性，如字体大小、字体系列、前景色和文本本身。

接下来，您通过在`DrawingVisual`实例上调用`RenderOpen()`来获得必要的`DrawingContext`对象。这里，您将一个彩色的圆角矩形呈现到`DrawingVisual`中，后面是您的格式化文本。在这两种情况下，您都是使用硬编码的值将图形数据放入`DrawingVisual`中，这对于生产来说不一定是个好主意，但是对于这个简单的测试来说却很好。

Note

确保在。NET Framework 4.6 SDK 文档来查看所有呈现成员。如果您过去使用过 Windows 窗体图形对象，`DrawingContext`看起来应该非常相似。

最后几个语句将`DrawingVisual`映射到一个`RenderTargetBitmap`对象，该对象是`System.Windows.Media.Imaging`名称空间的成员。这个类将接受一个可视对象，并将其转换成内存中的位图图像。至此，您设置了`Image`控件的`Source`属性，果然，您将看到图 [28-22](#Fig22) 中的输出。

![A978-1-4842-1332-2_28_Fig22_HTML.jpg](img/A978-1-4842-1332-2_28_Fig22_HTML.jpg)

图 28-22。

Using the visual layer to render an in-memory bitmap Note

`System.Windows.Media.Imaging`名称空间包含许多额外的编码类，允许您以各种格式将内存中的`RenderTargetBitmap`对象保存到物理文件中。查看`JpegBitmapEncoder`类(和朋友)了解更多信息。

### 向自定义布局管理器呈现可视数据

虽然使用`DrawingVisual`在 WPF 控件的背景上绘图很有趣，但构建一个自定义布局管理器(`Grid`、`StackPanel`、`Canvas`等)可能更常见。)在内部使用可视层来呈现其内容。在你创建了这样一个定制的布局管理器之后，你可以把它插入到一个普通的窗口(或者`Page`，或者`UserControl`)并且拥有一个使用高度优化的渲染代理的 UI 的一部分，而托管窗口的非关键方面使用图形和绘图来处理剩余的图形数据。

如果您不需要专用布局管理器提供的额外功能，您可以选择简单地扩展`FrameworkElement`，它有必要的基础设施来包含可视项目。为了说明如何做到这一点，在您的项目中插入一个名为`CustomVisualFrameworkElement`的新类。从`FrameworkElement`扩展这个类，并导入`System.Windows`、`System.Windows.Input`和`System.Windows.Media`名称空间。

这个类将维护一个类型为`VisualCollection`的成员变量，它包含两个固定的`DrawingVisual`对象(当然，您可以通过鼠标操作向这个集合添加新成员，但是这个示例将保持简单)。使用以下新功能更新您的类:

`class CustomVisualFrameworkElement : FrameworkElement`

`{`

`// A collection of all the visuals we are building.`

`VisualCollection theVisuals;`

`public CustomVisualFrameworkElement()`

`{`

`// Fill the VisualCollection with a few DrawingVisual objects.`

`// The ctor arg represents the owner of the visuals.`

`theVisuals = new VisualCollection(this);`

`theVisuals.Add(AddRect());`

`theVisuals.Add(AddCircle());`

`}`

`private Visual AddCircle()`

`{`

`DrawingVisual drawingVisual = new DrawingVisual();`

`// Retrieve the DrawingContext in order to create new drawing content.`

`using (DrawingContext drawingContext = drawingVisual.RenderOpen())`

`{`

`// Create a circle and draw it in the DrawingContext.`

`Rect rect = new Rect(new Point(160, 100), new Size(320, 80));`

`drawingContext.DrawEllipse(Brushes.DarkBlue, null, new Point(70, 90), 40, 50);`

`}`

`return drawingVisual;`

`}`

`private Visual AddRect()`

`{`

`DrawingVisual drawingVisual = new DrawingVisual();`

`using (DrawingContext drawingContext = drawingVisual.RenderOpen())`

`{`

`Rect rect = new Rect(new Point(160, 100), new Size(320, 80));`

`drawingContext.DrawRectangle(Brushes.Tomato, null, rect);`

`}`

`return drawingVisual;`

`}`

`}`

现在，在你可以在你的窗口中使用这个自定义的`FrameworkElement`之前，你必须覆盖前面提到的两个关键的虚拟方法，这两个方法都是在渲染过程中由 WPF 内部调用的。`GetVisualChild()`方法从子元素集合中返回指定索引处的子元素。只读`VisualChildrenCount`属性返回该可视集合中可视子元素的数量。这两种方法都很容易实现，因为您可以将真正的工作委托给`VisualCollection`成员变量。

`protected override int VisualChildrenCount`

`{`

`get { return theVisuals.Count; }`

`}`

`protected override Visual GetVisualChild(int index)`

`{`

`// Value must be greater than zero, so do a sainity check.`

`if (index < 0 || index >= theVisuals.Count)`

`{`

`throw new ArgumentOutOfRangeException();`

`}`

`return theVisuals[index];`

`}`

现在，您已经有了足够的功能来测试您的定制类。更新`Window`的 XAML 描述，将一个`CustomVisualFrameworkElement`对象添加到现有的`StackPanel`中。这样做将要求您构建一个自定义的 XML 命名空间，该命名空间映射到您的。NET 命名空间。

`<Window x:Class="RenderingWithVisuals.MainWindow"`

`xmlns="`[`http://schemas.microsoft.com/winfx/2006/xaml/presentation`](http://schemas.microsoft.com/winfx/2006/xaml/presentation)T2】

`xmlns:x="`[`http://schemas.microsoft.com/winfx/2006/xaml`](http://schemas.microsoft.com/winfx/2006/xaml)T2】

`xmlns:custom="clr-namespace:RenderingWithVisuals"`

`Title="Fun with the Visual Layer" Height="350" Width="525"`

`Loaded="Window_Loaded" WindowStartupLocation="CenterScreen">`

`<StackPanel Background="AliceBlue" Name="myStackPanel">`

`<Image Name="myImage" Height="80"/>`

`<custom:CustomVisualFrameworkElement/>`

`</StackPanel>`

`</Window>`

如果一切正常，当您运行程序时，您应该会看到类似于图 [28-23](#Fig23) 的内容。

![A978-1-4842-1332-2_28_Fig23_HTML.jpg](img/A978-1-4842-1332-2_28_Fig23_HTML.jpg)

图 28-23。

Using the visual layer to render data to a custom `FrameworkElement`

### 响应点击测试操作

因为`DrawingVisual`没有`UIElement`或`FrameworkElement`的任何基础设施，您将需要以编程方式添加计算点击测试操作的能力。幸运的是，由于逻辑和可视化树的概念，这在可视化层很容易做到。事实证明，当你创作一个 XAML 的 blob 时，你实际上是在构建一个元素的逻辑树。然而，在每一个逻辑树的背后都有一个更丰富的描述，称为视觉树，它包含更低级的渲染指令。

[第 29 章](29.html)将更详细地探究这些树，但是现在，只要明白，直到你用这些数据结构注册你的自定义视觉，你将不能执行点击测试操作。幸运的是，`VisualCollection`容器为您做了这件事(这解释了为什么您需要传入对自定义`FrameworkElement`的引用作为构造函数参数)。

首先，使用标准 C#语法更新`CustomVisualFrameworkElement`类以处理类构造函数中的`MouseDown`事件，如下所示:

`this.MouseDown += MyVisualHost_MouseDown;`

这个处理程序的实现将调用`VisualTreeHelper.HitTest()`方法来查看鼠标是否在一个渲染的视觉对象的边界内。要做到这一点，您需要指定一个执行计算的`HitTestResultCallback`委托作为`HitTest()`的参数。如果您单击一个视觉对象，您将在视觉对象的倾斜渲染和原始渲染之间切换。将以下方法添加到您的`CustomVisualFrameworkElement`类中:

`void MyVisualHost_MouseDown(object sender, MouseButtonEventArgs e)`

`{`

`// Figure out where the user clicked.`

`Point pt = e.GetPosition((UIElement)sender);`

`// Call helper function via delegate to see if we clicked on a visual.`

`VisualTreeHelper.HitTest(this, null,`

`new HitTestResultCallback(myCallback), new PointHitTestParameters(pt));`

`}`

`public HitTestResultBehavior myCallback(HitTestResult result)`

`{`

`// Toggle between a skewed rendering and normal rendering,`

`// if a visual was clicked.`

`if (result.VisualHit.GetType() == typeof(DrawingVisual))`

`{`

`if (((DrawingVisual)result.VisualHit).Transform == null)`

`{`

`((DrawingVisual)result.VisualHit).Transform = new SkewTransform(7, 7);`

`}`

`else`

`{`

`((DrawingVisual)result.VisualHit).Transform = null;`

`}`

`}`

`// Tell HitTest() to stop drilling into the visual tree.`

`return HitTestResultBehavior.Stop;`

`}`

现在，再次运行你的程序。现在，您应该能够单击任一渲染视图，并看到正在进行的转换！虽然这只是一个非常简单的使用 WPF 视觉图层的例子，但是请记住，您使用的笔刷、变换、钢笔和布局管理器与使用 XAML 时相同。因此，您已经对使用这个可视化派生类有了相当多的了解。

Source Code

RenderingWithVisuals 项目可以在 [`Chapter 28`](28.html) 子目录中找到。

这就结束了您对 Windows Presentation Foundation 的图形呈现服务的研究。虽然您了解了许多有趣的主题，但实际情况是，您只是触及了 WPF 图形功能的皮毛。我将把它留给你，让你更深入地挖掘形状、绘画、画笔、变换和视觉效果的主题(当然，你会在 WPF 剩余的章节中看到这些主题的更多细节)。

## 摘要

因为 Windows Presentation Foundation 是一个图形密集型 GUI API，所以我们有多种方法来呈现图形输出也就不足为奇了。本章首先研究了 WPF 应用可以做到的三种方式(形状、绘图和视觉)，并讨论了各种呈现原语，如画笔、钢笔和变换。

请记住，当你需要建立交互式 2D 渲染，形状使过程非常简单。然而，静态、非交互式渲染可以通过使用绘图和几何图形以更优化的方式进行渲染，而可视化层(仅在代码中可访问)为您提供最大的控制和性能。