# 31.ASP.NET Web 窗体简介

到目前为止，本书中的所有例子都集中在使用 WPF 平台创建的基于控制台和桌面的图形用户界面上。本文的其余部分将探讨。NET 平台使用名为 ASP.NET 的技术来促进基于互联网的应用的构建。这一章和接下来的两章涵盖了 ASP.NET Web 表单，第 34 章涵盖了 ASP.NET MVC 和 ASP.NET Web API。首先，您将快速概述一些关键的 web 开发概念(HTTP、HTML、客户端脚本、回发),并研究微软的商业 web 服务器(IIS)以及 IIS Express 的作用。

Note

本章和接下来的两章涵盖了 ASP.NET Web Forms，它是. NET 中最初的 Web 开发框架。第 34 章涵盖了 ASP.NET MVC 和 ASP.NET Web API，它们是 ASP.NET 框架家族的两个新成员。

有了这个简短的 web 入门，本章的剩余部分将集中在 brief web 表单编程模型的结构上(包括单页和代码隐藏模型),并检查`Page`基类的功能。在此过程中，您将了解 ASP.NET web 控件的作用、ASP.NET 网站的目录结构，以及如何使用`Web.config`文件来控制网站的运行时操作。

## HTTP 的作用

Web 应用与图形桌面应用是非常不同的动物。第一个明显的区别是，生产级 web 应用至少涉及两台联网的机器:一台托管 web 站点，另一台在 web 浏览器中查看数据。当然，在开发过程中，让一台机器同时扮演基于浏览器的客户端和提供内容的托管 web 服务器的角色是完全可能的。鉴于 web 应用的性质，所讨论的联网机器必须就特定的有线协议达成一致，以确定如何发送和接收数据。连接相关计算机的有线协议是超文本传输协议(HTTP)。

### HTTP 请求/响应周期

当客户机启动 web 浏览器(如 Google Chrome、Opera、Mozilla Firefox、Apple Safari 或 Microsoft Internet Explorer/Edge)时，会发出 HTTP 请求来访问远程服务器上的特定资源(通常是网页)。HTTP 是一种基于文本的协议，建立在标准的请求/响应范式之上。例如，如果您导航到 [`http://www.facebook.com`](http://www.facebook.com/) ，浏览器软件会利用一种称为域名服务(DNS)的网络技术，将注册的 URL 转换为称为 IP 地址的数值。此时，浏览器打开一个套接字连接(对于不安全的连接，通常通过端口 80)，并将 HTTP 请求发送到目标站点进行处理。

web 服务器接收传入的 HTTP 请求，并可以选择解析出任何客户端提供的输入值(如文本框、复选框或列表框中的值)，以便格式化正确的 HTTP 响应。Web 程序员可以利用任意数量的服务器端技术(PHP、ASP.NET、JSP 等)。)来动态生成要发送到 HTTP 响应中的内容。此时，客户端浏览器呈现从 web 服务器发送的返回 HTML。图 [31-1](#Fig1) 说明了基本的 HTTP 请求/响应周期。

![A978-1-4842-1332-2_31_Fig1_HTML.gif](img/A978-1-4842-1332-2_31_Fig1_HTML.gif)

图 31-1。

The HTTP request/response cycle

### HTTP 是一种无状态协议

web 开发与传统桌面编程显著不同的另一个方面是，HTTP 本质上是一种无状态的有线协议。一旦 web 服务器向客户端浏览器发送响应，之前交互的所有内容都会被遗忘。在传统的桌面应用中，可执行文件的状态通常是活跃的，直到用户关闭应用的主窗口。

考虑到这一点，作为一名 web 开发人员，您应该采取特定的步骤来“记住”当前登录到您的站点的用户的信息(比如购物车中的商品、信用卡号码和家庭地址)。正如你将在第 33 章中看到的，Web 表单提供了许多处理状态的方法，使用了诸如会话变量、cookies、应用缓存以及 Web 表单配置文件管理 API 等技术。

## 了解 Web 应用和 Web 服务器

web 应用可以被理解为存储在 web 服务器上的特定目录集中的文件(例如，`*.html`、`*.aspx`、图像文件、基于 XML 的文件数据)和相关组件(例如. NET 代码库)的集合。如[第 33 章](33.html)所示，Web Forms 应用有一个特定的生命周期，并提供了许多事件(比如初始启动或最终关闭),你可以在网站运行期间挂接这些事件以执行专门的处理。

网络服务器是一种负责托管你的网络应用的软件产品；它通常提供许多相关的服务，如集成安全性、文件传输协议(FTP)支持、邮件交换服务等。Internet 信息服务(IIS)是 Microsoft 企业级 web 服务器产品，它为 Web 窗体应用提供了内在支持。

假设您的工作站上正确安装了 IIS，您可以通过双击 Internet 信息服务管理器小程序，从“管理工具”文件夹(位于“控制面板”文件夹中)与 IIS 进行交互。图 [31-2](#Fig2) 显示了 IIS 的默认网站节点，大部分的配置细节都出现在这里(如果你运行的是 IIS 的早期版本，你的 UI 看起来会有所不同)。

![A978-1-4842-1332-2_31_Fig2_HTML.jpg](img/A978-1-4842-1332-2_31_Fig2_HTML.jpg)

图 31-2。

The IIS applet can be used to configure the runtime behavior of Microsoft IIS

### IIS 虚拟目录的作用

一个 IIS 安装能够承载大量 web 应用，每个应用都驻留在一个虚拟目录中。每个虚拟目录都映射到机器硬盘上的一个物理目录。例如，如果您创建了一个名为`CarsAreUs`的新虚拟目录，外部世界可以使用诸如 [`http://www.MyDomain.com/CarsAreUs`](http://www.mydomain.com/CarsAreUs) 之类的 URL 导航到该站点(假设您的站点的 IP 地址已经用 [`www.MyDomain.com`](http://www.mydomain.com/) 的 DNS 注册)。在幕后，这个虚拟目录映射到 web 服务器上的一个物理根目录，其中包含 CarsAreUs web 应用的内容。

正如您将在本章后面看到的，当您使用 Visual Studio 创建 Web 窗体应用时，您可以选择让 IDE 自动为当前网站生成一个新的虚拟目录。但是，如果需要，您当然可以通过右键单击 IIS 的默认网站节点并从上下文菜单中选择“添加虚拟目录”来手动创建虚拟目录。

### 服务器

在早期版本的。NET 平台，ASP.NET 开发人员被要求在开发和测试他们的 web 应用时使用 IIS 虚拟目录。在许多情况下，这种对 IIS 的紧密依赖使得团队开发比必要的更复杂，更不用说许多网络管理员不赞成在每个开发人员的机器上安装 IIS。

令人高兴的是，有一个名为 IIS Express 的轻量级 web 服务器选项。该实用工具允许开发人员在 IIS 范围之外承载 Web 窗体应用。使用这个工具，您可以从机器上的任何文件夹构建和测试您的网页。这对于团队开发场景以及在不支持 IIS 安装的 Windows 版本上构建 Web 窗体应用非常有帮助。

本书中的大多数示例将利用 IIS Express(通过正确的 Visual Studio 项目选项)，而不是在 IIS 虚拟目录下托管 web 内容。虽然这种方法可以简化您的 web 应用的开发，但是请注意，该 web 服务器并不打算承载生产级的 web 应用。它纯粹是为了开发和测试的目的。当您的 web 应用准备就绪时，您的站点将需要被复制到 IIS 虚拟目录中。

Note

Visual Studio 提供了一个内置工具，用于将本地 web 应用复制到生产级 web 服务器。这样做就像点击(或两次)按钮一样简单。若要开始该过程，您需要在 Visual Studio 解决方案资源管理器中选择您的 web 项目，右击并选择“发布”。此时，您可以选择部署的预期目标，包括 Microsoft Azure。

## HTML 的作用

在配置了承载 web 应用的目录并选择了 web 服务器作为主机之后，您需要创建内容本身。回想一下，web 应用只是构成站点功能的一组文件。可以肯定的是，这些文件中有许多将包含超文本标记语言(HTML)语句。HTML 是一种标准标记语言，用于描述文本、图像、外部链接和各种 HTML 控件如何在客户端浏览器中呈现。

虽然现代的 ide(包括 Visual Studio)和 web 开发平台(如 ASP.NET)确实会自动生成大量的 HTML，但在使用 ASP.NET 时，你应该掌握一些 HTML 的应用知识。

Note

回想一下第 2 章中的内容，微软已经在 Express 系列产品和 Visual Studio Community Edition 下发布了许多免费的 ide，后者将所有的 Express 版本整合到一个包中。要学习 WebForms、MVC 和 Web API 的后续章节，可以下载 Visual Studio Express for Web 或 Community Edition。

虽然这一部分肯定不会涵盖 HTML 的所有方面，但它将触及一些基础知识。这将帮助您更好地理解 Web 窗体编程模型为您生成的标记。

### HTML 文档结构

典型的 HTML 文件由一组描述给定网页外观的标签组成。HTML 文档的基本结构倾向于保持不变。例如，`*.html`文件用`<html>`和`</html>`标签打开和关闭，通常定义一个`<body>`部分，等等。

若要开始，请打开 Visual Studio 并选择“新建➤项目”。在“其他项目类型”下，选择“Visual Studio 解决方案”,然后选择“空白解决方案”,如图 [31-3](#Fig3) 所示(请注意，此时您不是在创建 web 项目，您只是在创建一个空白解决方案来保存您的文件)。

![A978-1-4842-1332-2_31_Fig3_HTML.jpg](img/A978-1-4842-1332-2_31_Fig3_HTML.jpg)

图 31-3。

Select Blank Visual Studio Solution from the New Project dialog

接下来，通过项目➤添加新项菜单选项添加一个空的 HTML 页面文件，并在左侧栏中选择 Visual C#/Web，在中间窗格中选择 HTML 页面。将文件命名为`HtmlPage1.html`。您应该会看到一些初始标记，如下所示(具体的 HTML 可能会根据您配置 Visual Studio 的方式而有所不同):

`<!DOCTYPE html>`

`<html lang="en" xmlns="`[`http://www.w3.org/1999/xhtml`](http://www.w3.org/1999/xhtml)T2】

`<head>`

`<title> </title>`

`<meta charset="utf-8" />`

`</head>`

`<body>`

`</body>`

`</html>`

首先，注意这个 HTML 文件打开时带有一个`DOCTYPE`处理指令。这与开始的`<html>`标签一起确定了所包含的 HTML 标签应该根据 HTML 5.0 标准进行验证。HTML 5.0 标准是一个 W3C 规范，它为传统风格的标记增加了许多新特性。

Note

默认情况下，Visual Studio 根据 HTML 5.0 验证方案验证所有 HTML 文档，以确保标记与 HTML 5 标准同步。如果需要指定替代验证方案，请激活“工具”“➤选项”对话框，展开“文本编辑器”节点，展开“HTML (Web 窗体)”节点，然后选择“验证”节点。另外，如果您不希望看到验证警告，只需取消选中相同位置的 Show Errors 复选框。

为了稍微漂亮一点，更新你的页面标题，如下所示:

`<head>`

`<title>This is my simple web page</title>`

`</head>`

毫不奇怪，`<title>`标签用于指定应该放在宿主 web 浏览器标题栏中的文本字符串。

### HTML 表单的作用

HTML 表单只是一组命名的相关 UI 元素，通常用于收集用户输入。不要将 HTML 表单与给定浏览器显示的整个显示区域混淆。实际上，HTML 表单更像是放置在`<form>`和`</form>`标记集中的小部件的逻辑分组，比如

`<!DOCTYPE html>`

`<html xmlns="`[`http://www.w3.org/1999/xhtml`](http://www.w3.org/1999/xhtml)T2】

`<head>`

`<title>This is my simple web page</title>`

`</head>`

`<body>`

`<form id="defaultPage">`

`<!-- Insert web UI content here -->`

`</form>`

`</body>`

`</html>`

该表单已被分配了 id`"defaultPage"`。通常，开始的`<form>`标签提供了一个`action`属性，指定用于提交表单数据的 URL，以及传输数据本身的方法(POST 或 GET)。在下一节中，您将了解到更多这方面的内容。现在，让我们来看看可以放在 HTML 表单中的各种条目(不仅仅是简单的文本)。

### Visual Studio HTML 设计器工具

Visual Studio 在工具箱上提供了一个 HTML 选项卡(可通过“查看➤工具箱”菜单选项访问)，该选项卡允许您选择一个可以放在 HTML 设计器上的 HTML 控件(请参见图 [31-4](#Fig4) )。与构建 WPF 应用的过程类似，这些 HTML 控件可以被拖到设计器表面或直接拖到页面的标记中。

![A978-1-4842-1332-2_31_Fig4_HTML.jpg](img/A978-1-4842-1332-2_31_Fig4_HTML.jpg)

图 31-4。

The HTML tab of the Toolbox Note

当您使用 web 窗体编程模型构建 Web 窗体页时，通常不会使用这些 HTML 控件来创建用户界面。相反，您将使用 Web 窗体控件，它将代表您呈现正确的 HTML。在这一章的后面，你会学到 web 控件的作用。

HTML 编辑器没有设计器图面。为了使用设计器(或拆分模式)，您需要使用 Web Forms HTML 编辑器。为此，请关闭`HtmlPage1.html`的编辑器，在解决方案中，右键单击该文件，选择打开方式，您将看到一个对话框，允许您选择哪个编辑器(如图 [31-5](#Fig5) 所示)。如果您单击 Set as Default，那么您就不需要像我们在这里所做的那样创建一个解决方案，因为 Web Forms HTML 编辑器将始终被使用。

![A978-1-4842-1332-2_31_Fig5_HTML.jpg](img/A978-1-4842-1332-2_31_Fig5_HTML.jpg)

图 31-5。

Selecting the WebForms Editor

如果单击 HTML 编辑器底部的拆分按钮，HTML 编辑器的底部窗格将显示 HTML 可视布局，上部窗格将显示相关标记。该编辑器的另一个好处是，当您选择标记或 HTML UI 元素时，相应的表示会突出显示。图 [31-6](#Fig6) 显示了分割视图的一个实例。

![A978-1-4842-1332-2_31_Fig6_HTML.jpg](img/A978-1-4842-1332-2_31_Fig6_HTML.jpg)

图 31-6。

The Visual Studio Web Forms HTML designer

Visual Studio 还允许您使用属性窗口编辑`*.html`文件或`<form>`中给定 HTML 控件的整体外观。例如，如果您从属性窗口的下拉列表中选择文档，您可以配置 HTML 页面的各个方面(参见图 [31-7](#Fig7) )。

![A978-1-4842-1332-2_31_Fig7_HTML.jpg](img/A978-1-4842-1332-2_31_Fig7_HTML.jpg)

图 31-7。

The Visual Studio Properties window can be used to configure the HTML markup

当您使用“属性”窗口配置网页的某个方面时，IDE 将相应地更新 HTML。在阅读本书的剩余章节时，您可以随意使用 IDE 来帮助编辑您的 HTML 页面。

### 构建 HTML 表单

更新初始文件的`<body>`以显示一些提示用户输入消息的文字文本。请注意，您可以通过在 HTML 设计器中直接键入来输入和格式化文字文本内容。这里，您使用了`<h1>`标签来设置标题的粗细，`<p>`标签用于段落块，`<i>`标签用于斜体文本:

`<!DOCTYPE html>`

`<html xmlns="`[`http://www.w3.org/1999/xhtml`](http://www.w3.org/1999/xhtml)T2】

`<head>`

`<title>This is my simple web page</title>`

`</head>`

`<body>`

`<!--``Prompt for user input.`T2】

`<h1>Simple HTML Page</h1>`

`<p>`

`<br/>`

`<i>Please enter a message</i>.`

`</p>`

`<form id="defaultPage">`

`</form>`

`</body>`

`</html>`

现在让我们构建表单的输入区域。一般来说，每个 HTML 控件都使用一个`id`属性(用于以编程方式标识项目)和一个`type`属性(用于指定您希望将哪个输入控件放在`<form>`声明中)来描述。

您将在这里构建的 UI 将包含一个文本字段和两种按钮类型。第一个按钮用于运行客户端脚本，另一个按钮用于将表单输入字段重置为默认值。像这样更新你的 HTML 表单:

`<!--``Build a form to get user info.`T2】

`<form id="defaultPage">`

`<p>`

`Your Message:`

`<input id="txtUserMessage" type="text"/></p>`

`<p>`

`<input id="btnShow" type="button" value="Show!"/>`

`<input id="btnReset" type="reset" value="Reset"/>`

`</p>`

`</form>`

请注意，您已经为每个控件分配了相关的`id`(`txtUserMessage`、`btnShow`和`btnReset`)。还要注意，每个输入项都有一个名为`type`的额外属性，该属性将这些输入控件标记为 UI 项，这些 UI 项会自动将所有字段清除为初始值(`type="reset"`)、接收文本输入(`type="text"`)，或者充当一个简单的客户端按钮，不会回发到 web 服务器(`type="button"`)。

保存文件，然后右键单击设计器，并选择“在浏览器中查看”菜单选项。图 [31-8](#Fig8) 显示了新的微软 Edge 网络浏览器的当前页面。

![A978-1-4842-1332-2_31_Fig8_HTML.jpg](img/A978-1-4842-1332-2_31_Fig8_HTML.jpg)

图 31-8。

Your simple HTML page Note

当您为 HTML 文件选择“在浏览器中查看”选项时，Visual Studio 将自动启动 IIS Express 来承载您的内容。

## 客户端脚本的作用

除了 GUI 元素，给定的`*.html`文件可能包含将由请求浏览器处理的脚本代码块。以下是使用客户端脚本的两个主要原因:

*   在回发到 web 服务器之前验证用户在浏览器中的输入
*   与浏览器的文档对象模型(DOM)交互

关于第一点，要理解 web 应用的内在缺陷是需要频繁地往返于服务器机器(称为回发)来更新要在浏览器中呈现的 HTML。虽然回发是不可避免的，但您应该始终注意尽量减少跨网络传输的方法。一种节省回发的技术是在将表单数据提交给 web 服务器之前，使用客户端脚本来验证用户输入。如果发现错误，例如没有在必填字段中提供数据，您可以提醒用户该错误，而不会产生回发到 web 服务器的成本。(毕竟，没有什么比在慢速连接上回发，只收到解决输入错误的指令更让用户恼火的了！)

Note

请注意，即使在执行客户端验证时(为了缩短响应时间)，验证也应该发生在 web 服务器本身。这将确保数据在通过网络发送时不会被篡改。ASP.NET 验证控件自动执行客户端和服务器端的验证(更多信息见第 32 章)。

客户端脚本也可以用于与 web 浏览器本身的底层对象模型(文档对象模型，或 DOM)进行交互。大多数商业浏览器都公开了一组可以用来控制浏览器行为的对象。

当浏览器解析一个 HTML 页面时，它会在内存中构建一个对象树，表示网页的所有内容(表单、输入控件等)。).浏览器提供了一个名为 DOM 的 API，它公开了对象树并允许您以编程方式修改其内容。例如，您可以编写在浏览器中执行的 JavaScript 来获取特定控件的值、更改控件的颜色、向页面动态添加新控件，等等。

一个主要的烦恼是不同的浏览器倾向于公开相似但不相同的对象模型。因此，如果您发出一个与 DOM 交互的客户端脚本代码块，它可能无法在所有浏览器上同样地工作(因此，测试总是必须的！).

ASP.NET 提供了`HttpRequest.Browser`属性，允许您在运行时确定浏览器和发送当前请求的设备的容量。您可以使用这些信息来确定如何以最佳方式发送回 HTTP 响应。但是您很少需要担心这一点，除非您正在实现自定义控件，因为 ASP.NET 的所有标准 web 控件都自动知道如何根据浏览器类型适当地呈现它们自己。这种非凡的能力被称为自适应渲染，它是为所有标准的 ASP.NET 控件现成实现的。

有各种脚本语言可用于创作客户端脚本代码，但目前最流行的是 JavaScript。值得注意的是，JavaScript 与 Java 语言完全不同。虽然 JavaScript 和 Java 的语法有些相似，但是 JavaScript 没有 Java 强大。好消息是，所有现代 web 浏览器都支持 JavaScript，这使它成为客户端脚本逻辑的自然候选。

### 客户端脚本示例

为了说明客户端脚本的作用，让我们首先研究如何拦截从客户端 GUI 部件发送的事件。为了捕获显示按钮的`click`事件，更新`btnShow`小部件的定义以支持一个`onclick`属性，该属性被分配给一个名为`btnShow_onclick()`的 JavaScript 方法。

`<input id="btnShow" type="button" value="Show!"`

`onclick="return btnShow_onclick()" />`

现在，直接在开始的`<head>`元素后添加下面的 JavaScript 函数，当用户单击按钮时调用该函数。使用`alert()`方法通过`value`属性显示包含文本框中的值的客户端消息框。

`<script type="text/javascript">`

`// <![CDATA[`

`function btnShow_onclick() {`

`alert(window.txtUserMessage.value);`

`}`

`// ]]>`

`</script>`

注意，脚本块已经被包装在一个`CDATA`部分中。原因很简单:如果您的页面最终出现在不支持 JavaScript 的浏览器上，代码将被视为注释块并被忽略。当然，您的页面可能功能性较差，但好处是您的页面在浏览器呈现时不会爆炸。在任何情况下，如果你再次在浏览器中查看你的页面，你应该能够输入一条消息，并看到它在客户端消息框中弹出(见图 [31-9](#Fig9) )。

![A978-1-4842-1332-2_31_Fig9_HTML.jpg](img/A978-1-4842-1332-2_31_Fig9_HTML.jpg)

图 31-9。

Invoking a client-side JavaScript function

同样，当您单击 Reset 按钮时，您应该会发现文本区域中的数据被清除了，因为这个特定的按钮是通过指定`type="reset"`创建的。

## 回发到 Web 服务器

这个简单的 HTML 页面执行主机浏览器中的所有功能。一个真实的 web 页面需要回发到 web 服务器上的一个资源，同时传递所有的输入数据。一旦服务器端资源接收到这些数据，它就可以使用这些数据来构建一个正确的、动态生成的 HTTP 响应。

开始的`<form>`标签上的`action`属性指定了输入表单数据的接收者。可能的接收者包括邮件服务器、web 服务器上的其他 HTML 文件、RESTful web 服务、web 表单页面等等。

除了`action`属性之外，您还可能有一个`submit`按钮，单击它会通过 HTTP 请求将表单数据传输到 web 应用。对于这个例子，没有必要这样做；然而，这里有一个对文件的更新，在开始的`<form>`标签中指定了以下属性:

`<form id="defaultPage"`

`action="``http://localhost/Cars/MyAspNetPage.aspx`T2】

`<input id="btnPostBack" type="submit" value="Post to Server!"/>`

`...`

`</form>`

当点击这个表单的`submit`按钮时，表单数据被发送到指定 URL 的`MyAspNetPage.aspx`。当您指定`method="GET"`作为传输模式时，表单数据将作为一组由&符号分隔的名称/值对附加到查询字符串中。您可能以前在浏览器中见过这种数据；它看起来像下面这样:

`http://www.google.com/search?hl=en&source=hp&q=vikings&cts=1264370773666&aq=f&aql=&aqi=g1g-z1g1g-z1g1g-z1g4&oq=`

将表单数据传输到 web 服务器的另一种方法是指定`method="POST"`，如下所示:

`<form id="defaultPage"`

`action="``http://localhost/Cars/MyAspNetPage.aspx`T2】

`...`

`</form>`

在这种情况下，表单数据不会追加到查询字符串中。使用`POST`，表单数据对外界不直接可见。更重要的是，`POST`数据没有字符长度限制；许多浏览器对`GET`查询有限制。

### Web 表单下的回发

当您构建基于 Web 表单的网站时，框架将代表您处理发布机制。使用 ASP.NET Web 窗体构建网站的众多好处之一是，编程模型层位于事件驱动系统的标准 HTTP 请求/响应协议之上。因此，与其手动设置一个`action`属性并定义一个 HTML `submit`按钮，不如使用标准 C#语法简单地处理 Web 表单控件上的事件。

使用这种事件驱动的模型，您可以非常容易地使用大量控件回发到 web 服务器。如果需要，您可以在用户单击单选按钮、列表框中的项目、日历控件上的日期等时回发到 web 服务器。在每种情况下，您只需处理正确的事件，ASP.NET 运行时将自动发送回正确的 HTML 发布数据。

Source Code

简单网页网站包含在 [`Chapter 31`](31.html) 子目录中。

## Web 窗体 API 概述

至此，您对经典 web 应用开发的快速回顾已经完成，您可以开始研究 Web 表单了。如您所料，每个版本的。NET 平台为 web 编程 API 增加了更多的功能，在。净 4.6。无论是哪个版本的？NET，以下特性对于基于 ASP.NET Web 窗体的应用来说是常见的:

*   ASP.NET 提供了一个称为代码隐藏的模型，它允许你将表示逻辑(HTML)和业务逻辑(C#代码)分开。
*   ASP.NET 页面使用。NET 编程语言，而不是服务器端脚本语言。代码文件被编译成有效的。NET `*.dll`程序集(这转化为更快的执行)。
*   Web 窗体控件可用于以类似于构建桌面 windows 应用的模型来构建 web UI。
*   Web 窗体应用可以利用。NET 基本类库，并且是使用本书中研究的面向对象技术(类、接口、结构、枚举和委托)构造的。
*   Web 表单应用可以通过 web 应用配置文件(`Web.config`)轻松配置。

我想在这里详细说明的第一点是，web 窗体网页的 UI 可以使用各种 Web 控件来构造。与典型的 HTML 控件不同，web 控件在 web 服务器上执行，并将它们正确的 HTML 标记发送回 HTTP 响应。这本身就是 Web 表单的一个巨大优势，因为您必须手工创建的 HTML 的数量大大减少了。举个简单的例子，假设您已经在一个 web 窗体页中定义了下面的 Web 窗体 Web 控件(我将很快介绍如何创建细节):

`<asp:Button ID="btnMyButton" runat="server" Text="Button" BorderColor="Blue"`

`BorderStyle="Solid" BorderWidth="5px" />`

您很快就会了解到声明 Web 窗体控件的细节，但是现在，请注意,`<asp:Button>`控件的许多属性看起来与您在 WPF 示例中遇到的属性非常相似。对于所有的 web 窗体控件来说也是如此，因为当微软构建 Web 控件工具包时，这些小部件被特意设计成看起来和感觉起来像它们的桌面对应物。

现在，如果浏览器调用包含该控件的`*.aspx`文件，该控件通过向输出流发出以下 HTML 声明来做出响应:

`<input type="submit" name="btnMyButton" value="Button" id="btnMyButton"`

`style="border-color:Blue;border-width:5px;border-style:Solid;" />`

请注意 web 控件如何发出可以在任何浏览器中呈现的标准 HTML。有鉴于此，请理解使用 Web 窗体控件不会将您与 Microsoft 操作系统系列或 Microsoft Internet Explorer 捆绑在一起。任何操作系统或浏览器(包括手持设备上的操作系统或浏览器，如 Apple iPhone、Android 或 Windows Phone 设备)都可以查看 Web 窗体页。

接下来，请注意前面的功能列表，Web 窗体应用将被编译成. NET 程序集。因此，您的 web 项目与其他项目没有什么不同。NET `*.dll`本书期间建成。编译后的 web 应用将由 CIL 代码、程序集清单和类型元数据组成。这有许多巨大的好处，最显著的是性能提升、强类型化和被 CLR 微观管理的能力(例如，垃圾收集等)。).

最后，Web 窗体应用提供了一种编程模型，通过这种模型，您可以使用代码文件将页面的标记与其相关的 C#代码库分开。使用代码文件，您键入的标记将映射到一个完整的对象模型，该模型通过分部类声明与您的 C#代码文件合并。

### Web Forms 2.0 和更高版本的主要功能

ASP.NET 1.0 是朝着正确方向迈出的重要一步，ASP.NET 2.0 提供了许多额外的功能，帮助 ASP.NET 从构建动态网页转向构建功能丰富的网站。请考虑以下部分关键特性:

*   引入 ASP.NET 开发 Web 服务器(这意味着开发人员不再需要在他们的开发计算机上安装完整版本的 IIS)。这现在被 IIS Express 所取代。
*   大量新的 web 控件可以处理许多复杂的情况(导航控件、安全控件、新的数据绑定控件等)。).
*   引入母版页，允许开发人员将一个通用的 UI 框架附加到一组相关的页面上。
*   对主题的支持，它提供了一种声明性的方式来改变 web 服务器上整个 web 应用的外观。
*   支持 Web 部件，允许最终用户定制网页的外观和感觉，并存储其设置以备后用(门户网站)。
*   引入基于 web 的配置和管理实用程序，用于维护各种`Web.config`文件。

除了 ASP.NET 开发的 Web 服务器，ASP.NET 2.0 带来的最大的附加功能之一是引入了母版页。如您所知，大多数网站的外观和感觉对网站上的所有页面都是通用的。考虑一个商业网站，比如 [`www.amazon.com`](http://www.amazon.com/) 。每个页面都有相同的元素，比如通用的页眉、页脚、导航菜单等等。

使用母版页，您可以对这种常见的功能进行建模，并定义其他`*.aspx`文件可以插入的占位符。这使得通过简单地改变母版页，保持其他`*.aspx`文件不变，就可以很容易地快速改变站点的整体外观(重新定位导航栏，改变标题徽标等等)。

Note

母版页非常有用，以至于从 Visual Studio 2010 开始，所有新的 web 窗体 Web 项目都默认包含一个母版页。

ASP.NET 2.0 还添加了许多新的 web 控件，包括自动整合通用安全功能的控件(登录控件、密码恢复控件等)。)、允许您在一组相关的`*.aspx`文件之上分层导航结构的控件，以及用于执行复杂数据绑定操作的更多控件，其中可以使用一组 Web 表单控件生成必要的 SQL 查询。

### Web Forms 3.5(和)的主要特性。净 3.5 SP1)和更高

请注意。NET 3.5 增加了 Web 窗体应用利用 LINQ 编程模型的能力(也在。NET 3.5)和以下以 web 为中心的功能:

*   支持针对 ADO.NET 实体框架类的数据绑定(见第 23 章)。
*   支持 ASP.NET 动态数据。这是一个受 Ruby on Rails 启发的 web 框架，可用于构建数据驱动的 web 应用。它通过在 ASP.NET web 服务的 URI 中对表进行编码来公开数据库中的表，并且表中的数据自动呈现为 HTML。
*   对 Ajax 风格开发的集成支持，本质上允许微回发尽快刷新网页的一部分。

中引入的 ASP.NET 动态数据项目模板。NET 3.5 Service Pack 1 提供了一种新的模型来构建大量由关系数据库驱动的站点。当然，大多数网站在某种程度上需要与数据库进行通信，但是 ASP.NET 动态数据项目与 ADO.NET 实体框架紧密相连，并且完全专注于数据驱动网站的快速开发(类似于使用 Ruby 时可能构建的内容)。

### Web Forms 4.0 的主要功能

。NET 4.0 为 Microsoft web 开发平台增加了更多的功能。以下是一些以网络为中心的关键功能的列表:

*   使用 GZIP 标准压缩“视图状态”数据的能力。
*   JQuery 包含在 Web 表单和 MVC 中。
*   更新了浏览器定义，以确保 Apple 页面在新的浏览器和设备(谷歌浏览器、苹果 iPhone、Windows Phone、安卓设备等)上正确呈现。).
*   使用级联样式表(CSS)自定义验证控件输出的能力。
*   包含 ASP.NET 图表控件，允许构建包含复杂统计或财务分析的直观图表的 ASP.NET 页面。
*   支持 ASP.NET 模型-视图-控制器项目模板，通过使用模型-视图-控制器(MVC)模式减少了应用层之间的依赖性。这是一种完全不同的网站开发方法，与本文中讨论的 web 表单编程模型几乎没有相似之处。

虽然这个列表确实令人印象深刻(而且它只是新特性的一个子集)，但是微软为 ASP.NET 4.5 版本的 Web 表单所做的工作让许多开发者从 ASP.NET MVC 回到了 Web 表单(在第 34 章中有所介绍)。

### Web Forms 4.5 和 4.6 的主要功能

的两个主要焦点领域。NET 4.5 的性能改进和移植许多 ASP.NET MVC 特性回到 Web 表单。这里只是 Web Forms 4.5 和 Web Forms 4.6 中新增功能的一部分。

#### Web Forms 4.5 中添加的功能

*   支持 HTML 5.0 的众多更新。
*   与 C#和 VB 的新异步语言功能集成。
*   您可以通过使用新的`ItemType`属性来声明控件将绑定到什么类型的数据，从而支持强类型控件、智能感知支持等等。
*   模型绑定，这意味着您可以将页面中的数据直接映射到方法类型参数中。
*   客户端验证现在与 JQuery 集成在一起，允许更简洁的验证代码。
*   通过数据注释可以进行额外的验证，数据注释是模型类的属性。
*   通过包含(默认)AntiXSS 库，进一步防止跨站点脚本攻击。
*   通过缩小(通过压缩文件的文本来减小文件大小)来减小文件大小(对于 JavaScript 和 CSS)。
*   通过捆绑将文件合并成一个文件，减少了浏览器调用次数。
*   您可以推迟请求验证，允许张贴潜在的不安全内容(小心使用)。
*   编译 Web 窗体应用时，应用可以使用多个服务器代码。

#### Web Forms 4.6 中添加的功能

*   支持新的高速 HTTP2 协议(目前仅适用于 IIS 上的安全应用)
*   使用 Roslyn Code DOM 编译器启用新的 C# 6 特性
*   能够在模型绑定函数上使用异步/等待

您可能会同意，Web 表单的特性集相当丰富(这个 API 的特性比我在这里简单列举的要多得多)。说实话，如果我要涵盖 Web 表单的每一个可能的特性，这本书很容易就会翻一番(也许是三倍)。因为这是不现实的，所以本文剩余部分的目标是检查您在日常生活中可能会用到的 Web 表单的核心特性。请查看。NET Framework 4.6 SDK 文档，了解此处未涉及的功能。

Note

如果你需要一个使用 ASP.NET 构建 web 应用的综合教程，我建议你买一本由 Adam Freeman 和 Matthew MacDonald 编写的 Pro ASP.NET 4.5 c#第五版。

## 构建单文件 Web 窗体 Web 应用

可以使用两种主要方法中的一种来构建 Web 表单页面，第一种方法是构建一个包含服务器端代码和 HTML 的单个`*.aspx`文件。使用这种单文件页面模型方法，服务器端代码被放在一个`<script>`范围内，但是代码本身并不是脚本代码(例如 VBScript/JavaScript)。相反，`<script>`块中的代码是用您的。NET 语言的选择(C#、Visual Basic 等。).

如果您正在构建一个包含很少代码(但是包含大量静态 HTML)的 web 页面，单文件页面模型可能更容易使用，因为您可以在一个统一的`*.aspx`文件中看到代码和标记。此外，将您的过程代码和 HTML 标记放在一个单独的`*.aspx`文件中还有其他一些优点:

*   使用单文件模型编写的页面更容易部署或发送给其他开发人员。
*   因为多个文件之间没有依赖关系，所以单文件页面更容易重命名。
*   在源代码控制系统中管理文件稍微容易一些，因为所有的操作都发生在一个文件中。

不利的一面是，单文件页面模型可能会导致一些复杂的文件，因为 UI 标记和编程逻辑被隔离在一个位置。然而，您将通过研究单文件页面模型开始您的 Web 表单之旅。

您的目标是使用实体框架构建一个显示`AutoLot`数据库(在[第 21 章](21.html)中创建)的`Inventory`表的`*.aspx`文件。首先，启动 Visual Studio 并创建一个名为 SinglePageModel 的新的空 ASP.NET web 应用。选择文件➤新建项目，然后在左边栏选择 Visual C#/Web，在中间窗格选择 ASP.NET web 应用，输入 SinglePageModel 作为名称，如图 [31-10](#Fig10) 所示。

![A978-1-4842-1332-2_31_Fig10_HTML.jpg](img/A978-1-4842-1332-2_31_Fig10_HTML.jpg)

图 31-10。

Select ASP.NET Web Application from the New Project dialog

单击“确定”后，您将看到更新后的“新建 ASP.NET 项目”对话框。确保选择 ASP.NET 4.6 模板和空项目模板。保留“添加文件夹和核心引用:”下的 Web 表单、MVC 和 Web API 的复选框未选中；不要选中“添加单元测试”复选框；并在微软 Azure 下的云选项(如果勾选的话)中取消勾选主机，如图 [31-11](#Fig11) 。

![A978-1-4842-1332-2_31_Fig11_HTML.jpg](img/A978-1-4842-1332-2_31_Fig11_HTML.jpg)

图 31-11。

Choosing the empty project template Note

的。NET 4.6 框架(这本书涵盖)是当前的完整版本。NET 框架。ASP.NET 5 号是建立在。NET core，它是。净 4.6。请注意。NET Core 是用于跨平台网站的，从 web 开发的角度来看，它只支持 ASP.NET MVC 和 Web API。

接下来，通过选择“项目”“➤”“添加新项”,向项目中添加一个新的 Web 表单。确保在左侧栏中选择“Web ➤ Web 表单”。将该文件命名为`Default.aspx`。

### 参考 AutoLotDAL.dll

接下来，使用 Windows 资源管理器从第 23 章(或从本章的下载目录)中复制 AutoLotDAL 目录。通过右键单击解决方案并选择“添加➤现有项目”，然后选择“AutoLotDAL”项目，将项目添加到解决方案中。接下来，通过右键单击 SinglePageModel 项目中的 references 节点并从“项目/解决方案”选项中选择 AutoLotDAL，向 AutoLotDAL 项目添加一个引用。

您需要对`AutoLotDAL`项目做一点小小的改动。首先，添加一个对`System.Web`的引用。`DatabaseLogger`的构造函数没有指定目录，这将导致代码在网站中因为缺少权限而失败。这必须被更新以指向网站的物理目录。在`System.Web`名称空间中有一个名为`HttPRuntime.AppDomainAppPath`的服务器变量，它包含网站的物理目录。在 EF 文件夹中，打开`AutoLotEntities.cs`，为`System.Web`添加一个 using，并将`DatabaseLogger`初始值改为:

`static readonly DatabaseLogger DatabaseLogger =`

`new DatabaseLogger($"{HttpRuntime.AppDomainAppPath}/sqllog.txt");`

这一更改确保了日志文件创建在与网站相同的目录中，从而解决了权限问题。

接下来，通过在解决方案资源管理器中右键单击解决方案，选择“管理解决方案的 NuGet 包”,然后添加实体框架，将实体框架添加到 web 项目中。您还需要更新`web.config`文件(这类似于您在前面章节中已经使用过的`App.config`文件)以匹配以下内容(您可能需要根据 SQL Server 安装的实例名称来更改您的连接字符串):

`<configuration>`

`<configSections>`

`<!-- For more information on Entity Framework configuration, visit`[`http://go.microsoft.com/fwlink/?LinkID=237468`](http://go.microsoft.com/fwlink/?LinkID=237468)T2】

`<section name="entityFramework"`

`type="System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"`

`requirePermission="false"/>`

`</configSections>`

`<system.web>`

`<compilation debug="true" targetFramework="4.6"/>`

`<httpRuntime targetFramework="4.6"/>`

`</system.web>`

`<entityFramework>`

`<defaultConnectionFactory type="System.Data.Entity.Infrastructure.LocalDbConnectionFactory, EntityFramework">`

`<parameters>`

`<parameter value="mssqllocaldb"/>`

`</parameters>`

`</defaultConnectionFactory>`

`<providers>`

`<provider invariantName="System.Data.SqlClient" type="System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer"/>`

`</providers>`

`</entityFramework>`

`<connectionStrings>`

`<add name="AutoLotConnection"`

`connectionString="data source=.\SQLEXPRESS2014;initial catalog=AutoLot;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework"`

`providerName="System.Data.SqlClient"/>`

`</connectionStrings>`

`</configuration>`

### 设计用户界面

现在，打开`Default.aspx`，点击 Design 选项卡，使用 Visual Studio 工具箱，选择 Standard 选项卡，将一个`GridView`控件(工具箱的 Data 选项卡下可以找到`GridView`小部件)拖放到页面设计器的开始和结束`form`元素之间。请注意，设计人员在`GridView`中填入随机数据，让您了解页面的外观。您可以随意使用“属性”窗口来设置您选择的各种可视属性设置。现在，找到页面的`<form>`部分。注意 web 控件是如何使用`<asp>`标签定义的。在这个标记前缀之后，您将找到一个 Web 窗体控件的名称(`GridView`)。在给定元素的结束标记之前，您会发现一系列与“属性”窗口中的可用设置相对应的名称/值对，如下所示:

`<form id="form1" runat="server">`

`<div>`

`<asp:GridView ID="carsGridView" runat="server">`

`</asp:GridView>`

`</div>`

`</form>`

在第 32 章的[中，你会深入了解 Web 表单控件的全部细节(包括`runat="server"`)。在此之前，请记住 web 控件是在 web 服务器上处理的对象，它们自动将其 HTML 表示形式发送回传出的 HTTP 响应。除了这一主要优点之外，Web 窗体控件模仿了类似桌面的编程模型，因为属性、方法和事件的名称通常模仿了等效的 Windows 窗体/WPF。](32.html)

### 添加数据访问逻辑

现在，切换到源代码，用值`"AutoLotDAL.Models.Inventory"`给`asp:GridView`标签添加一个`ItemType`属性。中引入的这项新功能。NET 4.5，在 ASP.NET Web 窗体中提供强类型列表控件，并由 IntelliSense 支持来识别解决方案中可用的类。

接下来，添加一个值为`"GetData"`的`SelectMethod`属性。中也引入了`SelectMethod`属性。NET 4.5，并设置在呈现控件以获取将填充列表控件的数据时将执行的方法。更新后的标记如下所示:

`<asp:GridView ID="carsGridView" runat="server"`

`ItemType="AutoLotDAL.Models.Inventory"`

`SelectMethod="GetData" >`

`</asp:GridView>`

在页面的`<script>`标签中创建`GetData`方法。在方法中，调用`InventoryRepo.GetAll`方法。使用`<%@ Import ... %>`输入`AutoLotDAL.Models`和`AutoLotDAL.Repos`。您的代码应该与此类似:

`<!--At the top of the file, after the Page directive -->`

`<%@ Import Namespace="AutoLotDAL.Models" %>`

`<%@ Import Namespace="AutoLotDAL.Repos" %>`

`<!--Anywhere in the file, before the GridView control -->`

`<script runat="server">`

`public IEnumerable<Inventory> GetData()`

`{`

`return new InventoryRepo().GetAll();`

`}`

`</script>`

Note

如果您使用单文件代码模型构建页面，那么您只需要使用`<%@ Import %>`指令。如果您使用默认的代码文件方法，请使用 C#的`using`关键字在代码文件中包含名称空间。下面描述的`<%@ Assembly %>`指令也是如此。

在您深入了解这个`*.aspx`文件格式背后的细节之前，让我们试一试。首先，保存您的`*.aspx`文件。单击“运行”或按 F5，这将启动承载您的页面的 IIS Express。

当页面被提供时，执行`Select`方法，将数据加载到`GridView`中。图 [31-12](#Fig12) 显示了输出。

![A978-1-4842-1332-2_31_Fig12_HTML.jpg](img/A978-1-4842-1332-2_31_Fig12_HTML.jpg)

图 31-12。

ASP.NET provides a declarative data-binding model

鉴于目前的用户界面相当平淡。为了增加当前示例的趣味，在 Visual Studio 设计器上选择`GridView`控件，并使用上下文菜单(控件右上角的小箭头)，选择自动格式化选项(参见图 [31-13](#Fig13) )。

![A978-1-4842-1332-2_31_Fig13_HTML.jpg](img/A978-1-4842-1332-2_31_Fig13_HTML.jpg)

图 31-13。

Configuring the ASP.NET `GridView` control

从出现的对话框中，选择一个适合你的模板(我选择了“Slate”)。单击 OK 后，查看生成的控件声明，它比以前丰富了很多。

`<asp:GridView ID="carsGridView" runat="server"`

`ItemType="AutoLotDAL.Models.Inventory"`

`SelectMethod="GetData" BackColor="White" BorderColor="#E7E7FF"`

`BorderStyle="None" BorderWidth="1px" CellPadding="3" GridLines="Horizontal" >`

`<AlternatingRowStyle BackColor="#F7F7F7" />`

`<FooterStyle BackColor="#B5C7DE" ForeColor="#4A3C8C" />`

`<HeaderStyle BackColor="#4A3C8C" Font-Bold="True" ForeColor="#F7F7F7" />`

`<PagerStyle BackColor="#E7E7FF" ForeColor="#4A3C8C" HorizontalAlign="Right" />`

`<RowStyle BackColor="#E7E7FF" ForeColor="#4A3C8C" />`

`<SelectedRowStyle BackColor="#738A9C" Font-Bold="True" ForeColor="#F7F7F7" />`

`<SortedAscendingCellStyle BackColor="#F4F4FD" />`

`<SortedAscendingHeaderStyle BackColor="#5A4C9D" />`

`<SortedDescendingCellStyle BackColor="#D8D8F0" />`

`<SortedDescendingHeaderStyle BackColor="#3E3277" />`

`</asp:GridView>`

如果你再次查看你的应用并点击你的按钮，你将会看到一个更有趣的用户界面(见图 [31-14](#Fig14) )。

![A978-1-4842-1332-2_31_Fig14_HTML.jpg](img/A978-1-4842-1332-2_31_Fig14_HTML.jpg)

图 31-14。

A richer display for your test page

这很简单，对吗？当然，正如他们所说，细节决定成败，所以让我们更深入地研究一下这个`*.aspx`文件的组成，从检查`<%@Page... %>`指令的角色开始。请注意，您研究的主题将直接应用于接下来研究的更受欢迎的代码文件模型。

### ASP.NET 指令的作用

给定的`*.aspx`文件通常用一组指令打开。ASP.NET 指令总是用`<%@ ... %>`标记来表示，并且可以用各种属性来限定，以通知 ASP.NET 运行时如何处理有问题的属性。

每个`*.aspx`文件至少有一个`<%@Page%>`指令，用于定义页面中使用的托管语言(通过`language`属性)。此外，`<%@Page%>`指令可以定义相关代码隐藏文件的名称(马上就要检查)，等等。表 [31-1](#Tab1) 记录了一些更有趣的以`<%@Page%>`为中心的属性。

表 31-1。

Select Attributes of the `<%@Page%>` Directive

<colgroup><col> <col></colgroup> 
| 属性 | 生命的意义 |
| --- | --- |
| `CodePage` | 指定相关代码隐藏文件的名称 |
| `EnableTheming` | 确定`*.aspx`页面上的控件是否支持 ASP.NET 主题 |
| `EnableViewState` | 指示视图状态是否跨页面请求被维护(关于这个属性的更多细节在第 33 章中) |
| `Inherits` | 在代码隐藏页面中定义一个从`*.aspx`文件派生的类，它可以是从`System.Web.UI.Page`派生的任何类 |
| `MasterPageFile` | 设置与当前`*.aspx`页面结合使用的母版页 |
| `Trace` | 指示是否启用跟踪 |

除了`<%@Page%>`指令之外，一个给定的`*.aspx`文件可以指定各种`<%@Import%>`指令来明确地声明当前页面所需的名称空间，以及`<%@Assembly%>`指令来指定站点使用的外部代码库(通常放在网站的`\bin`文件夹中)。

在这个例子中，您在`AutoLotDAL.dll`程序集的`Models`和`Repos`命名空间中指定了类型。如果你需要利用额外的。NET 命名空间，您只需指定多个`<%@Import%>` / `<%@Assembly%>`指令。

可以肯定的是，ASP.NET 确实定义了许多其他的指令，它们可能出现在一个`*.aspx`文件中，在`<%@Page%>`、`<%@Import%>`和`<%@Assembly%>`之外；然而，我将暂时保留对这些的评论。在阅读剩余章节的过程中，您将看到其他指令的示例。

### 分析“脚本”块

在单文件页面模型下，`*.aspx`文件可能包含在 web 服务器上执行的服务器端脚本逻辑。在这种情况下，使用`runat="server"`属性将所有服务器端代码块定义为在服务器上执行是至关重要的。如果没有提供`runat="server"`属性，运行时会假设您已经编写了一个客户端脚本块，该脚本块将被发送到传出的 HTTP 响应中，并且会抛出一个异常。也就是说，这里有一个合适的服务器端`<script>`块:

`<script runat="server">`

`public IEnumerable<Inventory> GetData()`

`{`

`return new InventoryRepo().GetAll();`

`}`

`</script>`

Note

所有的 Web 表单控件都需要在它们的开始声明中有`runat="server"`属性。否则，它们不会将其 HTML 呈现到出站 HTTP 响应中。

### 分析 ASP.NET 控制声明

在第一个例子中，最后一个有趣的地方是`GridView` web 控件的声明。像经典的 ASP 和原始 HTML 一样，Web 表单小部件的范围在`<form>`元素内。然而，这一次，开始的`<form>`元素被标记为`runat="server"`属性。同样，控件用`asp:`标签前缀限定。任何带有此前缀的控件都是 ASP.NET 控件库的成员，并且在给定的。的. NET 命名空间。NET 基础类库。在这里你可以找到

`<form id="form1" runat="server">`

`<div>`

`<asp:GridView ID="carsGridView" runat="server"`

`ItemType="AutoLotDAL.Models.Inventory"`

`SelectMethod="GetData" >`

`</asp:GridView>`

`</div>`

`</form>`

`System.Web.dll`程序集的`System.Web.UI.WebControls`命名空间包含大多数 Web 窗体控件。例如，如果您要打开 Visual Studio 对象浏览器，您可以找到`DataGrid`控件(参见图 [31-15](#Fig15) )。

![A978-1-4842-1332-2_31_Fig15_HTML.jpg](img/A978-1-4842-1332-2_31_Fig15_HTML.jpg)

图 31-15。

All ASP.NET control declarations map to a .NET class type

正如你所看到的，一个 Web 表单控件有一个继承链，在最顶端有一个`System.Object`。`WebControl`父类是所有 ASP.NET 控件的公共基础，它定义了您所期望的所有公共 UI 属性(`BackColor`、`Height`等)。).`Control`类在框架内也很常见；然而，它定义了更多以基础设施为中心的成员(数据绑定、视图状态等)。)而不是孩子的图形化观感。你将在第 33 章中了解更多关于这些职业的知识。

Source Code

SinglePageModel 网站包含在 [`Chapter 31`](31.html) 子目录中。

## 使用代码文件构建 ASP.NET 网页

虽然单文件代码模型有时会有所帮助，但 Visual Studio(在创建新的 web 项目时)采用的默认方法是利用一种称为代码隐藏的技术，这种技术允许您使用两个不同的文件将服务器端编程代码与 HTML 表示逻辑分开。当您的页面包含大量代码或者多个开发人员在同一个网站上工作时，这种模式非常适用。代码隐藏模型还提供了其他好处，例如:

*   因为代码隐藏页提供了 HTML 标记和代码的清晰分离，所以可以让设计人员处理标记，而程序员编写 C#代码。
*   代码不向页面设计者或其他只处理页面标记的人公开(正如您可能猜到的，HTML 人并不总是对查看大量 C#代码感兴趣)。
*   代码文件可以跨多个`*.aspx`文件使用。

无论您采用哪种方法，在性能方面都没有区别。事实上，许多 Web 窗体应用受益于构建同时使用这两种方法的站点。为了说明代码隐藏页面模型，让我们使用一个空白的 Visual Studio 网站模板再次创建上一个示例。激活文件 ASP.NET 新➤项目菜单选项，然后选择 Web 应用，然后选择空 ASP.NET 4.6 模板。

现在，使用项目➤的 Add New Item 菜单选项，插入一个名为`Default.aspx`的新 Web 表单项。再次，利用设计器构建一个由单个`GridView`组成的 UI，并利用属性窗口构建一个您喜欢的 UI。如果您愿意，您可以将 SinglePageModel 示例中以前的 ASP.NET 控件声明直接复制到新的`*.aspx`文件中。鉴于这是完全相同的标记，我就不在这里赘述了(只要确保将控件声明粘贴在`<form>`和`</form>`标签之间)。

现在，注意代码文件模型中使用的`<%@Page%>`指令有几个属性:

`<%@ Page Language="C#" AutoEventWireup="true"`

`CodeBehind="Default.aspx.cs" Inherits="CodeBehindPageModel.Default" %>`

`CodeFile`属性用于指定包含该页面编码逻辑的相关外部文件。默认情况下，这些代码隐藏文件的命名方式是在`*.aspx`文件的名称后面加上后缀`.cs`(在本例中为`Default.aspx.cs`)。如果您检查解决方案资源管理器，您会看到这个代码隐藏文件通过 Web 表单图标上的子节点可见(参见图 [31-16](#Fig16) )。

![A978-1-4842-1332-2_31_Fig16_HTML.jpg](img/A978-1-4842-1332-2_31_Fig16_HTML.jpg)

图 31-16。

The associated code-behind file for a given `*.aspx` file

如果您要打开代码隐藏文件，您会发现一个从`System.Web.UI.Page`派生的分部类，支持处理`Load`事件。注意，这个类的完全限定名(`CodeBehindPageModel.Default`)与`<%@Page%>`指令中的`Inherits`属性相同。

`public partial class Default : System.Web.UI.Page`

`{`

`protected void Page_Load(object sender, EventArgs e)`

`{`

`}`

`}`

### 参考 AutoLotDAL 项目

您将需要更新的 AutoLotDAL 项目(或之前练习中编译的`AutoLotDAL.dll)`)。如果将 AutoLotDAL 项目添加到解决方案中，则需要从 web 项目中添加对 AutoLotDAL 的引用。如果你要引用编译过的`AutoLotDAL.dll`程序集，你需要将文件添加到解决方案资源管理器中的`\bin`文件夹，如图 [31-17](#Fig17) 所示(你可能需要切换显示所有文件按钮)。

![A978-1-4842-1332-2_31_Fig17_HTML.jpg](img/A978-1-4842-1332-2_31_Fig17_HTML.jpg)

图 31-17。

Visual Studio web projects make use of special ASP.NET folders

就像前面的例子一样，通过右键单击项目，选择 Manage NuGet Packages，然后安装 EF，将实体框架添加到 web 项目中。最后，将`<connectionStrings>`节点复制到`Web.config`文件中。

### 更新代码文件

如果您检查前一个示例中的`Default.aspx`文件，您将看到每个 Web 表单页面由三个文件组成:`*.aspx`文件(用于标记)、`*.designer.cs`文件(用于设计器生成的 C#代码)和主 C#代码文件(用于事件处理程序、自定义方法等等)。见图 [31-18](#Fig18) 。

![A978-1-4842-1332-2_31_Fig18_HTML.jpg](img/A978-1-4842-1332-2_31_Fig18_HTML.jpg)

图 31-18。

Under the Web Application model, each web page is composed of three files

如果您从前面的示例中复制了标记，那么现在您需要做的就是在`Default.aspx.cs`代码隐藏文件中创建`GetData`方法。首先为`AutoLotDAL.Models`和`AutoLotDAL.Repos`添加`using`语句。然后，添加`GetData`方法如下:

`using AutoLotDAL.Models;`

`using AutoLotDAL.Repos;`

`namespace CodeBehindPageModel`

`{`

`public partial class Default : System.Web.UI.Page`

`{`

`protected void Page_Load(object sender, EventArgs e)`

`{`

`}`

`public IEnumerable<Inventory> GetData()`

`{`

`return new InventoryRepo().GetAll();`

`}`

`}`

`}`

此时，您可以通过按 Ctrl+F5(或 F5)组合键来运行您的 web 应用。IIS Express 将再次启动，将您的页面提供给托管浏览器。

### 调试和跟踪 ASP.NET 页面

要调试 Web 窗体应用，您的站点必须包含一个正确配置的`Web.config`文件。当您启动调试会话时，如果 IDE 询问您是否要修改`Web.config`文件以启用调试，请回答 yes。这意味着您的`Web.config`缺少以下标记(最重要的是`debug="true"`属性):

`<compilation debug="true" targetFramework="4.6"/>`

另外，您可以通过在`<%@Page%>`指令中将`Trace`属性设置为`true`来启用对`*.aspx`文件的跟踪支持(也可以通过修改`Web.config`文件来启用对整个站点的跟踪)。

`<%@ Page Language="C#" AutoEventWireup="true"`

`CodeBehind="Default.aspx.cs" Inherits="CodeBehindPageModel.Default"`

`Trace="true" %>`

Note

Web 应用页面继承自类的完全限定名，在本例中是`CodeBehindPageModel.Default`。网站页面继承了带有下划线的页面名称，如`_Default`。

一旦您这样做了，发出的 HTML 包含许多关于以前的 HTTP 请求/响应的细节(服务器变量、会话和应用变量、请求/响应等。).要将您自己的跟踪消息插入到混合中，您可以使用从`System.Web.UI.Page`继承的`Trace`属性。任何时候你想记录一个定制的消息(从一个脚本块或 C#源代码文件)，只需调用静态的`Trace.Write()`方法。第一个参数代表自定义类别的名称；第二个参数指定跟踪消息。举例来说，用下面的代码语句更新`GetData`方法:

`public IEnumerable<Inventory> GetData()`

`{`

`Trace.Write("Default.aspx","Getting Data");`

`return new InventoryRepo().GetAll();`

`}`

再次运行您的项目。您会发现您的自定义类别和自定义消息都已显示和说明。在图 [31-19](#Fig19) 中，注意显示追踪信息的高亮信息。

![A978-1-4842-1332-2_31_Fig19_HTML.jpg](img/A978-1-4842-1332-2_31_Fig19_HTML.jpg)

图 31-19。

Logging custom trace messages

现在，您知道了如何使用单文件和代码文件方法构建单个 Web 窗体页。本章的其余部分将深入探讨 Web 表单项目的组成，以及与 HTTP 请求/响应和`Page`派生类的生命周期进行交互的方式。

Source Code

CodeBehindPageModel 网站包含在 [`Chapter 31`](31.html) 子目录中。

## ASP.NET 网站与 ASP.NET 网络应用

当您准备构建一个新的 Web 窗体项目时，您需要选择使用两种项目格式中的哪一种，ASP.NET 网站还是 ASP.NET Web 应用。您对 web 项目的选择将控制 Visual Studio 组织和处理 web 应用启动文件的方式、创建的初始项目文件的类型以及您对编译的。NET 程序集。

当 ASP.NET 第一次和。NET 1.0，唯一的选择就是构建现在所谓的 web 应用。在此模型下，您可以直接控制已编译的输出程序集的名称和位置。

当您迁移旧版本时，Web 应用非常有用。NET 1.1 网站转换成。NET 2.0 及更高版本的项目。当您希望生成可以包含多个项目的单个 Visual Studio 解决方案(例如，Web 应用和任何相关的。NET 代码库)。前两个例子使用 ASP.NET web 应用作为起点。

Note

因为 Visual Studio ASP.NET 项目模板可以生成大量的起始代码(母版页、内容页、脚本库、登录页等)。)，本书将选择使用空白网站模板。但是，在您阅读了本文的 ASP.NET 章节后，请确保您创建了一个新的 ASP.NET 网站项目，并亲自检查了该起始代码。

与此形成鲜明对比的是，visual studio ASP.NET 网站项目模板(位于“文件”“➤新网站”菜单选项下)隐藏了`*.designer.cs`文件，以支持内存中的分部类。此外，ASP.NET 网站项目支持许多特殊命名的文件夹，如`App_Code`。在这个文件夹中，您可以放置任何没有直接映射到您的网页的 C#(或 VB)代码文件，运行时编译器将根据需要动态编译它们。这是对构建专用的正常行为的极大简化。NET 代码库并在新项目中引用它。

与此相关的一点是，网站项目可以按原样推送到生产 web 服务器，而不需要预编译网站，就像您需要预编译 ASP.NET web 应用一样。

在本书中，我们将利用 ASP.NET 网站项目类型，因为它们确实简化了在。NET 平台。然而，无论您采用哪种方法，您都可以访问相同的整体编程模型。

### 为 ASP.NET 网站启用 C# 6

默认情况下，ASP.NET 网站没有启用 C# 6(Web 窗体项目在默认项目模板中启用了 c#)。要启用新的 C# 6 语言特性，您必须安装 CodeDom Providers NuGet 包。若要为网站安装此，请在解决方案资源管理器中右击网站名称，选择“管理 NuGet 包”，然后搜索 CodeDom。这将打开 Microsoft . codedom . providers . dotnet compiler platform。单击安装。

## ASP.NET 网站目录结构

当您创建一个新的 ASP.NET 网站项目时，您的项目可能包含任意数量的专门命名的子目录，每个子目录对 ASP.NET 运行时都有特殊的意义。表 [31-2](#Tab2) 记录了这些特殊的子目录。

表 31-2。

Special ASP.NET Subdirectories

<colgroup><col> <col></colgroup> 
| 子文件夹 | 生命的意义 |
| --- | --- |
| `App_Browsers` | 浏览器定义文件的文件夹，用于标识各个浏览器并确定其功能。 |
| `App_Code` | 要作为应用的一部分进行编译的组件或类的源代码的文件夹。当页面被请求时，ASP.NET 编译这个文件夹中的代码。您的应用可以自动访问`App_Code`文件夹中的代码。 |
| `App_Data` | 用于存储 Access `*.mdb`文件、SQL Express `*.mdf`文件、XML 文件或其他数据存储的文件夹。 |
| `App_GlobalResources` | 从应用代码以编程方式访问的`*.resx`文件的文件夹。 |
| `App_LocalResources` | 绑定到特定页面的`*.resx`文件的文件夹。 |
| `App_Themes` | 包含定义 Web 窗体页和控件外观的文件集合的文件夹。 |
| `App_WebReferences` | 与在应用中使用 web 服务相关的代理类、模式和其他文件的文件夹。 |
| `Bin` | 用于编译的私有程序集(`*.dll`文件)的文件夹。应用会自动引用`Bin`文件夹中的程序集。 |

如果您有兴趣将这些已知的子文件夹添加到您当前的 web 应用中，您可以使用网站➤添加 ASP.NET 文件夹菜单选项来明确地执行此操作。但是，在许多情况下，IDE 会自动这样做，因为您会自然地将相关文件插入到站点中。例如，将一个新的类文件插入到您的项目中，会自动将一个`App_Code`文件夹添加到您的目录结构中，如果当前不存在的话。

### 引用程序集

尽管网站模板确实会生成一个`*.sln`文件来将您的`*.aspx`文件加载到 IDE 中，但是不再有相关的`*.csproj`文件。然而，一个 ASP.NET web 应用项目记录了`*.csproj`中的所有外部程序集。那么 ASP.NET 统治下的外部集会记录在哪里呢？

正如您所看到的，当您引用私有程序集时，Visual Studio 会自动在您的目录结构中创建一个`\bin`目录来存储二进制文件的本地副本。当您的代码库使用这些代码库中的类型时，它们会根据需要自动加载。

如果您引用位于全局程序集缓存中的共享程序集，Visual Studio 会自动将一个`Web.config`文件插入到您当前的 web 解决方案中(如果当前没有),并在`<assemblies>`元素中记录外部引用。例如，如果您再次激活网站➤添加引用菜单选项，并且这一次选择一个共享的程序集(例如`System.Security.dll)`，您将发现您的`Web.config`文件已经更新如下:

`<assemblies>`

`<add assembly="System.Security, Version=4.0.0.0,`

`Culture=neutral, PublicKeyToken=B03F5F7F11D50A3A"/>`

`</assemblies>`

正如你所看到的，通过`Assembly.Load()`方法，每个组件都使用动态加载所需的相同信息进行描述(见[第 15 章](15.html))。

### App_Code 文件夹的作用

`App_Code`文件夹用于存储不直接绑定到特定网页的源代码文件(例如代码隐藏文件),但是要被编译以供您的网站使用。`App_Code`文件夹中的代码将根据需要自动编译。此后，网站中的任何其他代码都可以访问该程序集。为此，`App_Code`文件夹很像`Bin`文件夹，除了你可以在里面存储源代码而不是编译后的代码。这种方法的主要好处是可以为您的 web 应用定义自定义类型，而不必单独编译它们。

一个单独的`App_Code`文件夹可以包含多种语言的代码文件。在运行时，适当的编译器开始生成有问题的程序集。但是，如果您希望对代码进行分区，您可以定义多个子目录，用于保存任意数量的托管代码文件(`*.vb`、`*.cs`等)。).

例如，假设您已经向一个网站应用的根目录添加了一个`App_Code`文件夹，该应用有两个子文件夹`MyCSharpCode`和`MyVbNetCode`，其中包含特定于语言的文件。完成之后，您可以更新您的`Web.config`文件，使用嵌套在`<configuration>`元素中的`<codeSubDirectories>`元素来指定这些子目录，如下所示:

`<compilation debug="true" strict="false" explicit="true">`

`<codeSubDirectories>`

`<add directoryName="MyCSharpCode" />`

`<add directoryName="MyVbNetCode" />`

`</codeSubDirectories>`

`</compilation>`

Note

`App_Code`目录也将用于包含不是语言文件但仍然有用的文件`(*.xsd`文件、`*.wsdl`文件等。).

在`Bin`和`App_Code`之外，`App_Data`和`App_Themes`文件夹是另外两个你应该熟悉的特殊子目录，这两个目录将在接下来的几章中详细介绍。一如既往，请参考。NET Framework 4.6 SDK 文档，如果您需要进一步的信息，可以获得其余 ASP.NET 子目录的完整详细信息。

## 页面类型的继承链

全部。NET 网页最终源于`System.Web.UI.Page`。与任何基类一样，此类型为所有派生类型提供了多态接口。然而，`Page`类型并不是继承层次结构中的唯一成员。如果您要使用 Visual Studio 对象浏览器定位`System.Web.UI.Page`类(在`System.Web.dll`程序集内)，您会发现`Page`是-a `TemplateControl`是-a `Control`，是-a`Object`(参见图 [31-20](#Fig20) )。

![A978-1-4842-1332-2_31_Fig20_HTML.jpg](img/A978-1-4842-1332-2_31_Fig20_HTML.jpg)

图 31-20。

The inheritance chain of `Page`

这些基类中的每一个都为每一个`*.aspx`文件带来了大量的功能。对于您的大多数项目，您将利用在`Page`和`Control`父类中定义的成员。从`System. Web.UI.TemplateControl`类获得的功能只有在您构建定制 Web 表单控件或与呈现过程交互时才感兴趣。

第一个感兴趣的父类是`Page`本身。在这里，您将发现许多属性，这些属性使您能够与各种 web 原语进行交互，例如应用和会话变量、HTTP 请求/响应支持等等。表 [31-3](#Tab3) 描述了一些(但绝不是全部)核心属性。

表 31-3。

Select Properties of the `Page` Type

<colgroup><col> <col></colgroup> 
| 财产 | 生命的意义 |
| --- | --- |
| `Application` | 允许您与所有用户可以通过整个网站访问的数据进行交互 |
| `Cache` | 允许您与当前网站的缓存对象进行交互 |
| `ClientTarget` | 允许您指定此页面应如何基于请求浏览器呈现自身 |
| `IsPostBack` | 获取一个值，该值指示该页是为响应客户端回发而被加载，还是首次被加载和访问 |
| `MasterPageFile` | 为当前页面建立母版页 |
| `Request` | 提供对当前 HTTP 请求的访问 |
| `Response` | 允许您与传出的 HTTP 响应进行交互 |
| `Server` | 提供对`HttpServerUtility`对象的访问，该对象包含各种服务器端助手函数 |
| `Session` | 允许您与当前呼叫者的会话数据进行交互 |
| `Theme` | 获取或设置用于当前页面的主题的名称 |
| `Trace` | 提供对一个`TraceContext`对象的访问，该对象允许您在调试会话期间记录定制消息 |

## 与传入的 HTTP 请求交互

正如您在本章前面所看到的，web 应用的基本流程始于客户端请求一个 web 页面，可能需要填写用户信息，然后单击“提交按钮”将 HTML 表单数据发送回给定的 web 页面进行处理。在大多数情况下，`form`语句的开始标记指定了一个`action`属性和一个`method`属性，这两个属性表示 web 服务器上的文件，这些文件将在各种 HTML 小部件中被发送数据，以及发送这些数据的方法(`GET`或`POST`)。

`<form name="defaultPage" id="defaultPage"`

`action="``http://localhost/Cars/ClassicAspPage.asp`T2】

`...`

`</form>`

所有 ASP.NET 页面都支持`System.Web.UI.Page.Request`属性，该属性提供对`HttpRequest`类类型的实例的访问(参见表 [31-4](#Tab4) 中该类的一些公共成员)。

表 31-4。

Members of the `HttpRequest` Class

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `ApplicationPath` | 获取 ASP.NET 应用在服务器上的虚拟应用根路径 |
| `Browser` | 提供有关客户端浏览器功能的信息 |
| `Cookies` | 获取客户端浏览器发送的 cookies 集合 |
| `FilePath` | 指示当前请求的虚拟路径 |
| `Form` | 获取 HTTP 表单变量的集合 |
| `Headers` | 获取 HTTP 标头的集合 |
| `HttpMethod` | 表示客户端使用的 HTTP 数据传输方法(`GET`、`POST`) |
| `IsSecureConnection` | 指示 HTTP 连接是否安全(即`HTTPS`) |
| `QueryString` | 获取 HTTP 查询字符串变量的集合 |
| `RawUrl` | 获取当前请求的原始 URL |
| `RequestType` | 表示客户端使用的 HTTP 数据传输方法(`GET`、`POST`) |
| `ServerVariables` | 获取 web 服务器变量的集合 |
| `UserHostAddress` | 获取远程客户端的 IP 主机地址 |
| `UserHostName` | 获取远程客户端的 DNS 名称 |

除了这些属性之外，`HttpRequest`类型还有许多有用的方法，包括如下:

*   `MapPath()`:将请求 URL 中的虚拟路径映射到当前请求的服务器上的物理路径。
*   `SaveAs`:将当前 HTTP 请求的详细信息保存到 web 服务器上的一个文件中，这将有助于调试。
*   `ValidateInput()`:如果通过`Page`指令的`Validate`属性启用了验证特性，那么可以调用这个方法来对照预定义的潜在危险输入数据列表检查所有用户输入数据(包括 cookie 数据)。

### 获取浏览器统计信息

`HttpRequest`类型的第一个有趣的方面是`Browser`属性，它提供了对底层`HttpBrowserCapabilities`对象的访问。`HttpBrowserCapabilities`反过来公开了许多成员，这些成员允许您以编程方式调查关于发送传入 HTTP 请求的浏览器的统计信息。

通过选择文件➤新网站菜单选项，创建一个新的 ASP.NET 空网站(名为 FunWithPageMembers)。您将看到一个类似于图 [31-21](#Fig21) 的屏幕。

![A978-1-4842-1332-2_31_Fig21_HTML.jpg](img/A978-1-4842-1332-2_31_Fig21_HTML.jpg)

图 31-21。

Creating a new, blank web site

请注意，在图 [31-21](#Fig21) 中，您可以选择新站点的位置。如果选择文件系统，您的内容文件将放在本地目录中，页面将通过 IIS Express 提供。如果选择 FTP 或 HTTP，您的网站将驻留在由 IIS 维护的新虚拟目录中。对于这个例子，选择哪个选项没有什么区别，但是为了简单起见，我建议选择文件系统选项。

如果你选择了一个已经有网站的目录(或者任何文件)，你将会被提示通过如图 [31-22](#Fig22) 所示的对话框输入一个新的名称(这将创建一个新的目录)。

![A978-1-4842-1332-2_31_Fig22_HTML.jpg](img/A978-1-4842-1332-2_31_Fig22_HTML.jpg)

图 31-22。

Specifying the name for the new, blank web site

设置好站点后，使用网站➤添加新项目菜单选项，将新的 Web 表单文件插入到项目中。在左栏选择 Visual C#，将文件命名为`Default.aspx`。您的第一个任务是构建一个 UI，允许用户单击一个`Button` web 控件(名为`btnGetBrowserStats`)来查看关于调用浏览器的各种统计数据。这些统计数据将动态生成，并附加到一个`Label`类型(名为`lblOutput`)。将这两个控件添加到网页设计器中您喜欢的任何位置。接下来，通过在源代码视图中添加`OnClick`属性来处理按钮的`Click`事件，并将方法命名为`btnGetBrowserStats`。您的标记应该如下所示:

`<strong style="font-weight: 700">Basic Request / Response Info<br />`

`<br />`

`<asp:Button ID="btnGetBrowserStats" runat="server"`

`OnClick="btnGetBrowserStats_Click" Text="Get Stats" />`

`<br />`

`<br />`

`<asp:Label ID="lblOutput" runat="server"></asp:Label>`

`</strong>`

在 Web 窗体页的代码隐藏中，实现如下所示的处理程序(注意字符串插值的使用，您在本书的前面部分已经学习过):

`protected void btnGetBrowserStats_Click(object sender, EventArgs e)`

`{`

`string theInfo = "";`

`theInfo += $"<li>Is the client AOL? {Request.Browser.AOL}</li>";`

`theInfo += $"<li>Does the client support ActiveX? {Request.Browser.ActiveXControls}</li>";`

`theInfo += $"<li>Is the client a Beta? {Request.Browser.Beta}</li>";`

`theInfo += $"<li>Does the client support Java Applets? {Request.Browser.JavaApplets}</li>";`

`theInfo += $"<li>Does the client support Cookies? {Request.Browser.Cookies}</li>";`

`theInfo += $"<li>Does the client support VBScript? {Request.Browser.VBScript}</li>";`

`lblOutput.Text = theInfo;`

`}`

在这里，您正在测试许多浏览器功能。正如您所猜测的，发现浏览器对 ActiveX 控件、Java 小程序和客户端 VBScript 代码的支持(非常)有帮助。如果调用浏览器不支持给定的 web 技术，您的`*.aspx`页面将能够采取替代的行动。

### 对传入表单数据的访问

`HttpRequest`类型的其他方面是`Form`和`QueryString`属性。这两个属性允许您使用名称/值对检查传入的表单数据。虽然您可以利用`HttpRequest.` `Form`和`HttpRequest.QueryString`属性来访问 web 服务器上客户端提供的表单数据，但是 ASP.NET 提供了一种更优雅的、面向对象的方法。鉴于 ASP.NET 为您提供了服务器端 web 控件，您可以将 HTML UI 元素视为真正的对象。因此，与在文本框中获取值不同，如

`protected void btnGetFormData_Click(object sender, System.EventArgs e)`

`{`

`// Get value for a widget with ID txtFirstName.`

`string firstName = Request.Form("txtFirstName");`

`// Use this value in your page...`

`}`

您可以简单地通过`Text`属性直接请求服务器端小部件在您的程序中使用，就像这样:

`protected void btnGetFormData_Click(object sender, System.EventArgs e)`

`{`

`// Get value for a widget with ID txtFirstName.`

`string firstName = txtFirstName.Text;`

`// Use this value in your page...`

`}`

要显示这一点，请在您的表单中添加一个文本框和按钮。将文本框的 Id 设置为`txtFirstName`，将按钮的 Id 设置为`btnGetFormData`。添加`OnClick`属性，并将值设置为`btnGetFormData_` `OnClick`，如下:

`<br/>`

`<label>First Name</label>`

`<asp:TextBox runat="server" Id="txtFirstName"/>`

`<asp:Button runat="server" Id="btnGetFormData"`

`OnClick="btnGetFormData_Click" Text="Get First Name"/>`

如上所示实现`btnGetFormData_Click`事件处理程序。运行应用，在文本框中输入您的姓名，然后单击获取名字按钮。您将在标签中看到您输入的名称。

这种方法不仅符合可靠的 OO 原则，而且在获取值之前，您不需要关心表单数据是如何提交的(`GET`或`POST`)。此外，直接使用小部件更加类型安全，因为键入错误是在编译时而不是运行时发现的。当然，这并不是说你永远不需要使用 ASP.NET 的`Form`或`QueryString`房产；相反，这样做的必要性已经大大减少，通常是可选的。

### IsPostBack 属性

`Page`的另一个非常重要的成员是`IsPostBack`属性。回想一下,“回发”指的是网页回发到 web 服务器上的同一个 URL。根据这个定义，如果当前的 HTTP 请求是由当前会话中的用户发送的，那么`IsPostBack`属性将返回`true`，如果这是用户与页面的第一次交互，则返回`false`。

通常，当您需要仅在用户第一次访问给定页面时执行代码块时，确定当前 HTTP 请求是否确实是回发是非常有用的。例如，当用户第一次访问一个`*.aspx`文件时，您可能想要填充一个 ADO.NET`DataSet`，并缓存该对象以备后用。当调用者返回页面时，您可以避免不必要的访问数据库(当然，有些页面可能需要在每次请求时更新`DataSet al`方法，但这是另一个问题)。假设您的`*.aspx`文件已经处理了页面的`Load`事件(将在本章后面详细描述)，您可以通过编程测试回发条件，如下所示:

`protected void Page_Load(object sender, EventArgs e)`

`{`

`// Fill Data only the very first time`

`// the user comes to this page.`

`if (!IsPostBack)`

`{`

`// Populate Data and cache it!`

`}`

`// Use cached Data.`

`}`

## 与传出的 HTTP 响应交互

现在您已经更好地理解了`Page`类型如何允许您与传入的 HTTP 请求进行交互，下一步是看看如何与传出的 HTTP 响应进行交互。在 ASP.NET，`Page`类的`Response`属性提供了对`HttpResponse`类型实例的访问。此类型定义了许多属性，允许您格式化发送回客户端浏览器的 HTTP 响应。表 [31-5](#Tab5) 列出了一些核心属性。

表 31-5。

Properties of the `HttpResponse` Type

<colgroup><col> <col></colgroup> 
| 财产 | 生命的意义 |
| --- | --- |
| `Cache` | 返回网页的缓存语义(见第 34 章 |
| `ContentEncoding` | 获取或设置输出流的 HTTP 字符集 |
| `ContentType` | 获取或设置输出流的 HTTP MIME 类型 |
| `Cookies` | 获取将返回给浏览器的`HttpCookie`集合 |
| `Output` | 允许文本输出到传出的 HTTP 内容正文 |
| `OutputStream` | 启用对传出 HTTP 内容主体的二进制输出 |
| `StatusCode` | 获取或设置返回给客户端的输出的 HTTP 状态代码 |
| `StatusDescription` | 获取或设置返回给客户端的输出的 HTTP 状态字符串 |
| `SuppressContent` | 获取或设置一个值，该值指示不会将 HTTP 内容发送到客户端 |

同样，考虑由`HttpResponse`类型支持的方法的部分列表，在表 [31-6](#Tab6) 中描述。

表 31-6。

Methods of the `HttpResponse` Type

<colgroup><col> <col></colgroup> 
| 方法 | 生命的意义 |
| --- | --- |
| `Clear()` | 从缓冲流中清除所有头和内容输出 |
| `End()` | 将所有当前缓冲的输出发送到客户端，然后关闭套接字连接 |
| `Flush()` | 将所有当前缓冲的输出发送到客户端 |
| `Redirect()` | 将客户端重定向到新的 URL |
| `Write()` | 将值写入 HTTP 输出内容流 |
| `WriteFile()` | 将文件直接写入 HTTP 内容输出流 |

### 发出 HTML 内容

也许`HttpResponse`类型最广为人知的方面是能够将内容直接写入 HTTP 输出流。`HttpResponse.Write()`方法允许你传入任何 HTML 标签和/或文本。`HttpResponse.WriteFile()`方法将这一功能向前推进了一步，因为您可以在 web 服务器上指定一个物理文件的名称，该文件的内容应该呈现到输出流中(这对于快速发出现有`*.htm`文件的内容非常有帮助)。

举例来说，将另一个`Button`添加到当前的`*.aspx`文件中，如下所示:

`<br/>`

`<asp:Button runat="server" Id="btnHttpResponse"`

`OnClick="btnHttpResponse_Click" Text="Get First Name"/>`

现在实现服务器端的`Click`事件处理程序，就像这样:

`protected void btnHttpResponse_Click(object sender, EventArgs e)`

`{`

`Response.Write("<b>My name is:</b><br>");`

`Response.Write(this.ToString());`

`}`

这个 helper 函数的角色(您可以假设它是由某个服务器端事件处理程序调用的)非常简单。同样，虽然你总是可以采用这种老派的方法，使用`Write()`方法呈现 HTML 标签和内容，但这种方法在 ASP.NET 下远不如在经典 ASP 下常见。原因是(再次)由于服务器端 web 控件的出现。因此，如果您想向浏览器呈现一个文本数据块，您的任务就像给一个`Label`小部件的`Text`属性分配一个字符串一样简单。

### 重定向用户

`HttpResponse`类型的另一个特点是能够将用户重定向到一个新的 URL，如下所示:

`protected void btnWasteTime_Click(object sender, EventArgs e)`

`{`

`Response.Redirect("`[`http://www.facebook.com`](http://www.facebook.com/)T2】

`}`

如果通过客户端回发调用此事件处理程序，用户将被自动重定向到指定的 URL。

Note

`HttpResponse.Redirect()`方法总是需要返回到客户端浏览器。如果您只是想将控制转移到同一个虚拟目录中的一个`*.aspx`文件，那么通过继承的`Server`属性访问的`HttpServerUtility.Transfer()`方法会更有效。

关于`System.Web.UI.Page`功能的调查到此为止。您将在下一章中研究`System.Web.UI.Control`基类的角色。接下来，让我们检查一个`Page`派生对象的生命和时代。

Source Code

FunWithPageMembers 网站包含在 [`Chapter 31`](31.html) 子目录中。

## ASP.NET 网页的生命周期

每个 Web 窗体页都有固定的生命周期。当 ASP.NET 运行时收到对给定的`*.aspx`文件的传入请求时，关联的`System.Web.UI.Page`派生类型使用该类型的默认构造函数被分配到内存中。此后，框架将自动触发一系列事件。默认情况下，`Load`事件是自动计算的，您可以在其中添加自定义代码。

`public partial class _Default : System.Web.UI.Page`

`{`

`protected void Page_Load(object sender, EventArgs e)`

`{`

`Response.Write("Load event fired!");`

`}`

`}`

除了`Load`事件之外，给定的`Page`能够拦截表 [31-7](#Tab7) 中的任何核心事件，这些事件按照它们被遇到的顺序列出(参考。NET Framework 4.6 SDK 文档，了解在页面生存期内可能触发的所有事件的详细信息)。

表 31-7。

Select Events of the `Page` Type

<colgroup><col> <col></colgroup> 
| 事件 | 生命的意义 |
| --- | --- |
| `PreInit` | 框架使用此事件来分配任何 web 控件、应用主题、建立母版页以及设置用户配置文件。您可以截取此事件以自定义流程。 |
| `Init` | 框架使用此事件通过回发或视图状态数据将 web 控件的属性设置为它们以前的值。 |
| `Load` | 当此事件激发时，该页及其控件被完全初始化，并恢复其以前的值。此时，与每个 web 小部件进行交互是安全的。 |
| "触发回发的事件" | 当然，没有这个名字的事件。这个“事件”只是指导致浏览器执行回发到 web 服务器的事件(比如一个`Button`点击)。 |
| `PreRender` | 所有控件数据绑定和 UI 配置都已完成，控件已准备好将其数据呈现到出站 HTTP 响应中。 |
| `Unload` | 页面及其控件已完成呈现过程，页面对象即将被销毁。此时，与传出的 HTTP 响应进行交互是一个运行时错误。但是，您可以捕获该事件来执行任何页面级清理(关闭文件或数据库连接、执行任何形式的日志记录活动、释放对象等)。). |

当一个 C#程序员需要处理超过`Load`的事件时，你可能会惊讶地发现没有 IDE 支持这样做！相反，您必须在代码文件中手动创作一个方法，命名为`Page_NameOfEvent`。例如，下面是处理`Unload`事件的方法:

`public partial class _Default : System.Web.UI.Page`

`{`

`protected void Page_Load(object sender, EventArgs e)`

`{`

`Response.Write("Load event fired!");`

`}`

`protected void Page_Unload(object sender, EventArgs e)`

`{`

`// No longer possible to emit data to the HTTP`

`// response, so we will write to a local file.`

`System.IO.File.WriteAllText(@"C:\MyLog.txt", "Page unloading!");`

`}`

`}`

Note

页面类型的每个事件都与`System.EventHandler`委托协同工作；因此，处理这些事件的子程序总是将一个`Object`作为第一个参数，将一个`EventArgs`作为第二个参数。

### AutoEventWireup 属性的作用

当您想要处理页面的事件时，您需要用适当的事件处理程序更新您的`<script>`块或代码隐藏文件。然而，如果您检查`<%@Page%>`指令，您会注意到一个名为`AutoEventWireUp`的特定属性，默认情况下，它被设置为`true`。

`<%@ Page Language="C#" AutoEventWireup="true"`

`CodeFile="Default.aspx.cs" Inherits="_Default" %>`

使用这种默认行为，如果您输入适当命名的方法，将自动处理每个页面级事件处理程序。但是，如果通过将该属性设置为`false`来禁用`AutoPageWireUp`，如

`<%@ Page Language="C#" AutoEventWireup="false"`

`CodeFile="Default.aspx.cs" Inherits="_Default" %>`

将不再捕获页面级事件。顾名思义，该属性(启用时)将在本章前面描述的自动生成的分部类中生成必要的事件触发。即使您禁用了`AutoEventWireup`，您仍然可以通过使用 C#事件处理逻辑来处理页面级事件，如下所示:

`public _Default()`

`{`

`// Explicitly hook into the Load and Unload events.`

`this.Load += Page_Load;`

`this.Unload += Page_Unload;`

`}`

正如您可能会怀疑的那样，您通常会让`AutoEventWireup`处于启用状态。

### 错误事件

页面生命周期中可能发生的另一个事件是`Error`。如果`Page`派生类型上的方法触发了未显式处理的异常，将触发此事件。假设您已经为页面上给定的`Button`处理了`Click`事件，并且在事件处理程序(名为`btnGetFile_Click`)中，您尝试将本地文件的内容写到 HTTP 响应中。

还假设您没有通过标准的结构化异常处理测试该文件的存在。如果您已经在默认构造函数中装配了页面的`Error`事件，那么在最终用户发现一个难看的错误之前，您还有最后一次机会来处理这个页面上的问题。考虑以下代码:

`public partial class _Default : System.Web.UI.Page`

`{`

`void Page_Error(object sender, EventArgs e)`

`{`

`Response.Clear();`

`Response.Write("I am sorry...I can’t find a required file.<br>");`

`Response.Write($"The error was: <b>{ Server.GetLastError().Message }</b>");`

`Server.ClearError();`

`}`

`protected void Page_Load(object sender, EventArgs e)`

`{`

`Response.Write("Load event fired!");`

`}`

`protected void Page_Unload(object sender, EventArgs e)`

`{`

`// No longer possible to emit data to the HTTP`

`// response at this point, so we will write to a local file.`

`System.IO.File.WriteAllText(@"C:\MyLog.txt", "Page unloading!");`

`}`

`protected void btnPostback_Click(object sender, EventArgs e)`

`{`

`// Nothing happens here. This is just to ensure a`

`// postback to the page.`

`}`

`protected void btnTriggerError_Click(object sender, EventArgs e)`

`{`

`System.IO.File.ReadAllText(@"C:\IDontExist.txt");`

`}`

`}`

请注意，您的`Error`事件处理程序首先清除 HTTP 响应中当前的任何内容，并发出一条通用错误消息。如果您想访问特定的`System.Exception`对象，您可以使用由继承的`Server`属性公开的`HttpServerUtility.GetLastError()`方法。

`Exception e = Server.GetLastError();`

最后，请注意，在退出这个通用错误处理程序之前，您通过`Server`属性显式调用了`HttpServerUtility.ClearError()`方法。这是必需的，因为它通知运行时您已经处理了手头的问题，不需要进一步处理。如果您忘记这样做，最终用户将看到运行时的错误页面。

在这一点上，你应该对 ASP.NET`Page`型的构图有信心了。既然有了这样的基础，就可以将注意力转向 Web 窗体控件、主题和母版页的作用，所有这些都是剩余章节的主题。然而，为了结束这一章，让我们检查一下`Web.config`文件的作用。

Source Code

PageLifeCycle 网站包含在 [`Chapter 31`](31.html) 子目录中。

## Web.config 文件的作用

默认情况下，所有用 Visual Studio 创建的 C# Web 窗体应用都会自动提供一个`Web.config`文件。但是，如果您需要手动将一个`Web.config`文件插入到您的站点中(例如，当您正在使用单页模型并且尚未创建 web 解决方案时)，您可以使用网站➤添加新项目菜单选项来完成。在这两种情况下，在这个`Web.config`文件的范围内，您可以添加设置来控制您的 web 应用在运行时如何运行。

在你检查……NET assemblies(在[第 14 章](14.html)中)您了解到客户端应用可以利用基于 XML 的配置文件来指示 CLR 应该如何处理绑定请求、程序集探测和其他运行时细节。这同样适用于 web 表单应用，一个显著的例外是以 Web 为中心的配置文件总是被命名为`Web.config`(不像`*.exe`配置文件，它是基于相关的客户端可执行文件来命名的)。

一个`Web.config`文件的完整结构相当冗长。然而，表 [31-8](#Tab8) 概述了一些可以在`Web.config`文件中找到的更有趣的子元素。

表 31-8。

Select Elements of a `Web.config` File

<colgroup><col> <col></colgroup> 
| 元素 | 生命的意义 |
| --- | --- |
| `<appSettings>` | 该元素用于建立自定义的名称/值对，这些名称/值对可以在内存中以编程方式读取，供使用`ConfigurationManager`类型的页面使用。 |
| `<authentication>` | 此安全相关元素用于定义此 web 应用的身份验证模式。 |
| `<authorization>` | 这是另一个以安全为中心的元素，用于定义哪些用户可以访问 web 服务器上的哪些资源。 |
| `<connectionStrings>` | 此元素用于保存此网站中使用的外部连接字符串。 |
| `<customErrors>` | 该元素用于告诉运行时如何准确地显示 web 应用运行过程中出现的错误。 |
| `<globalization>` | 此元素用于配置此 web 应用的全球化设置。 |
| `<namespaces>` | 如果您的 web 应用已经使用新的`aspnet_compiler.exe`命令行工具进行了预编译，那么这个元素记录了要包含的所有名称空间。 |
| `<sessionState>` | 此元素用于控制会话状态数据将由。NET 运行时。 |
| `<trace>` | 该元素用于启用(或禁用)对该 web 应用的跟踪支持。 |

一个`Web.config`文件可能包含表 [31-8](#Tab8) 中给出的集合之外的附加子元素。这些项目中的绝大多数都与安全相关，而剩余的项目只在高级 ASP.NET 场景中有用，比如创建自定义 HTTP 头或自定义 HTTP 模块(这里不讨论这些主题)。

### ASP.NET 网站管理实用程序

虽然您总是可以使用 Visual Studio 直接修改`Web.config`文件的内容，但是 Web Forms 项目可以使用一个方便的基于 Web 的编辑器，它允许您以图形方式编辑项目的`Web.config`文件的许多元素和属性。要启动该工具，请激活 ASP.NET➤网站配置菜单选项。

如果您单击位于页面顶部的选项卡，您会很快注意到该工具的大部分功能用于为您的网站建立安全设置。然而，这个工具也可以为您的`<appSettings>`元素添加设置，定义调试和跟踪设置，并建立一个默认的错误页面。

在必要的地方，您会看到更多这种工具的应用；但是，请注意，该实用程序不允许您将所有可能的设置添加到`Web.config`文件中。大多数情况下，您需要使用您选择的文本编辑器来手动更新这个文件。

## 摘要

构建 web 应用需要不同于组装传统桌面应用的思维框架。在这一章中，你首先快速而轻松地回顾了一些核心的 web 主题，包括 HTML、HTTP、客户端脚本的作用以及使用经典 ASP 的服务器端脚本。本章的大部分都花在了研究 spent 页面的架构上。如您所见，项目中的每个`*.aspx`文件都有一个关联的`System.Web.UI.Page`派生类。使用这种面向对象的方法，ASP.NET 允许你构建更多可重用的和面向对象感知的系统。

在研究了页面继承链的一些核心功能之后，本章接着讨论了页面如何最终被编译成一个有效的。NET 程序集。在本章的最后，您探索了`Web.config`文件的作用，并概述了 ASP.NET 网站管理工具。