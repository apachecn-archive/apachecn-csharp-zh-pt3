# 12.LINQ 对物体

无论您使用。NET 平台上，您的程序在执行时肯定需要访问某种形式的数据。可以肯定的是，数据可以在很多地方找到，包括 XML 文件、关系数据库、内存集合和原始数组。从历史上来说，基于所述数据的位置，程序员需要利用不同的和不相关的 API。语言集成查询(LINQ)技术集，最初在。NET 3.5 提供了一种简洁、对称和强类型的方式来访问各种各样的数据存储。在这一章中，你将通过关注 LINQ 来开始你对 LINQ 的调查。

在深入 LINQ 到对象本身之前，本章的第一部分快速回顾了支持 LINQ 的关键 C#编程结构。当你阅读本章时，你会发现隐式类型的局部变量、对象初始化语法、lambda 表达式、扩展方法和匿名类型将会非常有用(如果不是偶尔强制的话)。

在回顾了这个支持基础结构之后，本章的剩余部分将向您介绍 LINQ 编程模型及其在。NET 平台。在这里，您将学习查询操作符和查询表达式的作用，它们允许您定义查询数据源以产生请求的结果集的语句。在这个过程中，您将构建许多与数组中包含的数据以及各种集合类型(泛型和非泛型)进行交互的 LINQ 示例，并理解表示 LINQ 到对象 API 的程序集、命名空间和类型。

Note

本章中的信息是本书后续章节研究其他 LINQ 技术的基础，包括 LINQ 到 XML ( [第 24 章](24.html))、并行 LINQ ( [第 19 章](19.html))和 LINQ 到实体([第 23 章](23.html))。

## 特定于 LINQ 的编程结构

从高层次来看，LINQ 可以理解为一种强类型查询语言，直接嵌入到 C#的语法中。使用 LINQ，您可以构建任意数量的外观和感觉都与数据库 SQL 查询相似的表达式。然而，LINQ 查询可以应用于任何数量的数据存储，包括与文字关系数据库无关的存储。

Note

尽管 LINQ 查询看起来类似于 SQL 查询，但语法并不相同。事实上，许多 LINQ 查询似乎是一个类似的数据库查询的完全相反的格式！如果您试图将 LINQ 直接映射到 SQL，您肯定会感到沮丧。为了保持理智，我建议您尽最大努力将 LINQ 查询视为唯一的语句，它只是“碰巧看起来”类似于 SQL。

当 LINQ 第一次被介绍给。NET 平台的 3.5 版本中，C#和 VB 语言都扩展了大量新的编程结构，用于支持 LINQ 技术集。具体来说，C#语言使用以下以 LINQ 为中心的核心功能:

*   隐式类型的局部变量
*   对象/集合初始化语法
*   λ表达式
*   扩展方法
*   匿名类型

这些特征已经在文本的各个章节中详细探讨过了。然而，为了开始，让我们快速地依次回顾一下每个特性，以确保我们都有正确的心态。

Note

因为接下来的部分是对本书其他地方的内容的回顾，所以我没有为这些内容包含 C#代码项目。

### 局部变量的隐式类型化

在[第三章](03.html)中，你学习了 C#的`var`关键字。该关键字允许您定义局部变量，而无需显式指定基础数据类型。但是，该变量是强类型的，因为编译器将根据初始赋值确定正确的数据类型。回想一下第三章中的代码示例:

`static void DeclareImplicitVars()`

`{`

`// Implicitly typed local variables.`

`var myInt = 0;`

`var myBool = true;`

`var myString = "Time, marches on...";`

`// Print out the underlying type.`

`Console.WriteLine("myInt is a: {0}", myInt.GetType().Name);`

`Console.WriteLine("myBool is a: {0}", myBool.GetType().Name);`

`Console.WriteLine("myString is a: {0}", myString.GetType().Name);`

`}`

在使用 LINQ 时，这种语言特性很有帮助，而且通常是强制性的。正如您将在本章中看到的，许多 LINQ 查询将返回一系列数据类型，这些数据类型直到编译时才知道。考虑到在编译应用之前不知道底层数据类型，显然不能显式声明变量！

### 对象和集合初始化语法

第 5 章探讨了对象初始化语法的作用，它允许你创建一个类或结构变量，并一次性设置任意数量的公共属性。最终的结果是一个紧凑的(但仍然很好看)语法，可以用来让您的对象准备好使用。还记得第 9 章的[吗，C#语言允许你使用类似的语法来初始化对象集合。考虑下面的代码片段，它使用集合初始化语法来填充一个`Rectangle`对象的`List<T>`，每个对象维护两个`Point`对象来表示一个(x，y)位置:](09.html)

`List<Rectangle> myListOfRects = new List<Rectangle>`

`{`

`new Rectangle {TopLeft = new Point { X = 10, Y = 10 },`

`BottomRight = new Point { X = 200, Y = 200}},`

`new Rectangle {TopLeft = new Point { X = 2, Y = 2 },`

`BottomRight = new Point { X = 100, Y = 100}},`

`new Rectangle {TopLeft = new Point { X = 5, Y = 5 },`

`BottomRight = new Point { X = 90, Y = 75}}`

`};`

虽然您从来不需要使用集合/对象初始化语法，但是这样做可以产生更紧凑的代码库。此外，当与局部变量的隐式类型化结合使用时，这种语法允许您声明一个匿名类型，这在创建 LINQ 投影时很有用。在本章的后面你会学到 LINQ 投影。

### λ表达式

C# lambda 运算符(`=>`)在第 10 章的[中有充分的探讨。回想一下，这个操作符允许您构建 lambda 表达式，只要您调用需要强类型委托作为参数的方法，就可以使用这个表达式。Lambdas 大大简化了您的工作方式。NET 委托，因为它们减少了您必须手工编写的代码量。回想一下，lambda 表达式可以分解为以下用法:](10.html)

`( ArgumentsToProcess ) => { StatementsToProcessThem }`

在第 10 章的[中，我用三种不同的方法向你展示了如何与泛型`List<T>`类的`FindAll()`方法进行交互。在使用了原始的`Predicate<T>`委托和一个 C#匿名方法之后，您最终得到了下面的(非常简洁的)迭代，它使用了下面的 lambda 表达式:](10.html)

`static void LambdaExpressionSyntax()`

`{`

`// Make a list of integers.`

`List<int> list = new List<int>();`

`list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 });`

`// C# lambda expression.`

`List<int> evenNumbers = list.FindAll(i => (i % 2) == 0);`

`Console.WriteLine("Here are your even numbers:");`

`foreach (int evenNumber in evenNumbers)`

`{`

`Console.Write("{0}\t", evenNumber);`

`}`

`Console.WriteLine();`

`}`

当使用 LINQ 的底层对象模型时，Lambdas 会很有用。您很快就会发现，C# LINQ 查询操作符只是一种在名为`System.Linq.Enumerable`的类上调用可靠方法的简写符号。这些方法通常总是需要委托(特别是`Func<>`委托)作为参数，用于处理数据以产生正确的结果集。使用 lambdas，您可以简化代码，并允许编译器推断底层委托。

### 扩展方法

C#扩展方法允许你在现有的类上添加新的功能，而不需要子类化。此外，扩展方法允许您向密封的类和结构添加新的功能，这些功能永远不会在第一个位置被子类化。回想一下[第 11 章](11.html)，当你创建一个扩展方法时，第一个参数用`this`关键字限定，并标记被扩展的类型。还记得扩展方法必须总是在静态类中定义，因此也必须使用`static`关键字声明。这里有一个例子:

`namespace MyExtensions`

`{`

`static class ObjectExtensions`

`{`

`// Define an extension method to System.Object.`

`public static void DisplayDefiningAssembly(this object obj)`

`{`

`Console.WriteLine("{0} lives here:\n\t->{1}\n", obj.GetType().Name,`

`Assembly.GetAssembly(obj.GetType()));`

`}`

`}`

`}`

若要使用此扩展，应用必须导入定义该扩展的命名空间(并可能添加对外部程序集的引用)。此时，只需导入定义的名称空间和代码。

`static void Main(string[] args)`

`{`

`// Since everything extends System.Object, all classes and structures`

`// can use this extension.`

`int myInt = 12345678;`

`myInt.DisplayDefiningAssembly();`

`System.Data.DataSet d = new System.Data.DataSet();`

`d.DisplayDefiningAssembly();`

`Console.ReadLine();`

`}`

当您使用 LINQ 时，您将很少需要手动构建自己的扩展方法。然而，当您创建 LINQ 查询表达式时，实际上您将利用微软已经定义的许多扩展方法。事实上，每个 C# LINQ 查询操作符都是对底层扩展方法进行手动调用的简写符号，通常由`System.Linq.Enumerable`实用程序类定义。

### 匿名类型

我想快速回顾的最后一个 C#语言特性是匿名类型，这在第十一章中已经探讨过了。通过允许编译器在编译时基于提供的一组名称-值对生成新的类定义，该特性可用于快速建模数据的“形状”。回想一下，这个类型将使用基于值的语义来组合，并且`System.Object`的每个虚方法将被相应地覆盖。若要定义匿名类型，请声明一个隐式类型变量，并使用对象初始化语法指定数据的形状。

`// Make an anonymous type that is composed of another.`

`var purchaseItem = new {`

`TimeBought = DateTime.Now,`

`ItemBought = new {Color = "Red", Make = "Saab", CurrentSpeed = 55},`

`Price = 34.000};`

当你想设计新形式的数据时，LINQ 经常使用匿名类型。例如，假设您有一个`Person`对象的集合，并想使用 LINQ 来获得每个对象的年龄和社会保险号信息。使用 LINQ 投影，您可以允许编译器生成包含您的信息的新匿名类型。

## 理解 LINQ 的角色

这就结束了对 C#语言特性的快速回顾，这些特性让 LINQ 发挥了它的魔力。然而，为什么首先有 LINQ 呢？作为软件开发人员，很难否认我们编程的绝大部分时间都花在了获取和操作数据上。当谈到“数据”时，很容易立即想到关系数据库中包含的信息。然而，数据的另一个流行位置是在 XML 文档或简单的文本文件中。

除了这两个常见的信息之外，还可以在许多地方找到数据。例如，假设您有一个包含 300 个整数的数组或泛型`List<T>`类型，并且您想要获得一个满足给定标准的子集(例如，容器中只有奇数或偶数成员，只有质数，只有大于 50 的非重复数)。或者，您可能正在利用反射 API，并且只需要获得从一个`Type`数组中的特定父类派生的每个类的元数据描述。事实上，数据无处不在。

之前。NET 3.5 中，与特定风格的数据交互需要程序员使用非常多样化的 API。例如，考虑一下表 [12-1](#Tab1) ，它说明了几种用于访问各种类型数据的常见 API(我相信您可以想到许多其他的例子)。

表 12-1。

Ways to Manipulate Various Types of Data

<colgroup><col> <col></colgroup> 
| 你想要的数据 | 如何获得它 |
| --- | --- |
| 关系数据 | `System.Data.dll`、`System.Data.SqlClient.dll`等等 |
| XML 文档数据 | `System.Xml.dll` |
| 元数据表 | `System.Reflection`名称空间 |
| 对象集合 | `System.Array`和`System.Collections/System.Collections.Generic`名称空间 |

当然，这些处理数据的方法并没有错。事实上，您可以(也将会)直接使用 ADO.NET、XML 名称空间、反射服务和各种集合类型。然而，基本的问题是这些 API 中的每一个都是一个孤岛，很少提供集成。的确，可以(例如)将 ADO.NET`DataSet`保存为 XML，然后通过`System.Xml`名称空间操纵它，但是尽管如此，数据操纵仍然相当不对称。

LINQ API 试图提供一种一致的、对称的方式，程序员可以用这种方式获取和操作广义上的“数据”。使用 LINQ，您可以直接在 C#编程语言中创建称为查询表达式的结构。这些查询表达式基于许多查询操作符，这些操作符被有意设计成看起来和感觉上与 SQL 表达式相似(但不完全相同)。

然而，问题是查询表达式可以用于与多种类型的数据交互，甚至是与关系数据库无关的数据。严格地说，“LINQ”是用来描述这种整体数据访问方法的术语。但是，根据您应用 LINQ 查询的位置，您会遇到各种术语，例如:

*   对象的 LINQ:这个术语指的是对数组和集合应用 LINQ 查询的行为。
*   LINQ 到 XML:这个术语指的是使用 LINQ 操作和查询 XML 文档的行为。
*   对数据 t 的 LINQ:这个术语指的是对 ADO.NET 对象应用 LINQ 查询的行为。
*   对实体的 LINQ:LINQ 的这一方面允许您在 ADO.NET 实体框架(EF) API 中使用 LINQ 查询。
*   并行 LINQ(又名 PLINQ):这允许并行处理从 LINQ 查询返回的数据。

今天，LINQ 是世界不可分割的一部分。NET 基类库、托管语言和 Visual Studio 本身。

### LINQ 表达式是强类型的

指出 LINQ 查询表达式(不同于传统的 SQL 语句)是强类型的也很重要。因此，C#编译器会让你保持诚实，并确保这些表达式在语法上是格式良好的。Visual Studio 等工具可以将元数据用于智能感知、自动完成等有用的功能。

### 核心 LINQ 组件

正如在第 2 章中提到的，Visual Studio 的新项目对话框可以选择。NET 平台进行编译。当您选择针对。NET 3.5 或更高版本中，每个项目模板都将自动引用键 LINQ 程序集，可以使用解决方案资源管理器查看这些程序集。表 [12-2](#Tab2) 记录了关键 LINQ 组件的作用。然而，在本书的剩余部分，你会遇到更多的 LINQ 图书馆。

表 12-2。

Core LINQ-Centric Assemblies

<colgroup><col> <col></colgroup> 
| 装配 | 生命的意义 |
| --- | --- |
| `System.Core.dll` | 定义代表核心 LINQ API 的类型。如果你想使用任何 LINQ API，包括对象的 LINQ，这是你必须访问的一个程序集。 |
| `System.Data.DataSetExtensions.dll` | 定义了一些类型，将 ADO.NET 类型集成到 LINQ 编程范式(LINQ 到数据集)中。 |
| `System.Xml.Linq.dll` | 提供将 LINQ 用于 XML 文档数据(LINQ 到 XML)的功能。 |

要使用 LINQ 对象，必须确保每个包含 LINQ 查询的 C#代码文件都导入了`System.Linq`名称空间(主要在`System.Core.dll`中定义)。如果你不这样做，你会遇到许多问题。一个很好的经验法则是，如果您看到如下所示的编译器错误:

`Error 1 Could not find an implementation of the query pattern for source type ’int[]’. ’Where’ not found. Are you missing a reference to ’System.Core.dll’ or a using directive for ’System.Linq’?`

您的 C#文件很有可能没有下面的`using`指令:

`using System.Linq;`

## 将 LINQ 查询应用于原始数组

要开始研究对象的 LINQ，让我们构建一个将 LINQ 查询应用于各种数组对象的应用。创建一个名为 LinqOverArray 的控制台应用项目，并在名为`QueryOverStrings()`的`Program`类中定义一个静态 helper 方法。在这个方法中，创建一个包含大约六个您喜欢的项目的`string`数组(这里我列出了我的库中的一批视频游戏)。确保至少有两个包含数值的条目和几个包含空格的条目。

`static void QueryOverStrings()`

`{`

`// Assume we have an array of strings.`

`string[] currentVideoGames = {"Morrowind", "Uncharted 2",`

`"Fallout 3", "Daxter", "System Shock 2"};`

`}`

现在，更新`Main()`来调用`QueryOverStrings()`。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with LINQ to Objects *****\n");`

`QueryOverStrings();`

`Console.ReadLine();`

`}`

当您有任何数据数组时，通常会根据给定的需求提取项目的子集。也许您希望只获取包含数字的子项(例如，System Shock 2、Uncharted 2 和辐射 3)、多于或少于某个字符数的子项，或者不包含嵌入空格的子项(例如，Morrowind 或 Daxter)。虽然您当然可以使用`System.Array`类型的成员和一些额外的工作来执行这样的任务，但是 LINQ 查询表达式可以大大简化这个过程。

假设您希望从数组中仅获取包含嵌入空格的项目，并且希望这些项目按字母顺序列出，您可以构建以下 LINQ 查询表达式:

`static void QueryOverStrings()`

`{`

`// Assume we have an array of strings.`

`string[] currentVideoGames = {"Morrowind", "Uncharted 2",`

`"Fallout 3", "Daxter", "System Shock 2"};`

`// Build a query expression to find the items in the array`

`// that have an embedded space.`

`IEnumerable<string> subset = from g in currentVideoGames`

`where g.Contains(" ") orderby g select g;`

`// Print out the results.`

`foreach (string s in subset)`

`Console.WriteLine("Item: {0}", s);`

`}`

注意，这里创建的查询表达式使用了`from`、`in`、`where`、`orderby`和`select` LINQ 查询操作符。在本章的后面，你将深入研究查询表达式语法的形式。然而，即使是现在，您也应该能够大致将该语句理解为“给我包含空格的`currentVideoGames`中的项目，按字母顺序排列。”

这里，每个匹配搜索标准的项目都被赋予了名称`g`(如“game”)；但是，任何有效的 C#变量名都可以:

`IEnumerable<string> subset = from game in currentVideoGames`

`where game.Contains(" ") orderby`

`game select game;`

注意，返回的序列保存在一个名为`subset`的变量中，该变量的类型是实现通用版本`IEnumerable<T>`的类型，其中`T`的类型是`System.String`(毕竟，您查询的是一个由`string`组成的数组)。获得结果集后，您只需使用标准的`foreach`结构打印出每一项。如果运行您的应用，您会发现以下输出:

`***** Fun with LINQ to Objects *****`

`Item: Fallout 3`

`Item: System Shock 2`

`Item: Uncharted 2`

### 又一次，没有 LINQ

可以肯定的是，LINQ 从来不是强制性的。如果您选择这样做，您可以通过完全放弃 LINQ 并使用编程原语(如`if`语句和`for`循环)来找到相同的结果集。下面是一个方法，它产生与`QueryOverStrings()`方法相同的结果，但是方式更加冗长:

`static void QueryOverStringsLongHand()`

`{`

`// Assume we have an array of strings.`

`string[] currentVideoGames = {"Morrowind", "Uncharted 2",`

`"Fallout 3", "Daxter", "System Shock 2"};`

`string[] gamesWithSpaces = new string[5];`

`for (int i = 0; i < currentVideoGames.Length; i++)`

`{`

`if (currentVideoGames[i].Contains(" "))`

`gamesWithSpaces[i] = currentVideoGames[i];`

`}`

`// Now sort them.`

`Array.Sort(gamesWithSpaces);`

`// Print out the results.`

`foreach (string s in gamesWithSpaces)`

`{`

`if( s != null)`

`Console.WriteLine("Item: {0}", s);`

`}`

`Console.WriteLine();`

`}`

虽然我确信您可以想办法调整前面的方法，但事实是 LINQ 查询可以用来从根本上简化从数据源提取新数据子集的过程。一旦您创建了一个合适的 LINQ 查询，C#编译器将代表您执行脏活累活，而不是构建嵌套循环、复杂的`if` / `else`逻辑、临时数据类型等等。

### 对 LINQ 结果集的反思

现在，假设`Program`类定义了一个名为`ReflectOverQueryResults()`的辅助函数，该函数将打印出 LINQ 结果集的各种细节(注意，该参数是一个`System.Object`，用于说明多种类型的结果集)。

`static void ReflectOverQueryResults(object resultSet)`

`{`

`Console.WriteLine("***** Info about your query *****");`

`Console.WriteLine("resultSet is of type: {0}", resultSet.GetType().Name);`

`Console.WriteLine("resultSet location: {0}",`

`resultSet.GetType().Assembly.GetName().Name);`

`}`

假设您在打印出获得的子集后直接在`QueryOverStrings()`中调用了该方法，如果您运行该应用，您将看到`subset`实际上是通用`OrderedEnumerable<TElement, TKey>`类型的一个实例(在 CIL 代码中表示为`OrderedEnumerable`2`)，它是驻留在`System.Core.dll`程序集中的一个内部抽象类型。

`***** Info about your query *****`

`resultSet is of type: OrderedEnumerable`2`

`resultSet location: System.Core`

Note

Visual Studio 对象浏览器隐藏了许多表示 LINQ 结果的类型。这些是低级类型，不能直接在应用中使用。

### LINQ 和隐式类型化局部变量

虽然当前的示例程序可以相对容易地确定结果集可以被捕获为`string`对象的枚举(例如`IEnumerable<string>`)，但是我猜想`subset`是否真的属于`OrderedEnumerable<TElement, TKey>`类型还不清楚。

考虑到 LINQ 结果集可以在各种以 LINQ 为中心的名称空间中使用大量类型来表示，定义适当的类型来保存结果集将是乏味的，因为在许多情况下，底层类型可能并不明显，甚至无法从您的代码库直接访问(正如您将看到的，在某些情况下，类型是在编译时生成的)。

为了进一步强调这一点，考虑下面在`Program`类中定义的辅助方法(我假设您将从`Main()`方法中调用它):

`static void QueryOverInts()`

`{`

`int[] numbers = {10, 20, 30, 40, 1, 2, 3, 8};`

`// Print only items less than 10.`

`IEnumerable<int> subset = from i in numbers where i < 10 select i;`

`foreach (int i in subset)`

`Console.WriteLine("Item: {0}", i);`

`ReflectOverQueryResults(subset);`

`}`

在这种情况下，`subset`变量是完全不同的底层类型。这一次，实现`IEnumerable<int>`接口的类型是一个名为`WhereArrayIterator<T>`的低级类。

`Item: 1`

`Item: 2`

`Item: 3`

`Item: 8`

`***** Info about your query *****`

`resultSet is of type: WhereArrayIterator`1`

`resultSet location: System.Core`

鉴于 LINQ 查询的确切底层类型肯定不是显而易见的，这些第一个示例将查询结果表示为一个`IEnumerable<T>`变量，其中`T`是返回序列中的数据类型(`string`、`int`等)。).然而，这仍然相当麻烦。雪上加霜的是，鉴于`IEnumerable<T>`扩展了非泛型`IEnumerable`接口，也允许捕获 LINQ 查询的结果，如下所示:

`System.Collections.IEnumerable subset =`

`from i in numbers where i < 10 select i;`

幸运的是，在处理 LINQ 查询时，隐式类型化大大简化了工作。

`static void QueryOverInts()`

`{`

`int[] numbers = {10, 20, 30, 40, 1, 2, 3, 8};`

`// Use implicit typing here...`

`var subset = from i in numbers where i < 10 select i;`

`// ...and here.`

`foreach (var i in subset)`

`Console.WriteLine("Item: {0} ", i);`

`ReflectOverQueryResults(subset);`

`}`

根据经验，在捕获 LINQ 查询的结果时，您总是希望利用隐式类型。但是，请记住(在绝大多数情况下),真正的返回值是实现通用`IEnumerable<T>`接口的类型。

究竟这种类型是什么在掩盖之下(`OrderedEnumerable<TElement, TKey>`、`WhereArrayIterator<T>`等)。)无关，没必要发现。如前面的代码示例所示，您可以简单地在`foreach`构造中使用`var`关键字来迭代获取的数据。

### LINQ 和扩展方法

尽管当前的例子没有让您直接编写任何扩展方法，但是您实际上是在后台无缝地使用它们。LINQ 查询表达式可用于迭代实现通用`IEnumerable<T>`接口的数据容器。然而。NET `System.Array`类类型(用来表示字符串数组和整数数组)不实现这个契约。

`// The System.Array type does not seem to implement the correct`

`// infrastructure for query expressions!`

`public abstract class Array : ICloneable, IList, ICollection,`

`IEnumerable, IStructuralComparable, IStructuralEquatable`

`{`

`...`

`}`

虽然`System.Array`没有直接实现`IEnumerable<T>`接口，但是它通过静态的`System.Linq.Enumerable`类类型间接获得了这种类型(以及许多其他以 LINQ 为中心的成员)所需的功能。

这个实用程序类定义了许多通用的扩展方法(如`Aggregate<T>()`、`First<T>()`、`Max<T>()`等)。)，是`System.Array`(以及其他类型)在后台获取的。因此，如果你在`currentVideoGames`局部变量上应用点操作符，你会发现很多在`System.Array`的正式定义中没有的成员(见图 [12-1](#Fig1) )。

![A978-1-4842-1332-2_12_Fig1_HTML.jpg](img/A978-1-4842-1332-2_12_Fig1_HTML.jpg)

图 12-1。

The System.Array type has been extended with members of System.Linq.Enumerable

### 延期执行的作用

关于 LINQ 查询表达式的另一个要点是，在对序列进行迭代之前，不会对它们进行实际计算。从形式上讲，这被称为延期执行。这种方法的好处是，您能够对同一个容器多次应用同一个 LINQ 查询，并且可以放心地获得最新和最好的结果。考虑下面对`QueryOverInts()`方法的更新:

`static void QueryOverInts()`

`{`

`int[] numbers = { 10, 20, 30, 40, 1, 2, 3, 8 };`

`// Get numbers less than ten.`

`var subset = from i in numbers where i < 10 select i;`

`// LINQ statement evaluated here!`

`foreach (var i in subset)`

`Console.WriteLine("{0} < 10", i);`

`Console.WriteLine();`

`// Change some data in the array.`

`numbers[0] = 4;`

`// Evaluated again!`

`foreach (var j in subset)`

`Console.WriteLine("{0} < 10", j);`

`Console.WriteLine();`

`ReflectOverQueryResults(subset);`

`}`

如果您再次执行该程序，您会发现下面的输出。请注意，第二次迭代请求的序列时，您会发现一个额外的成员，因为您将数组中的第一项设置为小于 10 的值。

`1 < 10`

`2 < 10`

`3 < 10`

`8 < 10`

`4 < 10`

`1 < 10`

`2 < 10`

`3 < 10`

`8 < 10`

Visual Studio 的一个有用的方面是，如果在计算 LINQ 查询之前设置断点，就可以在调试会话期间查看内容。只需将鼠标光标置于 LINQ 结果集变量上方(图 [12-2](#Fig2) 中的`subset`)。当您这样做时，您将可以通过展开 Results View 选项来评估查询。

![A978-1-4842-1332-2_12_Fig2_HTML.jpg](img/A978-1-4842-1332-2_12_Fig2_HTML.jpg)

图 12-2。

Debugging LINQ expressions

### 立即执行的作用

当你需要在`foreach`逻辑之外评估 LINQ 表达式时，你可以调用任意数量的由`Enumerable`类型定义的扩展方法，比如`ToArray<T>()`、`ToDictionary<TSource,TKey>()`和`ToList<T>()`。这些方法将导致 LINQ 查询在您调用它们的同时执行，以获取数据的快照。完成此操作后，可以独立操作数据快照。

`static void ImmediateExecution()`

`{`

`int[] numbers = { 10, 20, 30, 40, 1, 2, 3, 8 };`

`// Get data RIGHT NOW as int[].`

`int[] subsetAsIntArray =`

`(from i in numbers where i < 10 select i).ToArray<int>();`

`// Get data RIGHT NOW as List<int>.`

`List<int> subsetAsListOfInts =`

`(from i in numbers where i < 10 select i).ToList<int>();`

`}`

注意，为了调用`Enumerable`的扩展方法，整个 LINQ 表达式都被括在括号中，以将其转换为正确的底层类型(无论是什么类型)。

还记得《T2》第 9 章中的内容吗，当 C#编译器可以明确地确定泛型的类型参数时，你不需要指定类型参数。因此，您也可以如下调用`ToArray<T>()`(或`ToList<T>()`):

`int[] subsetAsIntArray =`

`(from i in numbers where i < 10 select i).ToArray();`

当您需要将 LINQ 查询的结果返回给外部调用者时，立即执行的用处是显而易见的。幸运的是，这恰好是本章的下一个主题。

Source Code

LinqOverArray 项目可以在 [`Chapter 12`](12.html) 子目录中找到。

## 返回 LINQ 查询的结果

可以在类(或结构)中定义一个字段，其值是 LINQ 查询的结果。但是，要做到这一点，您不能使用隐式类型(因为关键字`var`不能用于字段)，并且 LINQ 查询的目标不能是实例级数据；因此，它必须是静态的。鉴于这些限制，您很少需要编写如下代码:

`class LINQBasedFieldsAreClunky`

`{`

`private static string[] currentVideoGames = {"Morrowind", "Uncharted 2",`

`"Fallout 3", "Daxter", "System Shock 2"};`

`// Can’t use implicit typing here! Must know type of subset!`

`private IEnumerable<string> subset = from g in currentVideoGames`

`where g.Contains(" ") orderby g select g;`

`public void PrintGames()`

`{`

`foreach (var item in subset)`

`{`

`Console.WriteLine(item);`

`}`

`}`

`}`

通常，LINQ 查询是在方法或属性的范围内定义的。此外，为了简化编程，用于保存结果集的变量将使用关键字`var`存储在隐式类型的局部变量中。现在，回想一下第三章中的内容，隐式类型变量不能用来定义参数、返回值或者类或结构的字段。

考虑到这一点，您可能想知道如何将查询结果返回给外部调用者。答案是，看情况。如果你有一个由强类型数据组成的结果集，比如一个字符串数组或者一个`Car`的`List<T>`，你可以放弃使用`var`关键字，使用一个合适的`IEnumerable<T>`或者`IEnumerable`类型(同样，因为`IEnumerable<T>`扩展了`IEnumerable`)。考虑以下名为 LinqRetValues 的新控制台应用的示例:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** LINQ Return Values *****\n");`

`IEnumerable<string> subset = GetStringSubset();`

`foreach (string item in subset)`

`{`

`Console.WriteLine(item);`

`}`

`Console.ReadLine();`

`}`

`static IEnumerable<string> GetStringSubset()`

`{`

`string[] colors = {"Light Red", "Green",`

`"Yellow", "Dark Red", "Red", "Purple"};`

`// Note subset is an IEnumerable<string>-compatible object.`

`IEnumerable<string> theRedColors = from c in colors`

`where c.Contains("Red") select c;`

`return theRedColors;`

`}`

`}`

结果如预期的那样:

`Light Red`

`Dark Red`

`Red`

### 通过立即执行返回 LINQ 结果

这个例子按预期工作，只是因为这个方法中的`GetStringSubset()`和 LINQ 查询的返回值是强类型的。如果您使用了`var`关键字来定义子集变量，那么只有当方法仍然原型化为返回`IEnumerable<string>`时，才允许返回值(并且隐式类型化的局部变量实际上与指定的返回类型兼容)。

因为在`IEnumerable<T>`上操作有点不方便，所以可以使用立即执行。例如，如果您将序列转换为强类型数组，您可以简单地返回一个`string[]`，而不是返回`IEnumerable<string>`。考虑一下`Program`类的这个新方法，它做了这样一件事:

`static string[] GetStringSubsetAsArray()`

`{`

`string[] colors = {"Light Red", "Green",`

`"Yellow", "Dark Red", "Red", "Purple"};`

`var theRedColors = from c in colors`

`where c.Contains("Red") select c;`

`// Map results into an array.`

`return theRedColors.ToArray();`

`}`

有了这个，调用者可以幸福地不知道他们的结果来自于 LINQ 查询，并简单地按照预期使用一组`string` s。这里有一个例子:

`foreach (string item in GetStringSubsetAsArray())`

`{`

`Console.WriteLine(item);`

`}`

当试图将 LINQ 投影的结果返回给调用者时，立即执行也很关键。您将在本章的稍后部分研究这个主题。接下来，让我们看看如何将 LINQ 查询应用于泛型和非泛型集合对象。

Source Code

LinqRetValues 项目可以在 [`Chapter 12`](12.html) 子目录中找到。

## 将 LINQ 查询应用于集合对象

除了从简单的数据数组中提取结果，LINQ 查询表达式还可以在`System.Collections.Generic`名称空间的成员中操作数据，比如`List<T>`类型。创建一个名为 LinqOverCollections 的新控制台应用项目，并定义一个基本的`Car`类，该类维护当前的速度、颜色、品牌和昵称，如以下代码所示:

`class Car`

`{`

`public string PetName {get; set;} = "";`

`public string Color {get; set;} = "";`

`public int Speed {get; set;}`

`public string Make {get; set;} = "";`

`}`

现在，在您的`Main()`方法中，定义一个`Car`类型的局部`List<T>`变量，并利用对象初始化语法用一些新的`Car`对象填充列表。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** LINQ over Generic Collections *****\n");`

`// Make a List<> of Car objects.`

`List<Car> myCars = new List<Car>() {`

`new Car{ PetName = "Henry", Color = "Silver", Speed = 100, Make = "BMW"},`

`new Car{ PetName = "Daisy", Color = "Tan", Speed = 90, Make = "BMW"},`

`new Car{ PetName = "Mary", Color = "Black", Speed = 55, Make = "VW"},`

`new Car{ PetName = "Clunker", Color = "Rust", Speed = 5, Make = "Yugo"},`

`new Car{ PetName = "Melvin", Color = "White", Speed = 43, Make = "Ford"}`

`};`

`Console.ReadLine();`

`}`

### 访问包含的子对象

将 LINQ 查询应用到通用容器与使用简单数组没有什么不同，因为对象的 LINQ 可以用在任何实现`IEnumerable<T>`的类型上。这一次，您的目标是构建一个查询表达式，只选择`myCars`列表中的`Car`对象，其中速度大于 55。

获得子集后，您将通过调用`PetName`属性打印出每个`Car`对象的名称。假设您有下面的 helper 方法(带一个`List<Car>`参数)，它是从`Main()`内部调用的:

`static void GetFastCars(List<Car> myCars)`

`{`

`// Find all Car objects in the List<>, where the Speed is`

`// greater than 55.`

`var fastCars = from c in myCars where c.Speed > 55 select c;`

`foreach (var car in fastCars)`

`{`

`Console.WriteLine("{0} is going too fast!", car.PetName);`

`}`

`}`

请注意，您的查询表达式只从`List<T>`中获取那些属性大于 55 的项目。如果您运行该应用，您会发现只有`Henry`和`Daisy`两项符合搜索条件。

如果您想要构建一个更复杂的查询，您可能想要只查找那些`Speed`值大于 90 的 BMW。为此，只需使用 C# `&&`操作符构建一个复合布尔语句。

`static void GetFastBMWs(List<Car> myCars)`

`{`

`// Find the fast BMWs!`

`var fastCars = from c in myCars where c.Speed > 90 && c.Make == "BMW" select c;`

`foreach (var car in fastCars)`

`{`

`Console.WriteLine("{0} is going too fast!", car.PetName);`

`}`

`}`

这种情况下，唯一打印出来的宠物名是`Henry`。

### 将 LINQ 查询应用于非泛型集合

回想一下，LINQ 的查询操作符被设计成可以处理任何实现`IEnumerable<T>`的类型(直接或者通过扩展方法)。鉴于`System.Array`已经提供了这种必要的基础设施，您可能会惊讶于`System.Collections`中的遗留(非通用)容器还没有。幸运的是，仍然可以使用泛型`Enumerable.OfType<T>()`扩展方法迭代非泛型集合中包含的数据。

当从非通用集合对象(如`ArrayList`)调用`OfType<T>()`时，只需在容器中指定项目的类型，以提取兼容的`IEnumerable<T>`对象。在代码中，可以使用隐式类型的变量存储该数据点。

考虑下面的新方法，它用一组`Car`对象填充`ArrayList`(确保将`System.Collections`名称空间导入到您的`Program.cs`文件中):

`static void LINQOverArrayList()`

`{`

`Console.WriteLine("***** LINQ over ArrayList *****");`

`// Here is a nongeneric collection of cars.`

`ArrayList myCars = new ArrayList() {`

`new Car{ PetName = "Henry", Color = "Silver", Speed = 100, Make = "BMW"},`

`new Car{ PetName = "Daisy", Color = "Tan", Speed = 90, Make = "BMW"},`

`new Car{ PetName = "Mary", Color = "Black", Speed = 55, Make = "VW"},`

`new Car{ PetName = "Clunker", Color = "Rust", Speed = 5, Make = "Yugo"},`

`new Car{ PetName = "Melvin", Color = "White", Speed = 43, Make = "Ford"}`

`};`

`// Transform ArrayList into an IEnumerable<T>-compatible type.`

`var myCarsEnum = myCars.OfType<Car>();`

`// Create a query expression targeting the compatible type.`

`var fastCars = from c in myCarsEnum where c.Speed > 55 select c;`

`foreach (var car in fastCars)`

`{`

`Console.WriteLine("{0} is going too fast!", car.PetName);`

`}`

`}`

与前面的例子类似，当从`Main()`调用这个方法时，它将根据 LINQ 查询的格式只显示名字`Henry`和`Daisy`。

### 使用 OfType <t>()过滤数据</t>

如你所知，非泛型类型能够包含任何项目的组合，因为这些容器的成员(比如`ArrayList`)被原型化为接收`System.Objects`。例如，假设一个`ArrayList`包含多种项目，其中只有一部分是数字。如果您想获得一个只包含数字数据的子集，您可以使用`OfType<T>()`来实现，因为它会在迭代过程中过滤掉类型不同于给定类型的每个元素。

`static void OfTypeAsFilter()`

`{`

`// Extract the ints from the ArrayList.`

`ArrayList myStuff = new ArrayList();`

`myStuff.AddRange(new object[] { 10, 400, 8, false, new Car(), "string data" });`

`var myInts = myStuff.OfType<int>();`

`// Prints out 10, 400, and 8.`

`foreach (int i in myInts)`

`{`

`Console.WriteLine("Int value: {0}", i);`

`}`

`}`

至此，您已经有机会将 LINQ 查询应用于数组、泛型集合和非泛型集合。这些容器保存了 C#基本类型(整数、字符串数据)以及自定义类。下一个任务是学习更多的 LINQ 操作符，这些操作符可以用来构建更复杂、更有用的查询。

Source Code

LinqOverCollections 项目可以在 [`Chapter 12`](12.html) 子目录中找到。

## 调查 C# LINQ 查询运算符

C#定义了大量现成的查询操作符。表 [12-3](#Tab3) 记录了一些更常用的查询操作符。

表 12-3。

Common LINQ Query Operators

<colgroup><col> <col></colgroup> 
| 查询运算符 | 生命的意义 |
| --- | --- |
| `from`，`in` | 用于定义任何 LINQ 表达式的主干，这允许您从拟合容器中提取数据的子集。 |
| `where` | 用于定义从容器中提取哪些项目的限制。 |
| `select` | 用于从容器中选择一个序列。 |
| `join`、`on`、`equals`、`into` | 基于指定的键执行联接。请记住，这些“连接”不需要与关系数据库中的数据有任何关系。 |
| `orderby`、`ascending`、`descending` | 允许结果子集按升序或降序排序。 |
| `group`，`by` | 生成包含按指定值分组的数据的子集。 |

Note

那个。NET Framework SDK 文档提供了关于每个 C# LINQ 运算符的完整细节。有关更多信息，请查阅主题“LINQ 通用编程指南”。

除了表 [12-3](#Tab3) 中显示的部分操作符列表外，`System.Linq.Enumerable`类还提供了一组方法，这些方法没有直接的 C#查询操作符简写符号，而是作为扩展方法公开。可以调用这些通用方法以各种方式转换结果集(`Reverse<>()`、`ToArray<>()`、`ToList<>()`等)。).一些用于从结果集中提取单例，另一些执行各种集合操作(`Distinct<>()`、`Union<>()`、`Intersect<>()`等)。)，还有一些汇总结果(`Count<>()`、`Sum<>()`、`Min<>()`、`Max<>()`等)。).

要开始研究更复杂的 LINQ 查询，请创建一个名为 FunWithLinqExpressions 的新控制台应用项目。接下来，您需要定义一些样本数据的数组或集合。对于这个项目，您将创建一个由以下代码定义的`ProductInfo`对象组成的数组:

`class ProductInfo`

`{`

`public string Name {get; set;} = "";`

`public string Description {get; set;} = "";`

`public int NumberInStock {get; set;} = 0;`

`public override string ToString()`

`{`

`return string.Format("Name={0}, Description={1}, Number in Stock={2}",`

`Name, Description, NumberInStock);`

`}`

`}`

现在用您的`Main()`方法中的一批`ProductInfo`对象填充一个数组。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Query Expressions *****\n");`

`// This array will be the basis of our testing...`

`ProductInfo[] itemsInStock = new[] {`

`new ProductInfo{ Name = "Mac’s Coffee",`

`Description = "Coffee with TEETH",`

`NumberInStock = 24},`

`new ProductInfo{ Name = "Milk Maid Milk",`

`Description = "Milk cow’s love",`

`NumberInStock = 100},`

`new ProductInfo{ Name = "Pure Silk Tofu",`

`Description = "Bland as Possible",`

`NumberInStock = 120},`

`new ProductInfo{ Name = "Cruchy Pops",`

`Description = "Cheezy, peppery goodness",`

`NumberInStock = 2},`

`new ProductInfo{ Name = "RipOff Water",`

`Description = "From the tap to your wallet",`

`NumberInStock = 100},`

`new ProductInfo{ Name = "Classic Valpo Pizza",`

`Description = "Everyone loves pizza!",`

`NumberInStock = 73}`

`};`

`// We will call various methods here!`

`Console.ReadLine();`

`}`

### 基本选择语法

因为 LINQ 查询表达式的语法正确性是在编译时验证的，所以您需要记住这些运算符的顺序非常重要。用最简单的话来说，每个 LINQ 查询表达式都是使用`from`、`in`和`select`操作符构建的。以下是要遵循的通用模板:

`var result = from matchingItem in container select matchingItem;`

`from`操作符后面的项表示与 LINQ 查询条件匹配的项，它可以被命名为您选择的任何名称。`in`操作符后面的项表示要搜索的数据容器(数组、集合、XML 文档等。).

下面是一个简单的查询，只需选择容器中的每一项(行为类似于数据库`Select *` SQL 语句)。请考虑以下几点:

`static void SelectEverything(ProductInfo[] products)`

`{`

`// Get everything!`

`Console.WriteLine("All product details:");`

`var allProducts = from p in products select p;`

`foreach (var prod in allProducts)`

`{`

`Console.WriteLine(prod.ToString());`

`}`

`}`

老实说，这个查询表达式并不完全有用，因为您的子集与传入参数中的数据子集相同。如果您愿意，可以使用以下选择语法只提取每辆汽车的`Name`值:

`static void ListProductNames(ProductInfo[] products)`

`{`

`// Now get only the names of the products.`

`Console.WriteLine("Only product names:");`

`var names = from p in products select p.Name;`

`foreach (var n in names)`

`{`

`Console.WriteLine("Name: {0}", n);`

`}`

`}`

### 获取数据子集

要从容器中获取特定的子集，可以使用`where`操作符。执行此操作时，通用模板现在变成以下代码:

`var result = from item in container where BooleanExpression select item;`

注意，`where`操作符期望一个解析为布尔值的表达式。例如，要从`ProductInfo[]`参数中仅提取手头有超过 25 个项目的项目，您可以编写以下代码:

`static void GetOverstock(ProductInfo[] products)`

`{`

`Console.WriteLine("The overstock items!");`

`// Get only the items where we have more than`

`// 25 in stock.`

`var overstock = from p in products where p.NumberInStock > 25 select p;`

`foreach (ProductInfo c in overstock)`

`{`

`Console.WriteLine(c.ToString());`

`}`

`}`

如本章前面所示，当您构建一个`where`子句时，允许使用任何有效的 C#操作符来构建复杂的表达式。例如，回想一下只提取出时速至少为 100 英里的宝马的查询:

`// Get BMWs going at least 100 mph.`

`var onlyFastBMWs = from c in myCars`

`where c.Make == "BMW" && c.Speed >= 100 select c;`

`foreach (Car c in onlyFastBMWs)`

`{`

`Console.WriteLine("{0} is going {1} MPH", c.PetName, c.Speed);`

`}`

### 投影新的数据类型

也可以从现有的数据源投射新形式的数据。让我们假设您想要接受传入的`ProductInfo[]`参数，并获得一个只包含每一项的名称和描述的结果集。为此，您可以定义一个`select`语句来动态生成一个新的匿名类型。

`static void GetNamesAndDescriptions(ProductInfo[] products)`

`{`

`Console.WriteLine("Names and Descriptions:");`

`var nameDesc = from p in products select new { p.Name, p.Description };`

`foreach (var item in nameDesc)`

`{`

`// Could also use Name and Description properties directly.`

`Console.WriteLine(item.ToString());`

`}`

`}`

请记住，当您的 LINQ 查询使用投影时，您无法知道底层的数据类型，因为这是在编译时确定的。在这些情况下，`var`关键字是必需的。同样，回想一下，您不能创建具有隐式类型返回值的方法。因此，下面的方法不会编译:

`static var GetProjectedSubset(ProductInfo[] products)`

`{`

`var nameDesc = from p in products select new { p.Name, p.Description };`

`return nameDesc; // Nope!`

`}`

当您需要将投影数据返回给调用者时，一种方法是使用`ToArray()`扩展方法将查询结果转换成. NET `System.Array`对象。因此，如果您要按如下方式更新查询表达式:

`// Return value is now an Array.`

`static Array GetProjectedSubset(ProductInfo[] products)`

`{`

`var nameDesc = from p in products select new { p.Name, p.Description };`

`// Map set of anonymous objects to an Array object.`

`return nameDesc.ToArray();`

`}`

您可以如下调用并处理来自`Main()`的数据:

`Array objs = GetProjectedSubset(itemsInStock);`

`foreach (object o in objs)`

`{`

`Console.WriteLine(o); // Calls ToString() on each anonymous object.`

`}`

请注意，您必须使用文本`System.Array`对象，并且不能使用 C#数组声明语法，因为您不知道类型的底层类型，因为您正在对编译器生成的匿名类进行操作！还要注意，您没有为泛型`ToArray<T>()`方法指定类型参数，因为您在编译时才知道底层的数据类型，这对于您的目的来说已经太晚了。

明显的问题是您丢失了任何强类型，因为`Array`对象中的每一项都被假定为类型`Object`。然而，当您需要返回一个作为投影操作结果的 LINQ 结果集时，必须将数据转换成一个`Array`类型(或者通过`Enumerable`类型的其他成员转换成另一个合适的容器)。

### 使用可枚举获得计数

当您计划新的数据批次时，您可能需要准确地发现有多少项被返回到序列中。任何时候，当您需要确定从 LINQ 查询表达式返回的项数时，只需使用`Enumerable`类的`Count()`扩展方法。例如，下面的方法将在一个本地数组中查找所有长度超过六个字符的`string`对象:

`static void GetCountFromQuery()`

`{`

`string[] currentVideoGames = {"Morrowind", "Uncharted 2",`

`"Fallout 3", "Daxter", "System Shock 2"};`

`// Get count from the query.`

`int numb =`

`(from g in currentVideoGames where g.Length > 6 select g).Count();`

`// Print out the number of items.`

`Console.WriteLine("{0} items honor the LINQ query.", numb);`

`}`

### 反转结果集

使用`Enumerable`类的`Reverse<>()`扩展方法，可以非常简单地反转结果集中的项目。例如，以下方法从传入的`ProductInfo[]`参数中反向选择所有项目:

`static void ReverseEverything(ProductInfo[] products)`

`{`

`Console.WriteLine("Product in reverse:");`

`var allProducts = from p in products select p;`

`foreach (var prod in allProducts.Reverse())`

`{`

`Console.WriteLine(prod.ToString());`

`}`

`}`

### 排序表达式

正如您在本章的初始示例中所看到的，查询表达式可以使用一个`orderby`操作符按照特定值对子集中的项目进行排序。默认情况下，顺序将是升序；因此，按字符串排序将是字母顺序，按数字数据排序将是从低到高，依此类推。如果您需要以降序查看结果，只需包含`descending`操作符。思考以下方法:

`static void AlphabetizeProductNames(ProductInfo[] products)`

`{`

`// Get names of products, alphabetized.`

`var subset = from p in products orderby p.Name select p;`

`Console.WriteLine("Ordered by Name:");`

`foreach (var p in subset)`

`{`

`Console.WriteLine(p.ToString());`

`}`

`}`

虽然升序是默认的，但是您可以通过使用`ascending`操作符来表达您的意图。

`var subset = from p in products orderby p.Name ascending select p;`

如果您想按降序排列项目，您可以通过`descending`操作符来实现。

`var subset = from p in products orderby p.Name descending select p;`

### LINQ 作为一个更好的文氏作图工具

`Enumerable`类支持一组扩展方法，允许您使用两个(或更多)LINQ 查询作为基础来查找数据的联合、差异、连接和交集。首先，考虑一下`Except()`扩展方法，它将返回一个包含两个容器之间差异的 LINQ 结果集，在本例中是值`Yugo`:

`static void DisplayDiff()`

`{`

`List<string> myCars = new List<String> {"Yugo", "Aztec", "BMW"};`

`List<string> yourCars = new List<String>{"BMW", "Saab", "Aztec" };`

`var carDiff =(from c in myCars select c)`

`.Except(from c2 in yourCars select c2);`

`Console.WriteLine("Here is what you don’t have, but I do:");`

`foreach (string s in carDiff)`

`Console.WriteLine(s); // Prints Yugo.`

`}`

`Intersect()`方法将返回一个结果集，该结果集包含一组容器中的公共数据项。例如，以下方法返回序列`Aztec`和`BMW`:

`static void DisplayIntersection()`

`{`

`List<string> myCars = new List<String> { "Yugo", "Aztec", "BMW" };`

`List<string> yourCars = new List<String> { "BMW", "Saab", "Aztec" };`

`// Get the common members.`

`var carIntersect = (from c in myCars select c)`

`.Intersect(from c2 in yourCars select c2);`

`Console.WriteLine("Here is what we have in common:");`

`foreach (string s in carIntersect)`

`Console.WriteLine(s); // Prints Aztec and BMW.`

`}`

正如您所猜测的,`Union()`方法返回一个包含一批 LINQ 查询的所有成员的结果集。像任何适当的联合一样，如果一个公共成员出现多次，您将不会发现重复值。因此，下面的方法将打印出值`Yugo`、`Aztec`、`BMW`和`Saab`:

`static void DisplayUnion()`

`{`

`List<string> myCars = new List<String> { "Yugo", "Aztec", "BMW" };`

`List<string> yourCars = new List<String> { "BMW", "Saab", "Aztec" };`

`// Get the union of these containers.`

`var carUnion = (from c in myCars select c)`

`.Union(from c2 in yourCars select c2);`

`Console.WriteLine("Here is everything:");`

`foreach (string s in carUnion)`

`Console.WriteLine(s); // Prints all common members.`

`}`

最后，`Concat()`扩展方法返回一个结果集，它是 LINQ 结果集的直接串联。例如，下面的方法打印出结果`Yugo`、`Aztec`、`BMW`、`BMW`、`Saab`和`Aztec`:

`static void DisplayConcat()`

`{`

`List<string> myCars = new List<String> { "Yugo", "Aztec", "BMW" };`

`List<string> yourCars = new List<String> { "BMW", "Saab", "Aztec" };`

`var carConcat = (from c in myCars select c)`

`.Concat(from c2 in yourCars select c2);`

`// Prints:`

`// Yugo Aztec BMW BMW Saab Aztec.`

`foreach (string s in carConcat)`

`Console.WriteLine(s);`

`}`

### 删除重复项

当您调用`Concat()`扩展方法时，您很可能在获取的结果中得到冗余条目，这在某些情况下可能正是您想要的。但是，在其他情况下，您可能希望删除数据中的重复条目。为此，只需调用`Distinct()`扩展方法，如下所示:

`static void DisplayConcatNoDups()`

`{`

`List<string> myCars = new List<String> { "Yugo", "Aztec", "BMW" };`

`List<string> yourCars = new List<String> { "BMW", "Saab", "Aztec" };`

`var carConcat = (from c in myCars select c)`

`.Concat(from c2 in yourCars select c2);`

`// Prints:`

`// Yugo Aztec BMW Saab Aztec.`

`foreach (string s in carConcat.Distinct())`

`Console.WriteLine(s);`

`}`

### LINQ 聚合运算

LINQ 查询还可以设计为对结果集执行各种聚合操作。`Count()`扩展方法就是这样一个聚合例子。其他可能性包括使用`Enumerable`类的`Max()`、`Min()`、`Average()`或`Sum()`成员获得平均值、最大值、最小值或值的总和。这里有一个简单的例子:

`static void AggregateOps()`

`{`

`double[] winterTemps = { 2.0, -21.3, 8, -4, 0, 8.2 };`

`// Various aggregation examples.`

`Console.WriteLine("Max temp: {0}",`

`(from t in winterTemps select t).Max());`

`Console.WriteLine("Min temp: {0}",`

`(from t in winterTemps select t).Min());`

`Console.WriteLine("Average temp: {0}",`

`(from t in winterTemps select t).Average());`

`Console.WriteLine("Sum of all temps: {0}",`

`(from t in winterTemps select t).Sum());`

`}`

这些例子应该给你足够的知识，让你对构建 LINQ 查询表达式的过程感到舒服。虽然您还没有研究其他操作符，但是当您学习相关的 LINQ 技术时，将会在本文后面看到更多的例子。为了总结你对 LINQ 的初步了解，本章的剩余部分将深入到 C# LINQ 查询操作符和底层对象模型之间的细节。

Source Code

FunWithLinqExpressions 项目可以在 [`Chapter 12`](12.html) 子目录中找到。

## LINQ 查询语句的内部表示

至此，您已经了解了使用各种 C#查询操作符(如`from`、`in`、`where`、`orderby`和`select`)构建查询表达式的过程。此外，您发现 LINQ 到对象 API 的一些功能只有在调用`Enumerable`类的扩展方法时才能被访问。然而，事实是，当编译时，C#编译器实际上将所有 C# LINQ 操作符翻译成对`Enumerable`类方法的调用。

大量的`Enumerable`方法已经被原型化，将委托作为参数。特别是，许多方法需要一个名为`Func<>`的泛型委托，这是在第 9 章的[中研究泛型委托时介绍给你的。考虑一下`Enumerable`的`Where()`方法，当您使用 C# `where` LINQ 查询操作符时，它会以您的名义被调用。](09.html)

`// Overloaded versions of the Enumerable.Where<T>() method.`

`// Note the second parameter is of type System.Func<>.`

`public static IEnumerable<TSource> Where<TSource>(this IEnumerable<TSource> source,`

`System.Func<TSource,int,bool> predicate)`

`public static IEnumerable<TSource> Where<TSource>(this IEnumerable<TSource> source,`

`System.Func<TSource,bool> predicate)`

`Func<>`委托(顾名思义)用一组多达 16 个参数和一个返回值表示给定函数的模式。如果您使用 Visual Studio 对象浏览器来检查这种类型，您会注意到各种形式的`Func<>`委托。这里有一个例子:

`// The various formats of the Func<> delegate.`

`public delegate TResult Func<T1,T2,T3,T4,TResult>(T1 arg1, T2 arg2, T3 arg3, T4 arg4)`

`public delegate TResult Func<T1,T2,T3,TResult>(T1 arg1, T2 arg2, T3 arg3)`

`public delegate TResult Func<T1,T2,TResult>(T1 arg1, T2 arg2)`

`public delegate TResult Func<T1,TResult>(T1 arg1)`

`public delegate TResult Func<TResult>()`

鉴于`System.Linq.Enumerable`的许多成员需要一个委托作为输入，当调用它们时，您可以手动创建一个新的委托类型并编写必要的目标方法，使用 C#匿名方法，或者定义一个合适的 lambda 表达式。不管你采取哪种方法，最终结果都是一样的。

虽然利用 C# LINQ 查询操作符确实是构建 LINQ 查询表达式最简单的方法，但是让我们来看看这些可能的方法，这样您就可以看到 C#查询操作符和底层的`Enumerable`类型之间的联系。

### 用查询运算符构建查询表达式(重访)

首先，创建一个名为 LinqUsingEnumerable 的新控制台应用项目。`Program`类将定义一系列静态帮助器方法(每个方法都在`Main()`方法中调用),以说明构建 LINQ 查询表达式的各种方式。

第一种方法`QueryStringsWithOperators()`提供了构建查询表达式的最直接的方法，与本章前面的 LinqOverArray 示例中显示的代码相同。

`static void QueryStringWithOperators()`

`{`

`Console.WriteLine("***** Using Query Operators *****");`

`string[] currentVideoGames = {"Morrowind", "Uncharted 2",`

`"Fallout 3", "Daxter", "System Shock 2"};`

`var subset = from game in currentVideoGames`

`where game.Contains(" ") orderby game select game;`

`foreach (string s in subset)`

`Console.WriteLine("Item: {0}", s);`

`}`

使用 C#查询操作符构建查询表达式的明显好处是,`Func<>`委托和对`Enumerable`类型的调用是看不见也想不到的，因为执行这种翻译是 C#编译器的工作。当然，使用各种查询操作符(`from`、`in`、`where`或`orderby`)构建 LINQ 表达式是最常见和最直接的方法。

### 使用可枚举类型和 Lambda 表达式构建查询表达式

请记住，这里使用的 LINQ 查询操作符只是调用由`Enumerable`类型定义的各种扩展方法的简写版本。考虑下面的`QueryStringsWithEnumerableAndLambdas()`方法，它现在直接使用`Enumerable`扩展方法处理本地字符串数组:

`static void QueryStringsWithEnumerableAndLambdas()`

`{`

`Console.WriteLine("***** Using Enumerable / Lambda Expressions *****");`

`string[] currentVideoGames = {"Morrowind", "Uncharted 2",`

`"Fallout 3", "Daxter", "System Shock 2"};`

`// Build a query expression using extension methods`

`// granted to the Array via the Enumerable type.`

`var subset = currentVideoGames.Where(game => game.Contains(" "))`

`.OrderBy(game => game).Select(game => game);`

`// Print out the results.`

`foreach (var game in subset)`

`Console.WriteLine("Item: {0}", game);`

`Console.WriteLine();`

`}`

在这里，首先调用`currentVideoGames`字符串数组上的`Where()`扩展方法。回想一下，`Array`类通过`Enumerable`授予的扩展方法接收这个。`Enumerable.Where()`方法需要一个`System.Func<T1, TResult>`委托参数。该委托的第一个类型参数表示要处理的`IEnumerable<T>`兼容数据(在本例中是一个字符串数组)，而第二个类型参数表示方法结果数据，该数据是从 lambda 表达式中的一个语句中获得的。

在这个代码示例中，`Where()`方法的返回值是隐藏的，但是在幕后，您操作的是一个`OrderedEnumerable`类型。从这个对象中，您调用通用的`OrderBy()`方法，它也需要一个`Func<>`委托参数。这一次，您只是通过一个合适的 lambda 表达式依次传递每一项。调用`OrderBy()`的最终结果是初始数据的一个新的有序序列。

最后但同样重要的是，您调用从`OrderBy()`返回的序列的`Select()`方法，这将产生存储在名为`subset`的隐式类型变量中的最终数据集。

可以肯定的是，这个“手写的”LINQ 查询比前面的 C# LINQ 查询操作符示例要复杂得多。毫无疑问，部分复杂性是由于使用点运算符将调用链接在一起。下面是同一个查询，其中每一步都被分解成离散的块(正如您可能猜到的，您可以用各种方式分解整个查询):

`static void QueryStringsWithEnumerableAndLambdas2()`

`{`

`Console.WriteLine("***** Using Enumerable / Lambda Expressions *****");`

`string[] currentVideoGames = {"Morrowind", "Uncharted 2",`

`"Fallout 3", "Daxter", "System Shock 2"};`

`// Break it down!`

`var gamesWithSpaces = currentVideoGames.Where(game => game.Contains(" "));`

`var orderedGames = gamesWithSpaces.OrderBy(game => game);`

`var subset = orderedGames.Select(game => game);`

`foreach (var game in subset)`

`Console.WriteLine("Item: {0}", game);`

`Console.WriteLine();`

`}`

您可能同意，直接使用`Enumerable`类的方法构建 LINQ 查询表达式比使用 C#查询操作符要冗长得多。同样，考虑到`Enumerable`的方法需要委托作为参数，您通常需要编写 lambda 表达式，以允许底层委托目标处理输入数据。

### 使用可枚举类型和匿名方法构建查询表达式

假设 C# lambda 表达式只是使用匿名方法的简写符号，考虑在`QueryStringsWithAnonymousMethods()` helper 函数中创建的第三个查询表达式:

`static void QueryStringsWithAnonymousMethods()`

`{`

`Console.WriteLine("***** Using Anonymous Methods *****");`

`string[] currentVideoGames = {"Morrowind", "Uncharted 2",`

`"Fallout 3", "Daxter", "System Shock 2"};`

`// Build the necessary Func<> delegates using anonymous methods.`

`Func<string, bool> searchFilter =`

`delegate(string game) { return game.Contains(" "); };`

`Func<string, string> itemToProcess = delegate(string s) { return s; };`

`// Pass the delegates into the methods of Enumerable.`

`var subset = currentVideoGames.Where(searchFilter)`

`.OrderBy(itemToProcess).Select(itemToProcess);`

`// Print out the results.`

`foreach (var game in subset)`

`Console.WriteLine("Item: {0}", game);`

`Console.WriteLine();`

`}`

这个查询表达式的迭代更加冗长，因为您正在手动创建由`Enumerable`类的`Where()`、`OrderBy()`和`Select()`方法使用的`Func<>`委托。有利的一面是，匿名方法语法确实将所有的委托处理包含在一个方法定义中。然而，该方法在功能上等同于前面章节中创建的`QueryStringsWithEnumerableAndLambdas()`和`QueryStringsWithOperators()`方法。

### 使用可枚举类型和原始委托构建查询表达式

最后，如果您想使用真正冗长的方法构建查询表达式，您可以避免使用 lambdas/anonymous 方法语法，直接为每个`Func<>`类型创建委托目标。这是查询表达式的最后一次迭代，在名为`VeryComplexQueryExpression`的新类类型中建模:

`class VeryComplexQueryExpression`

`{`

`public static void QueryStringsWithRawDelegates()`

`{`

`Console.WriteLine("***** Using Raw Delegates *****");`

`string[] currentVideoGames = {"Morrowind", "Uncharted 2",`

`"Fallout 3", "Daxter", "System Shock 2"};`

`// Build the necessary Func<> delegates.`

`Func<string, bool> searchFilter = new Func<string, bool>(Filter);`

`Func<string, string> itemToProcess = new Func<string,string>(ProcessItem);`

`// Pass the delegates into the methods of Enumerable.`

`var subset = currentVideoGames`

`.Where(searchFilter).OrderBy(itemToProcess).Select(itemToProcess);`

`// Print out the results.`

`foreach (var game in subset)`

`Console.WriteLine("Item: {0}", game);`

`Console.WriteLine();`

`}`

`// Delegate targets.`

`public static bool Filter(string game) {return game.Contains(" ");}`

`public static string ProcessItem(string game) { return game; }`

`}`

您可以通过在`Program`类的`Main()`方法中调用该方法来测试字符串处理逻辑的迭代，如下所示:

`VeryComplexQueryExpression.QueryStringsWithRawDelegates();`

如果您现在运行应用来测试每种可能的方法，那么无论采用哪种方法，输出都是相同的就不足为奇了。关于 LINQ 查询表达式如何在幕后表示，请记住以下几点:

*   查询表达式是使用各种 C#查询运算符创建的。
*   查询操作符只是调用由`System.Linq.Enumerable`类型定义的扩展方法的简写符号。
*   `Enumerable`的许多方法需要委托(特别是`Func<>`)作为参数。
*   任何需要委托参数的方法都可以被传递一个 lambda 表达式。
*   Lambda 表达式只是伪装的匿名方法(大大提高了可读性)。
*   匿名方法是分配原始委托和手动构建委托目标方法的简写符号。

咻！这可能比您想的要深入一些，但是我希望这个讨论能够帮助您理解用户友好的 C#查询操作符在幕后实际上在做什么。

Note

LinqUsingEnumerable 项目可以在 [`Chapter 12`](12.html) 子目录中找到。

## 摘要

LINQ 是一组相关的技术，试图提供一种单一的、对称的方式来与不同形式的数据进行交互。正如本章所解释的，LINQ 可以与任何实现`IEnumerable<T>`接口的类型交互，包括简单的数组以及通用和非通用的数据集合。

正如您所看到的，使用 LINQ 技术是通过几个 C#语言特性来完成的。例如，假设 LINQ 查询表达式可以返回任意数量的结果集，那么通常使用`var`关键字来表示底层数据类型。此外，lambda 表达式、对象初始化语法和匿名类型都可以用来构建功能性和紧凑的 LINQ 查询。

更重要的是，您已经看到了 C# LINQ 查询操作符是如何简单地对`System.Linq.Enumerable`类型的静态成员进行调用的简写符号。如图所示，`Enumerable`的大多数成员操作的是`Func<T>`委托类型，它可以将文字方法地址、匿名方法或 lambda 表达式作为输入来评估查询。