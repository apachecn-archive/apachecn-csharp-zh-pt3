# 14.构建和配置类库

在本书的前四部分中，您已经创建了许多“独立”的可执行应用程序，其中所有的编程逻辑都打包在一个可执行文件(`*.exe`)中。这些可执行程序集使用的资源比主程序集多不了多少。NET 类库，`mscorlib.dll`。虽然有些简单。NET 程序只需使用。NET 基础类库，您(或您的队友)将可重用的编程逻辑隔离到可以在应用程序之间共享的自定义类库(`*.dll`文件)中可能是很平常的事情。

在这一章中，你将学习各种将你的类型打包到自定义代码库中的方法。首先，您将学习将类型划分为。NET 命名空间。之后，您将检查 Visual Studio 的类库项目模板，并了解私有程序集和共享程序集之间的区别。

接下来，您将探索。NET 运行时解析程序集的位置，您将开始理解全局程序集缓存、XML 应用程序配置文件(`*.config`文件)、发行者策略程序集和`System.Configuration`命名空间。

## 定义自定义命名空间

在深入库部署和配置方面之前，第一项任务是了解将自定义类型打包到。NET 命名空间。到本文的这一点，您已经构建了一些小型测试程序，这些程序利用了。净宇宙(`System`，特指)。但是，当您构建具有许多类型的大型应用程序时，将相关类型分组到自定义命名空间中会很有帮助。在 C#中，这是通过使用`namespace`关键字来完成的。创建时，显式定义自定义命名空间甚至更加重要。NET `*.dll`程序集，因为其他开发人员将需要引用该库并导入您的自定义命名空间来使用您的类型。

为了直接调查这些问题，首先创建一个名为 CustomNamespaces 的新控制台应用程序项目。现在，假设您正在开发一个名为`Square`、`Circle`和`Hexagon`的几何类集合。鉴于它们的相似性，您希望将它们组合到一个独特的名称空间中，在`CustomNamespaces.` `exe`汇编中称为`MyShapes`。有两种基本方法。首先，您可以选择在一个 C#文件(`ShapesLib.cs`)中定义所有类，如下所示:

`//` `ShapesLib.cs`

`using System;`

`namespace MyShapes`

`{`

`// Circle class`

`public class Circle { /* Interesting members... */ }`

`// Hexagon class`

`public class Hexagon { /* More interesting members... */ }`

`// Square class`

`public class Square { /* Even more interesting members... */ }`

`}`

虽然 C#编译器对包含多种类型的单个 C#代码文件没有问题，但当您希望在新项目中重用类定义时，这可能会很麻烦。例如，假设您正在构建一个新项目，并且只需要使用`Circle`类。如果所有类型都在一个代码文件中定义，您或多或少会受到整个集合的束缚。因此，作为一种替代方法，您可以将单个命名空间拆分到多个 C#文件中。为了确保每个类型都被打包到同一个逻辑组中，只需将给定的类定义包装在同一个名称空间范围内，如下所示:

`// Circle.cs`

`using System;`

`namespace MyShapes`

`{`

`// Circle class`

`public class Circle { /* Interesting methods... */ }`

`}`

`// Hexagon.cs`

`using System;`

`namespace MyShapes`

`{`

`// Hexagon class`

`public class Hexagon { /* More interesting methods... */ }`

`}`

`// Square.cs`

`using System;`

`namespace MyShapes`

`{`

`// Square class`

`public class Square { /* Even more interesting methods... */ }`

`}`

在这两种情况下，请注意`MyShapes`名称空间是如何充当这些类的概念“容器”的。当另一个名称空间(比如`CustomNamespaces`)想要使用单独名称空间中的类型时，可以使用`using`关键字，就像使用。NET 基类库，如下所示:

`// Bring in a namespace from the base class libraries.`

`using System;`

`// Make use of types defined the` `MyShapes namespace.`

`using MyShapes;`

`namespace CustomNamespaces`

`{`

`public class Program`

`{`

`static void Main(string[] args)`

`{`

`Hexagon h = new Hexagon();`

`Circle c = new Circle();`

`Square s = new Square();`

`}`

`}`

`}`

对于这个特殊的例子，假设定义`MyShapes`名称空间的 C#文件是包含定义`CustomNamespaces`名称空间的文件的同一个控制台应用程序项目的一部分；换句话说，所有的文件都用来编译一个。NET 可执行程序集。如果您在外部程序集中定义了`MyShapes`命名空间，那么在成功编译之前，您还需要添加一个对该库的引用。在本章的课程中，你将学习到构建使用外部库的应用程序的所有细节。

### 解析具有完全限定名的名称类

从技术上讲，当引用外部命名空间中定义的类型时，不需要使用 C# `using`关键字。您可以使用类型的完全限定名，您可能还记得第一章中的[，它是以定义名称空间为前缀的类型名。这里有一个例子:](01.html)

`// Note we are not importing MyShapes anymore!`

`using System;`

`namespace CustomNamespaces`

`{`

`public class Program`

`{`

`static void Main(string[] args)`

`{`

`MyShapes.Hexagon h = new MyShapes.Hexagon();`

`MyShapes.Circle c = new MyShapes.Circle();`

`MyShapes.Square s = new MyShapes.Square();`

`}`

`}`

`}`

通常，不需要使用完全限定名。它不仅需要更多的击键次数，而且在代码大小或执行速度方面没有任何区别。事实上，在 CIL 代码中，类型总是用完全限定名定义的。从这个角度来看，C# `using`关键字仅仅是一个节省打字时间的工具。

但是，当使用包含同名类型的多个命名空间时，完全限定名有助于(有时是必要的)避免潜在的名称冲突。假设您有一个名为`My3DShapes`的新名称空间，它定义了以下三个类，能够以令人惊叹的 3D 方式呈现形状:

`// Another shape-centric namespace.`

`using System;`

`namespace My3DShapes`

`{`

`// 3D Circle class.`

`public class Circle { }`

`// 3D Hexagon class.`

`public class Hexagon { }`

`// 3D Square class.`

`public class Square { }`

`}`

如果您更新如下所示的`Program`类，您会收到许多编译时错误，因为两个名称空间都定义了相同名称的类:

`// Ambiguities abound!`

`using System;`

`using MyShapes;`

`using My3DShapes;`

`namespace CustomNamespaces`

`{`

`public class Program`

`{`

`static void Main(string[] args)`

`{`

`// Which namespace do I reference?`

`Hexagon h = new Hexagon(); // Compiler error!`

`Circle c = new Circle();   // Compiler error!`

`Square s = new Square();   // Compiler error!`

`}`

`}`

`}`

可以使用类型的完全限定名来解决这种不确定性，如下所示:

`// We have now resolved the ambiguity.`

`static void Main(string[] args)`

`{`

`My3DShapes.Hexagon h = new My3DShapes.Hexagon();`

`My3DShapes.Circle c = new My3DShapes.Circle();`

`MyShapes.Square s = new MyShapes.Square();`

`}`

### 解析带有别名的名称类

C# `using`关键字还允许您为类型的完全限定名创建别名。这样做时，您定义了一个在编译时替换类型全名的标记。定义别名提供了解决名称冲突的第二种方法。这里有一个例子:

`using System;`

`using MyShapes;`

`using My3DShapes;`

`// Resolve the ambiguity using a` `custom alias.`

`using The3DHexagon = My3DShapes.Hexagon;`

`namespace CustomNamespaces`

`{`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`// This is really creating a My3DShapes.Hexagon class.`

`The3DHexagon h2 = new The3DHexagon();`

`...`

`}`

`}`

`}`

这种替代的`using`语法还允许您为冗长的名称空间创建别名。基类库中较长的名称空间之一是`System.Runtime.Serialization.Formatters.Binary`，它包含一个名为`BinaryFormatter`的成员。如果您愿意，您可以创建一个`BinaryFormatter`的实例，如下所示:

`using bfHome = System.Runtime.Serialization.Formatters.Binary;`

`namespace MyApp`

`{`

`class ShapeTester`

`{`

`static void Main(string[] args)`

`{`

`bfHome.BinaryFormatter b = new bfHome.BinaryFormatter();`

`...`

`}`

`}`

`}`

以及传统的`using`指令:

`using System.Runtime.Serialization.Formatters.Binary;`

`namespace MyApp`

`{`

`class ShapeTester`

`{`

`static void Main(string[] args)`

`{`

`BinaryFormatter b = new BinaryFormatter();`

`...`

`}`

`}`

`}`

在游戏的这一点上，没有必要关心`BinaryFormatter`类是用来做什么的(你将在[第 20 章](20.html)中研究这个类)。现在，只要记住 C# `using`关键字可以用来为冗长的完全限定名定义别名，或者更常见的是，用来解决在导入多个定义同名类型的名称空间时可能出现的名称冲突。

Note

请注意，过度使用 C#别名会导致混乱的代码库。如果团队中的其他程序员不知道您的自定义别名，他们可能会认为这些别名引用了。NET 基类库，当他们在。NET 框架 SDK 文档！

### 创建嵌套命名空间

在组织类型时，您可以自由地在其他命名空间中定义命名空间。那个。NET 基类库在许多地方都这样做，以提供更深层次的类型组织。例如，`IO`名称空间嵌套在`System`中以产生`System.IO`。如果您想要创建一个包含现有的`My3DShapes`名称空间的根名称空间，您可以如下更新您的代码:

`// Nesting a namespace.`

名称空间第 14 章

`{`

`namespace My3DShapes`

`{`

`// 3D Circle class.`

`public class Circle{ }`

`// 3D Hexagon class.`

`public class Hexagon{ }`

`// 3D Square class.`

`public class Square{ }`

`}`

`}`

在许多情况下，根名称空间的作用只是提供更深一层的范围；因此，它可能不会直接在其作用域内定义任何类型(就像在`Chapter14`名称空间的情况下一样)。如果是这种情况，可以使用以下紧凑形式定义嵌套命名空间:

`// Nesting a namespace (take two).`

`namespace Chapter14.My3DShapes`

`{`

`// 3D Circle class.`

`public class Circle{ }`

`// 3D Hexagon class.`

`public class Hexagon{ }`

`// 3D Square class.`

`public class Square{ }`

`}`

假设您现在已经在`Chapter` `14`根名称空间中嵌套了`My3DShapes`名称空间，那么您需要更新任何现有的`using`指令和类型别名，如下所示:

`using Chapter``14`T2】

`using The3DHexagon = Chapter``14`T2】

### Visual Studio 的默认命名空间

关于与命名空间相关的最后一点，值得指出的是，默认情况下，当您使用 Visual Studio 创建新的 C#项目时，应用程序的默认命名空间的名称将与项目名称相同。从这一点开始，当您使用项目➤添加新项菜单选项插入新代码文件时，类型将自动包装在默认命名空间内。如果您想要更改默认名称空间的名称，只需使用项目属性窗口的应用程序选项卡访问默认名称空间选项(参见图 [14-1](#Fig1) )。

![A978-1-4842-1332-2_14_Fig1_HTML.jpg](img/A978-1-4842-1332-2_14_Fig1_HTML.jpg)

图 14-1。

Configuring the default namespace

通过这次更新，插入到项目中的任何新项都将被包装在`Chapter` `14` `.CoreLogic`名称空间中(很明显，如果另一个名称空间想要使用这些类型，必须应用正确的`using`指令)。

目前为止，一切顺利。既然您已经看到了关于如何将自定义类型打包到组织良好的命名空间中的一些细节，那么让我们快速回顾一下。NET 程序集。此后，您将深入研究创建、部署和配置自定义类库的细节。

Source Code

CustomNamespaces 项目位于 [`Chapter 14`](14.html) 子目录下。

## 的作用。网络程序集

。NET 应用程序是由任意数量的程序集拼凑而成的。简而言之，程序集是由 CLR 承载的版本化的自描述二进制文件。尽管如此。NET 程序集与以前的 Windows 二进制文件具有相同的文件扩展名(`*.exe`或`*.dll`)，它们与幕后的那些文件没有什么共同之处。因此，为了给即将到来的信息做好准备，让我们考虑一下汇编格式提供的一些好处。

### 程序集促进代码重用

由于您已经在前面的章节中构建了您的控制台应用程序项目，似乎所有应用程序的功能都包含在您正在构建的可执行程序集中。实际上，您的应用程序利用了包含在始终可访问的。NET 代码库，`mscorlib.dll`(回想一下 C#编译器自动引用`mscorlib.dll`)，在一些例子的情况下，`System.Core.dll`。

正如您可能知道的，代码库(也称为类库)是一个包含外部应用程序使用的类型的`*.dll`。当您创建可执行程序集时，您无疑会在创建应用程序时利用大量系统提供的和自定义的代码库。但是，请注意，代码库不需要使用`*.dll`文件扩展名。可执行程序集完全有可能(尽管肯定不常见)使用外部可执行文件中定义的类型。由此看来，引用的`*.exe`也可以被认为是一个代码库。

不管代码库是如何打包的。NET 平台允许您以独立于语言的方式重用类型。例如，您可以在 C#中创建一个代码库，并在任何其他代码库中重用该库。NET 编程语言。不仅可以跨语言分配类型，还可以从中派生类型。C#中定义的基类可以由 Visual Basic 中编写的类来扩展。F#中定义的接口可以通过 C#中定义的结构来实现，等等。重点是，当你开始把一个单一的可执行文件分解成许多个时。NET 程序集，您实现了与语言无关的代码重用形式。

### 程序集建立类型边界

回想一下，类型的完全限定名是通过将类型的名称空间(例如，`System`)作为其名称(例如，`Console`)的前缀来组成的。然而，严格地说，类型所在的程序集进一步建立了类型的标识。例如，如果您有两个唯一命名的程序集(比如，`MyCars.dll`和`YourCars.dll`，它们都定义了一个包含名为`SportsCar`的类的名称空间(`CarLibrary`),那么它们在。净宇宙。

### 程序集是可版本化的单位

。NET 程序集被分配一个由四部分组成的数字版本号，形式为<major>。<minor>。<build>。<revision>。(如果没有显式提供版本号，在给定默认 Visual Studio 项目设置的情况下，将自动为程序集分配版本 1.0.0.0。)这个数字，结合一个可选的公钥值，允许同一程序集的多个版本在一台机器上和谐共存。从形式上讲，提供公钥信息的程序集被称为强名称程序集。正如您将在本章中看到的，通过使用强名称，CLR 能够确保代表调用客户端加载程序集的正确版本。</revision></build></minor></major>

### 程序集是自描述的

程序集被认为是自描述的，部分原因是它们记录了为了正确运行它们必须访问的每个外部程序集。因此，如果您的程序集需要`System.Windows.Forms.dll`和`System.Core.dll`，这将记录在程序集的清单中。回想一下[第 1 章](01.html)中的内容，清单是描述程序集本身(名称、版本、所需的外部程序集等)的元数据块。).

除了清单数据，程序集还包含描述每个包含类型的组成(成员名称、实现的接口、基类、构造函数等)的元数据。因为程序集被记录得如此详细，所以 CLR 不会查询 Windows 系统注册表来解析它的位置(这与 Microsoft 的传统 COM 编程模型完全不同)。正如你将在本章中发现的，CLR 使用了一个全新的方案来解析外部代码库的位置。

### 程序集是可配置的

程序集可以部署为“私有”或“共享”私有程序集与使用它们的客户端应用程序驻留在同一个目录(或者可能是子目录)中。另一方面，共享程序集是旨在由单台计算机上的众多应用程序使用的库，并被部署到称为全局程序集缓存(GAC)的特定目录中。

无论如何部署程序集，您都可以自由创作基于 XML 的配置文件。使用这些配置文件，您可以指示 CLR“探测”特定位置的程序集，为特定客户端加载特定版本的引用程序集，或者查询本地计算机上的任意目录、网络位置或基于 web 的 URL。在本章中，你将学到更多关于 XML 配置文件的知识。

## 了解. NET 程序集的格式

既然您已经了解了。NET 程序集，让我们换个话题，更好地了解一个程序集是如何在幕后组成的。从结构上讲，. NET 程序集(`*.dll`或`*.exe`)由以下元素组成:

*   Windows 文件头
*   CLR 文件头
*   CIL 队列
*   类型元数据
*   程序集清单
*   可选嵌入式资源

虽然前两个元素(Windows 和 CLR 头)是通常可以忽略的数据块，但它们确实值得简单考虑一下。以下是每个元素的概述。

### Windows 文件头

Windows 文件头确定了这样一个事实，即该程序集可以由 Windows 系列操作系统加载和操作。该标题数据还标识了 Windows 托管的应用程序类型(基于控制台、基于 GUI 或`*.dll`代码库)。如果您使用`dumpbin.exe`实用程序(通过 Windows 命令提示符)打开一个. NET 程序集，并指定`/headers`标志如下:

`dumpbin /headers CarLibrary.dll`

您可以查看程序集的 Windows 头信息。以下是你将在本章稍后构建的`CarLibrary.dll`程序集的(部分)Windows 头文件信息(如果你现在想自己运行`dumpbin.exe`，你可以指定你在本书中编写的任何`*.dll`或`*.exe`的名称来代替`CarLibrary.dll`):

`Dump of file CarLibrary.dll`

`PE signature found`

`File Type: DLL`

`FILE HEADER VALUES`

`14C machine (x86)`

`3 number of sections`

`4B37DCD8 time date stamp Sun Dec 27 16:16:56 2011`

`0 file pointer to symbol table`

`0 number of symbols`

`E0 size of optional header`

`2102 characteristics`

`Executable`

`32 bit word machine`

`DLL`

`OPTIONAL HEADER VALUES`

`10B magic # (PE32)`

`8.00 linker version`

`E00 size of code`

`600 size of initialized data`

`0 size of uninitialized data`

`2CDE entry point (00402CDE)`

`2000 base of code`

`4000 base of data`

`400000 image base (00400000 to 00407FFF)`

`2000 section alignment`

`200 file alignment`

`4.00 operating system version`

`0.00 image version`

`4.00 subsystem version`

`0 Win32 version`

`8000 size of image`

`200 size of headers`

`0 checksum`

`3 subsystem (Windows CUI)`

`...`

记住绝大多数的。NET 程序员永远不需要关心嵌入在. NET 程序集中的标题数据的格式。除非你碰巧在建造一个新的。NET 语言编译器(您会关心这样的信息)，您可以自由地保持幸福，不知道头部数据的肮脏细节。但是，请注意，当 Windows 将二进制映像加载到内存中时，这些信息是在幕后使用的。

### CLR 文件头

CLR 头是一个数据块。NET 程序集必须支持(并且确实支持，这是由 C#编译器提供的)由 CLR 承载。简而言之，这个头文件定义了许多标志，使运行时能够理解托管文件的布局。例如，存在标识元数据和资源在文件中的位置、生成程序集所依据的运行库版本、(可选)公钥的值等的标志。如果像这样向`dumpbin.exe`提供`/clrheader`标志:

`dumpbin /clrheader CarLibrary.dll`

您将看到给定的内部 CLR 头信息。NET 程序集，如下所示:

`Dump of file CarLibrary.dll`

`File Type: DLL`

`clr Header:`

`48 cb`

`2.05 runtime version`

`2164 [     A74] RVA [size] of MetaData Directory`

`1 flags`

`IL Only`

`0 entry point token`

`0 [       0] RVA [size] of Resources Directory`

`0 [       0] RVA [size] of StrongNameSignature Directory`

`0 [       0] RVA [size] of CodeManagerTable Directory`

`0 [       0] RVA [size] of VTableFixups Directory`

`0 [       0] RVA [size] of ExportAddressTableJumps Directory`

`0 [       0] RVA [size] of ManagedNativeHeader Directory`

`Summary`

`2000 .reloc`

`2000 .rsrc`

`2000 .text`

同样，作为一名. NET 开发人员，您不需要关心程序集的 CLR 头信息的血淋淋的细节。你只要明白。NET 程序集包含这些数据，这些数据由。当图像数据加载到内存中时。现在将注意力转向一些在日常编程任务中更有用的信息。

### CIL 代码、类型元数据和程序集清单

在它的核心，一个汇编包含 CIL 代码，你还记得，这是一个平台和 CPU 无关的中间语言。在运行时，根据特定于平台和 CPU 的指令，使用实时(JIT)编译器动态编译内部 CIL。鉴于这种设计。NET 程序集确实可以在各种体系结构、设备和操作系统上执行。(尽管不理解 CIL 编程语言的细节，你也能过上快乐而富有成效的生活，[第 18 章](18.html)介绍了 CIL 的语法和语义。)

程序集还包含完整描述所包含类型的格式以及该程序集引用的外部类型的格式的元数据。那个。NET 运行时使用此元数据来解析二进制文件中类型(及其成员)的位置，在内存中布置类型，并方便远程方法调用。您将了解。NET 元数据格式在[第 15 章](15.html)中。

程序集还必须包含关联的清单(也称为程序集元数据)。清单记录程序集中的每个模块，建立程序集的版本，还记录当前程序集引用的任何外部程序集。正如您将在本章中看到的，CLR 在定位外部程序集引用的过程中广泛使用了程序集清单。

### 可选程序集资源

最后，一个. NET 程序集可能包含任意数量的嵌入资源，如应用程序图标、图像文件、声音剪辑或字符串表。事实上。NET 平台支持只包含本地化资源的附属程序集。如果您希望基于特定的文化(英语、德语等)来划分资源，这可能会很有用。)以构建国际软件为目的。构建附属程序集的主题超出了本文的范围；请参考。NET 4.6 Framework 文档，了解有关附属程序集的信息。

## 生成和使用自定义类库

开始探索。NET 类库，您将首先创建一个包含一小组公共类型的`*.dll`程序集(名为`CarLibrary`)。要使用 Visual Studio 构建代码库，通过文件➤新建项目菜单选项选择类库项目工作区(参见图 [14-2](#Fig2) )。

![A978-1-4842-1332-2_14_Fig2_HTML.jpg](img/A978-1-4842-1332-2_14_Fig2_HTML.jpg)

图 14-2。

Creating a C# class library

汽车库的设计始于一个名为`Car`的抽象基类，它通过自动属性语法定义各种状态数据。这个类还有一个名为`TurboBoost()`的抽象方法，它使用一个自定义枚举(`EngineState`)来表示汽车引擎的当前状态，如下所示:

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`using System.Threading.Tasks;`

`namespace CarLibrary`

`{`

`// Represents the state of the engine.`

`public enum EngineState`

`{ engineAlive, engineDead }`

`// The abstract base class in the hierarchy.`

`public abstract class Car`

`{`

`public string PetName {get; set;}`

`public int CurrentSpeed {get; set;}`

`public int MaxSpeed {get; set;}`

`protected EngineState egnState = EngineState.engineAlive;`

`public EngineState EngineState`

`{`

`get { return egnState; }`

`}`

`public abstract void TurboBoost();`

`public Car(){}`

`public Car(string name, int maxSp, int currSp)`

`{`

`PetName = name; MaxSpeed = maxSp; CurrentSpeed = currSp;`

`}`

`}`

`}`

现在假设您有两个名为`MiniVan`和`SportsCar`的`Car`类型的直接后代。每个方法都通过 Windows 窗体消息框显示适当的消息来覆盖抽象的`TurboBoost()`方法。将一个新的 C#类文件插入到您的项目中，命名为`DerivedCars.cs`，它包含以下代码:

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`using System.Threading.Tasks;`

`// Keep reading! This won’t compile until you reference a .NET library.`

`using System.Windows.Forms;`

`namespace CarLibrary`

`{`

`public class SportsCar : Car`

`{`

`public SportsCar(){ }`

`public SportsCar(string name, int maxSp, int currSp)`

`: base (name, maxSp, currSp){ }`

`public override void TurboBoost()`

`{`

`MessageBox.Show("Ramming speed!", "Faster is better...");`

`}`

`}`

`public class MiniVan : Car`

`{`

`public MiniVan(){ }`

`public MiniVan(string name, int maxSp, int currSp)`

`: base (name, maxSp, currSp){ }`

`public override void TurboBoost()`

`{`

`// Minivans have poor turbo capabilities!`

`egnState = EngineState.engineDead;`

`MessageBox.Show("Eek!", "Your engine block exploded!");`

`}`

`}`

`}`

注意每个子类是如何使用 Windows 窗体的`MessageBox`类实现`TurboBoost()`的，这个类是在`System.Windows.Forms.dll`程序集中定义的。为了使您的程序集使用在此外部程序集中定义的类型，carlibrary 项目必须通过“添加引用”对话框(参见图 [14-3](#Fig3) )添加对此程序集的引用，您可以通过 Visual Studio 项目➤的“添加引用”菜单选择来访问该对话框。

![A978-1-4842-1332-2_14_Fig3_HTML.jpg](img/A978-1-4842-1332-2_14_Fig3_HTML.jpg)

图 14-3。

Referencing external .NET assemblies using the Add Reference dialog box

理解"添加引用"对话框的框架区域中显示的程序集并不代表计算机上的每个程序集，这一点非常重要。“添加引用”对话框不会显示您的自定义库，也不会显示位于 GAC 中的所有库(本章稍后将详细介绍)。相反，此对话框只是显示 Visual Studio 预编程显示的常见程序集的列表。当您正在构建需要使用未在“添加引用”对话框中列出的程序集的应用程序时，您需要单击“浏览”节点来手动导航到有问题的`*.dll`或`*.exe`。

Note

请注意,"添加引用"对话框的"最近"部分保存了以前引用的程序集的运行列表。这很方便，因为很多。NET 项目倾向于使用相同的核心外部库。

### 探索清单

在从客户端应用程序使用`CarLibrary.dll`之前，让我们看看代码库是如何在幕后组成的。假设您已经编译了这个项目，通过文件➤打开菜单将`CarLibrary.dll`加载到`ildasm.exe`中，并导航到您的 CarLibrary 项目的`\bin\Debug`子目录。当你完成时，你应该看到你的库显示在 IL 反汇编工具中(见图 [14-4](#Fig4) )。

![A978-1-4842-1332-2_14_Fig4_HTML.jpg](img/A978-1-4842-1332-2_14_Fig4_HTML.jpg)

图 14-4。

CarLibrary.dll loaded into ildasm.exe

现在，双击清单图标打开`CarLibrary.dll`的清单。清单中的第一个代码块指定当前程序集正常工作所需的所有外部程序集。正如您所记得的，`CarLibrary.dll`使用了`mscorlib.dll`和`System.Windows.Forms.dll`中的类型，这两个类型都是使用`.assembly extern`标记在清单中列出的，如下所示:

`.assembly extern mscorlib`

`{`

`.publickeytoken = (B7 7A 5C 56 19 34 E0 89 )`

`.ver 4:0:0:0`

`}`

`.assembly extern System.Windows.Forms`

`{`

`.publickeytoken = (B7 7A 5C 56 19 34 E0 89 )`

`.ver 4:0:0:0`

`}`

这里，每个`.assembly extern`块都由`.publickeytoken`和`.ver`指令限定。只有当程序集配置了强名称时,`.publickeytoken`指令才会出现(本章后面的“理解强名称”一节中有关于强名称的更多详细信息)。`.ver`标记定义了(当然)引用程序集的数字版本标识符。

在外部引用之后，您会发现许多标识汇编级属性(版权信息、公司名称、汇编版本等)的`.custom`标记。).以下是这一特定清单数据块的(非常)部分列表:

`.assembly CarLibrary`

`{`

`.custom instance void ...AssemblyDescriptionAttribute...`

`.custom instance void ...AssemblyConfigurationAttribute...`

`.custom instance void ...RuntimeCompatibilityAttribute...`

`.custom instance void ...TargetFrameworkAttribute...`

`.custom instance void ...AssemblyTitleAttribute...`

`.custom instance void ...AssemblyTrademarkAttribute...`

`.custom instance void ...AssemblyCompanyAttribute...`

`.custom instance void ...AssemblyProductAttribute...`

`.custom instance void ...AssemblyCopyrightAttribute...`

`...`

`.ver 1:0:0:0`

`}`

`.module CarLibrary.dll`

通常，这些设置是使用当前项目的属性编辑器直观地建立的。现在，切换回 Visual Studio，如果单击解决方案资源管理器中的属性图标，可以单击位于(自动选择的)应用程序选项卡上的程序集信息按钮。这将调出如图 [14-5](#Fig5) 所示的 GUI 编辑器。

![A978-1-4842-1332-2_14_Fig5_HTML.jpg](img/A978-1-4842-1332-2_14_Fig5_HTML.jpg)

图 14-5。

Editing assembly information using Visual Studio’s Properties editor

当您保存您的更改时，GUI 编辑器会更新您的项目的`AssemblyInfo.cs`文件，该文件由 Visual Studio 维护，可以通过展开解决方案资源管理器的属性节点来查看(参见图 [14-6](#Fig6) )。

![A978-1-4842-1332-2_14_Fig6_HTML.jpg](img/A978-1-4842-1332-2_14_Fig6_HTML.jpg)

图 14-6。

The AssemblyInfo.cs file is updated as you use the GUI Properties editor

如果您查看这个 C#文件的内容，您会看到许多。NET 属性夹在方括号之间。这里有一个例子:

`[assembly: AssemblyTitle("CarLibrary")]`

`[assembly: AssemblyDescription("")]`

`[assembly: AssemblyConfiguration("")]`

`[assembly: AssemblyCompany("")]`

`[assembly: AssemblyProduct("CarLibrary")]`

`[assembly: AssemblyCopyright("Copyright © 2015")]`

`[assembly: AssemblyTrademark("")]`

`[assembly: AssemblyCulture("")]`

[第 15 章](15.html)深入考察了属性的作用，所以在这一点上不要纠结细节。现在，请注意，`AssemblyInfo.cs`中的大多数属性将用于更新程序集清单中的`.custom`标记值。

### 探索 CIL

回想一下，程序集不包含特定于平台的指令；相反，它包含平台无关的通用中间语言(CIL)指令。当。NET 运行库将程序集加载到内存中，基础 CIL 被编译(使用 JIT 编译器)成目标平台可以理解的指令。例如，回到`ildasm.exe`，如果双击`SportsCar`类的`TurboBoost()`方法，`ildasm.exe`将打开一个新窗口，显示实现该方法的 CIL 令牌。

`.method public hidebysig virtual instance void`

`TurboBoost() cil managed`

`{`

`// Code size       18 (0x12)`

`.maxstack 8`

`IL_0000: nop`

`IL_0001: ldstr  "Ramming speed!"`

`IL_0006: ldstr  "Faster is better..."`

`IL_000b: call  valuetype [System.Windows.Forms]System.Windows.Forms.DialogResult`

`[System.Windows.Forms]System.Windows.Forms.MessageBox::Show(string, string)`

`IL_0010: pop`

`IL_0011: ret`

`} // end of method SportsCar::TurboBoost`

再说一遍虽然大多数人。NET 开发者不需要每天都关心 CIL 的细节，第 18 章提供了更多关于它的语法和语义的细节。信不信由你，当你在构建需要高级服务的更复杂的应用程序时，理解 CIL 的语法会很有帮助，比如程序集的运行时构造(再次参见[第 18 章](18.html))。

### 探索类型元数据

在构建一些使用您的自定义。NET 库，如果在`ildasm.exe`中按下 Ctrl+M 组合键，可以看到`CarLibrary.dll`程序集内每种类型的元数据(见图 [14-7](#Fig7) )。

![A978-1-4842-1332-2_14_Fig7_HTML.jpg](img/A978-1-4842-1332-2_14_Fig7_HTML.jpg)

图 14-7。

Type metadata for the types within CarLibrary.dll

正如下一章所解释的，程序集的元数据是。NET 平台，并作为众多技术(对象序列化、后期绑定、可扩展应用程序等)的主干。).无论如何，现在你已经看到了`CarLibrary.dll`程序集的内部，你可以构建一些使用你的类型的客户端应用程序。

Source Code

CarLibrary 项目位于 [`Chapter 14`](14.html) 子目录下。

### 构建 C#客户端应用程序

因为每个`CarLibrary`类型都是使用`public`关键字声明的，所以其他。NET 应用程序也能够使用它们。回想一下，您也可以使用 C# `internal`关键字来定义类型(事实上，这是默认的 C#访问模式)。内部类型只能由定义它们的程序集使用。外部客户端既不能看到也不能创建用`internal`关键字标记的类型。

若要使用库的功能，请创建一个名为 CSharpCarClient 的新 C#控制台应用程序项目。完成后，使用“添加引用”对话框的“浏览”节点设置对`CarLibrary.dll`的引用(如果您使用 Visual Studio 编译了`CarLibrary.dll`，则您的程序集位于 CarLibrary 项目文件夹的`\bin\Debug`子目录中)。此时，您可以构建您的客户端应用程序来使用外部类型。按如下方式更新您的初始 C#文件:

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`using System.Threading.Tasks;`

`// Don’t forget to import the CarLibrary namespace!`

`using CarLibrary;`

`namespace CSharpCarClient`

`{`

`public class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** C# CarLibrary Client App *****");`

`// Make a sports car.`

`SportsCar viper = new SportsCar("Viper", 240, 40);`

`viper.TurboBoost();`

`// Make a minivan.`

`MiniVan mv = new MiniVan();`

`mv.TurboBoost();`

`Console.WriteLine("Done. Press any key to terminate");`

`Console.ReadLine();`

`}`

`}`

`}`

这段代码看起来就像书中到目前为止开发的其他应用程序的代码。唯一有趣的一点是，C#客户端应用程序现在使用在单独的自定义库中定义的类型。继续运行您的程序，并验证您看到了各种消息框的显示。

您可能想知道当您使用添加引用对话框引用`CarLibrary.dll`时到底发生了什么。如果您单击解决方案资源管理器的“显示所有文件”按钮，您会注意到 Visual Studio 将原始文件`CarLibrary.dll`的副本添加到了 CSharpCarClient 项目文件夹的`\bin\Debug`文件夹中(参见图 [14-8](#Fig8) )。

![A978-1-4842-1332-2_14_Fig8_HTML.jpg](img/A978-1-4842-1332-2_14_Fig8_HTML.jpg)

图 14-8。

Visual Studio copies private assemblies to the client’s directory

简单来说，`CarLibrary.dll`已经被配置为一个“私有”程序集(这是所有 Visual Studio 类库项目的自动行为)。当您在新应用程序(如`CSharpCarClient.exe`)中引用私有程序集时，IDE 会将库的副本放在客户端应用程序的输出目录中进行响应。

Source Code

CSharpCarClient 项目位于 [`Chapter 14`](14.html) 子目录中。

### 构建 Visual Basic 客户端应用程序

回想一下。NET 平台允许开发人员跨编程语言共享编译后的代码。来说明。NET 平台，让我们创建另一个控制台应用程序(VisualBasicCarClient)，这次使用 Visual Basic(见图 [14-9](#Fig9) )。创建项目后，使用添加引用对话框设置对`CarLibrary.dll`的引用，该对话框可通过项目➤添加引用菜单选项激活。

![A978-1-4842-1332-2_14_Fig9_HTML.jpg](img/A978-1-4842-1332-2_14_Fig9_HTML.jpg)

图 14-9。

Creating a Visual Basic Console Application project

像 C#一样，Visual Basic 允许您列出当前文件中使用的每个命名空间。然而，Visual Basic 提供了`Imports`关键字而不是 C# `using`关键字，所以在`Module1.vb`代码文件中添加下面的`Imports`语句:

`Imports CarLibrary`

`Module Module1`

`Sub Main()`

`End Sub`

`End Module`

请注意，`Main()`方法是在 Visual Basic 模块类型中定义的。简而言之，模块是一种 Visual Basic 符号，用于定义只能包含静态方法的类(很像 C#静态类)。在任何情况下，要使用 Visual Basic 的语法来练习`MiniVan`和`SportsCar`类型，请按如下方式更新您的`Main()`方法:

`Sub Main()`

`Console.WriteLine("***** VB CarLibrary Client App *****")`

`’ Local variables are declared using the Dim keyword.`

`Dim myMiniVan As New MiniVan()`

`myMiniVan.TurboBoost()`

`Dim mySportsCar As New SportsCar()`

`mySportsCar.TurboBoost()`

`Console.ReadLine()`

`End Sub`

当您编译并运行您的应用程序时，您会再次发现显示了一系列消息框。此外，这个新的客户端应用程序在`bin\Debug`文件夹下有自己的`CarLibrary.dll`本地副本。

### 跨语言继承在起作用

迷人的一面。NET 开发是跨语言继承的概念。为了说明，让我们创建一个从`SportsCar`(使用 C#编写)派生的新 Visual Basic 类。首先，向当前的 Visual Basic 应用程序添加一个名为`PerformanceCar.vb`的新类文件(通过选择项目➤添加类菜单选项)。通过使用`Inherits`关键字从`SportsCar`类型派生来更新初始类定义。然后，使用关键字`Overrides`覆盖抽象的`TurboBoost()`方法，就像这样:

`Imports CarLibrary`

`’ This VB class is deriving from the C# SportsCar.`

`Public Class PerformanceCar`

`Inherits SportsCar`

`Public Overrides Sub TurboBoost()`

`Console.WriteLine("Zero to 60 in a cool 4.8 seconds...")`

`End Sub`

`End Class`

为了测试这个新的类类型，更新模块的`Main()`方法，如下所示:

`Sub Main()`

`...`

`Dim dreamCar As New PerformanceCar()`

`’ Use Inherited property.`

`dreamCar.PetName = "Hank"`

`dreamCar.TurboBoost()`

`Console.ReadLine()`

`End Sub`

注意,`dreamCar`对象能够调用继承链中的任何公共成员(比如`PetName`属性),不管基类是用完全不同的语言和完全不同的程序集中定义的！以独立于语言的方式跨程序集边界扩展类的能力是。净开发周期。这使得使用由不愿意用 C#构建共享代码的人编写的编译代码变得容易。

Source Code

VisualBasicCarClient 项目位于 [`Chapter 14`](14.html) 子目录中。

## 了解私有程序集

从技术上讲，到目前为止你在本章中创建的类库已经被部署为私有程序集。私有程序集必须与使用它们的客户端应用程序位于同一目录(应用程序目录)或其子目录中。回想一下，当您在构建`CSharpCarClient.exe`和`VisualBasicCarClient.exe`应用程序时添加对`CarLibrary.dll`的引用时，Visual Studio 的响应是在客户端的应用程序目录中放置一份`CarLibrary.dll`的副本(至少在第一次编译之后)。

当客户端程序使用这个外部程序集中定义的类型时，CLR 只需加载`CarLibrary.dll`的本地副本。因为。NET 运行时在搜索引用的程序集时不查询系统注册表，您可以将`CSharpCarClient.exe`(或`VisualBasicCarClient.exe`)和`CarLibrary.dll`程序集重新定位到您的计算机上的新位置，并运行应用程序(这通常称为 Xcopy 部署)。

卸载(或复制)独占使用私有程序集的应用程序是显而易见的:只需删除(或复制)应用程序文件夹。更重要的是，您不需要担心私有程序集的移除会破坏机器上的任何其他应用程序。

### 私有程序集的标识

私有程序集的完整标识由友好名称和数字版本组成，这两者都记录在程序集清单中。友好名称只是包含程序集清单的模块的名称减去文件扩展名。例如，如果您检查`CarLibrary.dll`程序集的清单，您会发现以下内容:

`.assembly CarLibrary`

`{`

`...`

`.ver 1:0:0:0`

`}`

考虑到私有程序集的隔离性质，CLR 在解析其位置时不麻烦使用版本号应该是有意义的。假设私有程序集不需要任何复杂的版本检查，因为客户端应用程序是唯一“知道”其存在的实体。因此，一台计算机可能在不同的应用程序目录中拥有同一私有程序集的多个副本。

### 了解探查过程

那个。NET 运行时使用一种称为探测的技术来解析私有程序集的位置，这种技术比听起来要简单得多。探测是将外部程序集请求映射到所请求的二进制文件位置的过程。严格地说，加载程序集的请求可以是隐式的，也可以是显式的。当 CLR 查询清单以解析使用`.assembly extern`标记定义的程序集的位置时，会发生隐式加载请求。这里有一个例子:

`// An implicit load request.`

`.assembly extern CarLibrary`

`{ ... }`

显式加载请求通过使用`System.Reflection.Assembly`类类型的`Load()`或`LoadFrom()`方法以编程方式发生，通常用于类型成员的后期绑定和动态调用。你将在第 15 章中进一步研究这些主题，但是现在你可以在下面的代码中看到一个显式加载请求的例子:

`// An explicit load request based on a friendly name.`

`Assembly asm = Assembly.Load("CarLibrary");`

无论哪种情况，CLR 都会提取程序集的友好名称，并开始在客户端的应用程序目录中查找名为`CarLibrary.dll`的文件。如果找不到该文件，将尝试基于相同的友好名称(例如，`CarLibrary.exe`)来查找可执行程序集。如果两个文件都不在应用程序目录中，运行时将放弃并在运行时抛出一个`FileNotFoundException`异常。

Note

从技术上讲，如果在客户端的应用程序目录中找不到所请求程序集的副本，CLR 还会尝试查找与程序集的友好名称同名的客户端子目录(例如，`C:\MyClient\CarLibrary`)。如果请求的程序集位于该子目录中，CLR 会将该程序集加载到内存中。

### 配置私有程序集

虽然可以通过简单地将所有必需的程序集复制到用户硬盘上的单个文件夹来部署. NET 应用程序，但您很可能希望定义许多子目录来对相关内容进行分组。例如，假设您有一个名为`C:\MyApp`的应用程序目录，其中包含`CSharpCarClient.exe`。在这个文件夹下可能有一个名为`MyLibraries`的包含`CarLibrary.dll`的子文件夹。

不管这两个目录之间的预期关系如何，CLR 都不会探测`MyLibraries`子目录，除非您提供一个配置文件。配置文件包含各种 XML 元素，允许您影响探测过程。配置文件必须与启动的应用程序同名，并带有`*.config`文件扩展名，并且必须部署在客户端的应用程序目录中。因此，如果您想为`CSharpCarClient.exe`创建一个配置文件，它必须被命名为`CSharpCarClient.exe.config`，并且位于`C:\MyApp`目录中(对于本例)。

为了演示这个过程，使用 Windows 资源管理器在您的`C:`驱动器上创建一个名为`MyApp`的新目录。接下来，将`CSharpCarClient.exe`和`CarLibrary.dll`复制到这个新文件夹，双击可执行文件运行程序。此时，您的程序应该会成功运行。

现在，在`C:\MyApp`中新建一个名为`MyLibraries`的子目录(见图 [14-10](#Fig10) )，并将`CarLibrary.dll`移动到这个位置。

![A978-1-4842-1332-2_14_Fig10_HTML.jpg](img/A978-1-4842-1332-2_14_Fig10_HTML.jpg)

图 14-10。

CarLibrary.dll now resides under the MyLibraries subdirectory

双击可执行文件，尝试再次运行客户端程序。因为 CLR 无法直接在应用程序目录中找到名为`CarLibrary`的程序集，所以您会看到一个相当糟糕的未处理的`FileNotFoundException`异常。

为了指示 CLR 在`MyLibraries`子目录下进行探测，使用任何文本编辑器创建一个名为`CSharpCarClient.exe.config`的新配置文件，并将该文件保存在包含`CSharpCarClient.exe`应用程序的文件夹中，在本例中是`C:\MyApp`。打开这个文件，输入如下所示的内容(注意 XML 是区分大小写的！):

`<configuration>`

`<runtime>`

`<assemblyBinding >`

`<probing privatePath="MyLibraries"/>`

`</assemblyBinding>`

`</runtime>`

`</configuration>`

。NET `*.config`文件总是以名为`<configuration>`的根元素打开。嵌套的`<runtime>`元素可以指定一个`<assemblyBinding>`元素，该元素嵌套了另一个名为`<probing>`的元素。`privatePath`属性是本例中的关键点，因为它用于指定相对于 CLR 应该探测的应用程序目录的子目录。

创建完`CSharpCarClient.exe.config`后，双击 Windows 资源管理器中的可执行文件来运行客户端。您应该会发现`CSharpCarClient.exe`执行起来没有任何问题(如果不是这样，请仔细检查您的`*.config`文件中的拼写错误)。

请注意，`<probing>`元素没有指定哪个程序集位于给定的子目录下。换句话说，你不能说，“CarLibrary 位于 MyLibraries 子目录下，但是 MathLibrary 位于 OtherStuff 子目录下。”`<probing>`元素简单地指示 CLR 调查所请求程序集的所有指定子目录，直到遇到第一个匹配项。

Note

请注意，`privatePath`属性不能用于指定绝对(`C:\SomeFolder\SomeSubFolder`)或相对(`(..\SomeFolder\AnotherFolder`)路径！如果您需要指定客户机应用程序目录之外的目录，您将需要使用一个名为`<codeBase>`的完全不同的 XML 元素(本章后面将详细介绍这个元素)。

可以使用分号分隔的列表将多个子目录分配给`privatePath`属性。此时您不需要这样做，但是这里有一个示例，它通知 CLR 查询`MyLibraries`和`MyLibraries\Tests`客户端子目录:

`<probing privatePath="MyLibraries;MyLibraries\Tests"/>`

接下来，出于测试目的，更改配置文件的名称(以某种方式)，并尝试再次运行程序。客户端应用程序现在应该失败了。记住`*.config`文件必须以与相关客户端应用程序相同的名称作为前缀。作为最后的测试，打开您的配置文件进行编辑，并大写任何 XML 元素。一旦保存了文件，您的客户机应该不会再次运行(因为 XML 是区分大小写的)。

Note

了解 CLR 将加载它在探测过程中找到的第一个程序集。例如，如果`C:\MyApp`文件夹确实包含了`CarLibrary.dll`的副本，它将被加载到内存中，而`MyLibraries`中的副本实际上被忽略了。

### 应用程序的作用。配置文件

虽然您总是可以使用您选择的文本编辑器手动创建 XML 配置文件，但是 Visual Studio 允许您在开发客户端程序的过程中创建配置文件。默认情况下，新的 Visual Studio 项目将包含一个用于编辑的配置文件。如果您需要手动添加一个，您可以通过项目➤添加新项目菜单选项来完成。请注意，在图 [14-11](#Fig11) 中，您将该文件的名称保留为建议的`App.config`。

![A978-1-4842-1332-2_14_Fig11_HTML.jpg](img/A978-1-4842-1332-2_14_Fig11_HTML.jpg)

图 14-11。

Inserting a new XML configuration file

如果您打开这个文件进行查看，您将看到一个最小的指令集，您将向其中添加额外的元素。

`<?xml version="1.0" encoding="utf-8" ?>`

`<configuration>`

`<startup>`

`<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6" />`

`</startup>`

`</configuration>`

现在，最酷的事情来了。每次编译项目时，Visual Studio 都会使用适当的命名约定(如`CSharpCarClient.exe.config`)自动将`App.config`中的数据复制到`\bin\Debug`目录中的一个新文件中。然而，只有当您的配置文件确实被命名为`App.config`时，才会发生这种行为；见图 [14-12](#Fig12) 。

![A978-1-4842-1332-2_14_Fig12_HTML.jpg](img/A978-1-4842-1332-2_14_Fig12_HTML.jpg)

图 14-12。

The contents of App.config will be copied to a correctly named *.config in your output directory

使用这种方法，您需要做的就是维护`App.config`，Visual Studio 将确保您的应用程序目录包含最新和最好的配置数据(即使您碰巧重命名了您的项目)。

## 了解共享程序集

现在您已经了解了如何部署和配置私有程序集，您可以开始研究共享程序集的角色了。像私有程序集一样，共享程序集是旨在供项目间重用的类型的集合。共享程序集和私有程序集之间最明显的区别是，同一台计算机上的几个应用程序可以使用共享程序集的单个副本。

考虑这样一个事实，即本文中创建的所有应用程序都需要访问`mscorlib.dll`。如果您在这些客户端的应用程序目录中查找，您将不会找到它的私有副本。NET 程序集。原因是`mscorlib.dll`已经被部署为共享程序集。显然，如果您需要创建一个机器范围的类库，这是一条可行之路。

Note

决定一个代码库应该被部署为私有库还是共享库是另一个需要解决的设计问题，这将基于许多特定于项目的细节。根据经验，当您构建需要被各种各样的应用程序使用的库时，共享程序集非常有用，因为它们可以很容易地更新到新版本(正如您将看到的)。

### 全局程序集缓存

正如上一段所建议的，共享程序集不部署在使用它的应用程序所在的目录中。相反，共享程序集被安装到 GAC 中。但是，GAC 的确切位置将取决于。NET 平台，您安装在目标计算机上。

尚未安装的机器。NET 4.0 或更高版本会发现 GAC 位于您的 Windows 目录的一个名为 Assembly 的子目录中(如`C:\Windows\assembly`)。如今，您可能会认为这是“历史 GAC”，因为它只能包含。在 1.0、2.0、3.0 或 3.5 版上编译的. NET 库。见图 [14-13](#Fig13) 。

![A978-1-4842-1332-2_14_Fig13_HTML.jpg](img/A978-1-4842-1332-2_14_Fig13_HTML.jpg)

图 14-13。

The “historical” global assembly cache Note

您不能将可执行程序集(`*.exe`)安装到 GAC 中。只有文件扩展名为`*.dll`的程序集才能被部署为共享程序集。

随着的发布。NET 4.0，微软决定隔离。NET 4.0 和更高版本的库到一个单独的位置，具体来说就是`C:\Windows\Microsoft.NET\assembly\GAC_MSIL`(图 [14-14](#Fig14) )。

![A978-1-4842-1332-2_14_Fig14_HTML.jpg](img/A978-1-4842-1332-2_14_Fig14_HTML.jpg)

图 14-14。

The .NET 4.0 and higher global assembly cache

在这个新文件夹下，您会发现一组子目录，每个子目录的名称都与特定代码库的友好名称相同(例如，`\System.Windows.Forms`、`\System.Core`等等)。在给定的友好名称文件夹下，您会发现另一个子目录，该子目录始终采用以下命名约定:

`v4.0_major.minor.build.revision_publicKeyTokenValue`

前缀“v4.0”表示在。NET 4.0 版或更高版本。该前缀后跟一个下划线，然后是相关的库版本(例如，1.0.0.0)。在一对下划线之后，您将看到另一个数字 publickeytoken 值。正如您将在下一节中看到的，公钥值是程序集的“强名称”的一部分最后，在这个文件夹下，你会发现有问题的`*.dll`的副本。

在本书中，我假设您正在使用。NET 4.6 因此，如果您将一个库安装到 GAC，它将被安装在`C:\Windows\Microsoft.NET\assembly\GAC_MSIL`下。但是，请注意，如果您要配置一个使用 3.5 或更早版本编译的类库项目，您会发现共享库安装在`C:\Windows\assembly`下。

### 理解强名称

在将程序集部署到 GAC 之前，必须为其分配一个强名称，该强名称用于唯一标识给定的发行者。NET 二进制。要明白“发布者”可以是个人程序员(比如你自己)，也可以是给定公司内的一个部门，或者是整个公司本身。

在某些方面，一个强有力的名字是现代的。COM 全局唯一标识符(GUID)标识方案的. NET 等效项。如果您有 COM 背景，您可能还记得 AppIDs 是标识特定 COM 应用程序的 GUIDs。与 COM GUID 值(只不过是 128 位数字)不同，强名称(部分)基于两个加密相关的密钥(公钥和私钥)，这比简单的 GUID 更唯一，更不易被篡改。

从形式上讲，强名称由一组相关数据组成，其中大部分数据是使用下列程序集级属性指定的:

*   程序集的友好名称(您记得，它是程序集的名称减去文件扩展名)
*   程序集的版本号(使用`[AssemblyVersion]`属性分配)
*   公钥值(使用`[AssemblyKeyFile]`属性分配)
*   用于本地化目的的可选区域性标识值(使用`[AssemblyCulture]`属性分配)
*   使用程序集内容和私钥值的哈希创建的嵌入式数字签名

若要为程序集提供强名称，第一步是使用。NET Framework `sn.exe`实用程序(稍后您将会用到)。`sn.exe`实用程序生成一个文件(通常以`*.snk`[强名称密钥]文件扩展名结尾)，该文件包含两个不同但数学上相关的密钥的数据，即公钥和私钥。一旦 C#编译器知道了您的`*.snk`文件的位置，它将在编译时使用`.publickey`标记在程序集清单中记录完整的公钥值。

C#编译器还会基于整个程序集的内容(CIL 代码、元数据等)生成哈希代码。正如你在第 6 章中回忆的那样，散列码是一个数字值，对于一个固定的输入在统计上是唯一的。因此，如果您修改. NET 程序集的任何方面(即使是字符串中的单个字符)，编译器都会生成不同的哈希代码。这个哈希代码与`*.snk`文件中的私钥数据相结合，产生一个嵌入在程序集的 CLR 头数据中的数字签名。图 [14-15](#Fig15) 展示了强命名程序集的过程。

![A978-1-4842-1332-2_14_Fig15_HTML.gif](img/A978-1-4842-1332-2_14_Fig15_HTML.gif)

图 14-15。

At compile time, a digital signature is generated and embedded into the assembly based, in part, on public and private key data

请理解，实际的`private key`数据并没有在清单中的任何地方列出，而是仅用于对程序集的内容进行数字签名(与生成的哈希代码一起使用)。同样，使用公钥/私钥数据的整体思想是确保没有两个公司、部门或个人在。净宇宙。在任何情况下，一旦分配强名称的过程完成，就可以将程序集安装到 GAC 中。

Note

强名称还提供了一定程度的保护，防止潜在的作恶者篡改程序集的内容。鉴于这一点，对每个程序集(包括`*.exe`程序集)进行强名称命名被认为是. NET 的最佳实践，无论它是否被部署到 GAC。

### 在命令行生成强名称

让我们看一下给本章前面创建的`CarLibrary`程序集分配强名称的过程。现在，您很可能会使用 Visual Studio 生成所需的`*.snk`文件。然而，在过去糟糕的日子里(大约 2003 年)，对程序集进行强签名的唯一选择是在命令行中这样做。让我们看看如何做到这一点。

首要任务是使用`sn.exe`实用程序生成所需的关键数据。尽管这个工具有许多命令行选项，但目前您需要关心的只是`-k`标志，它指示工具生成一个包含公钥/私钥信息的新文件。

在 c 盘上创建一个名为`MyTestKeyPair`的新文件夹，并使用开发人员命令提示符切换到该目录。接下来，发出以下命令来生成一个名为`MyTestKeyPair.snk`的文件:

`sn –k MyTestKeyPair.snk`

现在您已经有了您的关键数据，您需要通知 C#编译器`MyTestKeyPair.snk`的确切位置。回想一下本章前面的内容，当您使用 Visual Studio 创建任何新的 C#项目工作区时，其中一个初始项目文件(位于解决方案资源管理器的 Properties 节点下)被命名为`AssemblyInfo.cs`。该文件包含许多描述程序集本身的属性。可以将`[AssemblyKeyFile]`汇编级属性添加到您的`AssemblyInfo.cs`文件中，以通知编译器有效的`*.snk`文件的位置。只需将路径指定为字符串参数。这里有一个例子:

`[assembly: AssemblyKeyFile(@"C:\MyTestKeyPair\MyTestKeyPair.snk")]`

Note

当您手动指定[ `AssemblyKeyFile` ]属性时，Visual Studio 将生成一条警告，通知您使用`csc.exe`的/ `keyfile`选项或通过 Visual Studio 属性窗口建立密钥文件。您将很快使用 IDE 来完成这项工作(因此可以忽略生成的警告)。

因为共享程序集的版本是强名称的一个方面，所以为`CarLibrary.dll`选择版本号是一个必要的细节。在`AssemblyInfo.cs`文件中，您会发现另一个名为`[AssemblyVersion]`的属性。最初，该值被设置为`1.0.0.0`。

`[assembly: AssemblyVersion("1.0.0.0")]`

a。NET 版本号由四部分组成(<major>)。<minor>。<build>。<revision>)。虽然指定版本号完全由您决定，但是您可以使用通配符标记，而不是使用特定的内部版本号和修订号值，指示 Visual Studio 在每次编译时自动递增内部版本号和修订号。对于这个例子，您不需要这样做；但是，请考虑以下情况:</revision></build></minor></major>

`// Format: <Major number>.<Minor number>.<Build number>.<Revision number>`

`// Valid values for each part of the version number are between 0 and 65535.`

`[assembly: AssemblyVersion("1.0.*")]`

此时，C#编译器拥有了生成强名称数据所需的所有信息(因为您没有通过`[AssemblyCulture]`属性指定唯一的区域性值，所以您“继承”了您当前计算机的区域性，在我的例子中是美国英语)。

编译您的 CarLibrary 代码库，在`ildasm.exe`中打开您的程序集，并检查清单。现在你会看到一个新的`.publickey`标签被用来记录完整的公钥信息，而`.ver`令牌记录了通过`[AssemblyVersion]`属性指定的版本(见图 [14-16](#Fig16) )。

![A978-1-4842-1332-2_14_Fig16_HTML.jpg](img/A978-1-4842-1332-2_14_Fig16_HTML.jpg)

图 14-16。

A strongly named assembly records the public key in the manifest

太好了。此时，您可以将共享的`CarLibrary.dll`程序集部署到 GAC。但是，请记住，这些天来。NET 开发人员可以使用 Visual Studio 通过友好的用户界面而不是晦涩的`sn.exe`命令行工具来创建强名称程序集。在了解如何做到这一点之前，请确保从您的`AssemblyInfo.cs`文件中删除(或注释掉)以下代码行(假设您在本节文本中手动添加了这一行):

`// [assembly: AssemblyKeyFile(@"C:\MyTestKeyPair\MyTestKeyPair.snk")]`

### 使用 Visual Studio 生成强名称

Visual Studio 允许您使用项目的属性页指定现有`*.snk`文件的位置，并生成新的`*.snk`文件。要为 CarLibrary 项目创建一个新的`*.snk`文件，首先双击解决方案资源管理器的属性图标并选择签名选项卡。接下来，选择“签署装配”复选框，并从下拉列表中选择<new...>选项(见图</new...> [14-17](#Fig17) )。

![A978-1-4842-1332-2_14_Fig17_HTML.jpg](img/A978-1-4842-1332-2_14_Fig17_HTML.jpg)

图 14-17。

Creating a new *.snk file using Visual Studio

这样做之后，将要求您为新的`*.snk`文件提供一个名称(比如`myKeyPair.snk`)，并且您可以选择用密码保护您的文件(本例中不需要)；见图 [14-18](#Fig18) 。

![A978-1-4842-1332-2_14_Fig18_HTML.jpg](img/A978-1-4842-1332-2_14_Fig18_HTML.jpg)

图 14-18。

Naming the new *.snk file using Visual Studio

此时，您将在解决方案浏览器中看到您的`*.snk`文件(图 [14-19](#Fig19) )。每次生成应用程序时，这些数据都将用于为程序集分配一个正确的强名称。

![A978-1-4842-1332-2_14_Fig19_HTML.jpg](img/A978-1-4842-1332-2_14_Fig19_HTML.jpg)

图 14-19。

Visual Studio will now strongly sign your assembly with each compilation Note

回想一下，属性编辑器的 Application 选项卡提供了一个名为 Assembly Information 的按钮。单击该按钮时，会显示一个对话框，允许您建立许多程序集级属性，包括版本号、版权信息等。

### 将强名称程序集安装到 GAC

最后一步是将`CarLibrary.dll`安装到 GAC 中。虽然在生产环境中将程序集部署到 GAC 的首选方法是创建安装程序包(使用商业安装程序，如 InstallShield ),但是。NET Framework SDK 附带了一个名为`gacutil.exe`的命令行工具，这对于快速测试非常有用。

Note

您必须拥有管理员权限才能在您的机器上与 GAC 交互。确保以管理员身份运行命令窗口。

表 [14-1](#Tab1) 记录了`gacutil.exe`的一些相关选项(运行程序时指定`/?`标志以查看每个选项)。

表 14-1。

Various Options of `gacutil.exe`

<colgroup><col> <col></colgroup> 
| [计]选项 | 生命的意义 |
| --- | --- |
| `-i` | 将强名称程序集安装到 GAC 中 |
| `-u` | 从 GAC 中卸载程序集 |
| `-l` | 显示 GAC 中的组件(或特定组件) |

要使用`gacutil.exe`安装强名称程序集，首先打开命令提示符，然后切换到包含`CarLibrary.dll`的目录。这里有一个例子(你的路径可能不同):

`cd C:\MyCode\CarLibrary\bin\Debug`

接下来，使用`-i`命令安装库，如下所示:

`gacutil /i CarLibrary.dll`

这样做之后，可以通过指定如下的`-l`命令来验证库是否已经部署(注意，使用`-l`命令时省略了文件扩展名):

`gacutil /l CarLibrary`

如果一切正常，您应该会在控制台窗口中看到以下输出(您将会发现一个独特的`PublicKeyToken`值，正如预期的那样):

`The Global Assembly Cache contains the following assemblies:`

`CarLibrary, Version=1.0.0.0, Culture=neutral, PublicKeyToken=33a2bc294331e8b9, processorArchitecture=MSIL`

`Number of items = 1`

此外，如果您要导航到`C:\Windows\Microsoft.NET\assembly\GAC_MSIL`，您会发现一个具有正确子目录结构的新`CarLibrary`文件夹(参见图 [14-20](#Fig20) )。

![A978-1-4842-1332-2_14_Fig20_HTML.jpg](img/A978-1-4842-1332-2_14_Fig20_HTML.jpg)

图 14-20。

The shared CarLibrary assembly in the GAC

## 使用共享程序集

当您生成使用共享程序集的应用程序时，与使用私有程序集的唯一区别在于如何使用 Visual Studio 引用库。实际上，就工具而言没有什么不同，您仍然使用“添加引用”对话框。

当您需要引用私有程序集时，可以使用“浏览”按钮导航到 GAC 的正确子目录。但是，您也可以简单地导航到强名称程序集的位置(例如类库项目的`/bin/debug`文件夹)并引用副本。当 Visual Studio 找到具有强名称的库时，它不会将该库复制到客户端应用程序的输出文件夹中。无论如何，图 [14-21](#Fig21) 显示了引用的库。

![A978-1-4842-1332-2_14_Fig21_HTML.jpg](img/A978-1-4842-1332-2_14_Fig21_HTML.jpg)

图 14-21。

Referencing the strongly named, shared CarLibrary (version 1.0.0.0) using Visual Studio

举例来说，创建一个名为 SharedCarLibClient 的新 C#控制台应用程序项目，并引用您的`CarLibrary.dll`程序集，就像刚才描述的那样。正如您所希望的，现在您可以在解决方案资源管理器的 Reference 文件夹中看到一个图标。如果选择此图标，然后查看“属性”窗口(可从 Visual Studio“视图”菜单中访问)，您会注意到所选磁带库的“复制本地”属性现在设置为 False。在任何情况下，在新的客户端应用程序中编写以下测试代码:

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`using System.Threading.Tasks;`

`using CarLibrary;`

`namespace SharedCarLibClient`

`{`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Shared Assembly Client *****");`

`SportsCar c = new SportsCar();`

`c.TurboBoost();`

`Console.ReadLine();`

`}`

`}`

`}`

编译完客户端应用程序后，使用 Windows 资源管理器导航到包含`SharedCarLibClient.exe`的目录，注意 Visual Studio 没有将`CarLibrary.dll`复制到客户端的应用程序目录中。当您引用其清单包含一个`.publickey`值的程序集时，Visual Studio 假定强名称程序集将被部署到 GAC，因此，不会费心复制二进制文件。

### 探索 SharedCarLibClient 的清单

回想一下，当您为程序集生成强名称时，整个公钥都记录在程序集清单中。与此相关的是，当客户端引用强名称程序集时，它的清单记录了完整公钥的压缩哈希值，由`.publickeytoken`标记表示。如果您使用`ildasm.exe`打开`SharedCarLibClient.exe`的清单，您会发现以下内容(您的公钥标记值当然会有所不同，因为它是基于公钥值计算的):

`.assembly extern CarLibrary`

`{`

`.publickeytoken = (33 A2 BC 29 43 31 E8 B9 )`

`.ver 1:0:0:0`

`}`

如果将记录在客户端清单中的公钥标记值与 GAC 中显示的公钥标记值进行比较，您会发现完全匹配。回想一下，公钥代表强名称程序集标识的一个方面。鉴于此，CLR 将只加载名为`CarLibrary`的程序集的版本`1.0.0.0`，该程序集的公钥可以被哈希分解为值`33A2BC294331E8B9`。如果 CLR 在 GAC 中没有找到符合这个描述的程序集(也没有在客户端的目录中找到名为`CarLibrary`的私有程序集)，就会抛出`FileNotFoundException`异常。

Source Code

您可以在 [`Chapter 14`](14.html) 子目录中找到 SharedCarLibClient 应用程序。

## 配置共享程序集

像私有程序集一样，共享程序集可以使用客户端`*.config`文件进行配置。当然，因为共享程序集被部署到一个众所周知的位置(GAC)，所以您不会像对私有程序集那样使用`<privatePath>`元素(尽管如果客户端同时使用共享程序集和私有程序集，`<privatePath>`元素可能仍然存在于`*.config`文件中)。

每当您希望指示 CLR 绑定到特定程序集的不同版本时，都可以将应用程序配置文件与共享程序集结合使用，从而有效地绕过客户端清单中记录的值。由于许多原因，这可能是有用的。例如，假设您已经发布了 1.0.0.0 版本的程序集，后来发现了一个主要的 bug。一种纠正措施是重新构建客户端应用程序，以引用无错误程序集的正确版本(比如 1.1.0.0 ),并将更新后的客户端和新库重新分发到每台目标机器。

另一个选择是发布新的代码库和一个`*.config`文件，该文件自动指示运行时绑定到新的(无 bug)版本。只要新版本已经安装到 GAC 中，原来的客户端就可以运行，无需重新编译、重新分发，也不用担心必须更新您的简历。

下面是另一个例子:您已经发布了第一个版本的无 bug 程序集(1.0.0.0)，一两个月后，您向该程序集添加了新的功能，产生了版本 2.0.0.0。显然，针对版本 1.0.0.0 编译的现有客户端应用程序对这些新类型一无所知，因为它们的代码库没有引用它们。

但是，新的客户端应用程序希望引用 2.0.0.0 版中的新功能。在下面。NET 中，您可以自由地将版本 2.0.0.0 发布到目标机器上，并让版本 2.0.0.0 与旧版本 1.0.0.0 一起运行。如果需要，可以使用应用程序配置文件动态重定向现有客户端以加载版本 2.0.0.0(以获得对实现改进的访问)，而无需重新编译和重新部署客户端应用程序。

### 冻结当前共享程序集

为了说明如何动态绑定到共享程序集的特定版本，打开 Windows 资源管理器，将编译后的`CarLibrary.dll`程序集的当前版本(1.0.0.0)复制到一个不同的子目录(我称之为 mine `CarLibrary Version 1.0.0.0`)中，以象征该版本的冻结(见图 [14-22](#Fig22) )。

![A978-1-4842-1332-2_14_Fig22_HTML.jpg](img/A978-1-4842-1332-2_14_Fig22_HTML.jpg)

图 14-22。

Freezing the current version of CarLibrary.dll

### 生成共享程序集版本 2.0.0.0

现在，打开您现有的 CarLibrary 项目，用一个名为`MusicMedia`的新的`enum`类型更新您的代码库，它定义了以下四种可能的音乐设备。

`// Which type of music player does this car have?`

`public enum MusicMedia`

`{`

`musicCd,`

`musicTape,`

`musicRadio,`

`musicMp3`

`}`

同样，向`Car`类型添加一个新的公共方法，该方法允许调用者打开一个给定的媒体播放器(如果需要，确保导入`System.Windows.Forms`名称空间)，如下所示:

`public abstract class Car`

`{`

`...`

`public void TurnOnRadio(bool musicOn, MusicMedia mm)`

`{`

`if(musicOn)`

`MessageBox.Show(string.Format("Jamming {0}", mm));`

`else`

`MessageBox.Show("Quiet time...");`

`}`

`}`

更新`Car`类的构造函数以显示一个`MessageBox`,验证您确实在使用 CarLibrary 2.0.0.0，如下所示:

`public abstract class Car`

`{`

`...`

`public Car()`

`{`

`MessageBox.Show("CarLibrary Version 2.0!");`

`}`

`public Car(string name, int maxSp, int currSp)`

`{`

`MessageBox.Show("CarLibrary Version 2.0!");`

`PetName = name; MaxSpeed = maxSp; CurrentSpeed = currSp;`

`}`

`...`

`}`

最后但同样重要的是，在重新编译新库之前，将版本更新为 2.0.0.0。回想一下，您可以通过双击“解决方案资源管理器”的“属性”图标，然后单击“应用程序”选项卡上的“程序集信息”按钮，以可视化的方式完成此操作。完成后，只需更新组件版本号(见图 [14-23](#Fig23) )。

![A978-1-4842-1332-2_14_Fig23_HTML.jpg](img/A978-1-4842-1332-2_14_Fig23_HTML.jpg)

图 14-23。

Setting the version number of CarLibrary.dll to 2.0.0.0

如果你查看你的项目的`\bin\Debug`文件夹，你会看到你有这个程序集的一个新版本(2.0.0.0)，而版本 1.0.0.0 安全地存储在`CarLibrary Version 1.0.0.0`目录中。如本章前面所述，使用`gacutil.exe`将这个新组件安装到 4.0 GAC 中。注意，现在你有了同一个组件的两个版本(见图 [14-24](#Fig24) )。

![A978-1-4842-1332-2_14_Fig24_HTML.jpg](img/A978-1-4842-1332-2_14_Fig24_HTML.jpg)

图 14-24。

Side-by-side execution of a shared assembly

如果您通过双击 Windows 资源管理器中的图标来运行当前的`SharedCarLibClient.exe`程序，您应该不会看到“CarLibrary Version 2.0！”消息框，因为清单明确要求版本 1.0.0.0。那么，如何指示 CLR 绑定到版本 2.0.0.0 呢？很高兴你问了！

Note

当您编译应用程序时，Visual Studio 将自动重置引用！因此，如果您在 Visual Studio 中运行您的`SharedCarLibClient.exe`应用程序，它将获取`CarLibrary.dll`版本 2.0.0.0！如果您不小心以这种方式运行了您的应用程序，只需删除当前的`CarLibrary.dll`引用并选择版本 1.0.0.0(我建议您将它放在名为`CarLibrary Version 1.0.0.0`的文件夹中)。

### 动态重定向到共享程序集的特定版本

当您想要告诉 CLR 加载清单中未列出的共享程序集版本时，您可以构建一个包含`<dependentAssembly>`元素的`*.config`文件。这样做时，您将需要创建一个`<assemblyIdentity>`子元素，它指定在客户端清单中列出的程序集的友好名称(对于本例为`CarLibrary`)和一个可选的 culture 属性(如果您想为机器使用默认的区域性，可以为其分配一个空字符串或完全省略)。此外，`<dependentAssembly>`元素将定义一个`<` `bindingRedirect>`子元素来定义清单中当前的版本(通过`oldVersion`属性)和 GAC 中要加载的版本(通过`newVersion`属性)。

更新应用程序目录`SharedCarLibClient`中名为`SharedCarLibClient.exe.config`的当前配置文件，该文件包含以下 XML 数据。

Note

您的公钥标记的值将与您在以下标记中看到的不同。要找到您的公钥标记值，回想一下，您可以在`ildasm.exe`中打开客户端，双击 MANIFEST 图标，并将该值复制到您的剪贴板(只是要确保删除空格！).

`<?xml version="1.0" encoding="utf-8" ?>`

`<configuration>`

`<!--Runtime binding info -->`

`<runtime>`

`<assemblyBinding >`

`<dependentAssembly>`

`<assemblyIdentity name="CarLibrary"`

`publicKeyToken="64ee9364749d8328"`

`culture="neutral"/>`

`<bindingRedirect oldVersion= "1.0.0.0"`

`newVersion= "2.0.0.0"/>`

`</dependentAssembly>`

`</assemblyBinding>`

`</runtime>`

`</configuration>`

现在通过双击 Windows 资源管理器中的可执行文件来运行`SharedCarLibClient.exe`程序。您应该会看到版本 2.0.0.0 已经加载的消息。

多个`<dependentAssembly>`元素可以出现在一个客户端的配置文件中。尽管这个例子没有必要，但是假设`SharedCarLibClient.exe`的清单也引用了名为`MathLibrary`的程序集的 2.5.0.0 版本。如果您想重定向到版本 3.0.0.0 的`MathLibrary`(除了版本 2.0.0 的`CarLibrary`)，那么`SharedCarLibClient.exe.config`文件将如下所示:

`<configuration>`

`<runtime>`

`<assemblyBinding >`

`<!-- Controls Binding to CarLibrary -->`

`<dependentAssembly>`

`<assemblyIdentity name="CarLibrary"`

`publicKeyToken="64ee9364749d8328"`

`culture=""/>`

`<bindingRedirect oldVersion= "1.0.0.0" newVersion= "2.0.0.0"/>`

`</dependentAssembly>`

`<!-- Controls Binding to MathLibrary -->`

`<dependentAssembly>`

`<assemblyIdentity name="MathLibrary"`

`publicKeyToken="64ee9364749d8328"`

`culture=""/>`

`<bindingRedirect oldVersion= "2.5.0.0" newVersion= "3.0.0.0"/>`

`</dependentAssembly>`

`</assemblyBinding>`

`</runtime>`

`</configuration>`

Note

可以通过`oldVersion`属性指定旧版本号的范围；例如，`<bindingRedirect oldVersion="1.0.0.0-1.2.0.0" newVersion="2.0.0.0"/>`通知 CLR 对 1.0.0.0 到 1.2.0.0 范围内的任何旧版本使用版本 2.0.0.0。

## 了解发行者策略程序集

您将研究的下一个配置问题是发行者策略程序集的角色。正如您刚才看到的，`*.config`文件可以被构造为绑定到共享程序集的特定版本，从而绕过客户端清单中记录的版本。虽然这一切都很好，但想象一下，您是一名管理员，现在需要重新配置给定机器上的所有客户端应用程序，以重新绑定到版本 2.0.0.0 的`CarLibrary.dll`程序集。给定配置文件的严格命名约定，您将需要在许多位置复制相同的 XML 内容(假设您实际上知道使用`CarLibrary`的可执行文件的位置！).显然，这将是一场维护噩梦。

发布者策略允许给定程序集的发布者(您、您的部门、您的公司等等)发布一个二进制版本的`*.config`文件，该文件与相关程序集的最新版本一起安装到 GAC 中。这种方法的好处是客户端应用程序目录不需要包含特定的`*.config`文件。相反，CLR 将读取当前清单，并尝试在 GAC 中找到请求的版本。但是，如果 CLR 找到发行者策略程序集，它将读取嵌入的 XML 数据，并在 GAC 级别执行请求的重定向。

发行者策略程序集是使用名为`al.exe`(程序集链接器)的. NET 实用程序在命令行创建的。尽管此工具提供了许多选项，但构建发行者策略程序集只需要传入以下输入参数:

*   包含重定向指令的`*.config`或`*.xml`文件的位置
*   生成的发行者策略程序集的名称
*   用于签署发行者策略程序集的`*.snk`文件的位置
*   为正在构造的发行者策略程序集分配的版本号

如果您想要构建一个控制`CarLibrary.dll`的发布者策略程序集，命令集如下所示(必须在命令窗口的一行中输入):

`al /link:CarLibraryPolicy.xml /out:policy.1.0.CarLibrary.dll`

`/keyf:C:\MyKey\myKey.snk /v:1.0.0.0`

这里，XML 内容包含在名为`CarLibraryPolicy.xml`的文件中。使用明显的`/out`标志指定输出文件的名称(必须是格式`policy.<major>.<minor>.assemblyToConfigure`)。此外，注意包含公钥/私钥对的文件名也需要通过`/keyf`选项提供。请记住，发行者策略文件是共享的，因此必须具有强名称！

一旦执行了`al.exe`工具，结果就是一个新的程序集，它可以被放入 GAC 中以强制所有客户端绑定到`CarLibrary.dll`的 2.0.0.0 版本，而无需使用特定的客户端应用程序配置文件。使用这种技术，您可以使用现有程序集的特定版本(或版本范围)为所有应用程序设计计算机范围的重定向。

### 禁用发行者策略

现在，假设您(作为系统管理员)已经将发行者策略程序集(以及相关程序集的最新版本)部署到客户端机器的 GAC。幸运的是，十个受影响的应用程序中有九个被正确地重新绑定到 2.0.0.0 版本。但是，剩下的客户端应用程序(无论什么原因)在访问`CarLibrary.dll` 2.0.0.0 时会爆炸。(众所周知，几乎不可能构建出 100%时间都能工作的向后兼容软件。)

在这种情况下，可以为特定的有问题的客户端构建一个配置文件，指示 CLR 忽略 GAC 中安装的任何发行者策略文件。剩余的客户端应用程序乐于使用最新的。NET 程序集将通过已安装的发行者策略程序集被简单地重定向。要逐个客户端地禁用发布者策略，请创建一个(正确命名的)`*.config`文件，该文件使用`<publisherPolicy>`元素并将`apply`属性设置为`no`。当您这样做时，CLR 将加载最初在客户端清单中列出的程序集版本。

`<configuration>`

`<runtime>`

`<assemblyBinding >`

`<publisherPolicy apply="no" />`

`</assemblyBinding>`

`</runtime>`

`</configuration>`

## 理解<codebase>元素</codebase>

应用程序配置文件也可以指定基本代码。`<codeBase>`元素可用于指示 CLR 探测位于任意位置的依赖程序集(如网络端点或客户端应用程序目录外的任意机器路径)。

如果分配给一个`<codeBase>`元素的值位于一个远程机器上，那么该程序集将被按需下载到 GAC 中一个称为下载缓存的特定目录中。鉴于您已经了解了如何将程序集部署到 GAC，从`<codeBase>`元素加载的程序集需要分配一个强名称(毕竟，CLR 还能如何将远程程序集安装到 GAC？).如果你感兴趣，你可以通过向`gacutil.exe`提供`/ldl`选项来查看你的机器的下载缓存的内容，就像这样:

`gacutil /ldl`

Note

从技术上讲，`<codeBase>`元素可以用来探测没有强名称的程序集。然而，程序集的位置必须相对于客户端的应用程序目录(因此，它只不过是`<privatePath>`元素的替代)。

要查看运行中的`<codeBase>`元素，创建一个名为 CodeBaseClient 的控制台应用程序项目，设置对`CarLibrary.dll`版本 2.0.0.0 的引用，并更新初始文件，如下所示:

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`using System.Threading.Tasks;`

`using CarLibrary;`

`namespace CodeBaseClient`

`{`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with CodeBases *****");`

`SportsCar c = new SportsCar();`

`Console.WriteLine("Sports car has been allocated.");`

`Console.ReadLine();`

`}`

`}`

`}`

鉴于`CarLibrary.dll`已经部署到 GAC，您可以按原样运行该程序。然而，为了说明`<codeBase>`元素的使用，在您的`C:`驱动器(可能是`C:\MyAsms`)下创建一个新文件夹，并将`CarLibrary.dll`版本 2.0.0.0 的副本放入这个目录。

现在，向 CodeBaseClient 项目添加一个`App.config`文件(或编辑一个现有的`App.config`)并创作以下 XML 内容(记住，您的`.` `publickeytoken`值会有所不同；根据需要咨询您的 GAC):

`<configuration>`

`...`

`<runtime>`

`<assemblyBinding >`

`<dependentAssembly>`

`<assemblyIdentity name="CarLibrary" publicKeyToken="33A2BC294331E8B9"`

`culture="neutral"` `/>`

`<codeBase version="2.0.0.0" href="file:///C:/MyAsms/CarLibrary.dll" />`

`</dependentAssembly>`

`</assemblyBinding>`

`</runtime>`

`</configuration>`

如您所见，`<codeBase>`元素嵌套在`<assemblyIdentity>`元素中，后者利用`name`和`publicKeyToken`属性来指定友好名称和相关的`publicKeyToken`值。`<codeBase>`元素本身指定了要加载的程序集的版本和位置(通过`href`属性)。如果您要从 GAC 中删除版本 2.0.0.0 的`CarLibrary.dll`，这个客户端仍然可以成功运行，因为 CLR 能够在`C:\MyAsms`下定位外部程序集。

Note

如果将程序集放在开发计算机上的随机位置，实际上是在重新创建系统注册表(以及相关的 DLL hell ),因为如果移动或重命名包含二进制文件的文件夹，当前的绑定将会失败。记住这一点，谨慎使用`<codeBase>`。

当引用位于远程网络机器上的程序集时,`<codeBase>`元素也很有帮助。假设您有权限访问位于 [`http://www.MySite.com`](http://www.mysite.com/) 的文件夹。要将远程`*.dll`下载到您本地机器上的 GAC 下载缓存中，您可以如下更新`<codeBase>`元素:

`<codeBase version="2.0.0.0"`

`href="`[`http://www.MySite.com/Assemblies/CarLibrary.dll`](http://www.mysite.com/Assemblies/CarLibrary.dll)T2】

Source Code

您可以在 [`Chapter 14`](14.html) 子目录中找到 CodeBaseClient 应用程序。

## 系统。配置命名空间

目前，本章中显示的所有`*.config`文件都使用了众所周知的 XML 元素，CLR 读取这些元素来解析外部程序集的位置。除了这些公认的元素之外，客户机配置文件完全可以包含与绑定试探法无关的特定于应用程序的数据。鉴于此，毫不奇怪。NET Framework 提供了一个命名空间，允许您以编程方式读取客户端配置文件中的数据。

`System.Configuration`名称空间提供了一小组类型，可以用来从客户机的`*.config`文件中读取定制数据。这些自定义设置必须包含在一个`<appSettings>`元素的范围内。`<appSettings>`元素包含任意数量的`<add>`元素，这些元素定义了以编程方式获得的键值对。

例如，假设您有一个名为 AppConfigReaderApp 的控制台应用程序项目的`App.config`文件，它定义了两个特定于应用程序的值，如下所示:

`<?xml version="1.0" encoding="utf-8" ?>`

`<configuration>`

`<startup>`

`<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6" />`

`</startup>`

`<!-- Custom App settings -->`

`<appSettings>`

`<add key="TextColor" value="Green" />`

`<add key="RepeatCount" value="8" />`

`</appSettings>`

`</configuration>`

读取这些值供客户端应用程序使用就像调用`System.Configuration.AppSettingsReader`类型的实例级`GetValue()`方法一样简单。如下面的代码所示，`GetValue()`的第一个参数是`*.config`文件中键的名称，而第二个参数是键的底层类型(通过 C# `typeof`操作符获得):

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`using System.Threading.Tasks;`

`using System.Configuration;`

`namespace AppConfigReaderApp`

`{`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Reading <appSettings> Data *****\n");`

`// Get our custom data from the *.config file.`

`AppSettingsReader ar = new AppSettingsReader();`

`int numbOfTimes = (int)ar.GetValue("RepeatCount", typeof(int));`

`string textColor = (string)ar.GetValue("TextColor", typeof(string));`

`Console.ForegroundColor =`

`(ConsoleColor)Enum.Parse(typeof(ConsoleColor), textColor);`

`// Now print a message correctly.`

`for (int i = 0; i < numbOfTimes; i++)`

`Console.WriteLine("Howdy!");`

`Console.ReadLine();`

`}`

`}`

`}`

Source Code

您可以在 [`Chapter 14`](14.html) 子目录中找到 AppConfigReaderApp 应用程序。

## 配置文件架构文档

在本章中，您已经了解了 XML 配置文件的作用。这里，您关注了一些可以添加到`<runtime>`元素中的设置，这些设置控制 CLR 如何尝试定位外部所需的库。当您阅读本书接下来的章节时(当您超越本书并开始构建更大规模的软件时)，您会很快注意到 XML 配置文件的使用非常普遍。

可以肯定的是。NET 平台在众多 API 中使用`*.config`文件。比如在[第 25 章](25.html)中，你会看到 Windows 通信基础(WCF)使用配置文件来建立复杂的网络设置。在本文的后面，当你通过 ASP.NET 检查 web 开发时，你会很快注意到,`web.config`文件包含与桌面`App.config`文件相同类型的指令。

因为给定的。NET 配置文件可以包含大量的指令，您应该知道这个 XML 文件的整个架构都记录在。NET 帮助系统。具体来说，如果您搜索。NET Framework 的帮助系统中，会给出每个元素的详细解释(见图 [14-25](#Fig25) )。

![A978-1-4842-1332-2_14_Fig25_HTML.jpg](img/A978-1-4842-1332-2_14_Fig25_HTML.jpg)

图 14-25。

XML configuration files are fully documented in the .NET help system

## 摘要

本章考察了。NET 类库(又名。NET `*.dll` s)。如你所见，类库是。NET 二进制文件，其中包含旨在跨各种项目重用的逻辑。回想一下，库可以以两种主要方式部署，特别是私有或共享。如果您有适当的 XML 配置文件，私有程序集将部署到客户端文件夹或其子目录中。共享程序集是计算机上的任何应用程序都可以使用的库，并且还会受到客户端配置文件中的设置的影响。

您了解了如何用“强名称”标记共享程序集，这实质上是为 CLR 眼中的库建立了一个唯一的标识。此外，您还了解了在共享库的开发和部署过程中使用的各种命令行工具(`sn.exe`和`gacutil.exe`)。

本章最后研究了发布者策略的作用以及使用`System.Configuration`名称空间存储和检索自定义设置的过程。