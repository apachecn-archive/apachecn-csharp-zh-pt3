# 34.ASP.NET MVC 和 Web API

最后三章介绍了 ASP.NET Web 表单以及与 Web 相关的概念，如 HTTP 和 HTML。本章介绍了 ASP.NET 生态系统的两个新成员:ASP.NET MVC 和 Web API。MVC 是从用户社区(特别是 ALT.NET 运动)中发展出来的，用户社区要求一个更紧密地附着于 HTTP 的租户、更易测试、并且坚持关注点分离的框架。虽然 Web 窗体仍然控制着。NET web 开发生态系统中，MVC 的采用率正在迅速增长。

本章从 MVC 模式的简要解释开始，然后深入到创建一个 MVC 项目。默认的项目模板附带了许多脚手架，接下来的章节将介绍为您创建的部分。在对 MVC 有了扎实的理解之后，您将为 CarLotMVC 构建库存页面，这是您在前三章中构建的网站的一个基于 MVC 的子集。

下一节将向您介绍 Web API，这是一个主要构建在 MVC 框架上的服务框架，并分享许多概念，包括路由、控制器和动作。ASP.NET Web API 允许你利用你的 MVC 知识来构建 RESTful 服务，而不需要 WCF ( [第 25 章](25.html))所要求的配置和管道。您将创建一个名为 CarLotWebAPI 的 RESTful 服务，该服务公开库存记录的所有创建、读取、更新、删除(CRUD)功能。最后，您通过更新 CarLotMVC 以使用 CarLotWebAPI 作为数据源，而不是使用实体框架和 AutoLotDAL 来完成这一章。

## 介绍 MVC 模式

模型-视图-控制器(MVC)模式在 20 世纪 70 年代就已经出现了(作为 Smalltalk 中使用的一种模式创建的)，但是最近才开始流行起来。很多语言都有 MVC 框架，包括 Java(最显著的是 Spring 框架)，Ruby (Ruby on Rails)，。NET(随着 2007 年 ASP.NET MVC 的引入)，以及 Angular 和 EmberJS 等许多 JavaScript 客户端框架。

如果下面对模式的描述让你想起了模型-视图-视图模型模式(在第 30 章中有所涉及)，那么你是正确的。MVVM 利用了 MVC 的许多组件(以及表示模型模式)。历史够多了。我们进入模式吧！

### 模型

就像在 MVVM，模型就是你应用的数据。数据通常由普通的旧 CLR 对象(POCOs)表示，就像您在 AutoLotDAL 库中构建的([第 23 章](23.html))以及在 MVVM 示例([第 30 章](30.html))中使用的一样。模型类可以(并且经常)内置验证，并且根据使用的客户端 JavaScript 框架(比如 knockout.js)，可以配置为可观察的。

### 景色

视图是应用程序的用户界面，向用户呈现输出。视图应该尽可能的轻便。

### 控制器

控制者是操作的大脑。管制员有两个责任；第一个是接受来自用户的命令/请求(称为动作)并正确地对它们进行适当的编组(比如到一个存储库)，第二个是将任何更改发送到视图。控制器(以及模型和视图)应该是轻量级的，并利用其他组件来维护关注点的分离。这听起来很简单，不是吗？在您开始构建 MVC 应用程序之前，有一个老问题…

### 为什么是 MVC？

到 2007 年 ASP.NET MVC 发布的时候，ASP.NET Web 表单已经生产了六年。数以千计的基于 Web 表单的网站正在生产中，每天都有越来越多的网站上线。那么，微软为什么要从头开始做一个新的框架呢？在我们回答这个问题之前，简单回顾一下过去是合适的。

当微软第一次发布 ASP.NET 网络表单时，网络开发并不像今天这样多产。无状态范式很难理解，尤其是对于智能客户端开发人员(例如那些使用 Visual Basic 6、MFC 和 PowerBuilder 开发桌面应用程序的人员)。为了缩小知识差距并使开发人员更容易构建网站，web 窗体启用了许多桌面概念，如状态(通过 viewstate)和预建控件。

计划成功了。Web Forms 通常很受欢迎，许多开发人员转向了 Web 开发人员。基于 web 表单的网站数量持续增长。网络进化了。一个欣欣向荣的第三方生态系统，提供 Web 表单控件(以及许多其他。NET 控件)伴随着 Web 窗体和. NET 的步伐成长起来。

与此同时，开发人员对 Web、HTTP 协议、HMTL 和 JavaScript 编程的无状态性有了更多的了解(并且越来越适应)。这些开发人员对桥接技术的需求越来越少，而对渲染视图的控制越来越多。

随着 Web 表单的每一个新版本，框架中都添加了额外的特性和功能，每一项都增加了应用程序的重量。正在开发的网站越来越复杂，这意味着像 viewstate 这样的项目似乎越来越失去控制。更糟糕的是，在创建 Web 表单时做出的一些早期决策(比如视图状态在呈现页面中的位置)导致了性能下降等问题。这导致了一些高调的“倒戈”。NET 到其他语言，比如 Ruby(使用 Ruby on Rails)。

但是微软不能(也不会明智地)在不牺牲数百万行代码的情况下，从 ASP.NET 核心中移除那些桥接技术和其他代码。必须做点什么，而且重组 Web 表单不是一个选项(尽管正如您在前面章节中了解到的，ASP.NET Web Forms 4.5 做了大量工作来解决一大堆问题)。微软需要做出一些艰难的决定:如何让现有的 web 开发人员(以及伴随 Web 表单成长起来的控件生态系统)保持愉快和高效，同时为那些希望更接近 Web 金属的开发人员提供一个平台。

### 进入 ASP.NET MVC

因此，出于所有这些原因，一个新的框架诞生了。ASP.NET MVC 是作为 ASP.NET Web 表单的替代物而创建的。ASP.NET Web 窗体和 ASP.NET MVC 之间有一些明显的区别，包括:

*   移除:
    *   视图的代码隐藏文件
    *   服务器端控制支持
    *   view state-检视状态
*   添加:
    *   模型绑定
    *   选择途径
    *   Razor 视图引擎(从 MVC 3 开始)

结果是一个轻量级的框架，它建立在渲染速度的基础上，为可测试性和关注点分离而设计，但也需要对 HTML 和 JavaScript 以及 HTTP 的实际工作方式有更深入的了解。因为包括 MVC5 在内的版本仍然构建在同一个内核上。NET 库作为 Web 窗体和 Web API，结合 Web 窗体、MVC 和/或 Web API 成为一种可行的部署模式。每种工具都有优点和缺点，您应该为正确的工作选择正确的工具。

#### 约定胜于配置

ASP.NET MVC 的租户之一是约定胜于配置。这意味着 MVC 项目有特定的约定(如命名约定和目录结构),使得 Visual Studio 和. NET 可以为您完成许多“神奇”的事情。这减少了必要的手动或模板化配置的数量，但也意味着您需要了解这些约定。随着本章的深入，您将会看到几个约定在起作用。

## 构建您的第一个 ASP.NET MVC 应用程序

理论够了。是时候写代码了。Visual Studio 附带了一个用于构建 ASP.NET MVC 应用程序的相当完整的项目模板，您将在构建 CarLotMVC 时充分利用它。

### 新建项目向导

首先启动 Visual Studio，选择文件➤New ➤项目。在左侧栏中，选择 Visual C#下的 Web，选择 ASP.NET Web 应用，将名称改为 CarLotMVC，如图 [34-1](#Fig1) 所示。

![A978-1-4842-1332-2_34_Fig1_HTML.jpg](img/A978-1-4842-1332-2_34_Fig1_HTML.jpg)

图 34-1。

Creating a new ASP.NET web application

如果您一直在阅读前面关于 ASP.NET 的章节，您会注意到这与您开始构建 ASP.NET Web 窗体应用程序的方式是一样的。所有 ASP.NET 应用程序类型(Web Forms、MVC、Web API)都是从新建项目向导中的一个选项开始的，而不是必须选择一个特定的框架。被称为一个 ASP.NET，这种变化是在 2000 年推出的.净 4.5。

在下一个屏幕上，选择 ASP.NET 4.6 模板下的 MVC。请注意，在“添加文件夹和核心引用:”下，MVC 复选框被选中，而其他复选框没有被选中。如果您想创建一个支持 MVC 和 Web 表单的混合应用程序，您也可以选择 Web 表单复选框。对于这个例子，只需选择 MVC app，如图 [34-2](#Fig2) 所示。还要注意“添加单元测试”复选框。如果您选择此选项，将会为您创建另一个项目，它为您的 ASP.NET 应用程序提供了一个基本的单元测试框架。先不要单击 OK，因为您将检查项目的身份验证机制。

![A978-1-4842-1332-2_34_Fig2_HTML.jpg](img/A978-1-4842-1332-2_34_Fig2_HTML.jpg)

图 34-2。

Selecting MVC

点击更改认证按钮，您将看到如图 [34-3](#Fig3) 所示的对话框。保留默认设置为个人用户帐户(默认)，单击确定，然后在选择模板对话框中单击确定。

![A978-1-4842-1332-2_34_Fig3_HTML.jpg](img/A978-1-4842-1332-2_34_Fig3_HTML.jpg)

图 34-3。

Authentication options for the project

表 [34-1](#Tab1) 讨论了 MVC 应用程序可用的四个认证选项。

表 34-1。

Authentication Choices

<colgroup><col> <col></colgroup> 
| [计]选项 | 生命的意义 |
| --- | --- |
| 无认证 | 没有登录机制、成员资格的实体类或成员资格数据库。 |
| 个人用户帐户 | 使用 ASP.NET 身份(以前称为 ASP.NET 成员身份)进行用户身份验证。 |
| 工作和学校账户 | 适用于通过 Active Directory、Azure Active Directory 或 Office 365 进行身份验证的应用程序。 |
| Windows 身份验证 | 使用 Windows 身份验证。适用于内部网网站。 |

Note

由于篇幅限制，我在本书中不涉及认证。有关 MVC 中身份验证的更多信息，请参阅 Adam Freeman 的书 Pro ASP.NET MVC 5。

一旦完成，你会看到很多生成的文件和文件夹，如图 [34-4](#Fig4) 所示。您将在下一节中检查这些内容。

![A978-1-4842-1332-2_34_Fig4_HTML.jpg](img/A978-1-4842-1332-2_34_Fig4_HTML.jpg)

图 34-4。

The generated files and folders for an MVC app

### 基本 MVC 项目的组件

有些文件夹和文件您应该很熟悉，因为它们的名称与 ASP.NET Web 窗体项目可用的文件和文件夹的名称相同。

#### 项目根文件

MVC 项目中的大多数文件都有特定的放置位置。但是，有几个文件位于项目的根目录中，并不是所有的文件都部署在网站上。表 [34-2](#Tab2) 列出了 MVC 站点根目录中的文件以及它们是否被部署。

表 34-2。

Files in the Project Root

<colgroup><col> <col> <col></colgroup> 
| 文件 | 生命的意义 | 部署了吗？ |
| --- | --- | --- |
| `favicon.ico` | 浏览器在页面名称旁边的地址栏中显示的图标。不具备这一点会导致性能问题，因为浏览器会不断地寻找这一点。 | 是 |
| `Global.asax` / `Global.asax.cs` | 应用程序的入口点(如 ASP.NET Web 窗体)。 | 是 |
| `packages.config` | 项目中使用的 NuGet 包的配置信息。 | 是 |
| `Project_Readme.html` | Visual Studio 特定文件，提供有用的链接和其他有关 ASP.MVC 的信息。 | 不 |
| `Startup.cs` | ASP.NET 身份的 OWIN 启动类。 | 是(已编译) |
| `Web.config` | 项目配置文件。 | 是 |

##### Global.asax.cs

文件是你进入 ASP.NET 管道的地方。这些事件与 ASP.NET Web 窗体可用的事件相同。默认的项目模板只使用了`Application_Start`事件处理程序，但是如果您需要的话，还可以加入更多的事件。表 [34-3](#Tab3) 列出了最常用的事件。

表 34-3。

Commonly Used Global.asax.cs Events

<colgroup><col> <col></colgroup> 
| 事件 | 生命的意义 |
| --- | --- |
| `Application_Start` | 首次请求应用程序时引发 |
| `Application_End` | 当应用程序结束时引发 |
| `Application_Error` | 发生未处理的错误时引发 |
| `Session_Start` | 当首次请求新会话时引发 |
| `Session_End` | 当会话结束(或超时)时引发 |
| `Application_BeginRequest` | 向服务器发出请求时引发 |
| `Application_EndRequest` | 当 ASP.NET 响应请求时，作为 HTTP 管道执行链中的最后一个事件引发 |

#### 模型文件夹

这正是它听起来的样子；是放模型类的地方。在较大的应用程序中，应该使用数据访问库来保存数据访问模型。`Models`文件夹最常用于特定于视图的模型，例如由 Visual Studio for ASP.NET 标识生成的模型类。

#### 控制器文件夹

同样，顾名思义，`Controllers`文件夹是应用程序中的控制器所在的位置。我将在本章的后面更详细地介绍控制器。

#### 视图文件夹

`Views`文件夹是存储 MVC 视图的地方(顾名思义)，但是与`Models`和`Controllers`文件夹不同的是，`Views`文件夹中包含的目录结构有一个约定。

在`Views`文件夹的根目录下有一个`Web.config`文件和一个名为`_ViewStart.cshtml`的文件。`Web.config`文件特定于该文件夹层次结构中的视图，定义了基本页面类型(例如`System.Web.Mvc.WebViewPage`)，并且在基于 Razor 的项目中，为 Razor 添加了所有的引用和`using`语句。`_ViewStart.cshtml`文件指定了默认的布局视图，如果没有为一个视图特别指定的话。这将在布局中详细讨论。布局视图类似于 Web 表单中的母版页，我们将在本章后面详细介绍。

Note

为什么`_ViewStart.html`(和`_Layout.cshtml`)的前导下划线？Razor 视图引擎最初是为 WebMatrix 创建的，它允许呈现任何不以下划线开头的文件，因此核心文件(如布局和配置)都有以下划线开头的名称。您还将看到这种命名约定用于局部视图。然而，这并不是 MVC 所关心的约定，因为 MVC 没有 WebMatrix 那样的问题，但是下划线的传统仍然存在。

每个控制器在`Views`文件夹下都有自己的文件夹。这个文件夹结构是 MVC 惯例的一部分；控制器在与控制器同名的文件夹中查找它们的视图(去掉了单词 controller)。例如，`Views/Home`文件夹保存了`HomeController`控制器类的所有视图。

##### 共享文件夹

在`Views`下面有一个特殊的文件夹叫做`Shared`。所有视图都可以访问该文件夹。

#### ASP.NET 文件夹

还有为 ASP.NET 保留的文件夹。默认 MVC 模板中包含的`App_Data`ASP.NET 文件夹就是一个例子。该文件夹是一个特殊的文件夹，用于存储网站所需的任何基于文件的数据。还有用于存储代码、资源和主题的文件夹。右键单击项目，选择添加➤添加新 ASP.NET web 文件夹，从图 [34-5](#Fig5) 所示对话框中选择一个，即可添加 ASP.NET 文件夹。即使启用了文件夹导航，也无法从网站上查看 ASP.NET 文件夹。

![A978-1-4842-1332-2_34_Fig5_HTML.jpg](img/A978-1-4842-1332-2_34_Fig5_HTML.jpg)

图 34-5。

Adding new ASP.NET folders

表 [34-4](#Tab4) 列出了可用的 ASP.NET 网络文件夹。

表 34-4。

ASP.NET Web Folders

<colgroup><col> <col></colgroup> 
| 文件夹 | 生命的意义 |
| --- | --- |
| `App_Code` | 该文件夹中包含的代码文件是动态编译的。 |
| `App_GlobalResources` | 保存可供整个应用程序使用的资源文件。通常用于本地化。 |
| `App_LocalResources` | 包含特定页面可用的资源。通常用于本地化。 |
| `App_Data` | 包含应用程序使用的基于文件的数据。 |
| `App_Browsers` | 存放浏览器功能文件的地方。 |
| `App_Themes` | 保存网站的主题。 |

#### App_Start 文件夹

MVC 的早期版本在`Global.asax.cs`类中包含了所有的站点配置代码(比如路由和安全性)。随着配置量的增长，MVC 团队的开发人员明智地将代码分成不同的类，以更好地遵循单一职责。通过这种重构，`App_Start`文件夹及其包含的类诞生了(详情见表 [34-5](#Tab5) )。`App_Start`文件夹中的任何代码都会被自动编译到网站中。

表 34-5。

Files in App_Start

<colgroup><col> <col></colgroup> 
| 文件 | 生命的意义 |
| --- | --- |
| `BundleConfig.cs` | 为 JavaScript 和 CSS 文件创建文件包。可以(也应该)在这个类中创建额外的包。 |
| `FilterConfig.cs` | 在全局范围内注册操作筛选器(如身份验证或授权)。 |
| `IdentityConfig.cs` | 包含 ASP.NET 身份的支持类。 |
| `RouteConfig.cs` | 配置路由表的类。 |
| `Startup.Auth.cs` | ASP.NET 身份配置的入口点。 |

##### BundleConfig

这个类为 CSS 和 JavaScript 文件设置包。默认情况下，当使用`ScriptBundle`时，所有包含的文件都被捆绑和缩小(见下一节对捆绑和缩小的解释)用于生产，而不是捆绑或缩小用于调试模式。这个可以通过`Web.config`控制，也可以在类本身控制。要关闭捆绑和缩小，请在顶层`Web.config`的`system.web`部分输入以下内容(如果它还不存在的话):

`<system.web>`

`<compilation debug="true" targetFramework="4.6" />`

`</system.web>`

或者在`BundleConfig.cs`的`RegisterBundles`方法中添加`BundleTable.EnableOptimizations = false`，如下:

`public static void RegisterBundles(BundleCollection bundles)`

`{`

`bundles.Add(new ScriptBundle("∼/bundles/jquery").Include("∼/Scripts/jquery-{version}.js"));`

`// Code removed for clarity.`

`BundleTable.EnableOptimizations = false;`

`}`

###### 集束

捆绑是将多个文件合并成一个文件的过程。这样做有几个原因；主要原因是为了加快你的网站。浏览器对从一台服务器上同时下载的文件数量有限制。如果您的站点包含许多小文件(这通常是一个支持关注点分离和单一责任的好主意)，这会降低用户的体验。捆绑和使用内容交付网络(cdn)可以帮助解决这个问题。当然，你需要用智慧来调整你的行为，因为拥有一个巨大的文件可能不会比一百万个小文件更好。

###### 缩小

像捆绑一样，缩小是为了加快网页的加载时间。为了使 CSS 和 JavaScript 文件可读，它们通常用有意义的变量名、函数名、注释和其他格式(至少它们应该是这样)来编写。问题是，通过网络发送的每一位都很重要，尤其是在处理移动客户端时。

缩小是用短名称(有时只有一个字符)替换长名称、删除多余空格以及其他格式的过程。大多数现代框架都附带了两个版本的 CSS 和 JavaScript 文件。Bootstrap 也不例外，在开发应用程序时使用`bootstrap.css`，在生产时使用`bootstrap.min.css`。

##### 对象

过滤器是自定义的类，它提供了一种拦截动作和请求的机制。它们可以应用于动作、控制器或全局级别。MVC 中有四种类型的过滤器，如表 [34-6](#Tab6) 所列。

表 34-6。

Filters in ASP.NET MVC

<colgroup><col> <col></colgroup> 
| 过滤方式 | 生命的意义 |
| --- | --- |
| `Authorization` | 这些实现`IAuthorizationFilter`并在任何其他过滤器之前运行。两个例子是`Authorize`和`AllowAnonymous`。例如，`AccountController`类用`[Authorize]`属性注释，要求用户通过身份验证，而`Login`动作用`[AllowAnonymous]`属性标记，允许任何用户。 |
| `Action` | 实现`IActionFilter`并允许用`OnActionExecuting`和`OnActionExecuted`拦截动作执行。 |
| `Result` | 用`OnResultExecuting`和`OnResultExecuted`执行`IResultFilter`并截取一个动作的结果。 |
| `Exception` | 实现`IExceptionFilter`，如果在 ASP.NET 管道执行过程中出现未处理的异常，则执行。默认情况下，`HandleError`过滤器是在全局级别配置的。该过滤器显示位于`Shared\Error`文件夹中的错误视图页面`Error.cshtml`。 |

##### 身份

`Identity.config.cs`和`Startup.Auth.cs`都用来支持 ASP.NET 身份。身份是一个太大的话题，不能作为本章的一部分来讨论。事实上，人们可以就安全和身份的所有细节写一本书。如前所述，ASP.NET 身份基于 OWIN，将身份与其对 IIS 的依赖分离开来。虽然这种分离对于使用。NET 4.6 框架中，如果您是自托管服务，这在 ASP.NET Web API 中可能是很重要的。

##### 路由配置

ASP.NET Web 窗体的早期版本基于项目的物理文件夹结构定义了网站的 URL。这可以用`HttpModules`和`HttpHandlers`来改变，但是这并不理想。MVC 从一开始就包含了路由，这使您能够设计 URL 来更好地适应您的用户。这将在本章后面更详细地讨论。

#### 内容文件夹

文件夹被设计用来保存你的站点的 CSS 文件。这通常也用于保存图像和其他非编程内容。与这里列出的许多文件夹不同，这个文件夹名称没有依赖性；这只是一个方便的惯例。

ASP.NET MVC 附带了 Bootstrap，这是目前使用的最流行的 HTML、CSS 和 JavaScript 框架之一。两个默认的 CSS 文件(`bootstrap.css`和`bootstrap.min.css`)是 Bootstrap 的一部分，而`site.css`是放置站点特定 CSS 的地方。

#### 引导程序

Bootstrap 是一个开源的 HTML、CSS 和 JavaScript 框架，用于开发响应迅速的移动优先网站。Microsoft 开始在 MVC4 中包含 Bootstrap，并继续在 MVC5 中发布，MVC5 的默认项目模板使用 Bootstrap 来设计搭建页面的样式。虽然在本书中没有足够的空间来深入介绍 Bootstrap，但是您将会在本章中使用 Bootstrap 中的一些特性来为您的站点添加额外的样式。

#### 字体文件夹

Bootstrap 附带了 glyphicon-Halflings 字体集，您将在本章的后面使用它来增强您的应用程序 UI。MVC 项目模板附带的 Bootstrap 版本要求字体位于`Fonts`文件夹中。

#### 脚本文件夹

`Scripts`文件夹是放置 JavaScript 文件的地方。表 [34-7](#Tab7) 列出了默认模板附带的文件及其用途。

表 34-7。

JavaScript Files in the ASP.NET MVC Project Template

<colgroup><col> <col></colgroup> 
| JavaScript 文件 | 生命的意义 |
| --- | --- |
| `_references.js` | `_references.js`文件是用于 Visual Studio IntelliSense 的。您可以在该文件中添加指向自定义 JavaScript 文件的附加引用。 |
| `bootstrap.js` `bootstrap.min.js` | 这些是引导程序的 JavaScript 文件。`.min`文件是预先缩小的版本。 |
| `jquery-1.x.intellisense.js``jquery-1.x.js``jquery-1.x.min.js`T3】 | jQuery 是 web 开发人员的主流 JavaScript 框架。除了 DOM 操作能力之外，还有许多依赖于 jQuery 的框架，包括 MVC 项目模板中使用的验证插件。MVC 项目模板附带了早期版本的 jQuery。在下一节中，您将把它们更新到当前版本。 |
| `jquery.validate-vsdoc.js``jquery.validate.js`T2】 | jQuery Validate 插件使得客户端验证更加简单。`vsdoc`文件是针对 Visual Studio IntelliSense 的，`.min`文件是预缩小版本。 |
| `jquery.validate.unobtrusive.js` `jquery.validate.unobtrusive.min.js` | 不引人注目的 jQuery 验证插件与 jQuery 验证一起工作，利用 HTML5 属性进行客户端验证。 |
| `modernizr-2.x.js` | Modernizr 包含一系列快速测试(Modernizr 的说法是“检测”)来确定浏览器的功能。这直接对浏览器起作用，而不是依赖于可能过期也可能未过期的浏览器 caps 文件。 |
| `respond.js` `respond.min.js` | js 是一个实验性的 jQuery 插件，用于构建包含响应内容的网站。 |

### 将 NuGet 包更新到当前版本

正如您所看到的，有许多文件和包组成了核心 MVC 项目模板，其中许多是开源框架。开源项目更新的速度比微软发布 Visual Studio 更新的速度要快得多。几乎可以保证，一旦您创建了一个新项目，这些包就已经过时了。

幸运的是，更新它们就像运行 NuGet GUI 一样简单。右键单击您的项目，并从上下文菜单中选择 Manage NuGet Packages。一旦加载了 NuGet 包管理，将 Filter 更改为 Installed，这将只显示已安装的包。蓝色箭头向上的包有升级可用，如图 [34-6](#Fig6) 所示。继续更新您的所有软件包。

![A978-1-4842-1332-2_34_Fig6_HTML.jpg](img/A978-1-4842-1332-2_34_Fig6_HTML.jpg)

图 34-6。

Updating NuGet packages

### 测试你的网站

在您进一步阅读本章之前，运行项目并点击查看默认项目模板包含的内容。你会发现已经为你建造了很多。该模板有一个菜单、几个屏幕和登录功能(包括一个注册屏幕)。图 [34-7](#Fig7) 显示首页。

![A978-1-4842-1332-2_34_Fig7_HTML.jpg](img/A978-1-4842-1332-2_34_Fig7_HTML.jpg)

图 34-7。

Default home page

如前所述，Bootstrap 是一个响应式框架，这意味着它能够根据视口调整 UI。缩小你的浏览器尺寸，你会看到主页变得更加移动友好，如图 [34-8](#Fig8) 所示。菜单变成标准的“芝士汉堡”字形，三个“了解更多”部分的水平布局变为垂直布局。

![A978-1-4842-1332-2_34_Fig8_HTML.jpg](img/A978-1-4842-1332-2_34_Fig8_HTML.jpg)

图 34-8。

The responsive view of the home page

## 选择途径

路由是 MVC 将 URL 请求匹配到应用程序中的控制器和动作的方式，而不是旧的 Web 表单将 URL 匹配到文件结构的过程。再次运行 CarLotMVC 项目，注意 URL 基本上是空白的。在我的机器上，URL 是`http://localhost:14264`(在你的机器上，端口号很可能会不同)。现在点击联系人链接，URL 变为`http://localhost:14264/Home/Contact`。检查您的解决方案，没有文件夹路径的`Home/Contact`。这是因为路由表映射了`Home/Contact`的 URL 请求来执行`HomeController.cs`类上的`Contact()`动作方法。(在本章的后面，你会学到更多关于控制器和动作的知识。)

### URL 模式

路由条目由 URL 模式组成，URL 模式由放置在称为路由表的集合中的可变占位符和文字组成，每个条目定义一个不同的 URL 模式进行匹配。变量占位符可以是自定义变量，也可以是预定义变量列表中的变量。例如，`{controller}`和`{action}`指向一个控制器和动作。占位符`{id}`是自定义的，被转换成动作的参数。当根据路由表检查 URL 时，该过程是串行且有序的。它按照条目添加的顺序对照集合中的条目检查 URL。当找到第一个匹配时，该过程停止；如果路由表中稍后出现更好的匹配，也没有关系。这是添加路由表条目时需要牢记的一个重要考虑事项。

打开`RouteConfig.cs`(位于`App_Start`文件夹中)并检查内容，如下所示:

`public class RouteConfig`

`{`

`public static void RegisterRoutes(RouteCollection routes)`

`{`

`routes.IgnoreRoute("{resource}.axd/{*pathInfo}");`

`routes.MapRoute(`

`name: "Default",`

`url: "{controller}/{action}/{id}",`

`defaults: new { controller = "Home", action = "Index", id = UrlParameter.Optional }`

`);`

`}`

`}`

第一行命令路由引擎忽略扩展名为`.axd`的请求，扩展名为`HttpHandler`。`IgnoreRoute()`方法将请求传递回 web 服务器，在本例中是 IIS。`{*pathinfo}`模式处理可变数量的参数，将匹配扩展到任何包含`HttpHandler`的 URL。

`MapRoute()`方法向路由表中添加一个新条目。该调用为 URL 模式中的变量指定名称、URL 模式和默认值。前面例子中的 URL 模式与前面讨论的相同，在指定的控制器上调用指定的动作，并将`{id}`条目作为参数传递给动作方法。这个路由提供服务的一个例子是`Inventory/Add/5`。这调用了`InventoryController`上的`Add()`动作方法，将 5 传递给`id`参数。

缺省值指定如何填充部分 URL 的空格。在前面的代码中，如果 URL 中没有指定任何内容(例如`http://localhost:14264`，那么路由引擎将调用`HomeController`类的`Index()`操作方法，而不使用任何`id`参数。缺省值是渐进的，这意味着它们可以从右到左被排除。输入一个像`http://localhost14264/Add/5`这样的网址将无法通过`{controller}/{action}/{id}`模式。

### 为联系人和“关于”页面创建路线

当然，当你的站点被部署时，URL 不会是`localhost:14264`，而是像`http://skimedic.com`这样有意义的东西。路由的优势之一是能够根据用户的利益来设计 URL。这意味着创建易于记忆和在搜索引擎上找到的 URL。例如，不要用[`http://skimedic.com/Home/Contact`](http://skimedic.com/Home/Contact)[`http://skimedic.com/Home/About`](http://skimedic.com/Home/About)，最好还能用[`http://skimedic.com/Contact`](http://skimedic.com/Contact)[`http://skimedic.com/About`](http://skimedic.com/About)来达到它们(当然不会失去较长的映射)。有了路由，这很容易实现。

打开`RouteConfig.cs`，在`IgnoreRoutes`调用之后和默认路由之前添加以下代码行:

`routes.MapRoute("Contact", "Contact", new { controller = "Home", action = "Contact" });`

这一行在路由表中添加了一个名为`Contact`的新条目，该条目只包含一个文字值`Contact`。它映射到`Home/Contact`，不是作为默认值，而是作为硬编码值。要测试这一点，运行应用程序，并点击联系链接。URL 变为`http://localhost:14264/Contact`，这正是您想要的——一个便于客户记忆的 URL。

现在将网址更新为`http://localhost:14264/Home/Contact/Foo`。还能用！这是因为 URL 与路由表中的第一个条目不匹配，而是与第二个条目匹配。现在将浏览器中的 URL 更新为`http://localhost:14264/Home/Contact/Foo/Bar`。这一次它失败了，因为它不匹配任何路由。通过在图案中添加`{*pathinfo}`来解决这个问题。这允许任意数量的附加 URL 参数。将`Contact`路线条目更新如下:

`routes.MapRoute("Contact", "Contact/{*pathinfo}", new { controller = "Home", action = "Contact" });`

现在当你输入网址`http://localhost:14264/Home/Contact/Foo/Bar`时，仍然显示联系页面。任务完成。对于你的用户来说，这是一个容易记住的 URL，即使他们在末尾添加了一堆额外的垃圾，把它搞砸了，他们仍然可以找到你的页面。

为了完成这个练习，在`Contact`条目之后添加下面一行，为 About 页面创建一条路线:

`routes.MapRoute("About", "About/{*pathinfo}", new { controller = "Home", action = "About" });`

### 使用路由重定向用户

路由的另一个优点是你不再需要为你站点中的其他页面硬编码 URL。路由条目是双向使用的，不仅用于匹配传入的请求，还用于为您的站点构建 URL。例如，打开`Views/Shared`文件夹中的`_Layout.cshtml`文件。注意这一行(现在不要担心语法；你很快就会知道):

`@Html.ActionLink("Contact", "Contact", "Home")`

HTML 助手为`Home`控制器中的`Contact`动作创建一个带有显示文本联系人的超链接。就像传入的请求一样，路由引擎从顶部开始向下工作，直到找到匹配项。该行与您在本章前面添加的`Contact`路线相匹配，用于创建以下链接:

`<a href="/Contact">Contact</a>`

如果您没有添加联系路由，路由引擎将被创建为:

`<a href="/Home/Contact">Contact</a>`

Note

本节介绍了几个我还没有涉及到的新项目，比如`@`语法、`Html`对象和`_Layout.cshtml`文件。这些很快就会被涵盖。主要的要点是，路由表不仅用于解析传入的请求并将它们发送到适当的资源进行处理，还用于根据指定的资源创建 URL。

## 添加自动标记

应用程序需要数据，CarLotMVC 也不例外。首先将第 31 章的[中的 AutoLotDAL 项目及其所有文件复制到`CarLotMVC`文件夹中(与 CarLotMVC 解决方案文件在同一层)。也可以从下载源的](31.html) [`Chapter 34`](34.html) 子文件夹中复制项目。您将从您在 [`Chapter 31`](31.html) 中构建的库更新数据访问库，所以您不能只引用 DLL。

通过右键单击 CarLotMVC 解决方案，选择 Add ➤现有项目，导航到`AutoLotDAL`文件夹，并选择`AutoLotDAL.csproj`，将项目添加到您的解决方案中。通过右键单击 CarLotMVC 项目并从上下文菜单中选择“添加➤引用”来添加对 AutoLotDAL 的引用。在“引用管理器”对话框中，选择左侧栏中的“项目➤解决方案”，选中“AutoLotDAL”旁边的框(如图 [34-9](#Fig9) 所示)，然后单击“确定”。

![A978-1-4842-1332-2_34_Fig9_HTML.jpg](img/A978-1-4842-1332-2_34_Fig9_HTML.jpg)

图 34-9。

Adding the project reference for AutoLotDAL

下一步是将 AutoLot 数据库的连接字符串添加到 CarLotMVC `Web.config`文件中。由于 ASP.NET 身份使用实体框架(EF ),您不需要像构建 Web 表单站点时那样安装 EF 包。您只需要添加另一个连接字符串。打开`Web.config`文件并定位`<connectionStrings>`元素。从 AutoLotDAL 项目的`App.config`文件中复制`AutoLotConnection`值，或者手动添加`AutoLotConnection`值，如下所示(根据您安装 SQL Server Express 的方式，您的值可能与此处所示略有不同):

`<connectionStrings>`

`<!-- default connection omitted for brevity -->`

`<add name="AutoLotConnection" connectionString="data source=localhost\SQLEXPRESS2014;initial catalog=AutoLot;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework" providerName="System.Data.SqlClient" />`

`</connectionStrings>`

Note

您可能已经注意到，ASP.NET 身份使用 LocalDb(SQL Server 的一个轻量级版本，不需要管理)作为数据源，您当然可以将 local db 用于 ASP.NET MVC 项目(许多开发人员都这样做)。由于本书使用了自[第 21 章](21.html)以来所有数据驱动示例的相同数据库，我决定创建一个 SQL Express 数据库，而不是使用 LocalDb。你会如何建立这个网站有什么不同吗？不，不是的。最终结果是一样的，我想把重点放在 C#上，并保持 SQL Server 方面的简单和不引人注目。

## 控制器和动作

如前所述，当请求来自浏览器时，它(通常)被映射到特定控制器类的动作方法。虽然这听起来很奇特，但却非常简单。控制器是从两个抽象类`Controller`或`AsyncController`继承而来的类。注意，你也可以通过实现`IController`从头开始创建一个控制器，但是这超出了本书的范围。动作方法是控制器类的方法。

### 添加库存控制器

理解这一点的最好方法是使用 Visual Studio 中的内置帮助器添加一个带有动作的新控制器。右键单击项目中的`Controllers`文件夹，选择添加➤控制器，如图 [34-10](#Fig10) 所示。

![A978-1-4842-1332-2_34_Fig10_HTML.jpg](img/A978-1-4842-1332-2_34_Fig10_HTML.jpg)

图 34-10。

Launching the Add Scaffold dialog for a new controller

这将弹出添加脚手架对话框，如图 [34-11](#Fig11) 所示。有几个选项可用，你想选择“带有视图的 MVC5 控制器，使用实体框架。”

![A978-1-4842-1332-2_34_Fig11_HTML.jpg](img/A978-1-4842-1332-2_34_Fig11_HTML.jpg)

图 34-11。

The Add Scaffold dialog

这将弹出一个额外的对话框(如图 [34-12](#Fig12) 所示),允许您指定控制器的类型和动作方法。第一个问题是指定模型类，它决定控制器和动作方法的类型。从下拉列表中选择`Inventory`类别。下一个问题要求您指定上下文类。如果您没有选择，向导将为您创建一个。对于数据上下文，选择`AutoLotEntities`。接下来的选择是使用`async`的行动方法。选择最符合您的项目需求的选项。对于本例，选择“使用异步控制器操作”复选框。“生成视图”选项(默认情况下打开)指示向导为每个操作方法创建一个相关视图。“引用脚本库”选项指示包含 jQuery 验证的呈现。“使用布局页面”选项将在本章后面讨论。选中这三个选项(生成视图、引用脚本库和使用布局页面)，并将名称改为`InventoryController`(来自`InventoriesController`)。

![A978-1-4842-1332-2_34_Fig12_HTML.jpg](img/A978-1-4842-1332-2_34_Fig12_HTML.jpg)

图 34-12。

Selecting the model, context, and other options Note

Visual Studio 中有很多 MVC 工具助手。您刚刚看到了如何调用 New Controller 向导，该向导使用 scaffolding 来创建控制器和一系列视图(基于您在向导中的回答)。如果右键单击 Views 文件夹，会出现一个菜单项来添加一个新视图，并且 new view 向导会调用视图支架。如果您右键单击一个动作，您可以添加一个新视图(它将被放置在与该动作同名的`Views/Controller`文件夹中)，或者您可以导航到适当的视图。所有这些特征都取决于前面讨论的约定，所以如果你遵守规则，生活会很好！

这对你有几个好处。首先，它在`Controllers`文件夹中创建了一个`InventoryController`类。它还在`Views`文件夹中创建了一个`Inventory`文件夹，并在该文件夹下添加了五个视图。我们现在将详细研究其中的每一项。

### 检查脚手架视图

要在不破坏 URL 的情况下访问新视图，您需要为它们创建一个菜单项。打开`_Layout.cshtml`(在`Views/Shared`下)，定位包含`@Html.ActionLink(" Home", "Index","Home")`的线。复制这一行，粘贴在下面。将该行更新为以下内容:

`<li>@Html.ActionLink("Inventory", "Index", "Inventory")</li>`

在运行程序之前，您需要更改项目的启动设置。在解决方案资源管理器中选择 CarLotMVC 项目，右击并选择 Properties。在左侧栏中导航到 Web，在开始操作下选择“特定页面”(将值留空)，如图 [34-13](#Fig13) 所示。这将导致 Visual Studio 在根位置启动您的站点(例如，`http://localhost:14264`)。

![A978-1-4842-1332-2_34_Fig13_HTML.jpg](img/A978-1-4842-1332-2_34_Fig13_HTML.jpg)

图 34-13。

Updating the Web start action

现在运行程序，单击库存链接，并尝试查看、编辑、创建和删除汽车。这些视图不会赢得任何设计奖项，但它们很实用。您将在下一节中升级 UI，但是现在，让我们更详细地检查控制器和动作。

### MVC 控制器

打开`InventoryController.cs`类。请注意，它遵循以单词 Controller 结尾的惯例。它也源自抽象类`Controller`。有一系列的方法(动作)如`Index()`、`Edit()`等等。您将依次检查每一个，以及修饰它们的属性。最后，有一个`Dispose()`覆盖，您可以使用它来强制垃圾收集控制器使用的任何昂贵的资源。

#### 行动结果

动作通常返回一个`ActionResult`(或者对于`async`操作返回一个`Task<ActionResult>`)。从`ActionResult`衍生出几种类型，表 [34-8](#Tab8) 中列出了一些比较常见的类型。

表 34-8。

Typical ActionResult-Derived Classes

<colgroup><col> <col></colgroup> 
| 行动结果 | 生命的意义 |
| --- | --- |
| `ViewResult` `PartialViewResult` | 以网页形式返回视图(或局部视图) |
| `RedirectResult` `RedirectToRouteResult` | 重定向到另一个操作 |
| `JsonResult` | 向客户端返回序列化的 JSON 结果 |
| `FileResult` | 向客户端返回二进制文件内容 |
| `ContentResult` | 向客户端返回用户定义的内容类型 |
| `HttpStatusCodeResult` | 返回特定的 HTTP 状态代码 |

#### 使用库存存储库

`InventoryController`类中的第一行创建了一个新的`AutoLotEntities`实例，这正是您告诉向导要使用的。你需要修改这个来使用`InventoryRepo`类。在类的顶部添加一个`InventoryRepo`实例变量，如下所示:

`private readonly InventoryRepo _repo = new InventoryRepo();`

接下来，在 Dispose override 中处置实例:

`protected override void Dispose(bool disposing)`

`{`

`if (disposing)`

`{`

`db.Dispose();`

`_repo.Dispose();`

`}`

`base.Dispose(disposing);`

`}`

#### 索引操作

`Index`动作获取所有的`Inventory`记录并将数据返回给视图(下一节将详细介绍视图)。更新调用以使用`InventoryRepo class`，而不是直接调用`AutoLotEntities`类。

`public async Task<ActionResult> Index()`

`{`

`return View(await _repo.GetAllAsync());`

`}`

前面代码片段中的`View()`调用是`Controller`基类中的一个重载方法，并返回一个新的`ViewResult`。当没有传入一个视图名称时(如您刚才看到的版本)，约定规定视图将以动作方法命名，并位于以控制器命名的文件夹中，在本例中是`Views/Inventory/Index.cshtml`。您还可以更改视图的名称，并将新名称传递给`View()`方法。例如，如果您将您的视图命名为`Foo.cshtml`，您将如下调用`View()`方法:

`return View("Foo",await _repo.GetAllAsync());`

#### 详细信息操作

`Details()`动作方法返回一条`Inventory`记录的所有细节。格式为 [`http://mysite.com/Inventory/Details/5`](http://mysite.com/Inventory/Details/5) 的 URL 将被映射到`InventoryController`、`Details()`动作方法，参数名为`id`，值为 5。更新这个方法来调用`_repo.GetOneAsync(id)`而不是直接调用`AutoLotEntities`，就像这样:

`// GET: Inventory/Details/5`

`public async Task<ActionResult> Details(int? id)`

`{`

`if (id == null)`

`{`

`return new HttpStatusCodeResult(HttpStatusCode.BadRequest);`

`}`

`var inventory = await _repo.GetOneAsync(id);`

`if (inventory == null)`

`{`

`return HttpNotFound();`

`}`

`return View(inventory);`

`}`

在这个看起来简单的方法中有几个有趣的项目。请记住，在路由讨论中，`id`参数是可选的，因此 URL `/Inventory/Details`将正确地映射到这个方法。然而，如果没有一个`id`值传入该方法，您就不能获得一个`Inventory`记录，因此该方法返回一个 HttpStatusCode 400(错误的请求)。运行应用程序并输入`Inventory/Details`(去掉 URL 的`id`部分)，你应该会看到一个类似于图 [34-14](#Fig14) 的错误屏幕。

![A978-1-4842-1332-2_34_Fig14_HTML.jpg](img/A978-1-4842-1332-2_34_Fig14_HTML.jpg)

图 34-14。

Returning the HttpStatusCode (Bad Request)

同样，如果找不到库存记录，action 方法将返回 HttpNotFound (404)状态代码。

最后，如果 URL 的格式一切正常，并且找到了一个`Inventory`记录，那么将把`Views/Inventory/Details.cshtml`页面返回给客户端。

#### 创建操作

接下来考察`Create()`动作方法，你会看到两个`Create()`方法；一个不带参数，第二个带一个`Inventory`对象作为参数。

##### http get(http get)

没有任何参数的`Create()`方法处理一个 Http `Get`请求，不调用数据库(这是有意义的，因为用户不是创建一个新记录，而是检索一个记录)，并返回`∼/Views/Inventory/Create.cshtml`视图。

`// GET: Inventory/Create`

`public ActionResult Create()`

`{`

`return View();`

`}`

先不要担心视图细节；我很快会谈到这一点。

##### http post(http post)

将`Inventory`对象作为其参数(使用隐式模型绑定实例化)的`Create()`重载有两个方法级属性`[HttpPost]`和`[ValidateAntiForgeryToken]`，以及一个参数级属性`[Bind]`。当用户单击创建表单的 submit 按钮时，就会执行这个版本(假设所有客户端验证都已通过)。

###### 模型绑定

作为对第 32 章的复习，模型绑定接受所有的形式、查询字符串等等，名称-值对，并试图使用反射来重构一个指定的类型。有显式模型绑定和隐式模型绑定。在每种情况下，模型绑定引擎都会尝试将值(来自提交的表单值中的名称-值对)分配给所需类型的匹配属性。如果它不能分配一个或多个值(例如，由于数据类型转换问题或验证错误)，它将设置`ModelState.IsValid = false`。如果所有匹配的属性都被成功分配，它设置`ModelState.IsValid = true`。除了`IsValid`属性之外，`ModelState`是一个`ModelStateDictionary`，包含每个失败属性的错误信息，以及模型级别的错误信息。如果要为属性添加特定的错误，可以编写如下代码:

`ModelState.AddModelError("Name","Name is required");`

如果您想为整个模型添加一个错误，使用`string.Empty`作为属性名，如下所示:

`ModelState.AddModelError(string.Empty, $"Unable to create record: {ex.Message}");`

对于显式模型绑定，调用`TryUpdateModel()`，传入该类型的一个实例。如果模型绑定失败，`TryUpdateModel()`调用返回`false`。例如，您可以这样编写`Create()`方法:

`public async Task<ActionResult> Create()`

`{`

`var inv = new Inventory();`

`if (TryUpdateModel(inv))`

`{`

`//Save the data`

`}`

`}`

对于隐式模型绑定，使用所需的类型作为方法的参数。模型绑定引擎对该参数执行与前一示例中对`TryUpdateModel()`相同的操作。

`public async Task<ActionResult> Create(Inventory inventory)`

`{`

`if (ModelState.IsValid)`

`{`

`//Save the data;`

`}`

`}`

###### HttpPost 与 HttpGet

虽然 ASP.NET Web 表单很大程度上忽略了`HttpGet`和`HttpPost`之间的区别，但是 MVC 恰当地使用了 HTTP 动词。超文本传输协议(HTTP)将`HttpGet`调用定义为从服务器请求数据，将`HttpPost`调用定义为将待处理的数据提交给特定资源。

在 MVC 中，任何没有 HTTP 属性的动作(比如`HttpPost`)都会作为`HttpGet`操作执行。要指定一个`HttpPost`(数据将被提交并可能被更新的动作)，您必须用`[HttpPost]`属性来修饰您的动作。

###### 防伪代币

对抗黑客的众多武器之一，`AntiForgeryToken`是添加到你的视图中的表单值。当一个`HttpPost`请求进来时，只要`[ValidateAntiForgeryToken]`属性存在，令牌就会被验证。虽然不是安全的一站式商店(web 安全超出了本书的范围)，但是每个表单都应该添加一个`AntiForgeryToken`，每个`HttpPost`动作都应该验证它。

###### 绑定属性

`Create()`和`Edit()`动作方法中的`Bind`属性允许你将属性列入白名单或黑名单或添加前缀(本章不涉及)。当字段被列为白名单时，它们是通过模型绑定分配的唯一字段，有助于保护您的数据免受用户过量发布数据的影响。黑名单从模型绑定中排除属性。在`Create()`方法中，所有的字段都是白色列表，但是您只想要提交`Make`、`Color`和`PetName`。从`Include`部分移除`CarId`和`Timestamp`字段，如下所示:

`public async Task<ActionResult> Create([Bind(Include = "Make,Color,PetName”)] Inventory inventory)`

###### 现在代码…

如果模型状态无效，该方法会将带有当前数据的`Create`视图发送回用户，给用户一个纠正任何错误数据的机会。如果模型状态确实有效，并且存储库成功保存了值，那么动作方法返回一个`RedirectToAction`，它将用户重定向到库存控制器的`Index`动作方法。成功保存后重定向到`Index`视图可以防止用户再次单击 Create 按钮，这将导致双重 post。如果在保存过程中出现错误，一个新的`ModelError`将被添加到`ModelState`，用户将返回到创建页面重试。注意:我喜欢翻转最初的`if`语句，使方法更具可读性。最后的改变是使用回购的`AddAsync()`方法。更新后的代码应该如下所示:

`[HttpPost][ValidateAntiForgeryToken]`

`public async Task<ActionResult> Create([Bind(Include = " Make,Color,PetName")] Inventory inventory)`

`{`

`if (!ModelState.IsValid) { return View(inventory); }`

`try`

`{`

`await _repo.AddAsync(inventory);`

`return RedirectToAction("Index");`

`}`

`catch (Exception ex)`

`{`

`ModelState.AddModelError(string.Empty, $"Unable to create record: {ex.Message}");`

`return View(inventory);`

`}`

`}`

#### 编辑操作

就像`Create()`动作方法一样，`Edit()`动作方法有两个方法:一个处理`HttpGet`请求，另一个处理`HttpPost`请求。

##### http get(http get)

第一个`Edit()`方法采用一个`id`，并且与`Details() HttpGet`方法相同。确保将方法改为使用库存库，而不是`AutoLotEntities`。

`public async Task<ActionResult> Edit(int? id)`

`{`

`if (id == null)`

`{`

`return new HttpStatusCodeResult(HttpStatusCode.BadRequest);`

`}`

`Inventory inventory = await _repo.GetOneAsync(id);`

`if (inventory == null)`

`{`

`return HttpNotFound();`

`}`

`return View(inventory);`

`}`

##### http post(http post)

就像`Create()`动作方法一样，这个版本在用户点击编辑表单的提交按钮时执行(假设所有客户端验证都通过)。如果模型状态无效，该方法再次返回编辑视图，发送`Inventory`对象的当前值。如果模型状态有效，那么`Inventory`对象将被发送到存储库进行保存。除了一般的错误处理(就像您在`Create()`方法中使用的那样)，您还需要添加一个对`DbUpdateConcurrencyException`的检查，这将发生在另一个用户已经更新了记录的情况下，因为该用户最初将它加载到了 web 页面中。如果全部成功，action 方法返回一个`RedirectToAction`结果，将用户发送到`InventoryController`的`Index()` action 方法。

因为所有的值都需要来自表单，所以`Bind`属性可以保持不变，但是要将方法改为使用 repo 的`AddAsync()`方法，如下所示:

`[HttpPost][ValidateAntiForgeryToken]`

`public async Task<ActionResult> Edit(`

`[Bind(Include = "CarId,Make,Color,PetName,Timestamp")] Inventory inventory)`

`{`

`if (!ModelState.IsValid) { return View(inventory); }`

`try`

`{`

`await _repo.SaveAsync(inventory);`

`return RedirectToAction("Index");`

`}`

`catch (DbUpdateConcurrencyException)`

`{`

`ModelState.AddModelError(string.Empty, "Unable to save record. Another user updated the record.");`

`}`

`catch (Exception ex)`

`{`

`ModelState.AddModelError(string.Empty, $"Unable to save record: {ex.Message}");`

`}`

`return View(inventory);`

`}`

Note

正如你在 [`Chapter 23`](23.html) 中看到的，`DbUpdateConcurrencyException`给你这个开发者提供了很多信息。由于篇幅的限制，本章将不演示如何利用这种能力。

#### 删除操作

`Delete()`动作方法也有两个方法:一个处理`HttpGet`请求，另一个处理`HttpPost`请求。

##### http get(http get)

第一个`Delete()`方法采用一个`id`，与`Details()`和`Edit() HttpGet`方法相同。确保将`HttpGet`版本改为使用库存库而不是`AutoLotEntities`。

`public async Task<ActionResult> Delete(int? id)`

`{`

`if (id == null)`

`{`

`return new HttpStatusCodeResult(HttpStatusCode.BadRequest);`

`}`

`Inventory inventory = await _repo.GetOneAsync(id);`

`if (inventory == null)`

`{`

`return HttpNotFound();`

`}`

`return View(inventory);`

`}`

##### http post(http post)

当用户点击删除表单的提交按钮时，这个版本被执行。该方法的自动生成版本仅将`id`作为参数，这意味着它与该方法的`HttpGet`版本具有相同的签名。由于不能有两个同名的方法具有相同的签名，向导将这个方法命名为`DeleteConfirmed()`并添加了`[ActionName("Delete")]`属性。`AutoLotDAL`检查并发冲突，除了汽车`Id in order to delete a record`之外还需要`Timestamp`属性。您还希望一个`Inventory`实例显示任何模型错误。为了满足这些需求，只需将`int id`参数更改为`Inventory inventory`。这一更改将使用隐式模型绑定从请求中获取库存记录值。

要删除一条记录，只需要`CarId`和`Timestamp`属性。添加一个包含值为“CarId，Timestamp”的`[Bind]`属性，将这些值提取到`Inventory`实例中，并忽略其余的值。既然方法签名已经从 HttpGet 版本改变了，您可以重命名方法`Delete()`并删除`ActionName`属性。最后，更新方法以使用库存存储库的`DeleteAsync()`方法，并添加错误处理(与您对`Edit()`方法的`HttpPost`版本所做的一样)。代码的最终版本如下:

`[HttpPost]`

`[ValidateAntiForgeryToken]`

`public async Task<ActionResult> Delete([Bind(Include="CarId,Timestamp")]Inventory inventory)`

`{`

`try`

`{`

`await _repo.DeleteAsync(inventory);`

`return RedirectToAction("Index");`

`}`

`catch (DbUpdateConcurrencyException)`

`{`

`ModelState.AddModelError(string.Empty, "Unable to delete record. Another user updated the record.");`

`}`

`catch (Exception ex)`

`{`

`ModelState.AddModelError(string.Empty, $"Unable to create record: {ex.Message}");`

`}`

`return View(inventory);`

`}`

如果您现在运行您的项目并试图删除一个`Inventory`记录，它不会工作，因为视图不发送时间戳属性，只发送 CarId。你很快就会解决这个问题。

#### 该处理方法

最后，在`Dispose()`方法中，删除`AutoLotEntities`变量(`db`)的处置，然后删除`AutoLotEntities`的类级变量。清理后的 Dispose()方法应该如下所示:

`protected override void Dispose(bool disposing)`

`{`

`if (disposing)`

`{`

`_repo.Dispose();`

`}`

`base.Dispose(disposing);`

`}`

#### 控制器的最后一句话

这需要涵盖很多信息，而且(像路由一样)我们只是触及了你在 MVC 控制器和动作方法中所能做的一切的表面。然而，总的来说，控制器仅仅是 C#类。它们应该遵循`<Name>Controller.cs`命名约定(名称的`Controller`部分被框架去掉)。动作是控制器类中返回`ActionResult`的方法。动作方法可以用一个属性来修饰，该属性表明它是一个`HttpPost`还是一个`HttpGet`(默认)，并且所有的`HttpPost`方法都应该验证`AntiForgery`标记。现在，让我们转到视图。

## MVC 视图

MVC 中的视图代表了 MVC 站点中的用户界面。最初，MVC 视图是使用 Web 表单视图引擎构建的。现在，您可以选择使用 Razor 视图引擎或 Web 表单视图引擎，尽管大多数 MVC 站点都是使用 Razor 构建的。MVC 视图是非常轻量级的，将服务器端的处理传递给控制器，将客户端的处理传递给 JavaScript。

### Razor 视图引擎

Razor 视图引擎是对 Web 表单视图引擎的改进，它使用 Razor 作为核心语言。Razor 是在服务器端被解释成 C#(或 VB.NET 代码)的模板标记语法。在带有 HTML 和 CSS 的视图中使用 Razor 会产生更干净、更易读的标记。虽然在视图中使用 Razor 有很多改进，但是基于 Razor 的视图仍然支持 web 表单的所有功能。

#### Razor 语法

Web 表单视图引擎和 Razor 视图引擎的第一个区别是您添加了带有`@`符号的代码。Razor 还有内置的智能，不像 Web 表单需要打开和关闭“金块”()，它不需要添加关闭的@符号。

语句块以@开头，用大括号括起来，就像这样(注意没有@用作语句结束符):

`@foreach (var item in Model)`

`{`

`}`

代码块可以混合标记和代码。以标记开始的行被解释为 HTML，而以代码开始的行被解释为代码，如下所示:

`@foreach (var item in Model)`

`{`

`int x = 0;`

`<tr></tr>`

`}`

行也可以混合标记和代码，就像这样:

`<h1>Hello, @username</h1>`

`<text>`标签表示应该作为标记的一部分呈现的文本，如下所示:

`@item<text>-<text>`

变量前面的`@`符号等同于`Response.Write()`，默认情况下 HTML 对所有值进行编码。如果你想输出未编码的数据(即潜在的不安全数据)，你必须使用`@Html.Raw(username)`语法。

#### 助手、函数和委托

Razor 支持代码封装，以提高您的生产力并减少重复代码的数量。您可以将这些内容内嵌在`App_Code`文件夹中，或者作为静态内容。

##### HTML 助手

Razor HTML 帮助器呈现标记。有许多您将广泛使用的内置助手，例如您之前用于清单屏幕的`@Html.ActionLink()`。您还可以构建自己的 HTML 助手来减少(或消除)重复代码。例如，您可以编写一个助手来输出一个`Inventory`记录的详细信息。为此，将下面的 HTML 帮助器代码放在`Index.cshtml`视图文件的顶部(在`@model`行之后)，就像这样:

`@using AutoLotDAL.Models`

`@helper ShowInventory(Inventory item)`

`{`

`@item.Make<text>-</text>@item.Color<text>(</text>@item.PetName<text>)</text>`

`}`

在`@foreach`之后，添加一个对`ShowInventory()`的调用，像这样:

`@foreach (var item in Model)`

`{`

`@ShowInventory(item)`

`<!-- rest removed for brevity -->`

`}`

运行应用程序，导航到`Inventory`索引页面，您将看到每条记录的详细信息，显示为一个单独的字符串。在一个真正的 HTML 助手中，你可以添加格式和标记来与你的站点的外观保持一致。因为这只是一个如何创建 HTML 助手的例子，而不是你想在你的站点中使用的东西，所以用 Razor 注释注释掉这一行，它们是`@* … *@`，像这样:

`@*@ShowInventory(item)*@`

##### 剃刀功能

Razor 函数不返回标记，而是用于封装代码以供重用。要看到这一点，在`Index.cshtml`视图页面中的 HTML helper 之后添加下面的`SortCars()`函数。该函数获取一个`Inventory`项目列表，并按`PetName`对其进行排序:

`@functions`

`{`

`public IList<Inventory> SortCars(IList<Inventory> cars)`

`{`

`var list = from s in cars orderby s.PetName select s;`

`return list.ToList();`

`}`

`}`

更新`@foreach`以调用该功能。`Model`变量代表一个`IEnumerable<Inventory>`，因此您必须在该调用中添加`ToList()`方法，如下所示:

`@foreach (var item in SortCars(Model.ToList()))`

`{`

`<!-- rest removed for brevity -->`

`}`

##### 剃刀代表

最后一个例子展示了 Razor 委托，它的工作方式就像 C#委托一样。例如，在`Index.cshtml`视图文件中的`SortCars()`函数之后立即添加以下委托代码。此委托将标记的字符加粗。

`@{`

`Func<dynamic, object> b = @<strong>@item</strong>;`

`}`

若要查看实际效果，请在定义委托的代码块之后立即添加以下代码行:

`This will be bold: @b("Foo")`

当然，这个例子是琐碎的，但是更复杂的重复代码可以通过包装在委托中而受益。本质上，所有相同的 C#委托的利弊都适用。运行应用程序并导航到`Inventory`索引页面后，您会看到粗体字 Foo。继续注释掉对代表的调用，因为其余部分或示例不需要它。

#### 剃刀的最后一句话

再一次，你必须转移到一个新的主题，因为这本书没有足够的空间来详细说明你可以用 Razor 做的一切。在本章的剩余部分，你会看到更多关于 Razor 的例子。这一部分给了你扩展知识所需的基础。

### 布局

与 Web 窗体母版页类似，MVC 支持布局。MVC 视图可以基于主布局，给站点一个通用的外观和感觉。回想一下图 [34-12](#Fig12) ，有一个复选框写着“使用布局页面”如果在`_ViewStart.cshtml`文件中有指定，将文本框留空。同样回想一下，从`Views`文件夹中的信息来看，有一个名为`_ViewStart.cshtml`的文件。现在打开此文件检查内容，如下所示:

`@{`

`Layout = "∼/Views/Shared/_Layout.cshtml";`

`}`

这个文件只有一个 Razor 代码块，它将布局设置为一个特定的文件。这是回退值；如果视图中未指定布局，这是视图默认使用的文件。

导航到`Views/Shared`文件夹并打开`_Layout.cshtml`文件。这是一个成熟的 HTML 文件，有`<head>`和`<body>`标签，混合了 HTML 标记和 Razor HTML 助手。就像 Web 表单母版页一样，`_Layout.cshtml`页面是视图(使用`_Layout.cshtml`页面)呈现给用户的核心。

使用布局时要记住两个关键点:正文和节。当视图和布局组合在一起时，视图代码将插入到主体中。视图页面内容在布局中的位置由下面一行 Razor 代码控制:

`@RenderBody()`

区域是布局在运行时可以填充的布局页面区域。它们可以是必需的或可选的，并通过`RenderSection()`引入布局页面。第一个参数命名该节，第二个参数指示视图是否需要实现该节。在`_Layout.cshtml`中，下面一行代码创建了一个名为`scripts`的部分，对于视图来说是可选的:

`@RenderSection("scripts", required: false)`

通过将`true`作为第二个参数传入，也可以根据需要标记截面。例如，如果您想要创建一个名为`Header`的新的必需部分，您应该像这样编码:

`@RenderSection("Header",required: true)`

要从您的视图中渲染一个部分，您可以使用`@section`剃刀块。例如，在`Views/Inventory`下的`Edit.cshtml`页面中，下面几行代码将 jQuery 验证包添加到呈现的页面中:

`@section Scripts {`

`@Scripts.Render("∼/bundles/jqueryval")`

`}`

#### 使用特定的布局页面

除了依赖默认布局页面之外，您还可以指定您的视图来使用特定的页面。为了展示这一点，将`_Layout.cshtml`复制到一个名为`_LayoutNew.cshtml`的新文件中。打开这个新文件，在`<body>`标签后添加下面一行:

`<div class="jumbotron">`

`<h1>My MVC Application</h1>`

`</div>`

现在，打开`Views/Inventory`下的`Index.cshml`，加上`Layout="∼/Views/Shared/_LayoutNew.cshtml"`，就在`ViewBag`线后面。更新后的代码块应该如下所示:

`@{`

`ViewBag.Title = "Index";`

`Layout = "∼/Views/Shared/_LayoutNew.cshtml";`

`}`

该行指示视图使用新文件作为布局文件。运行应用程序，点击库存菜单，您将看到如图 [34-15](#Fig15) 所示的屏幕。

![A978-1-4842-1332-2_34_Fig15_HTML.jpg](img/A978-1-4842-1332-2_34_Fig15_HTML.jpg)

图 34-15。

The Index view with the new layout

### 局部视图

局部视图对于封装 UI 很有用，这样可以减少(或消除)重复代码。由于 Razor 视图不继承`System.Web.Page`(也没有`Page`指令)，局部视图和常规视图之间唯一的技术差异是如何从 action 方法中呈现。如果通过`_ViewStart.cshtml`或通过 Layout Razor 语句指定了一个布局页面，全视图(用`View()`方法从控制器返回)将使用这个布局页面。用`PartialView()`方法(或者 Partial() HTML 帮助器)呈现的视图不使用默认布局，但是如果用 Layout Razor 语句指定的话，仍然会使用一个布局。

为了演示这一点，打开`InventoryController.cs`类并更改`Index()`操作方法以返回局部视图而不是视图，如下所示:

`public async Task<ActionResult> Index()`

`{`

`return PartialView(await _repo.GetAllAsync());`

`}`

现在打开`Index.cshtml`页面，或者删除上面添加的`Layout=`行，或者将其注释掉，如下所示:

`@{`

`ViewBag.Title = "Index";`

`//Layout = "∼/Views/Shared/_LayoutNew.cshtml";`

`}`

运行应用程序，然后单击清单菜单链接。然后，您将看到与之前相同的数据，但没有任何布局，如图 [34-16](#Fig16) 所示。

![A978-1-4842-1332-2_34_Fig16_HTML.jpg](img/A978-1-4842-1332-2_34_Fig16_HTML.jpg)

图 34-16。

The inventory Index page rendered as a partial view

确保将`Index`动作方法改回调用`View()`而不是`PartialView()`。您可以将`//Layout = "∼/Views/Shared/_LayoutNew.cshtml"`行注释掉，以便索引视图返回使用默认布局。

除了使用`PartialView()`方法从一个动作方法呈现一个视图之外，您还可以使用 HTML 助手将一个局部视图拖入另一个视图，类似于在 Web 表单中加载一个用户控件。在`_Layout.cshtml`页面中，下面的 Razor 块创建了每个页面中显示的登录 UI。

`@Html.Partial("_LoginPartial")`

### 向视图发送数据

正如本章前面所讨论的，MVC 模式依赖于一定程度的关注点分离。控制器向视图发送数据，视图请求动作，模型作为应用程序的数据传递。我已经介绍了视图如何请求动作，但是我还没有讨论如何将数据(模型)放入视图。

#### ViewBag、ViewData 和 TempData

`ViewBag`、`ViewData`和`TempData`对象是向视图发送少量数据的机制。例如，在每个库存视图的顶部，有一行设置了`ViewBag.Title`属性，就像下面的`Index.cshtml`视图:

`@{`

`ViewBag.Title = "Index";`

`}`

`ViewBag.Title`用于将视图的标题发送给布局，以便在`_Layout.cshtml`的下一行中使用:

`<title>@ViewBag.Title - My ASP.NET Application</title>`

表 [34-9](#Tab9) 列出了将数据从控制器传递到视图(除了`Model`属性，在下一节描述)或从视图传递到视图的三种机制。

表 34-9。

Ways to Send Data to a View

<colgroup><col> <col></colgroup> 
| 数据传输对象 | 生命的意义 |
| --- | --- |
| `TempData` | 这是一个短命的对象，只在当前请求和下一个请求期间工作。 |
| `ViewData` | 允许以名称-值对的形式存储值的字典。下面举个例子:`ViewData["Title"] = "Foo"`。 |
| `ViewBag` | ViewData 字典的动态包装。下面举个例子:`ViewBag.Title = "Foo"`。 |

#### 强类型视图和视图模型

对于大量的数据(比如所有由`Index.cshtml`视图使用的`Inventory`记录)，您可以使用`Model`属性。检查`Index.cshtml`文件的第一行，您将会看到这一行，它表明视图是强类型的，类型被设置为`IEnumerable<Inventory>`:

`@model IEnumerable<AutoLotDAL.Models.Inventory>`

属性表示视图的类型。要在视图的其余部分访问它，可以使用`Model`属性。注意`Model`属性中的大写 M 和初始属性中的小写 M。当引用视图中包含的数据时，可以使用`Model`(大写 M)，如下行所示，它遍历每个库存记录:

`@foreach (var item in Model)`

`{`

`//Do something interesting here`

`}`

### 索引视图

现在是时候开始挖掘实际视图了。打开`Index.cshtml`，检查以下代码:

`@Html.DisplayNameFor(model => model.Make)`

这使用了`DisplayNameFor()` HTML 助手来显示 lambda 中引用的模型字段的显示名称(作为纯文本)。在这个例子中，代码获取了`Inventory`对象的`Make`属性的显示名称。

这对`Make`和`Color`来说很好，但是`PetName`显示为“宠物名”你宁愿它显示为“昵称”您可以更改代码，将单词 Pet Name 硬编码，但是这只能解决这个特定视图的问题。任何其他需要显示`PetName`字段的视图也必须硬编码这个标签。更好的方法是在模型上使用数据注释来设置显示名称。你很快就会这么做。

因为用户不想看到时间戳值，所以删除时间戳的头，包括标记和 Razor 代码。还要删除`for-`循环中的时间戳代码。

在`for-`循环中，使用另一个 HTML 助手`DisplayFor()`显示每个项目的值。这个 HTML 助手查看数据类型，并根据该数据类型的默认模板显示值。在这个例子中，数据字段是字符串，所以 HTML 助手只显示值。

#### MVC 显示数据注释

除了用于定义模型的数据注释，以便实体框架可以创建数据库(如在第 23 章中使用的)，还有其他数据注释可用于定义显示属性。虽然您可以将这些添加到模型类本身，但是如果您使用 EF 从现有的数据库中创建您的模型类，那么如果您需要重新生成您的模型，您所做的任何更改都将被覆盖。为了防止这种情况，您可以将数据注释放在另一个文件中。

首先导航到 AutoLotDAL 项目中的`Models`文件夹，并添加一个名为`MetaData`的新文件夹。在这个文件夹中，添加一个名为`InventoryMetaData.cs`的新类。将该类公开，并添加一个名为`PetName`的`string`类型的属性。向该属性添加`[Display(Name="Pet Name")]`属性。您的类应该是这样的:

`public class InventoryMetaData`

`{`

`[Display(Name="Pet Name")]`

`public string PetName;`

`}`

这不是一个完整的类定义文件；它将仅用于加载您已分配的属性。因此，您不需要向该属性添加`get/set`语法，事实上，您不应该这样做。你可能会问框架如何知道这个类正在向`Inventory`类提供属性。目前还没有。您需要给`Inventory.cs`类添加一个类级别的属性，这样框架就知道这个类为它保存了额外的属性。接下来您将进行更改。

打开`Models/Partials`文件夹中的`InventoryPartial.cs`类，并将`[MetadataType]`属性添加到该类中，如下所示:

`[MetadataType(typeof(InventoryMetaData))]`

`public partial class Inventory`

`{`

`public override string ToString() =>`

`$"{this.PetName ?? "**No Name**"} is a {this.Color} {this.Make} with ID {this.CarId}.";`

`}`

现在运行应用程序，单击库存链接，您将看到`PetName`标签显示为“宠物名称”，而没有更改视图中的任何代码。

#### 使用引导更新视图

下一步是使用 Bootstrap 给`Index.cshtml`视图增添一点活力。

##### 更新标题

首先要做的是更新页面标题。生成的视图有“Index”的标题，这没有什么意义。删除`<h2>Index</h2>`行，替换为下面的内容，这样就创建了一个包含页眉的小阴影区域。标记如下所示:

`<div class="well well-sm"><h1>Available Inventory</h1></div>`

图 [34-17](#Fig17) 显示了结果。

![A978-1-4842-1332-2_34_Fig17_HTML.jpg](img/A978-1-4842-1332-2_34_Fig17_HTML.jpg)

图 34-17。

Placing a header into a well

##### 更新表格

接下来，您将更新该表。Bootstrap 中的默认 table 类添加了一些基本的设计元素，包括分隔线。您还可以添加其他内置样式，如表 [34-10](#Tab10) 所示。

表 34-10。

Table-Style Options

<colgroup><col> <col></colgroup> 
| 风格 | 生命的意义 |
| --- | --- |
| `.table` | 这是基础表格样式。它添加了分隔线和浅色填充。 |
| `.table-striped` | 这给表格增加了条纹(想象一个绿色的条)。在 Internet Explorer 8 中不可用。 |
| `.table-bordered` | 这会在表格中的每个单元格周围添加边框。 |
| `.table-hover` | 这为表格添加了悬停高亮显示。 |
| `.table-condensed` | 这将单元格填充减半。 |
| `.table-responsive` | 使表格在移动设备上的响应速度更快。 |

将除 table-condensed 之外的所有内容添加到`<table>`类属性中，并在下一行添加一个带有文本“Vehicle List”的`<caption>`标记，如下所示:

`<table class="table table-striped table-responsive table-hover table-bordered">`

`<caption>Vehicle List</caption>`

图 [34-18](#Fig18) 显示了最终的用户界面。

![A978-1-4842-1332-2_34_Fig18_HTML.jpg](img/A978-1-4842-1332-2_34_Fig18_HTML.jpg)

图 34-18。

The updated table UI

##### 使用象形文字

图标是 Bootstrap 附带的一组图标，用于为链接和按钮添加视觉效果。您将向索引视图上的所有链接添加图标，但首先它有助于探索另一个 HTML 助手:`@Url.Action()`。`@Url.Action()`助手只返回 URL 部分，而`Html.ActionLink()`为锚标记创建整个标记。

将`@Html.ActionLink("Create")`行更新为:

`<a href="@Url.Action("Create")">Create a new Car</a>`

这创建了与`ActionLink`相同的 URL，但是现在您已经完全控制了标记。接下来，将“加号”图标添加到锚标记的内容中，如下所示:

`<a href="@Url.Action("Create")">`

`<span class="glyphicon glyphicon-plus"></span> Create`

`a new Car`

`</a>`

图 [34-19](#Fig19) 显示了更新后的链接。

![A978-1-4842-1332-2_34_Fig19_HTML.jpg](img/A978-1-4842-1332-2_34_Fig19_HTML.jpg)

图 34-19。

The Create a new Car link with the plus GlyphIcon

接下来，更新表格中的“编辑”、“详细信息”和“删除”链接，以分别使用“编辑”、“List-Alt”和“垃圾桶”图标。这显示在下面的代码清单中:

`<a href="@Url.Action("Edit", new {id = item.CarId})">`

`<span class="glyphicon glyphicon-edit"></span> Edit`

`</a>`

`|`

`<a href="@Url.Action("Details", new {id = item.CarId})">`

`<span class="glyphicon glyphicon-list-alt"></span> Details`

`</a>`

`|`

`<a href="@Url.Action("Delete", new {id = item.CarId})">`

`<span class="glyphicon glyphicon-trash"></span> Delete`

`</a>`

图 [34-20](#Fig20) 显示了最终页面。

![A978-1-4842-1332-2_34_Fig20_HTML.jpg](img/A978-1-4842-1332-2_34_Fig20_HTML.jpg)

图 34-20。

The final Index view

### 详细视图

对`Details.cshtml`视图没有太多的改变。就像`Index.cshtml`视图一样，`Details.cshtml`视图使用了`DisplayNameFor()`和`DisplayFor()` HTML 助手。自从你更新了`AutoLotDAL`,“昵称”的改变也延续到了这个视图。因此，您在这个页面上唯一需要做的事情就是删除`TimeStamp`行。

#### 使用引导更新视图

首先删除`<h2>Details</h2>`和`<h4>Inventory</h4>`行，并在顶部替换为以下内容:

`<div class="well well-sm"><h1>Inventory Details</h1></div>`

接下来，更新“编辑”和“返回列表”链接以使用图标，并添加一个“删除”链接。这里列出了更新后的标记，更新后的页面如图 [34-21](#Fig21) 所示:

![A978-1-4842-1332-2_34_Fig21_HTML.jpg](img/A978-1-4842-1332-2_34_Fig21_HTML.jpg)

图 34-21。

The updated details view

`<a href="@Url.Action("Edit", new {id = Model.CarId})">`

`<span class="glyphicon glyphicon-edit"></span> Edit`

`</a>`

`|`

`<a href="@Url.Action("Delete", new {id = Model.CarId})">`

`<span class="glyphicon glyphicon-trash"></span> Delete`

`</a>`

`|`

`<a href="@Url.Action("Index", new {id = Model.CarId})">`

`<span class="glyphicon glyphicon-list"></span> Back to List`

`</a>`

### 创建视图

检查这个视图中的代码，您会看到使用了另外两个 HTML 助手:`Html.LabelFor()`和`Html.EditorFor()`。HTML 助手基于 lambda 中引用的属性的数据类型创建一个输入字段。例如，下面一行:

`@Html.EditorFor(model => model.Make, new { htmlAttributes = new { @class = "form-control" } })`

创建此:

`<input name="Make" class="form-control text-box single-line" id="Make" type="text" value="" data-val-length-max="50" data-val-length="The field Make must be a string with a maximum length of 50." data-val="true">`

让我们在继续之前检查一下这一点。HTML 元素的`name`和`id`来自属性的`name`，类型来自属性的数据类型，类赋值来自 HTML 帮助器和通过帮助器添加的附加 HTML 属性的组合。控件的`value`被设置为属性值。在这种情况下，该值被设置为空字符串，因为它是`Inventory`的新实例。

`LabelFor`助手创建一个`Label`控件。例如，检查下面一行:

`@Html.LabelFor(model => model.Make, htmlAttributes: new { @class = "control-label col-md-2" })`

这将创建以下标记，包括自动添加的`for`属性(使用属性的名称):

`<label class="control-label col-md-2" for="Make">Make</label>`

#### BeginForm( ) HTML 帮助器

HTML 助手在 HTML 输出中创建一个标签。默认情况下，表单的 action 属性是当前 URL，表单的 method 属性是`post`(每个属性都可以通过`BeginForm()`方法的不同重载来定制)。Razor 中的`using`块将封装开始和结束 HTML 标签之间的所有东西。例如，如果您将此剃刀块输入到视图中:

`@using (Html.BeginForm())`

`{`

`<input name="foo" id="foo" type="text"/>`

`}`

它将在 HTML 中创建一个表单标记，并将 action 设置为与将用户带到该视图的 URL 相同的 URL。例如，如果`HttpGet`请求的 URL 是`Inventory` / `Create`，那么`Html.BeginForm()`助手将创建以下标记:

`<form action="/Inventory/Create" method="post">`

`<input name="foo" id="foo" type="text"/>`

`</form>`

#### 防伪令牌

如果您还记得，`[ValidateAntiForgeryToken]`属性被添加到动作方法的所有`HttpPost`版本中。该属性检查作为表单值的一部分提交的防伪标记，因此需要在`BeginForm()` Razor 代码块中添加一个防伪标记。完成这项工作的 HTML 助手被恰当地命名为`AntiForgeryToken()`，它已经被添加到需要它的搭建表单中。如果您需要自己将它添加到表单块中，语法很简单。

`@Html.AntiForgeryToken()`

#### 使用引导更新视图

通过删除`<h2>Create</h2>`和`<h4>Inventory</h4>`行来完成对`Create.cshtml`的更改，并在顶部替换为以下内容:

`<div class="well well-sm"><h1>Add Inventory</h1></div>`

接下来，更新“创建”按钮以包含加号图标，如下所示:

`<button type="submit" class="btn btn-default">`

`<span class="glyphicon glyphicon-plus"></span> Create`

`</button>`

最后的改变是将返回列表链接移动到创建按钮旁边(而不是像脚手架创建的那样在较低的`<div>`中),并使用列表图标。更新后的标记如下所示:

`|`

`<a href="@Url.Action("Index")">`

`<span class="glyphicon glyphicon-list"></span> Back to list`

`</a>`

`<div>`部分的完整标记如下所示:

`<div class="form-group">`

`<div class="col-md-offset-2 col-md-10">`

`<button type="submit" class="btn btn-default">`

`<span class="glyphicon glyphicon-plus"></span> Create`

`</button>`

`|`

`<a href="@Url.Action("Index")"><span class="glyphicon glyphicon-list"></span> Back to list</a>`

`</div>`

`</div>`

图 [34-22](#Fig22) 显示了视图的最终外观。

![A978-1-4842-1332-2_34_Fig22_HTML.jpg](img/A978-1-4842-1332-2_34_Fig22_HTML.jpg)

图 34-22。

The Add Inventory view

### 删除视图

搭建的 Delete 视图显示时间戳字段，这对用户来说是没有意义的(并且可能会混淆)。删除时间戳字段的`<dt>`和`<dd>`标签(接下来您将添加时间戳字段作为隐藏值)。

#### 隐藏的值

除了`CarId`值之外，`InventoryRepo object`上的`Delete()/DeleteAsync()`方法需要将`Timestamp`值与填充了 CarId 和时间戳字段的`CarId,`或`Inventory`对象一起发送。URL 被设置为发送`CarId`(例如`/Inventory/Delete/46`)，但是发送这些值的最佳方式是通过 HTTP 请求体中的表单值，而不是作为 URL 中的查询字符串值。

为此，您将在`BeginForm()` Razor 块中使用另一个 HTML 助手:`HiddenFor()`助手。这为 lambda 中引用的属性创建了一个隐藏的表单值。在隐藏表单中添加值(在`BeginForm()`剃刀块内)，像这样:

`@Html.HiddenFor(x => x.CarId)`

`@Html.HiddenFor(x => x.Timestamp)`

这将创建以下 HTML:

`<input name="CarId" id="CarId" type="hidden" value="46" data-val-required="The CarId field is required." data-val-number="The field CarId must be a number." data-val="true">`

`<input name="Timestamp" id="Timestamp" type="hidden" value="AAAAAAABAdE=">`

#### 验证摘要

尽管我还没有介绍验证，但是在`BeginForm()` Razor 块中添加另一个 HTML 助手`ValidationSummary()`。

`@Html.ValidationSummary(true, "", new { @class = "text-danger" })`

#### 使用引导更新视图

首先删除`<h2>Delete</h2>`和`<h4>Inventory</h4>`行，并在顶部替换为以下内容:

`<div class="well well-sm"><h1>Delete</h1></div>`

接下来，更新“删除”按钮以包含回收站图标，如下所示:

`<button type="submit" class="btn btn-default">`

`<span class="glyphicon glyphicon-trash"></span> Delete`

`</button>`

最后一项更改是更新“返回列表”链接，以使用列表图标。更新后的标记如下所示:

`|`

`<a href="@Url.Action("Index")">`

`<span class="glyphicon glyphicon-list"></span> Back to list`

`</a>`

`<div>`部分的完整标记如下所示:

`<div class="form-actions no-color">`

`<button type="submit" class="btn btn-default">`

`<span class="glyphicon glyphicon-trash"></span> Delete`

`</button>`

`|`

`<a href="@Url.Action("Index")"><span class="glyphicon glyphicon-list"></span> Back to list</a>`

`</div>`

图 [34-23](#Fig23) 显示了更新后的视图。

![A978-1-4842-1332-2_34_Fig23_HTML.jpg](img/A978-1-4842-1332-2_34_Fig23_HTML.jpg)

图 34-23。

The updated Delete view

### 编辑视图

搭建好的`Edit.schtml`视图显示时间戳字段，这对用户来说毫无意义(并且可能令人困惑)。删除时间戳字段的`<div class="form-group">`，并在`HiddenFor(model=>model.CarId)`行后立即添加一个`HiddenFor()`，如下所示:

`@Html.HiddenFor(model => model.Timestamp)`

#### 使用引导更新视图

首先删除`<h2>Edit</h2>`和`<h4>Inventory</h4>`行，并在顶部替换为以下内容:

`<div class="well well-sm"><h1>Edit</h1></div>`

接下来，更新保存按钮以包含保存图标，如下所示:

`<button type="submit" class="btn btn-default">`

`<span class="glyphicon glyphicon-save"></span> Save`

`</button>`

最后一项更改是更新“返回列表”链接以使用列表图标，并将其移动到“保存”按钮旁边。更新后的标记如下所示:

`|`

`<a href="@Url.Action("Index")">`

`<span class="glyphicon glyphicon-list"></span> Back to list`

`</a>`

`<div>`部分的完整标记如下所示:

`<div class="form-group">`

`<div class="col-md-offset-2 col-md-10">`

`<button type="submit" class="btn btn-default">`

`<span class="glyphicon glyphicon-save"></span> Save`

`</button>`

`|`

`<a href="@Url.Action("Index")"><span class="glyphicon glyphicon-list"></span> Back to list</a>`

`</div>`

`</div>`

图 [34-24](#Fig24) 显示了最终的用户界面。

![A978-1-4842-1332-2_34_Fig24_HTML.jpg](img/A978-1-4842-1332-2_34_Fig24_HTML.jpg)

图 34-24。

The Edit view

### 确认

MVC 应用程序有两层验证:服务器端和客户端。除了来自模型绑定失败(由于数据类型转换、数据注释失败或其他原因)的错误之外，您在本章前面看到了服务器端验证，当时您向`ModelState`添加了错误。JavaScript 会进行客户端检查，您很快就会看到这一点。

#### 显示错误

HTML 助手`ValidationMessageFor()`和`ValidationSummary()`在 UI 中显示`ModelState`错误。`ValidationSummary()`将显示与属性无关的`ModelState`错误以及属性错误(只要`ExcludePropertyErrors`设置为`false`)。通常，您会在属性旁边显示属性错误，并且在`ValidationSummary()`中只显示非特定于属性的错误。例如，下面一行(在`Create`、`Update`和`Delete`视图中)将以红色字体显示所有的模型错误，并且不显示任何属性错误:

`@Html.ValidationSummary(true, "", new { @class = "text-danger" })`

要显示单个属性错误，请使用视图页面中特定属性旁边的`ValidationMessageFor()`助手，如下所示:

`@Html.ValidationMessageFor(model => model.Make, "", new { @class = "text-danger" })`

这会产生以下标记:

`<span class="field-validation-valid text-danger" data-valmsg-replace="true" data-valmsg-for="Make"></span>`

要看到这一点，首先必须禁用客户端验证，这是作为默认搭建的一部分添加到页面中的。为此，打开`Create.cshtml`并在代码末尾注释掉 jQuery 验证包的呈现。

`@section Scripts {`

`@*@Scripts.Render("∼/bundles/jqueryval")*@`

`}`

接下来，打开`InventoryController.cs`，将`Create HttpPost`动作方法的第一部分更新为:

`if (!ModelState.IsValid)`

`{`

`ModelState.AddModelError(string.Empty,`

`"An error occurred in the data.  Please check all values and try again.");`

`return View(inventory);`

`}`

现在运行项目，导航到库存➤创建页面，并在 Make 字段中输入超过 50 个字符的内容。当您单击 Save 时，表单值被回发到`Create`方法。该模型在模型绑定期间被验证，但由于 Make 属性具有`[StringLength(50)]`属性而失败。结果应该如图 [34-25](#Fig25) 所示。

![A978-1-4842-1332-2_34_Fig25_HTML.jpg](img/A978-1-4842-1332-2_34_Fig25_HTML.jpg)

图 34-25。

Displaying server-side validation

#### 客户端验证

客户端验证通过 jquery (jquery-2.1.4.min.js)、jQuery 验证(jquery.validate.min.js)和 jQuery 验证非介入(jQuery . validate . obtructive . min . js)库来处理。jQuery 验证库添加了用于验证用户输入的 HTML5 数据属性。MVC 框架通过检查模型上的属性来决定添加哪些验证，从而与 jQuery 协同工作。然后，`EditorFor` HTML 助手将结果生成到下面的`Make`属性标记中:

`<input name="Make" class="form-control text-box single-line input-validation-error" id="Make" aria-invalid="true" aria-describedby="Make-error" type="text" value="" data-val-length-max="50" data-val-length="The field Make must be a string with a maximum length of 50." data-val="true">`

数据属性还支持自定义错误消息。打开 AutoLotDAL 项目中的`Inventory.cs`类，并更新`Make`属性上的`StringLength`属性，以包含一个`ErrorMessage`赋值，如下所示:

`[StringLength(50,ErrorMessage="Please enter a value less than 50 characters long.")]`

`public string Make { get; set; }`

现在运行 app，重复测试，错误信息显示如图 [34-26](#Fig26) 。

![A978-1-4842-1332-2_34_Fig26_HTML.jpg](img/A978-1-4842-1332-2_34_Fig26_HTML.jpg)

图 34-26。

Updated error message from the data annotations

### 完成用户界面

您将通过清理 UI 上的剩余项目来结束本章的 MVC 部分。

#### 更新布局视图

从打开`Views/Shared`下的`_Layout.cshtml`开始。在页面顶部，添加一个 Razor 代码块来声明一个字符串变量，并为`Car Lot MVC`赋值。这是为了替换应用程序名称的所有硬编码实例。代码如下所示:

`@{`

`var appName = "Car Lot MVC";`

`}`

接下来，用`@appName`替换硬编码的字符串`"My ASP.NET Application"`和`"Application Name"`。你会发现有三个地方需要修改:HTML 标签、导航条`ActionLink() helper`和页脚。更新后的代码如下所示:

`<!-- In the <head> section -->`

`<title>@ViewBag.Title - @appName</title>`

`<head>`

`<title>@ViewBag.Title - @appName</title>`

`<!-- rest ommitted for brevity -->`

`</head>`

`<!-- In the nav-bar header <div> -->`

`<div class="navbar navbar-inverse navbar-fixed-top">`

`<div class="container">`

`<div class="navbar-header">`

`<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">`

`<!-- ommitted for brevity -->`

`</button>`

`@Html.ActionLink(@appName, "Index", "Home", new { area = "" }, new { @class = "navbar-brand" })`

`</div>`

`<!-- ommitted for brevity -->`

`</div>`

`</div>`

`<!-- In the <footer> section -->`

`<footer>`

`<p>© @DateTime.Now.Year - @appName</p>`

`</footer>`

最后一个变化是，将 slug bug 的图像放在菜单栏中。在真实的网站中，这可能不是你想要放置广告的地方；然而，这个例子表明您可以在菜单栏中放置任何东西，并且当视窗大小改变时，Bootstrap 的响应特性会隐藏这些项目。在 CarLotMVC 中的`Content`文件夹下创建一个名为`Images`的文件夹。接下来，将图像添加到文件夹中；你可以在 [`Chapter 34`](34.html) 下载中找到示例图片。现在将图像添加到导航栏中，就在调用 load _`LoginPartial`部分视图之前。

`<img src="∼/Conteimg/CAR.gif" />`

`@Html.Partial("_LoginPartial")`

当你运行应用程序时，你会在菜单栏中看到图片，如图 [34-27](#Fig27) 所示。当你缩小浏览器的视窗时，你会看到图像和菜单一起消失了。

![A978-1-4842-1332-2_34_Fig27_HTML.jpg](img/A978-1-4842-1332-2_34_Fig27_HTML.jpg)

图 34-27。

Adding an image to the menu bar

#### 更新主页

最后一个变化是更新主页，这是`Home`控制器的`Index`视图。首先将大屏幕更新为以下内容:

`<div class="jumbotron">`

`<h1>Car Lot MVC</h1>`

`<p class="lead">A site for viewing and updating vehicles in the dealership.</p>`

`</div>`

接下来，删除超大屏幕块后的所有内容，并添加以下内容:

`<h2>View the Inventory</h2>`

`<p>`

`Autolot has the car you are looking for!  Check out our expansive inventory on the @Html.ActionLink("Inventory", "Index", "Inventory") page.`

`</p>`

图 [34-28](#Fig28) 显示了最终结果。

![A978-1-4842-1332-2_34_Fig28_HTML.jpg](img/A978-1-4842-1332-2_34_Fig28_HTML.jpg)

图 34-28。

Final version of the home page

### ASP.NET MVC 的最后一句话

我经常被问到的问题是:“Web 表单还是 MVC？”答案没那么简单。如果您的开发团队更习惯于 UI 创建的拖放特性，或者他们不适应 HTTP 的无状态特性，Web Forms 可能是更好的选择。如果您的团队更愿意完全控制 UI(这也意味着为您做的“魔术”更少)并开发利用 HTTP 动词(如`HttpGet`和`HttpPost`)的无状态应用程序，那么 MVC 可能是更好的选择。当然，在你的决定中还有很多因素需要考虑。这只是其中的一部分。

好消息是，您不必在 MVC 和 Web 表单之间做出选择。本章开头提到，两者都是基于`System.Web`(高达并包含 MVC5)的，一直以来都可以一起使用。当微软在 Visual Studio 2013 中引入一个 ASP.NET 时，将两个框架融合到一个项目中变得容易多了。

诚然，这一章只是触及了 ASP.NET MVC 的皮毛。一章涵盖的内容太多了。为了更深入地了解 MVC 所提供的一切，亚当·弗里曼的《Pro ASP.NET MVC 5》(在 [`www.apress.com/9781430265290?gtmf=s`](http://www.apress.com/9781430265290?gtmf=s) 有售)是一本关于这个主题的极好的书。

Source Code

CarLotMVC 解决方案可以在 [`Chapter 34`](34.html) 子文件夹中找到。

## ASP.NET Web API 简介

正如您在[第 25 章](25.html)中了解到的，Windows Communication Foundation(WCF)是一个成熟的创作框架。基于. NET 的服务，可以与各种客户端进行通信。虽然 WCF 非常强大，但是如果您需要的只是简单的基于 HTTP 的服务，那么创建基于 WCF 的服务可能会比您想要或需要的更复杂。进入 ASP.NET Web API，另一个在。NET，可以从任何支持 HTTP 的客户端访问它。作为 MVC 开发人员，Web API 是您的。NET 工具箱。Web API 建立在 MVC 之上，利用了许多相同的概念，比如模型、控制器和路由。Web API 最初是作为 MVC 4 的一部分与 Visual Studio 2012 一起发布的，并随着 Visual Studio 2013 Update 1 更新到 2.2 版。

### 添加 Web API 项目

首先向您的解决方案添加一个 Web API 项目。右键单击您的解决方案，选择添加➤新项目，然后选择 ASP.NET web 应用(如图 [34-29](#Fig29) )。将项目命名为 CarLotWebAPI。

![A978-1-4842-1332-2_34_Fig29_HTML.jpg](img/A978-1-4842-1332-2_34_Fig29_HTML.jpg)

图 34-29。

Adding a new ASP.NET web application

现在，您应该熟悉下一个屏幕。这一次，选择空模板并检查“添加文件夹和核心引用:”Web API(如图 [34-30](#Fig30) )。如果您选择 Web API 模板，那么项目中会添加许多样板和示例代码(包括 MVC 控制器和视图)，您所需要的只是基本的 Web API 管道。下一个屏幕显示了您在创建 Web 表单或 MVC 应用程序时看到的相同选项，这些选项统称为一个 ASP.NET。

![A978-1-4842-1332-2_34_Fig30_HTML.jpg](img/A978-1-4842-1332-2_34_Fig30_HTML.jpg)

图 34-30。

Adding the Empty project template with Web API support

单击“确定”,项目将添加到解决方案中。与 Web 表单和 MVC 项目一样，当您创建一个新项目时，许多包含的 NuGet 包都是过时的。在解决方案资源管理器中右击该项目，选择“管理 NuGet 包”，并将筛选器更改为“可用升级”。升级所有可以升级的包。将过滤器改回 All 并安装实体框架(就像您之前所做的那样)。您需要安装一个额外的包:AutoMapper(您将在本章后面用到它)。要找到这个包，在搜索框中输入 AutoMapper(如图 [34-31](#Fig31) )。

![A978-1-4842-1332-2_34_Fig31_HTML.jpg](img/A978-1-4842-1332-2_34_Fig31_HTML.jpg)

图 34-31。

Installing AutoMapper from NuGet

最后，添加对 AutoLotDAL 项目的引用(通过在 CarLotWebAPI 的解决方案资源管理器中右键单击 References 节点，并从“项目/解决方案”中选择 AutoLotDAL)。将连接字符串添加到`Web.config`文件中(根据您的安装路径，连接字符串可能会有所不同)。

`<connectionStrings>`

`<add name="AutoLotConnection" connectionString="data source=localhost\SQLEXPRESS2014;initial catalog=AutoLot;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework" providerName="System.Data.SqlClient" />`

`</connectionStrings>`

### 检查 Web API 项目

这个项目比你在本章开始时创建的 MVC 项目要贫瘠得多。让我们检查一下创建的文件。首先打开`App_Start`文件夹中的`WebApiConfig.cs`文件。下面列出的代码对您来说应该很熟悉。第一行启用了属性路由(本书没有涉及)。第二行用默认值定义了默认路由。默认的路线和你在 MVC 中看到的有点不同。第一个主要区别是路线中缺少一个动作。这是因为(正如你将在本章后面看到的)超出控制器的路由是基于请求中使用的 HTTP 动词。最后，将`id`设置为`RouteParameter.Optional`，就像 MVC 一样。

`public static void Register(HttpConfiguration config)`

`{`

`// Web API configuration and services`

`// Web API routes`

`config.MapHttpAttributeRoutes();`

`config.Routes.MapHttpRoute(`

`name: "DefaultApi",`

`routeTemplate: "api/{controller}/{id}",`

`defaults: new { id = RouteParameter.Optional }`

`);`

`}`

接下来，打开`Global.asax.cs`文件(如下所列)。这是你在 MVC 中看到的一个精简版本。文件中只有一行，它为 web 路由添加了路由。

`protected void Application_Start()`

`{`

`GlobalConfiguration.Configure(WebApiConfig.Register);`

`}`

### 配置项目

由于 CarLotWebAPI 项目是一个无头服务(即没有任何 UI)，因此需要将其配置为在启动时运行，并等待对其中一个已配置路由的调用。为此，请通过在解决方案资源管理器中右击项目名称并选择“属性”来打开项目属性。点按左侧边栏中的 Web 项目，然后选择“不要打开页面”。请等待外部应用程序的请求。另外，记下项目 URL(在我的例子中，它是`http://localhost:46024/`)。如图 [34-32](#Fig32) 所示。

![A978-1-4842-1332-2_34_Fig32_HTML.jpg](img/A978-1-4842-1332-2_34_Fig32_HTML.jpg)

图 34-32。

Configuring the project startup for CarLotWebAPI

最后，通过在解决方案资源管理器中右击项目名称并单击“设置为启动项目”,将 CarLotWebAPI 设置为解决方案中的启动项目。

### 关于 JSON 的一个注记

JavaScript 对象符号(JSON)是在服务之间传输数据的一种方式。它是对象和类的简单键值文本表示。例如，考虑下面一个`Inventory`项目的 JSON 表示:

`{"CarId":1,"Make":"VW","Color":"Black","PetName":"Zippy","Timestamp":"AAAAAAAAB9o=","Orders":[]}`

每个 JSON 对象以大括号开始和结束，属性名和字符串值用引号括起来。JSON 对象也可以嵌套。如果`Make`属性不是一个字符串而是一个对象(带有属性`Builder`和`Year`)，JSON 可能类似如下:

`{"CarId":1,"Make":{"Builder":"VW","Year":2015},"Color":"Black","PetName":"Zippy","Timestamp":"AAAAAAAAB9o=","Orders":[]}`

正如您在`Orders`属性中看到的，列表由括号(`[`)表示。如果服务正在发送一个`Inventory`对象的列表，JSON 可能如下所示:

`[{"CarId":1,"Make":"VW","Color":"Black","PetName":"Zippy","Timestamp":"AAAAAAAAB9o=","Orders":[]},{"CarId":2,"Make":"Ford","Color":"Rust","PetName":"Rusty","Timestamp":"AAAAAAAAB9s=","Orders":[]}]`

Note

Web API 项目模板包括一个名为 JSON.NET 的免费开源工具。它是一个健壮的实用程序，可以从对象创建 JSON，也可以从 JSON 创建对象。你将在本章后面使用 JSON.NET，你可以在 [`www.newtonsoft.com/json`](http://www.newtonsoft.com/json) 找到更多信息(包括文档和例子)。

### 添加控制器

就像 MVC 一样，Web API 代码以控制器和动作为中心。右键单击控制器文件夹，并选择添加➤控制器。接下来，使用实体框架(如图 [34-33](#Fig33) 所示)选择 Web API 2 Controller with actions，并点击 Add。

![A978-1-4842-1332-2_34_Fig33_HTML.jpg](img/A978-1-4842-1332-2_34_Fig33_HTML.jpg)

图 34-33。

Adding a new Web API 2 Controller

在添加控制器屏幕上，为模型选择`Inventory`类，并为数据上下文选择自动势。勾选要求使用`async`控制器动作的复选框，将名称改为`InventoryController`(如图 [34-34](#Fig34) ，点击添加。

![A978-1-4842-1332-2_34_Fig34_HTML.jpg](img/A978-1-4842-1332-2_34_Fig34_HTML.jpg)

图 34-34。

Adding the Model and Context classes for the controller

#### 检查控制器方法

打开新创建的`InventoryController.cs`类，为`InventoryRepo`类添加一个类级变量，并实例化它。还有，用控制器`Dispose()`的方法处置回购。下面列出了这两个代码片段:

`private readonly InventoryRepo _repo = new InventoryRepo();`

`protected override void Dispose(bool disposing)`

`{`

`if (disposing)`

`{`

`db.Dispose();`

`_repo.Dispose();`

`}`

`base.Dispose(disposing);`

`}`

接下来，看看动作方法签名。虽然它们类似于 MVC `InventoryController.cs`类中的动作，但还是有一些明显的区别。许多操作都采用相同的 URL，而不是基于 URL 的内容来路由请求！回想一下，在 MVC 中，`Add()`、`Update()`和`Delete()`动作各有两个方法，MVC 根据请求中的 HTTP 动词决定使用哪一个(要么是`HttpGet`，要么是`Httpost`)。Web API 遵循相同的模式，但是使用额外的 HTTP 动词来区分调用。除了 MVC 中使用的`HttpGet`和`HttpPost`动词，Web API 还使用了`HttpPut`和`HttpDelete`。另一个明显的区别是缺少修饰动作的 HTTP 动词属性！这比配置更符合惯例。Web API 查找动作名称的开头与 HTTP 动词的不区分大小写的匹配。例如，名为`DeleteInventory()`的动作将处理`HttpDelete`请求。你当然可以随意调用这个方法，但是你必须记住用正确的属性来修饰这个方法。在接下来的部分中，您将更详细地检查这些动作，因为您更新它们以使用来自`AutoLotDAL`库的`InventoryRepo`。

##### 获取所有库存记录

有两种`HttpGet`方法，`GetInventory(` `)`和`GetInventory(int id)`。第一个获取所有库存记录(回想一下，`id`参数在路由中是可选的)。这是一个非常标准的方法，就像你在 MVC 控制器中看到的一样，除了这个 action 方法不返回一个`ActionResult`；它似乎只是返回数据。实际上，除了数据之外，Web API 框架还将数据包装在一个 HttpOk (200) `HttpResponseMessage`中，将数据作为消息体添加进来。对该方法的唯一更改是更新`InventoryRepo.GetAll()`方法，并将返回类型更改为`IEnumerable<Inventory>`，如下所示:

`// GET: api/Inventory`

`public IEnumerable<Inventory> GetInventory()`

`{`

`return _repo.GetAll();`

`}`

现在是时候测试应用程序了。运行该解决方案时，除了 Visual Studio 中的“运行”图标更改为传统的“暂停/停止”图标之外，似乎什么也没发生。这是因为您将项目设置为无头运行，只是等待外部调用。当所有东西都被加载后(调试图标已经改变)，打开一个新的 web 浏览器。输入服务的 URL(您在更改 project web properties 时看到了这一点)，加上路由，即`api/Inventory`。在我的机器上，这相当于(您的端口号很可能不同):

`http://localhost:46024/api/Inventory`

当您在浏览器中输入这些内容时，您将得到以下纯文本形式的错误(实际上，错误要长得多，但为了显示消息的关键部分，这里将其缩短了)。没有你习惯在 Web 表单和 MVC 中看到的“死亡黄屏”！

`"Message":"An error has occurred.","ExceptionMessage":"Self referencing loop detected for property ’Car’ with type ’System.Data.Entity.DynamicProxies.Inventory_4F2216023579E149E169D586253289F35987B42694292AD3BF08836508A419F5’. Path ’[0].Orders[0]’"`

MVC(或 Web 表单)中没有传统的错误页面是因为 Web API 以 JSON 的形式返回所有内容，除非另有说明。因此，调用应用程序(在这种情况下是浏览器)不知道发生了错误；它只显示返回的文本。请注意，Web API 也可以返回任何标准的 HTTP 错误代码(您将在后面看到)。当 Web API 返回错误时，调用应用程序负责解释并相应地处理它。要查看这一点，请打开浏览器的开发工具(大多数浏览器为 F12)，导航到网络选项卡，然后刷新浏览器。开发者工具将向您显示关于调用、返回的`HttpMessage`以及任何错误的详细信息(如图 [34-35](#Fig35) 所示)。

![A978-1-4842-1332-2_34_Fig35_HTML.jpg](img/A978-1-4842-1332-2_34_Fig35_HTML.jpg)

图 34-35。

Showing HTTP errors in Microsoft Edge browser

错误本身是因为 EF(默认情况下)惰性加载实体。如果你还记得第 23 章中的[，延迟加载意味着当属性被请求时，EF 将从数据库中调用数据。的序列化。NET 对象遍历每一个属性，所以在这种情况下，它沿着`Orders`的列表向下走，并且`Order`类有一个对其`Inventory`类的引用。这种循环引用导致序列化失败。要解决这个问题，您要么需要关闭延迟加载，要么将所有相关属性复制到一个新类中，忽略那些导致序列化问题的属性。接下来，您将使用 AutoMapper 完成这项工作。](23.html)

###### 使用 AutoMapper 创建视图模型

AutoMapper(您在本节前面安装的)是一个免费的开源实用程序，用于从另一个类型的实例创建一个新的类型实例。它也可以用来创建一个相同类型的新实例，您将在这里这样做。在`InventoryController.cs`中添加一个新的构造函数，并在该构造函数中添加以下代码:

`public InventoryController()`

`{`

`Mapper.Initialize(`

`cfg =>`

`{`

`cfg.CreateMap<Inventory, Inventory>()`

`.ForMember(x => x.Orders, opt => opt.Ignore());`

`});`

`}`

这段代码在`Inventory`类型和它自身之间创建了一个映射，忽略了`Orders`属性。AutoMapper 使用反射来确定这两种类型之间匹配的属性，并将所有值从原始实例复制到目标类型的新实例中，任何被忽略的属性除外(在本例中为`Orders`导航属性)。它也适用于集合，您将在下面看到。

接下来，更新`Inventory()`方法，将`Inventory`记录列表转换为不包含任何`Orders`的新的`Inventory`记录列表，如下所示:

`// GET: api/Inventory`

`public IEnumerable<Inventory> GetInventory()`

`{`

`var inventories = _repo.GetAll();`

`return Mapper.Map<List<Inventory>, List<Inventory>>(inventories);`

`}`

Note

本章没有足够的篇幅来深入介绍 AutoMapper，但是它是一个活跃的、广泛使用的工具。NET 开发人员。您应该考虑将它添加到您的标准工具箱中。您可以在项目主页的 [`http://automapper.org`](http://automapper.org/) 找到更多信息，包括文档和示例。

再次运行应用程序，使用 Internet Explorer 或 Microsoft Edge(Chrome 和 Firefox 都默认返回 XML)，输入`Inventory` URI ( `http://localhost:46024/api/Inventory`)。您将看到以下 JSON 输出(您的实际数据可能会有所不同):

`[{"CarId":1,"Make":"VW","Color":"Black","PetName":"Zippy","Timestamp":"AAAAAAAAB9o=","Orders":[]},{"CarId":2,"Make":"Ford","Color":"Rust","PetName":"Rusty","Timestamp":"AAAAAAAAB9s=","Orders":[]},{"CarId":3,"Make":"Saab","Color":"Black","PetName":"Mel","Timestamp":"AAAAAAAAB9w=","Orders":[]},{"CarId":4,"Make":"Yugo","Color":"Yellow","PetName":"Clunker","Timestamp":"AAAAAAAAB90=","Orders":[]},{"CarId":5,"Make":"BMW","Color":"Black","PetName":"Bimmer","Timestamp":"AAAAAAAAB94=","Orders":[]},{"CarId":6,"Make":"BMW","Color":"Green","PetName":"Hank","Timestamp":"AAAAAAAAB98=","Orders":[]},{"CarId":7,"Make":"BMW","Color":"Pink","PetName":"Pinky","Timestamp":"AAAAAAAAB+A=","Orders":[]},{"CarId":13,"Make":"Pinto","Color":"Black","PetName":"Pete","Timestamp":"AAAAAAAAB+E=","Orders":[]},{"CarId":54,"Make":"Yugo","Color":"Brown","PetName":"Brownie","Timestamp":"AAAAAAABX5E=","Orders":[]},{"CarId":55,"Make":"Yugo","Color":"Brown","PetName":"Brownie","Timestamp":"AAAAAAABbzE=","Orders":[]},{"CarId":56,"Make":"Yugo","Color":"Brown","PetName":"Brownie","Timestamp":"AAAAAAABftE=","Orders":[]},{"CarId":57,"Make":"Yugo","Color":"Brown","PetName":"Brownie","Timestamp":"AAAAAAABjnE=","Orders":[]},{"CarId":58,"Make":"Yugo","Color":"Brown","PetName":"Brownie","Timestamp":"AAAAAAABnhE=","Orders":[]},{"CarId":59,"Make":"Yugo","Color":"Brown","PetName":"Brownie","Timestamp":"AAAAAAABrbE=","Orders":[]},{"CarId":60,"Make":"Yugo","Color":"Brown","PetName":"Brownie","Timestamp":"AAAAAAABvVE=","Orders":[]},{"CarId":61,"Make":"Yugo","Color":"Brown","PetName":"Brownie","Timestamp":"AAAAAAABzPE=","Orders":[]},{"CarId":62,"Make":"Yugo","Color":"Brown","PetName":"Brownie","Timestamp":"AAAAAAAB3JE=","Orders":[]},{"CarId":63,"Make":"Yugo","Color":"Brown","PetName":"Brownie","Timestamp":"AAAAAAAB7DE=","Orders":[]},{"CarId":64,"Make":"Yugo","Color":"Brown","PetName":"Brownie","Timestamp":"AAAAAAAB+9E=","Orders":[]}]`

您会看到`Orders`属性仍然存在，但是所有记录都是空的，避免了循环引用问题。问题解决了！

##### 获取一条库存记录

第二个`HttpGet`方法`GetInventory(int id)`根据传入的 ID 返回一条库存记录。更新方法，从 repo 中调用`GetOneAsync()`方法，并使用 AutoMapper 创建一个`Inventory`类的新实例，如下所示:

`// GET: api/Inventory/5`

`[ResponseType(typeof(Inventory))]`

`public async Task<IHttpActionResult> GetInventory(int id)`

`{`

`Inventory inventory = await _repo.GetOneAsync(id);`

`if (inventory == null)`

`{`

`return NotFound();`

`}`

`return Ok(Mapper.Map<Inventory,Inventory>(inventory));`

`}`

这个动作方法中有四个新的物品/方法:第`ResponseType attribute`、第一`HttpActionResult`、`NotFound()`和`Ok() methods`。`ResponseType`属性用于指定`HttpResponseMessage`主体中返回的实体类型。在这种情况下，它启动泵为`HttpActionResult`序列化一个`Inventory`记录(这是 MVC 的 ActionResult 的 Web API 版本)。`NotFound()`返回一个`NotFoundResult`，翻译成 404 错误信息。`Ok()`返回一个 HttpOk (200)并将传递给方法的对象(JSON 或 XML，取决于您的浏览器)添加到消息体中。

要对此进行测试，请在 Internet Explorer/Edge 中输入以下内容(您的端口和`CarId`可能不同):

`http://localhost:46024/api/Inventory/5`

##### 更新库存记录

用 HTTP 语言更新记录是通过调用`HttpPut`并传入要更新的记录的`id`和要更新的对象的实例来实现的。这个方法使用模型绑定(就像 Web Forms 和 MVC)来创建一个`Inventory`类的实例，在消息体中包含客户端发送的值。更新`PutInventory()`方法以使用`InventoryRepo`。这里显示了代码，将在下面的清单中讨论:

`// PUT: api/Inventory/5`

`[ResponseType(typeof(void))]`

`public async Task<IHttpActionResult> PutInventory(int id, Inventory inventory)`

`{`

`if (!ModelState.IsValid)`

`{`

`return BadRequest(ModelState);`

`}`

`if (id != inventory.CarId)`

`{`

`return BadRequest();`

`}`

`try`

`{`

`await _repo.SaveAsync(inventory);`

`}`

`catch (Exception ex)`

`{`

`//Production app should do more here`

`throw;`

`}`

`return StatusCode(HttpStatusCode.NoContent);`

`}`

在动作方法的主体中(与 MVC 和 Web 表单中的模型绑定一样)，第一项检查是确保`ModelState`有效。如果不是，那么它返回一个 HttpBadRequest (400)。如果有效，该方法将检查通过 URL 传入的`id`是否与`Inventory`记录的`CarId`匹配(来自消息体)。这有助于减少(但不能消除)不道德用户的 URL 黑客行为。然后，代码尝试保存记录，如果成功，则返回 HTTP 204(无内容)。如果有异常，这个例子只是将它抛出给客户端。在生产应用程序中，您可能希望相应地处理所有异常。

##### 添加库存记录

使用 HTTP 语言添加记录是通过调用`HttpPost`并在消息体中传递被更新的对象来实现的。在 MVC 中，除了`HttpGet`请求之外，您只使用了`Httpost`，但是 Web API 更擅长正确使用 HTTP 动词。`PostInventory()`方法还使用模型绑定来创建`Inventory`类的实例，在消息体中包含从客户端发送的值。更新方法以使用`InventoryRepo`。这里显示了代码，将在下面的清单中讨论:

`// POST: api/Inventory`

`[ResponseType(typeof(Inventory))]`

`public async Task<IHttpActionResult> PostInventory(Inventory inventory)`

`{`

`if (!ModelState.IsValid)`

`{`

`return BadRequest(ModelState);`

`}`

`try`

`{`

`await _repo.AddAsync(inventory);`

`}`

`catch (Exception ex)`

`{`

`//Production app should do more here`

`throw;`

`}`

`return CreatedAtRoute("DefaultApi", new { id = inventory.CarId }, inventory);`

`}`

`PostInventory()`动作返回添加的`Inventory`记录，以及服务器生成的值，因此`ResponseType`的类型是`Inventory`。这个动作方法还使用模型绑定从消息体获取值，检查`ModelState`，如果模型绑定有问题，返回一个 HttpBadRequest (400)。如果模型绑定成功，该方法将尝试添加新记录。如果添加成功，那么操作返回一个 HttpCreated (201 ),在消息体中有新的`Inventory`记录。

##### 删除库存记录

最后要更新的动作方法是`DeleteInventory`。控制器模板创建一个方法，该方法接受一个`id`，提取记录，如果找到记录，就删除它们。这样做的问题(正如您在 MVC `Delete`动作中发现的)是，AutoLotDAL 库使用并发检查来确保在当前用户发送删除请求之前没有其他人更改记录。因此，您需要更新签名以接受一个`id`和一个`Inventory`对象，它们将从消息体中填充。将方法更新为以下内容:

`// DELETE: api/Inventory/5`

`[ResponseType(typeof(void))]`

`public async Task<IHttpActionResult> DeleteInventory(int id, Inventory inventory)`

`{`

`if (id != inventory.CarId)`

`{`

`return BadRequest();`

`}`

`try`

`{`

`await _repo.DeleteAsync(inventory);`

`}`

`catch (Exception ex)`

`{`

`//Production app should do more here`

`throw;`

`}`

`return Ok();`

`}`

第一个变化是将`ResponeType`更新为`void`。接下来，更新签名以接受除了`id`参数之外的`Inventory`类型。在方法体中，还要检查以确保`id`参数与消息体中`Inventory`记录的`CarId`相匹配。如果匹配，尝试删除`Inventory`记录。如果删除成功，返回一个 HttpOk (200)。

#### 移除自动势变量

对`InventoryController`的最后清理是从类的顶部移除`AutoLotEntities`变量，并在控制器的`Dispose`方法中处置回购协议。更新后的`Dispose`方法如下所示:

`protected override void Dispose(bool disposing)`

`{`

`if (disposing)`

`{`

`_repo.Dispose();`

`}`

`base.Dispose(disposing);`

`}`

### 更新 CarLotMVC 以使用 CarLotWebAPI

目前，CarLotMVC 使用 AutoLotDAL 库进行所有的 CRUD 操作。在本节中，您将使用`CarLotWebAPI`进行所有的数据访问操作。

#### 更新索引操作

接下来，在 CarLotMVC 中打开`InventoryController.cs`文件，并导航到`Index()`动作方法。您将使用 CarLotWebAPI 中的服务，而不是使用 AutoLotDAL 库中的`InventoryRepo`。为此，创建一个新的`HttpClient`并调用`GetAsync()`，传入`GetInventory()`动作方法的 URL。这个 Web API 方法返回一个`IHTTPActionResult`。对于这个方法，这个结果有两个您关心的属性:`IsSuccessStatusCode`和`Content`。如果调用有效，则`IsSuccessStatusCode`返回`true`。这使您不必检查每一个可能返回的代码，因为有许多代码被认为是成功的。`Content`属性提供了对消息体的访问。对于`Index()`操作方法，如果返回了`Inventory`记录，Web API 将返回一个 HttpOk (200)。

如果一切正常，所有的`Inventory`记录都作为 JSON 包含在`Content`属性中。这就是 JSON.NET 发挥作用的地方(正如本章前面提到的)。使用单个类型(`Inventory`)或类型(`List<Inventory>`)的`IEnumerable`作为泛型参数来调用`JsonConvert.DeserializeObject<T>()`方法。然后传入 JSON 字符串，它试图将 JSON 字符串转换成指定的类型。如果该方法成功地将文本转换为对象，则它返回索引视图。请注意，您用于 Web API 调用的端口可能会不同。

`// GET: Inventory`

`public async Task<ActionResult> Index()`

`{`

`var client = new HttpClient();`

`var response = await client.GetAsync("``http://localhost:46024/api/Inventory`T2】

`if (response.IsSuccessStatusCode)`

`{`

`var items = JsonConvert.DeserializeObject<List<Inventory>>(`

`await response.Content.ReadAsStringAsync());`

`return View(items);`

`}`

`return HttpNotFound();`

`}`

Note

这些例子都不具备生产应用程序所需的错误处理水平。做出这个决定是为了确保例子清晰简洁。你可能想利用你在第 7 章中学到的知识来优雅地处理所有的异常。

通过在解决方案资源管理器中右击 CarLotMVC 项目名称，确保将 CarLotMVC 应用程序设置为启动项目。运行应用程序，然后单击设置为启动项目。运行应用程序并点击菜单中的库存链接，您将看到与`Index()`方法直接调用 AutoLotDAL 库时相同的页面。事实上就是这么简单！

Note

您可能想知道在 CarLotMVC 中是否还需要对 AutoLotDAL 的引用。答案是肯定的，至少对于这个解决方案是如何构建的。AutoLotDAL 包含模型定义，CarLotMVC 需要访问模型类。一种常见的模式(为了简单起见，这里没有显示)是将模型定义放入一个单独的程序集中，并从任何需要模型类型定义的项目中引用该库。

#### 更新详细信息操作

下一步是更新`Details()`动作方法。将代码更新为以下内容(根据需要更改您的端口):

`// GET: Inventory/Details/5`

`public async Task<ActionResult> Details(int? id)`

`{`

`if (id == null)`

`{`

`return new HttpStatusCodeResult(HttpStatusCode.BadRequest);`

`}`

`var client = new HttpClient();`

`var response = await client.GetAsync($"``http://localhost:46024/api/Inventory/{id.Value`T2】

`if (response.IsSuccessStatusCode)`

`{`

`var inventory = JsonConvert.DeserializeObject<Inventory>(`

`await response.Content.ReadAsStringAsync());`

`return View(inventory);`

`}`

`return HttpNotFound();`

`}`

这里的主要变化(就像在`Index`动作中一样)是使用一个新的`HttpClient`将获取记录的调用改为 CarLotMVC。检查响应是否是一个成功的调用，如果是，使用 JSON.NET 将消息内容反序列化为一个`Inventory`对象。最后，返回视图。

#### 更新添加操作

有两个`Create()`动作方法，但是`HttpGet`版本不需要更新，因为它在没有任何数据库交互的情况下加载视图。`HttpPost`版本确实需要更新。幸运的是，`HttpClient`为你处理了很多工作(就像在`Index()`动作方法中一样)。但是，在更新方法之前，您需要为`System.Net.Http`添加一个`using`语句和一个对`System.Net.Http.Formatting`的引用。`System.Net.Http.Formatting`类具有您将在整个项目中使用的扩展方法，例如`PostAsJsonAsync()`，如下面的代码所示。这里列出了整个操作方法，这些变化将在列出后讨论:

`[HttpPost]`

`[ValidateAntiForgeryToken]`

`public async Task<ActionResult> Create([Bind(Include = "Make,Color,PetName"] Inventory inventory)`

`{`

`if (!ModelState.IsValid)`

`{`

`ModelState.AddModelError(string.Empty,`

`"An error occurred in the data.  Please check all values and try again.");`

`return View(inventory);`

`}`

`try`

`{`

`var client = new HttpClient();`

`var response = await client.PostAsJsonAsync("``http://localhost:46024/api/Inventory`T2】

`if (response.IsSuccessStatusCode)`

`{`

`return RedirectToAction("Index");`

`}`

`}`

`catch (Exception ex)`

`{`

`ModelState.AddModelError(string.Empty, $"Unable to create record: {ex.Message}");`

`}`

`return View(inventory);`

`}`

主要的变化是在创建了一个`HttpClient`实例之后，您调用了`PostAsJsonAsync()`扩展方法。这个方法有两个参数:服务 URI(例如，`http:/localhost/46024/api/Inventory`)和要发布的数据(`inventory`)。该方法负责为您创建 JSON，创建一个`HttpPost`方法，并将您的数据插入消息体。如果请求成功，则`IsSuccessStatusCode`将被设置为`true`。

#### 更新编辑操作

两个`Edit()`动作方法都需要更新。`HttpGet`版本必须调用`CarLotWebAPI`来获得要显示的记录，对`Details()`动作方法的更改与从 web 服务获得数据的更改相同。

`// GET: Inventory/Edit/5`

`public async Task<ActionResult> Edit(int? id)`

`{`

`if (id == null)`

`{`

`return new HttpStatusCodeResult(HttpStatusCode.BadRequest);`

`}`

`var client = new HttpClient();`

`var response = await client.GetAsync($"``http://localhost:46024/api/Inventory/{id.Value`T2】

`if (response.IsSuccessStatusCode)`

`{`

`var inventory = JsonConvert.DeserializeObject<Inventory>(`

`await response.Content.ReadAsStringAsync());`

`return View(inventory);`

`}`

`return new HttpNotFoundResult();`

`}`

`HttpPost`版本使用了与`Add()`动作方法类似的扩展方法。`PutAsJsonAsync()`在指定的 URL 创建一个`HttpPut`消息，并将对象作为 JSON 添加到消息体中。下面列出了更新后的代码:

`// POST: Inventory/Edit/5`

`[HttpPost]`

`[ValidateAntiForgeryToken]`

`public async Task<ActionResult> Edit(`

`[Bind(Include = "CarId,Make,Color,PetName,Timestamp")] Inventory inventory)`

`{`

`if (!ModelState.IsValid) { return View(inventory); }`

`var client = new HttpClient();`

`var response = await client.PutAsJsonAsync($"``http://localhost:46024/api/Inventory/{inventory.CarId`T2】

`if (response.IsSuccessStatusCode)`

`{`

`return RedirectToAction("Index");`

`}`

`return View(inventory);`

`}`

Note

您可能想知道为什么 MVC 控制器中的 action 方法用`HttpPost`属性标记，但是对 web 服务的调用是一个`HttpPut`。重要的一点是，用于调用 MVC 动作的 HTTP 动词不必与用于调用 Web API 动作方法的 HTTP 动词相匹配。它们是独立的操作。

#### 更新删除操作

有两个`Delete()`动作方法，和`Edit() HttpGet`版本一样，唯一的变化是调用 web 服务获取数据。更改的方式与您对`Delete()`和`Details()`动作方法所做的相同。

`// GET: Inventory/Delete/5`

`public async Task<ActionResult> Delete(int? id)`

`{`

`if (id == null)`

`{`

`return new HttpStatusCodeResult(HttpStatusCode.BadRequest);`

`}`

`var client = new HttpClient();`

`var response = await client.GetAsync($"``http://localhost:46024/api/Inventory/{id.Value`T2】

`if (response.IsSuccessStatusCode)`

`{`

`var inventory = JsonConvert.DeserializeObject<Inventory>(`

`await response.Content.ReadAsStringAsync());`

`return View(inventory);`

`}`

`return new HttpNotFoundResult();`

`}`

`HttpGet Delete()`动作方法需要更多的工作。正如您可能怀疑的那样，`HttpClient`上确实有一个`DeleteAsync()`扩展方法，但是它不接受消息体中内容的任何参数。使用这种方法将导致`delete`失败，因为时间戳值必须作为并发检查的一部分传入。相反，你必须手工制作`HttpRequestMessage`。`HttpRequestMessage`的构造函数将`HttpMethod`作为第一个参数，将 URL 作为第二个参数。创建一个新实例，传入作为动词的`HttpDelete`和`Delete()`动作方法的 URL，如下所示:

`HttpRequestMessage request = new HttpRequestMessage(`

`HttpMethod.Delete,`

`$"``http://localhost:46024/api/Inventory/{inventory.CarId`T2】

接下来，使用 JSON.NET 来序列化库存对象，然后将其添加到内容中。序列化调用很简单:

`JsonConvert.SerializeObject(inventory)`

将内容分配给`HttpRequestMessage`时，必须设置编码和类型，即`application.json`，如下所示:

`Content = new StringContent(JsonConvert.SerializeObject(inventory), Encoding.UTF8, "application/json")`

使用对象初始化将所有这些放在一起，您应该得到:

`HttpRequestMessage request = new HttpRequestMessage(`

`HttpMethod.Delete,`

`$"``http://localhost:46024/api/Inventory/{inventory.CarId`T2】

`{`

`Content =`

`new StringContent(JsonConvert.SerializeObject(inventory), Encoding.UTF8, "application/json")`

`};`

最后，通过在`HttpClient`的实例上调用`SendAsync()`来发送消息，从而发送您刚刚创建的请求。完整的`Delete()`方法如下所示:

`// POST: Inventory/Delete/5`

`[HttpPost]`

`[ValidateAntiForgeryToken]`

`public async Task<ActionResult> Delete([Bind(Include = "CarId,Timestamp")]Inventory inventory)`

`{`

`try`

`{`

`var client = new HttpClient();`

`HttpRequestMessage request = new HttpRequestMessage(`

`HttpMethod.Delete,`

`$"``http://localhost:46024/api/Inventory/{inventory.CarId`T2】

`{`

`Content =`

`new StringContent(JsonConvert.SerializeObject(inventory), Encoding.UTF8, "application/json")`

`};`

`var response = await client.SendAsync(request);`

`return RedirectToAction("Index");`

`}`

`catch (DbUpdateConcurrencyException)`

`{`

`ModelState.AddModelError(string.Empty, "Unable to delete record. Another user updated the record.");`

`}`

`catch (Exception ex)`

`{`

`ModelState.AddModelError(string.Empty, $"Unable to create record: {ex.Message}");`

`}`

`return View(inventory);`

`}`

#### 测试应用程序

要运行该应用程序，您需要在开始调试时将 CarLotMVC 和 CarLotWebAPI 都设置为 start。为此，请在解决方案资源管理器中右击该解决方案，然后选择“设置启动项目”。在打开的对话框中，选择“多个启动项目”，将 CarLotMVC 和 CarLotWebAPI 都设置为启动(如图 [34-36](#Fig36) )。

![A978-1-4842-1332-2_34_Fig36_HTML.jpg](img/A978-1-4842-1332-2_34_Fig36_HTML.jpg)

图 34-36。

Setting multiple startup projects

现在，当您按 F5 运行解决方案时，CarLotMVC 项目将加载一个浏览器到主页，CarLotWebAPI 将作为一个无头应用程序运行，等待调用。运行应用程序，单击清单菜单，然后单击页面。从用户的角度来看，该应用程序的工作方式与以前一样。

Source Code

CarLotMVC_Web API 解决方案可以在 [`Chapter 34`](34.html) 子文件夹中找到。

## 摘要

本章研究了 ASP.NET MVC 和 Web API 的许多方面。您从研究模型-视图-控制器模式开始，然后构建您的第一个 MVC 站点。您了解了 MVC 框架的配置约定，作为新项目模板的一部分为您搭建的所有文件，以及创建的文件夹及其用途。您研究了在`App_Start`文件夹中创建的每个类，以及它们如何帮助您创建 MVC 应用程序。您还了解了捆绑和缩小，以及如何在需要时将其关闭。

下一节将讨论路由以及如何将请求定向到控制器和动作。您为“关于”和“联系”页面创建了新的路由，并了解了如何使用路由而不是硬编码的 URL 将用户重定向到站点中的其他资源。

接下来，您为`Inventory`页面创建了一个控制器，并学习了 Visual Studio 内置的脚手架如何创建基本的操作方法和视图。您了解了`HttpGet`和`HttpPost`请求，以及它们如何与路由一起工作，以便更好地控制调用什么动作方法。然后，您更新了操作方法以使用 AutoLotDAL，并更新了签名和代码以适应您的业务需求。

然后，您学习了 Razor 视图引擎、语法、Razor 助手、函数和委托。您还了解了更多关于强类型视图、局部视图和布局的知识。您还学习了使用`ViewBag`、`ViewData`和`TempData`向视图发送数据。

之后，您修改了每个搭建的视图，更新了`InventoryController`动作，添加了验证，并使用 Bootstrap 来修饰 UI。

在接下来的主要部分中，您学习了 Web API。您创建了一个新的 Web API 项目，并检查了搭建的文件和文件夹及其用途。然后，您使用 Visual Studio 脚手架添加控制器及其操作方法。您了解了其他 HTTP 动词，以及它们如何应用于 Web API 路由。您更新了每个 action 方法以使用 AutoLotDAL 和 Entity Framework，并使用 AutoMapper 来避免 EF 延迟加载和序列化的循环引用问题。

在更新了`CarLotWebAPI`中的所有`InventoryController`动作之后，您更新了 CarLotMVC 来调用 CarLotWebAPI 服务的 URL，使用 JSON.NET 来反序列化和反序列化记录。您还了解了如何使用 Web API 使用的附加 HTTP 动词进行调用。