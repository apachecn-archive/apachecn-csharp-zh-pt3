# 10.委托、事件和 Lambda 表达式

到目前为止，您开发的大多数应用程序都向`Main()`添加了各种代码，以某种方式向给定对象发送请求。然而，许多应用程序要求对象能够使用回调机制与创建它的实体进行通信。虽然回调机制可以在任何应用程序中使用，但它们对于图形用户界面尤其重要，因为控件(如按钮)需要在正确的情况下(单击按钮时、鼠标进入按钮表面时等)调用外部方法。

在下面。NET 平台中，委托类型是在应用程序中定义和响应回调的首选方式。本质上。NET 委托类型是一个类型安全的对象，它“指向”一个方法或一组可以在以后调用的方法。然而，与传统的 C++函数指针不同的是。NET 委托是对多播和异步方法调用具有内置支持的类。

在本章中，你将学习如何创建和操作委托类型，然后你将研究 C# `event`关键字，它简化了使用委托类型的过程。在此过程中，您还将研究 C#的几个以委托和事件为中心的语言特性，包括匿名方法和方法组转换。

我通过研究 lambda 表达式来结束这一章。使用 C# lambda 运算符(`=>`)，您可以在任何需要强类型委托的地方指定代码语句块(以及传递给这些代码语句的参数)。正如您将看到的，lambda 表达式只不过是一个伪装的匿名方法，并提供了一种简化的委托处理方法。此外，相同的操作(截至。NET 4.6)可用于使用简洁的语法实现单语句方法或属性。

## 了解。网络委托类型

在正式定义之前。网络代表们，让我们来看一看。历史上，Windows API 经常使用 C 风格的函数指针来创建称为回调函数或简称回调的实体。使用回调，程序员能够配置一个函数来报告(回调)应用程序中的另一个函数。通过这种方法，Windows 开发人员能够处理按钮点击、鼠标移动、菜单选择以及内存中两个实体之间的一般双向通信。

在。NET Framework 中，回调是使用委托以类型安全和面向对象的方式完成的。本质上，委托是一个类型安全的对象，它指向应用程序中的另一个方法(或者可能是一组方法)，可以在以后调用。具体来说，代理维护三条重要的信息。

*   它调用的方法的地址
*   此方法的参数(如果有)
*   此方法的返回类型(如果有)

Note

。NET 委托可以指向静态方法或实例方法。

在委托对象被创建并被赋予必要的信息后，它可以在运行时动态地调用它所指向的方法。中的每个委托。NET Framework(包括您的自定义委托)自动被赋予同步或异步调用其方法的能力。这个事实极大地简化了编程任务，因为您可以在第二个执行线程上调用一个方法，而无需手动创建和管理一个`Thread`对象。

Note

在第 19 章的[中，你将在研究线程和异步调用的过程中研究委托类型的异步行为。在这一章中，你只关心委托类型的同步方面。](19.html)

### 在 C#中定义委托类型

当你想在 C#中创建一个委托类型时，你可以使用`delegate`关键字。您的委托类型的名称可以是您想要的任何名称。但是，您必须定义委托以匹配它将指向的方法的签名。例如，下面的委托类型(名为`BinaryOp`)可以指向任何返回一个整数并接受两个整数作为输入参数的方法(在本章的稍后部分，您将自己构建并使用这个委托，所以暂时不要着急):

`// This delegate can point to any method,`

`// taking two integers and returning an integer.`

`public delegate int BinaryOp(int x, int y);`

当 C#编译器处理委托类型时，它会自动生成一个从`System.MulticastDelegate`派生的密封类。这个类(与它的基类`System.Delegate`一起)为委托提供了必要的基础结构，以保存稍后要调用的方法列表。例如，如果您使用`ildasm.exe`来检查`BinaryOp`委托，您会发现如图 [10-1](#Fig1) 所示的类(如果您想自己检查的话，您将马上构建这个完整的示例)。

![A978-1-4842-1332-2_10_Fig1_HTML.jpg](img/A978-1-4842-1332-2_10_Fig1_HTML.jpg)

图 10-1。

The C# delegate keyword represents a sealed class deriving from System.MulticastDelegate

如您所见，编译器生成的`BinaryOp`类定义了三个公共方法。`Invoke()`可能是关键方法，因为它用于以同步方式调用委托对象维护的每个方法，这意味着调用者必须等待调用完成，然后才能继续。奇怪的是，同步`Invoke()`方法可能不需要从 C#代码中显式调用。正如您马上会看到的，当您使用适当的 C#语法时，`Invoke()`会在幕后被调用。

`BeginInvoke()`和`EndInvoke()`提供了在单独的执行线程上异步调用当前方法的能力。如果您有多线程方面的背景，您会知道开发人员创建辅助执行线程的最常见原因之一是调用需要时间才能完成的方法。虽然。NET 基本类库提供了几个专门用于多线程和并行编程的命名空间，委托提供了现成的这种功能。

现在，编译器如何确切地知道如何定义`Invoke()`、`BeginInvoke()`和`EndInvoke()`方法呢？为了理解这个过程，下面是编译器生成的`BinaryOp`类类型的关键(粗斜体标记了由定义的委托类型指定的项目):

`sealed class``BinaryOp`T2】

`{`

`public``int``Invoke(``int x, int y`T4】

`public IAsyncResult BeginInvoke(``int x, int y`T2】

`AsyncCallback cb, object state);`

`public``int`T2】

`}`

首先，注意为`Invoke()`方法定义的参数和返回类型与`BinaryOp`委托的定义完全匹配。`BeginInvoke()`成员的初始参数(在本例中是两个整数)也基于`BinaryOp`委托；然而，`BeginInvoke()`将总是提供两个最终参数(类型为`AsyncCallback`和`object`)，用于促进异步方法调用。最后，`EndInvoke()`的返回类型与最初的委托声明相同，并且总是将实现`IAsyncResult`接口的对象作为唯一的参数。

让我们看另一个例子。假设您已经定义了一个委托类型，它可以指向任何返回一个`string`并接收三个`System.Boolean`输入参数的方法。

`public delegate string``MyDelegate`T2】

这一次，编译器生成的类分解如下:

`sealed class``MyDelegate`T2】

`{`

`public``string``Invoke(``bool a, bool b, bool c`T4】

`public IAsyncResult BeginInvoke(``bool a, bool b, bool c`T2】

`AsyncCallback cb, object state);`

`public``string`T2】

`}`

委托还可以“指向”包含任意数量的`out`或`ref`参数(以及标有`params`关键字的数组参数)的方法。例如，假设以下委托类型:

`public delegate string MyOtherDelegate(out bool a, ref bool b, int c);`

`Invoke()`和`BeginInvoke()`方法的签名看起来就像你预期的那样；然而，看看下面的`EndInvoke()`方法，它现在包含了由委托类型定义的所有`out` / `ref`参数的集合:

`public sealed class``MyOtherDelegate`T2】

`{`

`public``string``Invoke(``out bool a, ref bool b, int c`T4】

`public IAsyncResult BeginInvoke(``out bool a, ref bool b, int c`T2】

`AsyncCallback cb, object state);`

`public``string``EndInvoke(``out bool a, ref bool b`T4】

`}`

总的来说，C#委托类型定义产生了一个密封的类，它有三个编译器生成的方法，这些方法的参数和返回类型基于委托的声明。以下伪代码近似于基本模式:

`// This is only pseudo-code!`

`public sealed class DelegateName : System.MulticastDelegate`

`{`

`public delegateReturnValue Invoke(``allDelegateInputRefAndOutParams`T2】

`public IAsyncResult BeginInvoke(``allDelegateInputRefAndOutParams`T2】

`AsyncCallback cb, object state);`

`public delegateReturnValue EndInvoke(``allDelegateRefAndOutParams`T2】

`IAsyncResult result);`

`}`

### 系统。多播代理和系统。委托基类

因此，当您使用 C# `delegate`关键字构建类型时，您是在间接声明一个从`System.MulticastDelegate`派生的类类型。该类为后代提供对列表的访问，该列表包含由委托对象维护的方法的地址，以及与调用列表交互的几个附加方法(和几个重载运算符)。以下是`System.MulticastDelegate`的一些精选成员:

`public abstract class MulticastDelegate : Delegate`

`{`

`// Returns the list of methods "pointed to."`

`public sealed override Delegate[] GetInvocationList();`

`// Overloaded operators.`

`public static bool operator ==(MulticastDelegate d1, MulticastDelegate d2);`

`public static bool operator !=(MulticastDelegate d1, MulticastDelegate d2);`

`// Used internally to manage the list of methods maintained by the delegate.`

`private IntPtr _invocationCount;`

`private object _invocationList;`

`}`

`System.MulticastDelegate`从其父类`System.Delegate`获得附加功能。下面是类定义的部分快照:

`public abstract class Delegate : ICloneable, ISerializable`

`{`

`// Methods to interact with the list of functions.`

`public static Delegate Combine(params Delegate[] delegates);`

`public static Delegate Combine(Delegate a, Delegate b);`

`public static Delegate Remove(Delegate source, Delegate value);`

`public static Delegate RemoveAll(Delegate source, Delegate value);`

`// Overloaded operators.`

`public static bool operator ==(Delegate d1, Delegate d2);`

`public static bool operator !=(Delegate d1, Delegate d2);`

`// Properties that expose the delegate target.`

`public MethodInfo Method { get; }`

`public object Target { get; }`

`}`

现在，要明白你永远不能在你的代码中直接从这些基类派生(这样做是一个编译器错误)。然而，当您使用`delegate`关键字时，您已经间接地创建了一个“is-a”`MulticastDelegate`类。表 [10-1](#Tab1) 记录了所有委托类型共有的核心成员。

表 10-1。

Select Members of System.MultcastDelegate/System.Delegate

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `Method` | 该属性返回一个代表由委托维护的静态方法的细节的`System.Reflection.MethodInfo`对象。 |
| `Target` | 如果要调用的方法是在对象级定义的(而不是静态方法)，`Target`返回一个对象，该对象表示由委托维护的方法。如果从`Target`返回的值等于`null`，那么要调用的方法是一个静态成员。 |
| `Combine()` | 此静态方法将方法添加到由委托维护的列表中。在 C#中，您使用重载的`+=`操作符作为一种简写符号来触发这个方法。 |
| `GetInvocationList()` | 该方法返回一个由`System.Delegate`对象组成的数组，每个对象代表一个可能被调用的特定方法。 |
| `Remove()  RemoveAll()` | 这些静态方法从委托的调用列表中移除一个方法(或所有方法)。在 C#中，可以使用重载的`-=`运算符间接调用`Remove()`方法。 |

## 最简单的委托示例

当然，第一次遇到委托时，可能会引起一些混乱。因此，开始吧，让我们看一个简单的控制台应用程序(名为 SimpleDelegate ),它使用了您之前见过的`BinaryOp`委托类型。下面是完整的代码，并附有分析:

`namespace SimpleDelegate`

`{`

`// This delegate can point to any method,`

`// taking two integers and returning an integer.`

`public delegate int BinaryOp(int x, int y);`

`// This class contains methods BinaryOp will`

`// point to.`

`public class SimpleMath`

`{`

`public static int Add(int x, int y)`

`{ return x + y; }`

`public static int Subtract(int x, int y)`

`{ return x - y; }`

`}`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Simple Delegate Example *****\n");`

`// Create a BinaryOp delegate object that`

`// "points to" SimpleMath.Add().`

`BinaryOp b = new BinaryOp(SimpleMath.Add);`

`// Invoke Add() method indirectly using delegate object.`

`Console.WriteLine("10 + 10 is {0}", b(10, 10));`

`Console.ReadLine();`

`}`

`}`

`}`

再次注意`BinaryOp`委托类型声明的格式；它指定`BinaryOp`委托对象可以指向任何一个接受两个整数并返回一个整数的方法(所指向的方法的实际名称是不相关的)。这里，您已经创建了一个名为`SimpleMath`的类，它定义了两个静态方法，这两个方法与`BinaryOp`委托定义的模式相匹配。

当您想要将目标方法分配给给定的委托对象时，只需将方法的名称传递给委托的构造函数。

`// Create a BinaryOp delegate object that`

`// "points to" SimpleMath.Add().`

`BinaryOp b = new BinaryOp(SimpleMath.Add);`

此时，您可以使用类似于直接函数调用的语法来调用所指向的成员。

`// Invoke() is really called here!`

`Console.WriteLine("10 + 10 is {0}", b(10, 10));`

在幕后，运行时实际上在您的`MulticastDelegate`派生类上调用编译器生成的`Invoke()`方法。如果您在`ildasm.exe`中打开您的程序集，并在`Main()`方法中检查 CIL 代码，您可以自己验证这一点。

`.method private hidebysig static void Main(string[] args) cil managed`

`{`

`...`

`callvirt instance int32 SimpleDelegate.BinaryOp::Invoke(int32, int32)`

`}`

C#不要求你在代码库中显式调用`Invoke()`。因为`BinaryOp`可以指向带两个参数的方法，下面的代码语句也是允许的:

`Console.WriteLine("10 + 10 is {0}", b.Invoke(10, 10));`

回想一下。网络委托是类型安全的。因此，如果您试图创建一个指向与模式不匹配的方法的委托对象，就会收到一个编译时错误。举例来说，假设`SimpleMath`类现在定义了一个名为`SquareNumber()`的附加方法，它接受一个整数作为输入。

`public class SimpleMath`

`{`

`...`

`public static int SquareNumber(int a)`

`{ return a * a; }`

`}`

鉴于`BinaryOp`委托只能指向接受两个整数并返回一个整数的方法，下面的代码是非法的，不会被编译:

`// Compiler error! Method does not match delegate pattern!`

`BinaryOp b2 = new BinaryOp(SimpleMath.SquareNumber);`

### 调查委托对象

让我们通过在`Program`类中创建一个静态方法(名为`DisplayDelegateInfo()`)来增加当前示例的趣味。该方法将打印出由委托对象维护的方法的名称，以及定义该方法的类的名称。为此，您将迭代由`GetInvocationList()`返回的`System.Delegate`数组，调用每个对象的`Target`和`Method`属性。

`static void DisplayDelegateInfo(Delegate delObj)`

`{`

`// Print the names of each member in the`

`// delegate’s invocation list.`

`foreach (Delegate d in delObj.GetInvocationList())`

`{`

`Console.WriteLine("Method Name: {0}", d.Method);`

`Console.WriteLine("Type Name: {0}", d.Target);`

`}`

`}`

假设您已经更新了您的`Main()`方法来实际调用这个新的帮助器方法，如下所示:

`BinaryOp b = new BinaryOp(SimpleMath.Add);`

`DisplayDelegateInfo(b);`

您会发现如下所示的输出:

`***** Simple Delegate Example *****`

`Method Name: Int32 Add(Int32, Int32)`

`Type Name:`

`10 + 10 is 20`

注意，当调用`Target`属性时，目标类的名称(`SimpleMath`)当前没有显示。原因是您的`BinaryOp`委托指向一个静态方法，因此没有对象可以引用！然而，如果您将`Add()`和`Subtract()`方法更新为非静态的(只需删除`static`关键字)，您可以创建一个`SimpleMath`类的实例，并使用对象引用指定要调用的方法。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Simple Delegate Example *****\n");`

`// .NET delegates can also point to instance methods as well.`

`SimpleMath m = new SimpleMath();`

`BinaryOp b = new BinaryOp(m.Add);`

`// Show information about this object.`

`DisplayDelegateInfo(b);`

`Console.WriteLine("10 + 10 is {0}", b(10, 10));`

`Console.ReadLine();`

`}`

在这种情况下，您会发现如下所示的输出:

`***** Simple Delegate Example *****`

`Method Name: Int32 Add(Int32, Int32)`

`Type Name: SimpleDelegate.SimpleMath`

`10 + 10 is 20`

Note

SimpleDelegate 项目位于 [`Chapter 10`](10.html) 子目录中。

## 使用委托发送对象状态通知

显然，前面的 SimpleDelegate 示例本质上纯粹是说明性的，因为没有令人信服的理由来定义一个简单地将两个数相加的委托。为了更真实地使用委托类型，让我们使用委托来定义一个`Car`类，它能够通知外部实体它当前的引擎状态。为此，您将采取以下步骤:

Define a new delegate type that will be used to send notifications to the caller.   Declare a member variable of this delegate in the `Car` class.   Create a helper function on the `Car` that allows the caller to specify the method to call back on.   Implement the `Accelerate()` method to invoke the delegate’s invocation list under the correct circumstances.  

首先，创建一个名为 CarDelegate 的新控制台应用程序项目。现在，定义一个新的`Car`类，最初如下所示:

`public class Car`

`{`

`// Internal state data.`

`public int CurrentSpeed { get; set; }`

`public int MaxSpeed { get; set; } = 100;`

`public string PetName { get; set; }`

`// Is the car alive or dead?`

`private bool carIsDead;`

`// Class constructors.`

`public Car() {}`

`public Car(string name, int maxSp, int currSp)`

`{`

`CurrentSpeed = currSp;`

`MaxSpeed = maxSp;`

`PetName = name;`

`}`

`}`

现在，考虑以下更新，这些更新解决了前三点:

`public class Car`

`{`

`...`

`// 1) Define a delegate type.`

`public delegate void CarEngineHandler(string msgForCaller);`

`// 2) Define a member variable of this delegate.`

`private CarEngineHandler listOfHandlers;`

`// 3) Add registration function for the caller.`

`public void RegisterWithCarEngine(CarEngineHandler methodToCall)`

`{`

`listOfHandlers = methodToCall;`

`}`

`}`

请注意，在这个例子中，您直接在`Car`类的范围内定义了委托类型，这当然不是必需的，但确实有助于强化委托自然地与这个特定的类一起工作的思想。委托类型`CarEngineHandler`可以指向任何将单个`string`作为输入并将`void`作为返回值的方法。

接下来，请注意，您声明了一个委托类型的私有成员变量(名为`listOfHandlers`)和一个助手函数(名为`RegisterWithCarEngine()`)，该函数允许调用者将一个方法分配给委托的调用列表。

Note

严格地说，您可以将您的委托成员变量定义为 public，从而避免创建额外的注册方法。但是，通过将委托成员变量定义为 private，您可以实施封装服务并提供更类型安全的解决方案。在本章的后面，当你查看 C# `event`关键字时，你将再次讨论公共委托成员变量的风险。

此时，您需要创建`Accelerate()`方法。回想一下，这里的要点是允许一个`Car`对象向任何订阅的侦听器发送与引擎相关的消息。以下是最新消息:

`// 4) Implement the Accelerate() method to invoke the delegate’s`

`//    invocation list under the correct circumstances.`

`public void Accelerate(int delta)`

`{`

`// If this car is "dead," send dead message.`

`if (carIsDead)`

`{`

`if (listOfHandlers != null)`

`listOfHandlers("Sorry, this car is dead...");`

`}`

`else`

`{`

`CurrentSpeed += delta;`

`// Is this car "almost dead"?`

`if (10 == (MaxSpeed - CurrentSpeed)`

`&& listOfHandlers != null)`

`{`

`listOfHandlers("Careful buddy! Gonna blow!");`

`}`

`if (CurrentSpeed >= MaxSpeed)`

`carIsDead = true;`

`else`

`Console.WriteLine("CurrentSpeed = {0}", CurrentSpeed);`

`}`

`}`

请注意，在调用由`listOfHandlers`成员变量维护的方法之前，您要对照一个`null`值检查它。原因是调用者的工作是通过调用`RegisterWithCarEngine()`助手方法来分配这些对象。如果调用者没有调用这个方法，而你试图调用委托的调用列表，你将在运行时触发一个`NullReferenceException`。既然已经有了委托基础设施，请观察对`Program`类的更新:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Delegates as event enablers *****\n");`

`// First, make a Car object.`

`Car c1 = new Car("SlugBug", 100, 10);`

`// Now, tell the car which method to call`

`// when it wants to send us messages.`

`c1.RegisterWithCarEngine(new Car.CarEngineHandler(OnCarEngineEvent));`

`// Speed up (this will trigger the events).`

`Console.WriteLine("***** Speeding up *****");`

`for (int i = 0; i < 6; i++)`

`c1.Accelerate(20);`

`Console.ReadLine();`

`}`

`// This is the target for incoming events.`

`public static void OnCarEngineEvent(string msg)`

`{`

`Console.WriteLine("\n***** Message From Car Object *****");`

`Console.WriteLine("=> {0}", msg);`

`Console.WriteLine("***********************************\n");`

`}`

`}`

`Main()`方法从简单地创建一个新的`Car`对象开始。既然您对引擎事件感兴趣，那么下一步就是调用您的定制注册函数`RegisterWithCarEngine()`。回想一下，该方法期望被传递一个嵌套的`CarEngineHandler`委托的实例，并且与任何委托一样，您指定一个“指向的方法”作为构造函数参数。这个例子中的诀窍在于，所讨论的方法位于`Program`类中！再次注意到，`OnCarEngineEvent()`方法与相关委托完全匹配，因为它接受一个`string`作为输入并返回`void`。考虑当前示例的输出:

`***** Delegates as event enablers *****`

`***** Speeding up *****`

`CurrentSpeed = 30`

`CurrentSpeed = 50`

`CurrentSpeed = 70`

`***** Message From Car Object *****`

`=> Careful buddy! Gonna blow!`

`***********************************`

`CurrentSpeed = 90`

`***** Message From Car Object *****`

`=> Sorry, this car is dead...`

`***********************************`

### 启用多播

回想一下。NET 委托具有多播的内置功能。换句话说，委托对象可以维护要调用的方法列表，而不仅仅是单个方法。当你想给一个委托对象添加多个方法时，你只需使用重载的`+=`操作符，而不是直接赋值。要在`Car`类上启用多播，您可以更新`RegisterWithCarEngine()`方法，如下所示:

`public class Car`

`{`

`// Now with multicasting support!`

`// Note we are now using the += operator, not`

`// the assignment operator (=).`

`public void RegisterWithCarEngine(CarEngineHandler methodToCall)`

`{`

`listOfHandlers += methodToCall;`

`}`

`...`

`}`

当您在委托对象上使用`+=`操作符时，编译器将其解析为对静态`Delegate.Combine()`方法的调用。事实上，你可以直接给`Delegate.Combine()`打电话；然而，`+=`操作符提供了一个更简单的选择。没有必要修改你当前的`RegisterWithCarEngine()`方法，但是这里有一个例子，如果使用`Delegate.Combine()`而不是`+=`操作符:

`public void RegisterWithCarEngine( CarEngineHandler methodToCall )`

`{`

`if (listOfHandlers == null)`

`listOfHandlers = methodToCall;`

`else`

`Delegate.Combine(listOfHandlers, methodToCall);`

`}`

无论如何，调用者现在可以为同一个回调通知注册多个目标。这里，第二个处理程序以大写形式打印传入的消息，只是为了显示:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Delegates as event enablers *****\n");`

`// First, make a Car object.`

`Car c1 = new Car("SlugBug", 100, 10);`

`// Register multiple targets for the notifications.`

`c1.RegisterWithCarEngine(new Car.CarEngineHandler(OnCarEngineEvent));`

`c1.RegisterWithCarEngine(new Car.CarEngineHandler(OnCarEngineEvent2));`

`// Speed up (this will trigger the events).`

`Console.WriteLine("***** Speeding up *****");`

`for (int i = 0; i < 6; i++)`

`c1.Accelerate(20);`

`Console.ReadLine();`

`}`

`// We now have TWO methods that will be called by the Car`

`// when sending notifications.`

`public static void OnCarEngineEvent(string msg)`

`{`

`Console.WriteLine("\n***** Message From Car Object *****");`

`Console.WriteLine("=> {0}", msg);`

`Console.WriteLine("***********************************\n");`

`}`

`public static void OnCarEngineEvent2(string msg)`

`{`

`Console.WriteLine("=> {0}", msg.ToUpper());`

`}`

`}`

### 从委托的调用列表中删除目标

`Delegate`类还定义了一个静态的`Remove()`方法，允许调用者从委托对象的调用列表中动态删除一个方法。这使得允许调用者在运行时“取消订阅”给定的通知变得简单。虽然您可以在代码中直接调用`Delegate.Remove()`，但是 C#开发人员可以使用`-=`操作符作为一种方便的简写符号。让我们给`Car`类添加一个新方法，它允许调用者从调用列表中删除一个方法。

`public class Car`

`{`

`...`

`public void UnRegisterWithCarEngine(CarEngineHandler methodToCall)`

`{`

`listOfHandlers -= methodToCall;`

`}`

`}`

使用当前对`Car`类的更新，您可以通过如下更新`Main()`来停止在第二个处理程序上接收引擎通知:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Delegates as event enablers *****\n");`

`// First, make a Car object.`

`Car c1 = new Car("SlugBug", 100, 10);`

`c1.RegisterWithCarEngine(new Car.CarEngineHandler(OnCarEngineEvent));`

`// This time, hold onto the delegate object,`

`// so we can unregister later.`

`Car.CarEngineHandler handler2 = new Car.CarEngineHandler(OnCarEngineEvent2);`

`c1.RegisterWithCarEngine(handler2);`

`// Speed up (this will trigger the events).`

`Console.WriteLine("***** Speeding up *****");`

`for (int i = 0; i < 6; i++)`

`c1.Accelerate(20);`

`// Unregister from the second handler.`

`c1.UnRegisterWithCarEngine(handler2);`

`// We won’t see the "uppercase" message anymore!`

`Console.WriteLine("***** Speeding up *****");`

`for (int i = 0; i < 6; i++)`

`c1.Accelerate(20);`

`Console.ReadLine();`

`}`

`Main()`中的一个不同之处是，这一次您创建了一个`Car.CarEngineHandler`对象，并将其存储在一个局部变量中，这样您就可以在以后使用该对象来注销通知。因此，第二次加速`Car`对象时，您将不再看到输入消息数据的大写版本，因为您已经从委托的调用列表中删除了这个目标。

Source Code

CarDelegate 项目位于 [`Chapter 10`](10.html) 子目录中。

### 方法组转换语法

在前面的 CarDelegate 示例中，您显式创建了`Car.CarEngineHandler` delegate 对象的实例，以便向引擎通知注册和注销。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Delegates as event enablers *****\n");`

`Car c1 = new Car("SlugBug", 100, 10);`

`c1.RegisterWithCarEngine(``new Car.CarEngineHandler(OnCarEngineEvent)`T2】

`Car.CarEngineHandler handler2 =`

`new Car.CarEngineHandler(OnCarEngineEvent2);`

`c1.RegisterWithCarEngine(handler2);`

`...`

`}`

可以肯定的是，如果您需要调用`MulticastDelegate`或`Delegate`的任何继承成员，手动创建一个委托变量是最简单的方法。然而，在大多数情况下，您并不真正需要抓住委托对象不放。相反，您通常只需要使用委托对象将方法名作为构造函数参数传入。

作为一种简化，C#提供了一种称为方法组转换的快捷方式。当调用以委托作为参数的方法时，此功能允许您提供直接的方法名，而不是委托对象。

Note

正如你将在本章后面看到的，你也可以使用方法组转换语法来简化你注册 C#事件的方式。

举例来说，创建一个名为 CarDelegateMethodGroupConversion 的新控制台应用程序项目，并插入包含您在 CarDelegate 项目中定义的`Car`类的文件(并更新`Car.cs`文件中的名称空间名称以匹配您的新名称空间名称)。现在，考虑下面的`Program`类，它使用方法组转换来注册和注销引擎通知:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Method Group Conversion *****\n");`

`Car c1 = new Car();`

`// Register the simple method name.`

`c1.RegisterWithCarEngine(CallMeHere);`

`Console.WriteLine("***** Speeding up *****");`

`for (int i = 0; i < 6; i++)`

`c1.Accelerate(20);`

`// Unregister the simple method name.`

`c1.UnRegisterWithCarEngine(CallMeHere);`

`// No more notifications!`

`for (int i = 0; i < 6; i++)`

`c1.Accelerate(20);`

`Console.ReadLine();`

`}`

`static void CallMeHere(string msg)`

`{`

`Console.WriteLine("=> Message from Car: {0}", msg);`

`}`

`}`

请注意，您不是直接分配相关的委托对象，而是简单地指定一个与委托的预期签名相匹配的方法(在本例中，该方法返回`void`并接受一个`string`)。要明白 C#编译器仍然在确保类型安全。因此，如果`CallMeHere()`方法没有接受`string`并返回`void`，就会出现编译器错误。

Source Code

CarDelegateMethodGroupConversion 项目位于 [`Chapter 10`](10.html) 子目录中。

## 了解泛型委托

在前一章中，我提到 C#允许你定义通用的委托类型。例如，假设您想要定义一个委托类型，它可以调用任何返回`void`并接收单个参数的方法。如果所讨论的参数可能不同，您可以使用类型参数对此进行建模。为了说明这一点，请考虑名为 GenericDelegate 的新控制台应用程序项目中的以下代码:

`namespace GenericDelegate`

`{`

`// This generic delegate can represnet any method`

`// returning void and taking a single parameter of type T.`

`public delegate void MyGenericDelegate<T>(T arg);`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Generic Delegates *****\n");`

`// Register targets.`

`MyGenericDelegate<string> strTarget =`

`new MyGenericDelegate<string>(StringTarget);`

`strTarget("Some string data");`

`MyGenericDelegate<int> intTarget =`

`new MyGenericDelegate<int>(IntTarget);`

`intTarget(9);`

`Console.ReadLine();`

`}`

`static void StringTarget(string arg)`

`{`

`Console.WriteLine("arg in uppercase is: {0}", arg.ToUpper());`

`}`

`static void IntTarget(int arg)`

`{`

`Console.WriteLine("++arg is: {0}", ++arg);`

`}`

`}`

`}`

注意，`MyGenericDelegate<T>`定义了一个类型参数，它表示传递给委托目标的参数。创建此类型的实例时，需要指定类型参数的值，以及委托将调用的方法的名称。因此，如果您指定了一个字符串类型，您将向目标方法发送一个字符串值。

`// Create an instance of MyGenericDelegate<T>`

`// with string as the type parameter.`

`MyGenericDelegate<string> strTarget =`

`new MyGenericDelegate<string>(StringTarget);`

`strTarget("Some string data");`

给定`strTarget`对象的格式，`StringTarget()`方法现在必须将单个字符串作为参数。

`static void StringTarget(string arg)`

`{`

`Console.WriteLine("arg in uppercase is: {0}", arg.ToUpper());`

`}`

Source Code

GenericDelegate 项目位于 [`Chapter 10`](10.html) 子目录中。

### 通用动作<>和功能<>委托

在本章的过程中，你已经看到了当你想在你的应用程序中使用委托来启用回调时，你通常遵循如下所示的步骤:

*   定义与所指向方法的格式相匹配的自定义委托。
*   创建自定义委托的实例，将方法名作为构造函数参数传入。
*   通过调用委托对象上的`Invoke()`来间接调用该方法。

当您采用这种方法时，您通常会得到许多自定义委托，这些委托可能永远不会在当前任务之外使用(例如，`MyGenericDelegate<T>`、`CarEngineHandler`等等)。虽然可能确实需要为项目定制一个唯一命名的委托类型，但在其他情况下，委托类型的确切名称并不重要。在许多情况下，您只是希望“某个委托”接受一组参数，并可能有一个不同于`void`的返回值。在这些情况下，您可以使用框架内置的`Action<>`和`Func<>`委托类型。为了说明它们的用途，创建一个名为 ActionAndFuncDelegates 的新控制台应用程序项目。

通用的`Action<>`委托在`mscorlib.dll`和`System.Core.dll`程序集的`System`命名空间中定义。您可以使用这个泛型委托来“指向”一个最多接受 16 个参数的方法(这应该足够了！)并返回`void`。现在回想一下，因为`Action<>`是一个泛型委托，您还需要指定每个参数的底层类型。

更新您的`Program`类来定义一个新的静态方法，它接受三个(或更多)唯一的参数。这里有一个例子:

`// This is a target for the Action<> delegate.`

`static void DisplayMessage(string msg, ConsoleColor txtColor, int printCount)`

`{`

`// Set color of console text.`

`ConsoleColor previous = Console.ForegroundColor;`

`Console.ForegroundColor = txtColor;`

`for (int i = 0; i < printCount; i++)`

`{`

`Console.WriteLine(msg);`

`}`

`// Restore color.`

`Console.ForegroundColor = previous;`

`}`

现在，您可以使用现成的`Action<>`委托，而不是手动构建一个自定义委托来将程序流传递给`DisplayMessage()`方法，如下所示:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Action and Func *****");`

`// Use the Action<> delegate to point to DisplayMessage.`

`Action<string, ConsoleColor, int> actionTarget =`

`new Action<string, ConsoleColor, int>(DisplayMessage);`

`actionTarget("Action Message!", ConsoleColor.Yellow, 5);`

`Console.ReadLine();`

`}`

如您所见，使用`Action<>`委托可以省去定义定制委托类型的麻烦。然而，回想一下，`Action<>`委托类型只能指向采用`void`返回值的方法。如果您想指向一个确实有返回值的方法(并且不想麻烦自己编写自定义委托)，您可以使用`Func<>`。

通用的`Func<>`委托可以指向(像`Action<>`)最多接受 16 个参数和一个自定义返回值的方法。为了举例说明，将下面的新方法添加到`Program`类中:

`// Target for the Func<> delegate.`

`static int Add(int x, int y)`

`{`

`return x + y;`

`}`

在本章的前面，我让你构建一个定制的`BinaryOp`委托来“指向”加减法。然而，您可以使用一个总共有三个类型参数的版本的`Func<>`来简化您的工作。要知道`Func<>`的最终类型参数总是方法的返回值。为了巩固这一点，假设`Program`类还定义了以下方法:

`static string SumToString(int x, int y)`

`{`

`return (x + y).ToString();`

`}`

现在，`Main()`方法可以调用这些方法中的每一个，如下所示:

`Func<int, int, int> funcTarget = new Func<int, int, int>(Add);`

`int result = funcTarget.Invoke(40, 40);`

`Console.WriteLine("40 + 40 = {0}", result);`

`Func<int, int, string> funcTarget2 = new Func<int, int, string>(SumToString);`

`string sum = funcTarget2(90, 300);`

`Console.WriteLine(sum);`

还记得方法组转换语法将允许您将前面的代码简化为以下内容:

`Func<int, int, int> funcTarget = Add;`

`int result = funcTarget.Invoke(40, 40);`

`Console.WriteLine("40 + 40 = {0}", result);`

`Func<int, int, string> funcTarget2 = SumToString;`

`string sum = funcTarget2(90, 300);`

`Console.WriteLine(sum);`

在任何情况下，考虑到`Action<>`和`Func<>`可以让您省去手动定义自定义委托的步骤，您可能想知道是否应该一直使用它们。与编程的许多方面一样，答案是“视情况而定”在许多情况下，`Action<>`和`Func<>`将是首选的行动方案(没有双关语)。但是，如果您需要一个具有自定义名称的委托，并且您认为它有助于更好地捕获您的问题域，那么构建自定义委托就像一条代码语句一样简单。在阅读本文的剩余部分时，您将会看到这两种方法。

Note

许多重要的。NET APIs 大量使用了`Action<>`和`Func<>`委托，包括并行编程框架和 LINQ(等等)。

这就结束了我们对。NET 委托类型。在本章的结尾，你会看到一些关于使用委托的细节，在你研究多线程和异步调用的时候，你会在第 19 章中再次看到。接下来，让我们继续讨论 C# `event`关键字的相关主题。

Source Code

ActionAndFuncDelegates 项目位于 [`Chapter 10`](10.html) 子目录中。

## 了解 C#事件

委托是相当有趣的构造，因为它们使内存中的对象能够进行双向对话。然而，在 raw 中使用委托可能需要创建一些样板代码(定义委托、声明必要的成员变量、创建自定义注册和注销方法以保留封装，等等)。).

此外，当您使用 raw 中的委托作为应用程序的回调机制时，如果您没有将类的委托成员变量定义为 private，调用方将可以直接访问委托对象。在这种情况下，调用者可以将变量重新分配给一个新的委托对象(有效地删除当前要调用的函数列表)，更糟糕的是，调用者可以直接调用委托的调用列表。为了说明这个问题，考虑对前一个 CarDelegate 示例中的`Car`类的以下修改(和简化):

`public class Car`

`{`

`public delegate void CarEngineHandler(string msgForCaller);`

`// Now a public member!`

`public CarEngineHandler listOfHandlers;`

`// Just fire out the Exploded notification.`

`public void Accelerate(int delta)`

`{`

`if (listOfHandlers != null)`

`listOfHandlers("Sorry, this car is dead...");`

`}`

`}`

请注意，您不再拥有用自定义注册方法封装的私有委托成员变量。因为这些成员确实是公共的，所以调用者可以直接访问`listOfHandlers`成员变量，并将该类型重新分配给新的`CarEngineHandler`对象，并在需要时调用委托。

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Agh! No Encapsulation! *****\n");`

`// Make a Car.`

`Car myCar = new Car();`

`// We have direct access to the delegate!`

`myCar.listOfHandlers = new Car.CarEngineHandler(CallWhenExploded);`

`myCar.Accelerate(10);`

`// We can now assign to a whole new object...`

`// confusing at best.`

`myCar.listOfHandlers = new Car.CarEngineHandler(CallHereToo);`

`myCar.Accelerate(10);`

`// The caller can also directly invoke the delegate!`

`myCar.listOfHandlers.Invoke("hee, hee, hee...");`

`Console.ReadLine();`

`}`

`static void CallWhenExploded(string msg)`

`{ Console.WriteLine(msg); }`

`static void CallHereToo(string msg)`

`{ Console.WriteLine(msg); }`

`}`

公开公共委托成员会破坏封装，这不仅会导致代码难以维护(和调试),还会使您的应用程序面临潜在的安全风险！以下是当前示例的输出:

`***** Agh! No Encapsulation! *****`

`Sorry, this car is dead...`

`Sorry, this car is dead...`

`hee, hee, hee...`

显然，您不希望让其他应用程序有权更改委托所指向的内容，或者在未经您允许的情况下调用成员。鉴于此，通常的做法是声明私有委托成员变量。

Source Code

PublicDelegateProblem 项目位于 [`Chapter 10`](10.html) 子目录下。

### C#事件关键字

作为一种快捷方式，C#提供了`event`关键字，这样您就不必构建自定义方法来向委托的调用列表添加或移除方法。当编译器处理`event`关键字时，会自动为您提供注册和注销方法，以及您的委托类型所需的任何成员变量。这些委托成员变量总是被声明为私有的，因此，它们不会从触发事件的对象中直接公开。当然，`event`关键字可以用来简化定制类向外部对象发送通知的方式。

定义事件是一个两步过程。首先，您需要定义一个委托类型(或者重用一个现有的类型),它将保存事件触发时要调用的方法列表。接下来，根据相关的委托类型声明一个事件(使用 C# `event`关键字)。

为了说明`event`关键字，创建一个名为 CarEvents 的新控制台应用程序。在这个`Car`类的迭代中，您将定义两个名为`AboutToBlow`和`Exploded`的事件。这些事件与一个名为`CarEngineHandler`的委托类型相关联。下面是对`Car`类的初始更新:

`public class Car`

`{`

`// This delegate works in conjunction with the`

`// Car’s events.`

`public delegate void CarEngineHandler(string msg);`

`// This car can send these events.`

`public event CarEngineHandler Exploded;`

`public event CarEngineHandler AboutToBlow;`

`...`

`}`

向调用者发送事件非常简单，只需按名称指定事件，以及相关委托定义的任何必需参数。为了确保调用者确实注册了事件，在调用委托的方法集之前，您需要对照一个`null`值来检查事件。考虑到这几点，下面是`Car`的`Accelerate()`方法的新迭代:

`public void Accelerate(int delta)`

`{`

`// If the car is dead, fire Exploded event.`

`if (carIsDead)`

`{`

`if (Exploded != null)`

`Exploded("Sorry, this car is dead...");`

`}`

`else`

`{`

`CurrentSpeed += delta;`

`// Almost dead?`

`if (10 == MaxSpeed - CurrentSpeed`

`&& AboutToBlow != null)`

`{`

`AboutToBlow("Careful buddy! Gonna blow!");`

`}`

`// Still OK!`

`if (CurrentSpeed >= MaxSpeed)`

`carIsDead = true;`

`else`

`Console.WriteLine("CurrentSpeed = {0}", CurrentSpeed);`

`}`

`}`

这样，您就可以配置 car 来发送两个定制事件，而不必定义定制注册函数或声明委托成员变量。您将很快看到这种新汽车的用法，但首先让我们更详细地检查一下事件架构。

### 幕后事件

当编译器处理 C# `event`关键字时，它会生成两个隐藏方法，一个有一个`add_`前缀，另一个有一个`remove_`前缀。每个前缀后跟 C#事件的名称。例如，`Exploded`事件产生了两个名为`add_Exploded()`和`remove_Exploded()`的隐藏方法。如果您要查看`add_AboutToBlow()`后面的 CIL 指令，您会发现对`Delegate.Combine()`方法的调用。考虑部分 CIL 码:

`.method public hidebysig specialname instance void`

`add_AboutToBlow(class CarEvents.Car/CarEngineHandler ’value’) cil managed`

`{`

`...`

`call class [mscorlib]System.Delegate`

`[mscorlib]System.Delegate::Combine(`

`class [mscorlib]System.Delegate, class [mscorlib]System.Delegate)`

`...`

`}`

正如您所料，`remove_AboutToBlow()`将代表您调用`Delegate.Remove()`。

`.method public hidebysig specialname instance void`

`remove_AboutToBlow(class CarEvents.Car/CarEngineHandler ’value’)`

`cil managed`

`{`

`...`

`call class [mscorlib]System.Delegate`

`[mscorlib]System.Delegate::Remove(`

`class [mscorlib]System.Delegate, class [mscorlib]System.Delegate)`

`...`

`}`

最后，代表事件本身的 CIL 代码利用`.addon`和`.removeon`指令来映射要调用的正确的`add_XXX() and remove_XXX()`方法的名称。

`.event CarEvents.Car/EngineHandler AboutToBlow`

`{`

`.addon instance void CarEvents.Car::add_AboutToBlow`

`(class CarEvents.Car/CarEngineHandler)`

`.removeon instance void CarEvents.Car::remove_AboutToBlow`

`(class CarEvents.Car/CarEngineHandler)`

`}`

既然您已经理解了如何构建一个可以发送 C#事件的类(并且意识到事件只不过是一个节省键入时间的工具)，下一个大问题就是如何在调用者端监听传入的事件。

### 监听传入事件

C#事件还简化了注册调用方事件处理程序的操作。调用者不必指定定制的助手方法，而是直接使用`+=`和`-=`操作符(这将在后台触发正确的`add_XXX()`或`remove_XXX()`方法)。当您想要注册某个事件时，请遵循此处显示的模式:

`// NameOfObject.NameOfEvent += new RelatedDelegate(functionToCall);`

`//`

`Car.CarEngineHandler d = new Car.CarEngineHandler(CarExplodedEventHandler);`

`myCar.Exploded += d;`

当您想要从事件源分离时，使用`-=`操作符，使用以下模式:

`// NameOfObject.NameOfEvent -= new RelatedDelegate(functionToCall);`

`//`

`myCar.Exploded -= d;`

给定这些非常可预测的模式，下面是重构的`Main()`方法，现在使用 C#事件注册语法:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Events *****\n");`

`Car c1 = new Car("SlugBug", 100, 10);`

`// Register event handlers.`

`c1.AboutToBlow += new Car.CarEngineHandler(CarIsAlmostDoomed);`

`c1.AboutToBlow += new Car.CarEngineHandler(CarAboutToBlow);`

`Car.CarEngineHandler d = new Car.CarEngineHandler(CarExploded);`

`c1.Exploded += d;`

`Console.WriteLine("***** Speeding up *****");`

`for (int i = 0; i < 6; i++)`

`c1.Accelerate(20);`

`// Remove CarExploded method`

`// from invocation list.`

`c1.Exploded -= d;`

`Console.WriteLine("\n***** Speeding up *****");`

`for (int i = 0; i < 6; i++)`

`c1.Accelerate(20);`

`Console.ReadLine();`

`}`

`public static void CarAboutToBlow(string msg)`

`{ Console.WriteLine(msg); }`

`public static void CarIsAlmostDoomed(string msg)`

`{ Console.WriteLine("=> Critical Message from Car: {0}", msg); }`

`public static void CarExploded(string msg)`

`{ Console.WriteLine(msg); }`

`}`

为了进一步简化事件注册，可以使用方法组转换。考虑下面的`Main()`迭代:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Events *****\n");`

`Car c1 = new Car("SlugBug", 100, 10);`

`// Register event handlers.`

`c1.AboutToBlow += CarIsAlmostDoomed;`

`c1.AboutToBlow += CarAboutToBlow;`

`c1.Exploded += CarExploded;`

`Console.WriteLine("***** Speeding up *****");`

`for (int i = 0; i < 6; i++)`

`c1.Accelerate(20);`

`c1.Exploded -= CarExploded;`

`Console.WriteLine("\n***** Speeding up *****");`

`for (int i = 0; i < 6; i++)`

`c1.Accelerate(20);`

`Console.ReadLine();`

`}`

### 使用 Visual Studio 简化事件注册

Visual Studio 为注册事件处理程序的过程提供了帮助。当您在事件注册期间应用`+=`语法时，您会发现显示了一个智能感知窗口，邀请您按 Tab 键来自动完成关联的委托实例(参见图 [10-2](#Fig2) )，这是使用方法组转换语法捕获的。

![A978-1-4842-1332-2_10_Fig2_HTML.jpg](img/A978-1-4842-1332-2_10_Fig2_HTML.jpg)

图 10-2。

Delegate selection IntelliSense

点击 Tab 键后，IDE 会自动生成新方法，如图 [10-3](#Fig3) 所示。

![A978-1-4842-1332-2_10_Fig3_HTML.jpg](img/A978-1-4842-1332-2_10_Fig3_HTML.jpg)

图 10-3。

Delegate target format IntelliSense

注意存根代码是委托目标的正确格式(注意这个方法已经被声明为静态的，因为事件是在静态方法中注册的)。

`static void NewCar_AboutToBlow(string msg)`

`{`

`// Delete the following line and add your code!`

`throw new NotImplementedException();`

`}`

所有人都可以使用智能感知。基类库中的. NET 事件。这个 IDE 特性节省了大量时间，因为它使您不必搜索。NET 帮助系统计算出用于特定事件的正确委托以及委托目标方法的格式。

### 使用 C# 6.0 空条件运算符清理事件调用

在当前的例子中，您很可能注意到，在向任何侦听器触发事件之前，您确保检查了`null`。这一点很重要，因为如果没有人监听您的事件，但您还是触发了它，那么您将在运行时收到一个空引用异常。虽然很重要，但你可能会同意对`null`进行大量的条件检查有点笨拙。

幸运的是，在当前版本的 C#中，您可以利用空条件操作符(`?`)，它本质上是自动执行这种检查。请注意，当使用这个新的简化语法时，您必须手动调用底层委托的`Invoke()`方法。例如，与其这样说:

`// If the car is dead, fire Exploded event.`

`if (carIsDead)`

`{`

`if (Exploded != null)`

`Exploded("Sorry, this car is dead...");`

`}`

我们现在可以简单地说如下:

`// If the car is dead, fire Exploded event.`

`if (carIsDead)`

`{`

`Exploded?.Invoke("Sorry, this car is dead...");`

`}`

你也可以用类似的方式更新触发`AboutToBlow`事件的代码(注意这里我把对`null`的检查从原来的`if`语句中移出):

`// Almost dead?`

`if (10 == MaxSpeed - CurrentSpeed)`

`{`

`AboutToBlow?.Invoke("Careful buddy!  Gonna blow!");`

`}`

由于简化的语法，在触发事件时，您可能更喜欢 null 条件运算符。然而，必要时手动检查`null`仍然是完全可以接受的。

Source Code

CarEvents 项目位于 [`Chapter 10`](10.html) 子目录中。

### 创建自定义事件参数

说实话，你可以对当前的`Car`类做最后一个增强，它反映了微软推荐的事件模式。当你开始研究基类库中给定类型发送的事件时，你会发现底层委托的第一个参数是一个`System.Object`，而第二个参数是`System.EventArgs`的后代。

`System.Object`参数表示对发送事件的对象的引用(比如`Car`)，而第二个参数表示关于当前事件的信息。`System.EventArgs`基类表示不发送任何自定义信息的事件。

`public class EventArgs`

`{`

`public static readonly EventArgs Empty;`

`public EventArgs();`

`}`

对于简单的事件，可以直接传递一个`EventArgs`的实例。然而，当您想要传递自定义数据时，您应该构建一个从`EventArgs`派生的合适的类。对于这个例子，假设您有一个名为`CarEventArgs`的类，它维护一个表示发送给接收者的消息的字符串。

`public class CarEventArgs : EventArgs`

`{`

`public readonly string msg;`

`public CarEventArgs(string message)`

`{`

`msg = message;`

`}`

`}`

这样，您现在可以如下更新`CarEngineHandler`委托类型定义(事件将保持不变):

`public class Car`

`{`

`public delegate void CarEngineHandler(object sender, CarEventArgs e);`

`...`

`}`

这里，当从`Accelerate()`方法中触发事件时，您现在需要提供一个对当前`Car`(通过`this`关键字)的引用和一个`CarEventArgs`类型的实例。例如，考虑以下部分更新:

`public void Accelerate(int delta)`

`{`

`// If the car is dead, fire Exploded event.`

`if (carIsDead)`

`{`

`Exploded?.Invoke(this, new CarEventArgs("Sorry, this car is dead..."));`

`}`

`...`

`}`

在调用者端，您需要做的就是更新您的事件处理程序来接收传入的参数并通过只读字段获取消息。这里有一个例子:

`public static void CarAboutToBlow(object sender, CarEventArgs e)`

`{`

`Console.WriteLine("{0} says: {1}", sender, e.msg);`

`}`

如果接收者想要与发送事件的对象交互，可以显式地强制转换`System.Object`。从这个引用中，您可以利用发送事件通知的对象的任何公共成员。

`public static void CarAboutToBlow(object sender, CarEventArgs e)`

`{`

`// Just to be safe, perform a`

`// runtime check before casting.`

`if (sender is Car)`

`{`

`Car c = (Car)sender;`

`Console.WriteLine("Critical Message from {0}: {1}", c.PetName, e.msg);`

`}`

`}`

Source Code

CarEventArgs 项目位于 [`Chapter 10`](10.html) 子目录下。

### 通用 EventHandler <t>委托</t>

鉴于如此多的自定义委托将一个`object`作为第一个参数，将一个`EventArgs`后代作为第二个参数，您可以通过使用通用的`EventHandler<T>`类型来进一步简化前面的示例，其中`T`是您的自定义`EventArgs`类型。考虑下面对`Car`类型的更新(注意您不再需要定义自定义委托类型):

`public class Car`

`{`

`public event EventHandler<CarEventArgs> Exploded;`

`public event EventHandler<CarEventArgs> AboutToBlow;`

`...`

`}`

然后，`Main()`方法可以在您之前指定了`CarEventHandler`的任何地方使用`EventHandler<CarEventArgs>`(或者，再次使用方法组转换)。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Prim and Proper Events *****\n");`

`// Make a car as usual.`

`Car c1 = new Car("SlugBug", 100, 10);`

`// Register event handlers.`

`c1.AboutToBlow += CarIsAlmostDoomed;`

`c1.AboutToBlow += CarAboutToBlow;`

`EventHandler<CarEventArgs> d = new EventHandler<CarEventArgs>(CarExploded);`

`c1.Exploded += d;`

`...`

`}`

太好了。至此，您已经看到了在 C#语言中使用委托和事件的核心方面。虽然您可以使用这些信息来满足所有的回调需求，但是在本章结束时，您将会看到一些最终的简化，特别是匿名方法和 lambda 表达式。

Source Code

GenericCarEventArgs 项目位于 [`Chapter 10`](10.html) 子目录中。

## 了解 C#匿名方法

正如您所看到的，当调用者想要监听传入事件时，它必须在一个类(或结构)中定义一个自定义方法，该方法与相关委托的签名相匹配。这里有一个例子:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`SomeType t = new SomeType();`

`// Assume "SomeDelegate" can point to methods taking no`

`// args and returning void.`

`t.SomeEvent += new SomeDelegate(MyEventHandler);`

`}`

`// Typically only called by the SomeDelegate object.`

`public static void MyEventHandler()`

`{`

`// Do something when event is fired.`

`}`

`}`

然而，仔细想想，像`MyEventHandler()`这样的方法很少会被程序中除了调用委托之外的任何部分调用。就生产效率而言，手动定义一个由委托对象调用的单独方法有点麻烦(尽管这绝不是一个阻碍)。

为了解决这一点，可以在事件注册时将事件直接关联到代码语句块。形式上，这种代码被称为匿名方法。为了说明语法，请看下面的`Main()`方法，它使用匿名方法处理从`Car`类发送的事件，而不是专门命名的事件处理程序:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Anonymous Methods *****\n");`

`Car c1 = new Car("SlugBug", 100, 10);`

`// Register event handlers as anonymous methods.`

`c1.AboutToBlow += delegate`

`{`

`Console.WriteLine("Eek! Going too fast!");`

`};`

`c1.AboutToBlow += delegate(object sender, CarEventArgs e)`

`{`

`Console.WriteLine("Message from Car: {0}", e.msg);`

`};`

`c1.Exploded += delegate(object sender, CarEventArgs e)`

`{`

`Console.WriteLine("Fatal Message from Car: {0}", e.msg);`

`};`

`// This will eventually trigger the events.`

`for (int i = 0; i < 6; i++)`

`c1.Accelerate(20);`

`Console.ReadLine();`

`}`

`}`

Note

匿名方法的最后一个花括号必须以分号结束。如果不这样做，就会出现编译错误。

同样，请注意，`Program`类型不再定义特定的静态事件处理程序，如`CarAboutToBlow()`或`CarExploded()`。相反，未命名(也称为匿名)方法是在调用者使用`+=`语法处理事件时内联定义的。匿名方法的基本语法与以下伪代码相匹配:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`SomeType t = new SomeType();`

`t.SomeEvent += delegate (optionallySpecifiedDelegateArgs)`

`{ /* statements */ };`

`}`

`}`

当处理前一个`Main()`方法中的第一个`AboutToBlow`事件时，请注意，您没有指定从委托传递的参数。

`c1.AboutToBlow += delegate`

`{`

`Console.WriteLine("Eek! Going too fast!");`

`};`

严格地说，您不需要接收特定事件发送的传入参数。但是，如果您想要利用可能的传入参数，您将需要指定由委托类型原型化的参数(如第二个对`AboutToBlow`和`Exploded`事件的处理所示)。这里有一个例子:

`c1.AboutToBlow += delegate(object sender, CarEventArgs e)`

`{`

`Console.WriteLine("Critical Message from Car: {0}", e.msg);`

`};`

### 访问局部变量

匿名方法很有趣，因为它们能够访问定义它们的方法的局部变量。从形式上讲，这样的变量被称为匿名方法的外部变量。关于匿名方法作用域和定义方法作用域之间的交互，应该提到几个要点。

*   匿名方法不能访问定义方法的`ref`或`out`参数。
*   匿名方法中的局部变量不能与外部方法中的局部变量同名。
*   匿名方法可以访问外部类范围内的实例变量(或静态变量，视情况而定)。
*   匿名方法可以声明与外部类成员变量同名的局部变量(局部变量具有不同的范围并隐藏外部类成员变量)。

假设您的`Main()`方法定义了一个名为`aboutToBlowCounter`的局部整数。在处理`AboutToBlow`事件的匿名方法中，您将使这个计数器加 1，并在`Main()`完成之前打印出计数。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Anonymous Methods *****\n");`

`int aboutToBlowCounter = 0;`

`// Make a car as usual.`

`Car c1 = new Car("SlugBug", 100, 10);`

`// Register event handlers as anonymous methods.`

`c1.AboutToBlow += delegate`

`{`

`aboutToBlowCounter++;`

`Console.WriteLine("Eek! Going too fast!");`

`};`

`c1.AboutToBlow += delegate(object sender, CarEventArgs e)`

`{`

`aboutToBlowCounter++;`

`Console.WriteLine("Critical Message from Car: {0}", e.msg);`

`};`

`// This will eventually trigger the events.`

`for (int i = 0; i < 6; i++)`

`c1.Accelerate(20);`

`Console.WriteLine("AboutToBlow event was fired {0} times.",`

`aboutToBlowCounter);`

`Console.ReadLine();`

`}`

运行这个更新后的`Main()`方法后，您会发现最终的`Console.WriteLine()`报告了`AboutToBlow`事件被触发了两次。

Source Code

AnonymousMethods 项目位于 [`Chapter 10`](10.html) 子目录下。

## 理解 Lambda 表达式

以此来结束您对。NET 事件体系结构，您将研究 C# lambda 表达式。正如刚才所解释的，C#支持“内联”处理事件的能力，方法是使用匿名方法将一组代码语句直接分配给一个事件，而不是构建一个由底层委托调用的独立方法。Lambda 表达式只不过是一种简洁的方式来创作匿名方法，并最终简化您使用。NET 委托类型。

要设置 lambda 表达式的检查阶段，请创建一个名为 SimpleLambdaExpressions 的新控制台应用程序项目。首先，考虑泛型`List<T>`类的`FindAll()`方法。当您需要从集合中提取项目的子集时，可以调用此方法，其原型如下:

`// Method of the System.Collections.Generic.List<T> class.`

`public List<T> FindAll(Predicate<T> match)`

正如您所看到的，这个方法返回了一个新的代表数据子集的`List<T>`。还要注意的是，`FindAll()`的唯一参数是一个类型为`System.Predicate<T>`的泛型委托。这个委托类型可以指向任何返回一个`bool`的方法，并将一个类型参数作为唯一的输入参数。

`// This delegate is used by FindAll() method`

`// to extract out the subset.`

`public delegate bool Predicate<T>(T obj);`

当你调用`FindAll()`时，`the List<T>`中的每一项都被传递给`Predicate<T>`对象所指向的方法。所述方法的实现将执行一些计算，以查看传入的数据是否匹配必要的标准，并将返回`true`或`false`。如果这个方法返回`true`，这个条目将被添加到新的代表子集的`List<T>`中(明白了吗？).

在您看到 lambda 表达式如何简化使用`FindAll()`之前，让我们直接使用委托对象，用手写符号来解决这个问题。在您的`Program`类型中添加一个与`System.Predicate<T>`类型交互的方法(名为`TraditionalDelegateSyntax()`),以发现整数的`List<T>`中的偶数。

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Lambdas *****\n");`

`TraditionalDelegateSyntax();`

`Console.ReadLine();`

`}`

`static void TraditionalDelegateSyntax()`

`{`

`// Make a list of integers.`

`List<int> list = new List<int>();`

`list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 });`

`// Call FindAll() using traditional delegate syntax.`

`Predicate<int> callback = IsEvenNumber;`

`List<int> evenNumbers = list.FindAll(callback);`

`Console.WriteLine("Here are your even numbers:");`

`foreach (int evenNumber in evenNumbers)`

`{`

`Console.Write("{0}\t", evenNumber);`

`}`

`Console.WriteLine();`

`}`

`// Target for the Predicate<> delegate.`

`static bool IsEvenNumber(int i)`

`{`

`// Is it an even number?`

`return (i % 2) == 0;`

`}`

`}`

这里，您有一个方法(`IsEvenNumber()`)，它负责通过 C#模操作符`%`测试传入的整数参数，看它是偶数还是奇数。如果您执行您的应用程序，您会发现数字 20、4、8 和 44 打印到控制台。

虽然这种使用委托的传统方法如预期的那样工作，但是只有在有限的情况下才会调用`IsEvenNumber()`方法——特别是当您调用`FindAll()`时，这会给您留下一个完整方法定义的包袱。如果您使用匿名方法，您的代码将会清理得相当干净。考虑下面这个`Program`类的新方法:

`static void AnonymousMethodSyntax()`

`{`

`// Make a list of integers.`

`List<int> list = new List<int>();`

`list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 });`

`// Now, use an anonymous method.`

`List<int> evenNumbers = list.FindAll(delegate(int i)`

`{ return (i % 2) == 0; } );`

`Console.WriteLine("Here are your even numbers:");`

`foreach (int evenNumber in evenNumbers)`

`{`

`Console.Write("{0}\t", evenNumber);`

`}`

`Console.WriteLine();`

`}`

在这种情况下，您可以匿名内联一个方法，而不是直接创建一个`Predicate<T>`委托对象，然后创作一个独立的方法。虽然这是朝着正确方向迈出的一步，但是仍然需要使用关键字`delegate`(或者强类型的`Predicate<T>`)，并且必须确保参数列表是完全匹配的。

`List<int> evenNumbers = list.FindAll(`

`delegate(int i)`

`{`

`return (i % 2) == 0;`

`}`

`);`

Lambda 表达式可以用来进一步简化对`FindAll()`的调用。当您使用 lambda 语法时，根本没有任何底层委托对象的痕迹。考虑下面对`Program`类的新方法:

`static void LambdaExpressionSyntax()`

`{`

`// Make a list of integers.`

`List<int> list = new List<int>();`

`list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 });`

`// Now, use a C# lambda expression.`

`List<int> evenNumbers = list.FindAll(i => (i % 2) == 0);`

`Console.WriteLine("Here are your even numbers:");`

`foreach (int evenNumber in evenNumbers)`

`{`

`Console.Write("{0}\t", evenNumber);`

`}`

`Console.WriteLine();`

`}`

在这种情况下，请注意传递给`FindAll()`方法的代码语句，它实际上是一个 lambda 表达式。在这个例子的迭代中，没有任何关于`Predicate<T>`委托(或者`delegate`关键字)的痕迹。您所指定的只是 lambda 表达式。

`i => (i % 2) == 0`

在我分解这个语法之前，首先要理解 lambda 表达式可以用在任何使用匿名方法或强类型委托的地方(通常击键次数少得多)。在幕后，C#编译器利用`Predicate<T>`委托类型(可以使用`ildasm.exe`或`reflector.exe`来验证)将表达式翻译成标准的匿名方法。具体来说，下面的代码语句:

`// This lambda expression...`

`List<int> evenNumbers = list.FindAll(i => (i % 2) == 0);`

被编译成如下近似的 C#代码:

`// ...becomes this anonymous method.`

`List<int> evenNumbers = list.FindAll(delegate (int i)`

`{`

`return (i % 2) == 0;`

`});`

### 剖析 Lambda 表达式

lambda 表达式的编写方式是首先定义一个参数列表，然后是`=>`标记(lambda 演算中 lambda 运算符的 C#标记)，最后是一组将处理这些参数的语句(或单个语句)。从高层次来看，lambda 表达式可以理解为:

`ArgumentsToProcess => StatementsToProcessThem`

在`LambdaExpressionSyntax()`方法中，事情是这样分解的:

`// "i" is our parameter list.`

`// "(i % 2) == 0" is our statement set to process "i".`

`List<int> evenNumbers = list.FindAll(i => (i % 2) == 0);`

lambda 表达式的参数可以显式或隐式类型化。目前，代表`i`参数(整数)的底层数据类型是隐式确定的。编译器能够根据整个 lambda 表达式和底层委托的上下文判断出`i`是一个整数。但是，也可以通过将数据类型和变量名放在一对括号中来显式定义表达式中每个参数的类型，如下所示:

`// Now, explicitly state the parameter type.`

`List<int> evenNumbers = list.FindAll((int i) => (i % 2) == 0);`

正如你所看到的，如果一个 lambda 表达式只有一个隐式类型的参数，那么圆括号可以从参数列表中省略。如果您想在 lambda 参数的使用上保持一致，您可以始终将参数列表放在括号内，留给您以下表达式:

`List<int> evenNumbers = list.FindAll((i) => (i % 2) == 0);`

最后，请注意，当前表达式没有用括号括起来(当然，您已经将 modulo 语句括起来，以确保它在相等测试之前首先执行)。Lambda 表达式允许语句包装如下:

`// Now, wrap the expression as well.`

`List<int> evenNumbers = list.FindAll((i) => ((i % 2) == 0));`

既然您已经看到了构建 lambda 表达式的各种方法，那么您如何以人类友好的方式阅读这个 lambda 语句呢？抛开原始的数学，下面的解释符合这个要求:

`// My list of parameters (in this case, a single integer named i)`

`// will be processed by the expression (i % 2) == 0.`

`List<int> evenNumbers = list.FindAll((i) => ((i % 2) == 0));`

### 处理多条语句中的参数

第一个 lambda 表达式是一个最终计算为布尔值的语句。但是，如您所知，许多委托目标必须执行大量代码语句。出于这个原因，C#允许您使用多个语句块来构建 lambda 表达式。当您的表达式必须使用多行代码来处理参数时，您可以通过使用预期的花括号来表示这些语句的范围。考虑以下对`LambdaExpressionSyntax()`方法的示例更新:

`static void LambdaExpressionSyntax()`

`{`

`// Make a list of integers.`

`List<int> list = new List<int>();`

`list.AddRange(new int[] { 20, 1, 4, 8, 9, 44 });`

`// Now process each argument within a group of`

`// code statements.`

`List<int> evenNumbers = list.FindAll((i) =>`

`{`

`Console.WriteLine("value of i is currently: {0}", i);`

`bool isEven = ((i % 2) == 0);`

`return isEven;`

`});`

`Console.WriteLine("Here are your even numbers:");`

`foreach (int evenNumber in evenNumbers)`

`{`

`Console.Write("{0}\t", evenNumber);`

`}`

`Console.WriteLine();`

`}`

在这种情况下，参数列表(同样是一个名为`i`的整数)由一组代码语句处理。除了对`Console.WriteLine()`的调用，为了增加可读性，modulo 语句被分成了两个代码语句。假设您在本节中看到的每个方法都是从`Main()`内部调用的:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Lambdas *****\n");`

`TraditionalDelegateSyntax();`

`AnonymousMethodSyntax();`

`Console.WriteLine();`

`LambdaExpressionSyntax();`

`Console.ReadLine();`

`}`

您会发现以下输出:

`***** Fun with Lambdas *****`

`Here are your even numbers:`

`20      4       8       44`

`Here are your even numbers:`

`20      4       8       44`

`value of i is currently: 20`

`value of i is currently: 1`

`value of i is currently: 4`

`value of i is currently: 8`

`value of i is currently: 9`

`value of i is currently: 44`

`Here are your even numbers:`

`20      4       8       44`

Source Code

SimpleLambdaExpressions 项目可以在 [`Chapter 10`](10.html) 子目录中找到。

### 具有多个(或零个)参数的 Lambda 表达式

你在这里看到的 lambda 表达式只处理一个参数。然而，这不是必需的，因为 lambda 表达式可以处理多个参数(或者一个都不处理)。为了说明第一个场景，创建一个名为 LambdaExpressionsMultipleParams 的控制台应用程序项目。接下来，假设下面是`SimpleMath`类型的实例:

`public class SimpleMath`

`{`

`public delegate void MathMessage(string msg, int result);`

`private MathMessage mmDelegate;`

`public void SetMathHandler(MathMessage target)`

`{mmDelegate = target; }`

`public void Add(int x, int y)`

`{`

`mmDelegate?.Invoke("Adding has completed!", x + y);`

`}`

`}`

请注意，`MathMessage`委托类型需要两个参数。为了将它们表示为 lambda 表达式，可以将`Main()`方法编写如下:

`static void Main(string[] args)`

`{`

`// Register with delegate as a lambda expression.`

`SimpleMath m = new SimpleMath();`

`m.SetMathHandler((msg, result) =>`

`{Console.WriteLine("Message: {0}, Result: {1}", msg, result);});`

`// This will execute the lambda expression.`

`m.Add(10, 10);`

`Console.ReadLine();`

`}`

这里，您利用了类型推断，因为为了简单起见，这两个参数没有被强类型化。但是，您可以调用`SetMathHandler()`，如下所示:

`m.SetMathHandler((string msg, int result) =>`

`{Console.WriteLine("Message: {0}, Result: {1}", msg, result);});`

最后，如果使用 lambda 表达式与不带任何参数的委托进行交互，可以通过提供一对空括号作为参数来实现。因此，假设您已经定义了以下委托类型:

`public delegate string VerySimpleDelegate();`

您可以按如下方式处理调用的结果:

`// Prints "Enjoy your string!" to the console.`

`VerySimpleDelegate d = new VerySimpleDelegate( () => {return "Enjoy your string!";} );`

`Console.WriteLine(d());`

Source Code

LambdaExpressionsMultipleParams 项目可以在 [`Chapter 10`](10.html) 子目录中找到。

### 使用 lambda 表达式改进汽车事件示例

考虑到 lambda 表达式的全部原因是提供一种干净、简洁的方式来定义匿名方法(从而间接地简化委托的工作)，让我们改进本章前面创建的 CarEventArgs 项目。下面是该项目的`Program`类的简化版本，它利用 lambda 表达式语法(而不是原始委托)来挂钩从`Car`对象发送的每个事件:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** More Fun with Lambdas *****\n");`

`// Make a car as usual.`

`Car c1 = new Car("SlugBug", 100, 10);`

`// Hook into events with lambdas!`

`c1.AboutToBlow += (sender, e) => { Console.WriteLine(e.msg);};`

`c1.Exploded += (sender, e) => { Console.WriteLine(e.msg); };`

`// Speed up (this will generate the events).`

`Console.WriteLine("\n***** Speeding up *****");`

`for (int i = 0; i < 6; i++)`

`c1.Accelerate(20);`

`Console.ReadLine();`

`}`

### Lambdas 和单语句成员实现

关于 C# lambda 操作符的最后一点是。NET 4.6 中，现在允许使用`=>`操作符来简化一些(但不是全部)成员实现。具体来说，如果您有一个方法或属性(除了自定义运算符或转换例程之外；见[第 11 章](11.html))在实现中只包含一行代码，你不需要通过花括号定义作用域。相反，您可以利用 lambda 运算符。

考虑前面的代码示例，其中您连接了处理`AboutToBlow`和`Exploded`事件的代码。请注意您是如何定义花括号范围来捕获`Console.WriteLine()`方法调用的。如果你愿意，你现在可以简单地写下以下内容:

`c1.AboutToBlow += (sender, e) => Console.WriteLine(e.msg);`

`c1.Exploded += (sender, e) => Console.WriteLine(e.msg);`

但是，请注意，这种新的简化语法可以在任何地方使用，即使您的代码与委托或事件无关。例如，如果您要构建一个简单的类来添加两个数字，您可以编写以下代码:

`class SimpleMath`

`{`

`public int Add(int x, int y)`

`{`

`return x + y;`

`}`

`public void PrintSum(int x, int y)`

`{`

`Console.WriteLine(x + y);`

`}`

`}`

或者，您现在可以编写如下代码:

`class SimpleMath`

`{`

`public int Add(int x, int y) =>  x + y;`

`public void PrintSum(int x, int y) => Console.WriteLine(x + y);`

`}`

理想情况下，此时您可以看到 lambda 表达式的整体作用，并理解它们如何提供一种“函数方式”来处理匿名方法和委托类型。尽管 lambda 运算符(`=>`)可能需要一点时间来适应，但请记住，lambda 表达式可以分解为以下简单的等式:

`ArgumentsToProcess => StatementsToProcessThem`

或者，如果使用`=>`操作符来实现一个单一的 line 类型成员，它将是这样的:

`TypeMember => SingleCodeStatement`

值得指出的是，LINQ 编程模型也大量使用 lambda 表达式来帮助简化您的编码工作。你将从第 12 章开始研究 LINQ。

Source Code

CarEventsWithLambdas 项目可以在 [`Chapter 10`](10.html) 子目录中找到。

## 摘要

在本章中，您研究了多个对象参与双向对话的多种方式。首先，您查看了 C# `delegate`关键字，该关键字用于间接构造从`System.MulticastDelegate`派生的类。正如您所看到的，委托对象维护了一个方法列表，当被告知要调用时就调用这个列表。这些调用可以同步进行(使用`Invoke()`方法)或者异步进行(通过`BeginInvoke()`和`EndInvoke()`方法)。同样，异步的本质。NET 委托类型将在第 19 章中讨论。

然后研究了 C# `event`关键字，当它与委托类型结合使用时，可以简化将事件通知发送给等待调用方的过程。如生成的 CIL 所示。NET 事件模型映射到`System.Delegate` / `System.MulticastDelegate`类型的隐藏调用。在这种情况下，C# `event`关键字完全是可选的，因为它只是为您节省了一些键入时间。同样，您已经看到 C# 6.0 空条件操作符简化了您如何安全地向任何感兴趣的一方触发事件。

本章还探讨了 C#语言的一个特性，叫做匿名方法。使用这种语法结构，您可以将代码语句块直接关联到给定的事件。正如您所看到的，匿名方法可以忽略事件发送的参数，并可以访问定义方法的“外部变量”。您还研究了一种使用方法组转换注册事件的简化方法。

最后，您通过查看 C# lambda 操作符`=>`完成了所有工作。如图所示，这种语法是创作匿名方法的一种很好的速记符号，其中可以将一堆参数传递给一组语句进行处理。中的任何方法。NET 平台可以用相关的 lambda 表达式替换，这通常会大大简化您的代码库。