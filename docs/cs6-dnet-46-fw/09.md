# 9.集合和泛型

使用。NET 平台将需要处理在内存中维护和操作一组数据点的问题。这些数据点可以来自任何位置，包括关系数据库、本地文本文件、XML 文档、web 服务调用，或者可能是通过用户提供的输入。

当。NET 平台首次发布时，程序员经常使用`System.Collections`名称空间的类来存储应用程序中使用的数据并与之交互。英寸 NET 2.0 中，C#编程语言得到了增强，以支持一种称为泛型的特性；随着这一变化，在基础类库中引入了一个全新的名称空间:`System.Collections.Generic`。

本章将向您概述在中找到的各种集合(泛型和非泛型)命名空间和类型。NET 基础类库。正如您将看到的，泛型容器通常比非泛型容器更受青睐，因为它们通常提供更好的类型安全性和性能优势。在你学会了如何创建和操作框架中的通用项之后，本章的剩余部分将研究如何构建你自己的通用方法和通用类型。当你这样做的时候，你将学习约束的作用(和相应的 C# `where`关键字)，它允许你构建非常类型安全的类。

## 集合类的动机

可以用来保存应用程序数据的最原始的容器无疑是数组。正如你在[第 4 章](04.html)中看到的，C#数组允许你定义一组固定上限的相同类型的项(包括一个`System.Object`的数组，它本质上代表一个任何类型数据的数组)。还记得第 4 章中的[吗，所有 C#数组变量都从`System.Array`类中收集了大量的功能。快速回顾一下，考虑下面的`Main()`方法，它创建一个文本数据数组，并以各种方式操作其内容:](04.html)

`static void Main(string[] args)`

`{`

`// Make an array of string data.`

`string[] strArray = {"First", "Second", "Third" };`

`// Show number of items in array using Length property.`

`Console.WriteLine("This array has {0} items.", strArray.Length);`

`Console.WriteLine();`

`// Display contents using enumerator.`

`foreach (string s in strArray)`

`{`

`Console.WriteLine("Array Entry: {0}", s);`

`}`

`Console.WriteLine();`

`// Reverse the array and print again.`

`Array.Reverse(strArray);`

`foreach (string s in strArray)`

`{`

`Console.WriteLine("Array Entry: {0}", s);`

`}`

`Console.ReadLine();`

`}`

虽然基本数组对于管理少量固定大小的数据很有用，但在很多其他情况下，您需要更灵活的数据结构，例如动态增长和收缩的容器，或者可以容纳仅满足特定条件的对象(例如，仅从特定基类派生的对象或仅实现特定接口的对象)的容器。当你使用一个简单的数组时，永远记住它们是“固定大小的”如果你做一个三项的数组，你只能得到三项；因此，下面的代码会导致运行时异常(确切地说是一个`IndexOutOfRangeException`):

`static void Main(string[] args)`

`{`

`// Make an array of string data.`

`string[] strArray = { "First", "Second", "Third" };`

`// Try to add a new item at the end?? Runtime error!`

`strArray[3] = "new item?";`

`...`

`}`

Note

实际上可以使用通用的`Resize()<T>`方法来改变数组的大小。但是，这将导致数据复制到一个新的数组对象中，并且可能是低效的。

为了帮助克服简单数组的局限性。NET 基类库附带了许多包含集合类的命名空间。与简单的 C#数组不同，当您插入或移除项时，集合类会动态调整自身大小。此外，许多集合类提供了更高的类型安全性，并经过高度优化，以内存高效的方式处理所包含的数据。当你阅读本章时，你会很快注意到一个集合类可以属于两大类中的一类。

*   非泛型集合(主要在`System.Collections`名称空间中)
*   通用集合(主要在`System.Collections.Generic`名称空间中)

非泛型集合通常被设计为操作`System.Object`类型，因此是松散类型的容器(然而，一些非泛型集合确实只操作特定类型的数据，例如`string`对象)。相比之下，泛型集合更加类型安全，因为您必须在创建时指定它们所包含的“类型的类型”。正如您将看到的，任何通用项目的指示符号都是用尖括号标记的“类型参数”(例如，`List<T>`)。在本章的稍后部分，你将会研究泛型的细节(包括它们提供的许多好处)。现在，让我们研究一下`System.Collections`和`System.Collections.Specialized`名称空间中的一些关键的非泛型集合类型。

### 系统。集合命名空间

当。NET 平台首次发布时，程序员经常使用在`System.Collections`名称空间中找到的非泛型集合类，它包含一组用于管理和组织大量内存数据的类。表 [9-1](#Tab1) 记录了这个名称空间的一些更常用的集合类和它们实现的核心接口。

表 9-1。

Useful Types of System.Collections

<colgroup><col> <col> <col></colgroup> 
| 系统。集合类 | 生命的意义 | 主要实现的接口 |
| --- | --- | --- |
| `ArrayList` | 表示按顺序列出的动态调整大小的对象集合 | `IList`、`ICollection`、`IEnumerable`和`ICloneable` |
| `BitArray` | 管理以布尔值表示的位值的紧凑数组，其中 true 表示该位为开(1)，false 表示该位为关(0) | `ICollection`、`IEnumerable`和`ICloneable` |
| `Hashtable` | 表示基于键的哈希代码组织的键值对的集合 | `IDictionary`、`ICollection`、`IEnumerable`和`ICloneable` |
| `Queue` | 表示对象的标准先进先出(FIFO)集合 | `ICollection`、`IEnumerable`和`ICloneable` |
| `SortedList` | 表示按键排序并可按键和索引访问的键-值对的集合 | `IDictionary`、`ICollection`、`IEnumerable`和`ICloneable` |
| `Stack` | 一种后进先出(LIFO)堆栈，提供推入和弹出(以及窥视)功能 | `ICollection`、`IEnumerable`和`ICloneable` |

这些集合类实现的接口提供了对其整体功能的深入了解。表 [9-2](#Tab2) 记录了这些关键接口的总体性质，其中一些你在[第 8 章](08.html)中直接使用过。

表 9-2。

Key Interfaces Supported by Classes of System.Collections

<colgroup><col> <col></colgroup> 
| 系统。收集界面 | 生命的意义 |
| --- | --- |
| `ICollection` | 定义所有非泛型集合类型的一般特征(例如，大小、枚举和线程安全) |
| `ICloneable` | 允许实现对象将自身的副本返回给调用方 |
| `IDictionary` | 允许非泛型集合对象使用键值对来表示其内容 |
| `IEnumerable` | 返回一个实现`IEnumerator`接口的对象(见下一个表项) |
| `IEnumerator` | 启用集合项目的`foreach`样式迭代 |
| `IList` | 提供在对象的顺序列表中添加、移除和索引项的行为 |

#### 一个说明性的例子:使用数组列表

根据您的经验，您可能有一些使用(或实现)这些经典数据结构(如堆栈、队列和列表)的第一手经验。如果不是这样，当你在本章稍后检查它们的通用对应物时，我将提供一些关于它们的差异的进一步细节。在此之前，这里有一个使用了一个`ArrayList`对象的`Main()`方法。请注意，您可以动态地添加(或删除)项目，容器会相应地自动调整大小。

`// You must import System.Collections to access the ArrayList.`

`static void Main(string[] args)`

`{`

`ArrayList strArray = new ArrayList();`

`strArray.AddRange(new string[] { "First", "Second", "Third" });`

`// Show number of items in ArrayList.`

`Console.WriteLine("This collection has {0} items.", strArray.Count);`

`Console.WriteLine();`

`// Add a new item and display current count.`

`strArray.Add("Fourth!");`

`Console.WriteLine("This collection has {0} items.", strArray.Count);`

`// Display contents.`

`foreach (string s in strArray)`

`{`

`Console.WriteLine("Entry: {0}", s);`

`}`

`Console.WriteLine();`

`}`

如您所料，`ArrayList`类除了`Count`属性、`AddRange()`和`Add()`方法之外，还有许多有用的成员，所以请务必参考。NET Framework 文档以了解完整的详细信息。与此相关的是，`System.Collections` ( `Stack`、`Queue`等)的其他类也在。NET 帮助系统。

然而，重要的是要指出，你的大多数。NET 项目很可能不会使用`System.Collections`名称空间中的集合类！可以肯定的是，如今使用在`System.Collections.Generic`名称空间中找到的通用对应类要普遍得多。鉴于这一点，我不会对`System.Collections`中剩余的非泛型类进行评论(或提供代码示例)。

### 系统概述。集合。专用命名空间

`System.Collections`不是唯一的。包含非泛型集合类的. NET 命名空间。`System.Collections.Specialized`名称空间定义了许多(原谅冗余)专门化的集合类型。表 [9-3](#Tab3) 记录了这个特殊的以集合为中心的名称空间中一些更有用的类型，所有这些类型都是非泛型的。

表 9-3。

Useful Classes of System.Collections.Specialized

<colgroup><col> <col></colgroup> 
| 系统。集合。专用类型 | 生命的意义 |
| --- | --- |
| `HybridDictionary` | 这个类通过在集合很小时使用一个`ListDictionary`来实现`IDictionary`，然后在集合变大时切换到一个`Hashtable`。 |
| `ListDictionary` | 当您需要管理少量(十个左右)会随时间变化的项目时，这个类非常有用。这个类使用一个单链表来维护它的数据。 |
| `StringCollection` | 这个类提供了管理大型字符串数据集合的最佳方式。 |
| `BitVector32` | 这个类提供了一个简单的结构，在 32 位内存中存储布尔值和小整数。 |

除了这些具体的类类型之外，这个命名空间还包含许多附加的接口和抽象基类，您可以将它们用作创建自定义集合类的起点。虽然这些“专门化”类型可能正是您的项目在某些情况下所需要的，但是我不会在这里对它们的用法进行评论。同样，在许多情况下，您可能会发现,`System.Collections.Generic`名称空间提供了具有类似功能和额外好处的类。

Note

中有两个额外的以集合为中心的名称空间(`System.Collections.ObjectModel`和`System.Collections.Concurrent`)。NET 基础类库。在熟悉了泛型的主题之后，你将在本章的后面检查前一个名称空间。`System.Collections.Concurrent`提供了非常适合多线程环境的集合类(见[第 19 章](19.html)关于多线程的信息)。

## 非一般性收藏的问题

虽然许多成功人士。NET 应用程序已经使用这些非泛型集合类(和接口)构建了多年，历史表明使用这些类型会导致许多问题。

第一个问题是使用`System.Collections`和`System.Collections.Specialized`类会导致一些性能很差的代码，尤其是当你操作数字数据(例如值类型)的时候。正如您马上会看到的，当您在任何非泛型集合类中存储结构以对`System.Object`进行操作时，CLR 必须执行大量内存转移操作，这会降低运行时执行速度。

第二个问题是，大多数非泛型集合类都不是类型安全的，因为(再次)它们是为在`System.Object`上操作而开发的，因此它们可以包含任何内容。如果. NET 开发人员需要创建一个高度类型安全的集合(例如，一个可以容纳只实现某个接口的对象的容器)，唯一真正的选择是手动创建一个新的集合类。这样做不需要太多的劳动，但是有点乏味。

在研究如何在程序中使用泛型之前，您会发现更仔细地研究一下非泛型集合类的问题是有帮助的；这将帮助你更好地理解泛型首先要解决的问题。如果您想继续操作，请创建一个名为 IssuesWithNonGenericCollections 的新控制台应用程序项目。接下来，确保将`System.Collections`名称空间导入到 C#代码文件的顶部。

`using System.Collections;`

### 性能的问题

你可能还记得《T2》第四章。NET 平台支持两大类数据:值类型和引用类型。鉴于此。NET 定义了两个主要的类型类别，有时您可能需要将一个类别的变量表示为另一个类别的变量。为此，C#提供了一种称为装箱的简单机制，将数据存储在引用变量内的值类型中。假设您已经在一个名为`SimpleBoxUnboxOperation()`的方法中创建了一个类型为`int`的局部变量。如果在应用程序的过程中，您要将该值类型表示为引用类型，您需要将该值装箱，如下所示:

`static void SimpleBoxUnboxOperation()`

`{`

`// Make a ValueType (int) variable.`

`int myInt = 25;`

`// Box the int into an object reference.`

`object boxedInt = myInt;`

`}`

装箱可以被正式定义为将值类型显式分配给一个`System.Object`变量的过程。当您装箱一个值时，CLR 在堆上分配一个新对象，并将值类型的值(在本例中为`25`)复制到该实例中。返回给您的是对新分配的基于堆的对象的引用。

通过取消装箱也允许相反的操作。取消装箱是将对象引用中保存的值转换回堆栈上相应值类型的过程。从语法上来说，拆箱操作看起来像普通的造型操作。然而，语义却大相径庭。CLR 首先验证接收数据类型是否等同于装箱类型，如果是，它将值复制回一个基于堆栈的局部变量。例如，假设`boxedInt`的底层类型确实是一个`int`，下面的拆箱操作会成功:

`static void SimpleBoxUnboxOperation()`

`{`

`// Make a ValueType (int) variable.`

`int myInt = 25;`

`// Box the int into an object reference.`

`object boxedInt = myInt;`

`// Unbox the reference back into a corresponding int.`

`int unboxedInt = (int)boxedInt;`

`}`

当 C#编译器遇到装箱/拆箱语法时，它会发出包含`box` / `unbox`操作码的 CIL 代码。如果您使用`ildasm.exe`检查您编译的程序集，您会发现如下内容:

`.method private hidebysig static void SimpleBoxUnboxOperation() cil managed`

`{`

`// Code size 19 (0x13)`

`.maxstack 1`

`.locals init ([0] int32 myInt, [1] object boxedInt, [2] int32 unboxedInt)`

`IL_0000: nop`

`IL_0001: ldc.i4.s 25`

`IL_0003: stloc.0`

`IL_0004: ldloc.0`

`IL_0005: box [mscorlib]System.Int32`

`IL_000a: stloc.1`

`IL_000b: ldloc.1`

`IL_000c: unbox.any [mscorlib]System.Int32`

`IL_0011: stloc.2`

`IL_0012: ret`

`} // end of method Program::SimpleBoxUnboxOperation`

请记住，与执行典型的强制转换不同，您必须取消装箱为适当的数据类型。如果您试图将一段数据拆箱为不正确的数据类型，将会抛出一个`InvalidCastException`异常。为了绝对安全，你应该用`try` / `catch`逻辑包装每个拆箱操作；然而，对于每个拆箱操作来说，这将是相当劳动密集型的。考虑下面的代码更新，它将抛出一个错误，因为您试图将装箱的`int`解装箱成一个`long`:

`static void SimpleBoxUnboxOperation()`

`{`

`// Make a ValueType (int) variable.`

`int myInt = 25;`

`// Box the int into an object reference.`

`object boxedInt = myInt;`

`// Unbox in the wrong data type to trigger`

`// runtime exception.`

`try`

`{`

`long unboxedInt = (long)boxedInt;`

`}`

`catch (InvalidCastException ex)`

`{`

`Console.WriteLine(ex.Message);`

`}`

`}`

乍一看，装箱/取消装箱似乎是一个平淡无奇的语言特性，其学术性大于实用性。毕竟，您很少需要在本地`object`变量中存储本地值类型，如下所示。然而，事实证明装箱/拆箱过程非常有用，因为它允许您假设一切都可以被视为一个`System.Object`，而 CLR 则代表您处理与内存相关的细节。

让我们看看这些技术的实际应用。假设您已经创建了一个非泛型`System.Collections.ArrayList`来保存一批数值(堆栈分配的)数据。如果你检查一下`ArrayList`的成员，你会发现它们是操作`System.Object`数据的原型。现在考虑一下`Add()`、`Insert()`和`Remove()`方法，以及类索引器。

`public class ArrayList : object,`

`IList, ICollection, IEnumerable, ICloneable`

`{`

`...`

`public virtual int Add(``object`T2】

`public virtual void Insert(int index,``object`T2】

`public virtual void Remove(``object`T2】

`public virtual``object`T2】

`}`

`ArrayList`已经被构建为在`object`上操作，这些表示在堆上分配的数据，因此下面的代码编译和执行时没有抛出错误可能看起来很奇怪:

`static void WorkWithArrayList()`

`{`

`// Value types are automatically boxed when`

`// passed to a method requesting an object.`

`ArrayList myInts = new ArrayList();`

`myInts.Add(10);`

`myInts.Add(20);`

`myInts.Add(35);`

`}`

尽管您将数字数据直接传递给需要一个`object`的方法，但运行时会自动为您将基于堆栈的数据装箱。稍后，如果您想使用类型索引器从`ArrayList`中检索一个项目，您必须使用一个转换操作将堆分配的对象拆箱为堆栈分配的整数。记住，`ArrayList`的索引器返回的是`System.Object` s，而不是`System.Int32` s

`static void WorkWithArrayList()`

`{`

`// Value types are automatically boxed when`

`// passed to a member requesting an object.`

`ArrayList myInts = new ArrayList();`

`myInts.Add(10);`

`myInts.Add(20);`

`myInts.Add(35);`

`// Unboxing occurs when an object is converted back to`

`// stack-based data.`

`int i = (int)myInts[0];`

`// Now it is reboxed, as WriteLine() requires object types!`

`Console.WriteLine("Value of your int: {0}", i);`

`}`

同样，请注意，堆栈分配的`System.Int32`在调用`ArrayList.Add()`之前被装箱，因此它可以在所需的`System.Object`中传递。还要注意的是，一旦通过转换操作从`ArrayList`中检索到`System.Object`，它就被解装箱回一个`System.Int32`，只有当它被传递给`Console.WriteLine()`方法时才被再次装箱，因为这个方法是对`System.Object`变量进行操作的。

从程序员的角度来看，装箱和拆箱很方便，但是这种简化的堆栈/堆内存传输方法带来了性能问题(在执行速度和代码大小方面)和缺乏类型安全性。要理解性能问题，请思考一下对一个简单整数进行装箱和拆箱所必须采取的步骤。

A new object must be allocated on the managed heap.   The value of the stack-based data must be transferred into that memory location.   When unboxed, the value stored on the heap-based object must be transferred back to the stack.   The now unused object on the heap will (eventually) be garbage collected.  

尽管这个特殊的`WorkWithArrayList()`方法不会导致性能方面的主要瓶颈，但是如果一个`ArrayList`包含了成千上万的整数，并且程序在一定程度上定期地对这些整数进行操作，那么您肯定会感觉到这种影响。在理想情况下，您可以在一个容器中操作基于堆栈的数据，而不会有任何性能问题。理想情况下，如果您不必费心使用`try` / `catch`作用域从这个容器中提取数据就好了(这正是泛型让您实现的)。

### 类型安全的问题

在讨论拆箱操作时，我提到了类型安全的问题。回想一下，您必须将数据取消装箱为装箱前声明的相同数据类型。然而，在一个无泛型的世界里，你必须记住类型安全的另一个方面:事实上,`System.Collections`的大多数类通常可以保存任何东西，因为它们的成员被原型化为在`System.Objects`上操作。例如，该方法构建了一个由不相关数据的随机位组成的`ArrayList`:

`static void ArrayListOfRandomObjects()`

`{`

`// The ArrayList can hold anything at all.`

`ArrayList allMyObjects = new ArrayList();`

`allMyObjects.Add(true);`

`allMyObjects.Add(new OperatingSystem(PlatformID.MacOSX, new Version(10, 0)));`

`allMyObjects.Add(66);`

`allMyObjects.Add(3.14);`

`}`

在某些情况下，你会需要一个非常灵活的容器，几乎可以容纳任何东西(如此处所示)。但是，大多数情况下，您希望类型安全的容器只能在特定类型的数据点上操作。例如，您可能需要一个只能容纳数据库连接、位图或与`IPointy`兼容的对象的容器。

在泛型出现之前，解决类型安全问题的唯一方法是手动创建一个自定义(强类型)集合类。假设您想要创建一个自定义集合，它只能包含类型为`Person`的对象。

`public class Person`

`{`

`public int Age {get; set;}`

`public string FirstName {get; set;}`

`public string LastName {get; set;}`

`public Person(){}`

`public Person(string firstName, string lastName, int age)`

`{`

`Age = age;`

`FirstName = firstName;`

`LastName = lastName;`

`}`

`public override string ToString()`

`{`

`return string.Format("Name: {0} {1}, Age: {2}",`

`FirstName, LastName, Age);`

`}`

`}`

要构建一个只能容纳`Person`对象的集合，可以在名为`PersonCollection`的类中定义一个`System.Collections.ArrayList`成员变量，并将所有成员配置为操作强类型`Person`对象，而不是操作`System.Object`类型。下面是一个简单的例子(产品级定制集合可以支持许多额外的成员，并且可能从`System.Collections`或`System.Collections.Specialized`名称空间扩展一个抽象基类):

`public class PersonCollection : IEnumerable`

`{`

`private ArrayList arPeople = new ArrayList();`

`// Cast for caller.`

`public Person GetPerson(int pos)`

`{ return (Person)arPeople[pos]; }`

`// Insert only Person objects.`

`public void AddPerson(Person p)`

`{ arPeople.Add(p); }`

`public void ClearPeople()`

`{ arPeople.Clear(); }`

`public int Count`

`{ get { return arPeople.Count; } }`

`// Foreach enumeration support.`

`IEnumerator IEnumerable.GetEnumerator()`

`{ return arPeople.GetEnumerator(); }`

`}`

注意，`PersonCollection`类实现了`IEnumerable`接口，该接口允许对每个包含的项目进行类似于`foreach`的迭代。还要注意，您的`GetPerson()`和`AddPerson()`方法已经被原型化，只对`Person`对象进行操作，而不是位图、字符串、数据库连接或其他项目。有了这些定义的类型，现在就可以确保类型安全，因为 C#编译器将能够确定任何插入不兼容数据类型的尝试。

`static void UsePersonCollection()`

`{`

`Console.WriteLine("***** Custom Person Collection *****\n");`

`PersonCollection myPeople = new PersonCollection();`

`myPeople.AddPerson(new Person("Homer", "Simpson", 40));`

`myPeople.AddPerson(new Person("Marge", "Simpson", 38));`

`myPeople.AddPerson(new Person("Lisa", "Simpson", 9));`

`myPeople.AddPerson(new Person("Bart", "Simpson", 7));`

`myPeople.AddPerson(new Person("Maggie", "Simpson", 2));`

`// This would be a compile-time error!`

`// myPeople.AddPerson(new Car());`

`foreach (Person p in myPeople)`

`Console.WriteLine(p);`

`}`

虽然自定义集合确实可以确保类型安全，但是这种方法使您必须为要包含的每个唯一数据类型创建一个(几乎相同的)自定义集合。因此，如果您需要一个只能在从`Car`基类派生的类上操作的定制集合，您需要构建一个高度相似的集合类。

`public class CarCollection : IEnumerable`

`{`

`private ArrayList arCars = new ArrayList();`

`// Cast for caller.`

`public Car GetCar(int pos)`

`{ return (Car) arCars[pos]; }`

`// Insert only Car objects.`

`public void AddCar(Car c)`

`{ arCars.Add(c); }`

`public void ClearCars()`

`{ arCars.Clear(); }`

`public int Count`

`{ get { return arCars.Count; } }`

`// Foreach enumeration support.`

`IEnumerator IEnumerable.GetEnumerator()`

`{ return arCars.GetEnumerator(); }`

`}`

然而，自定义集合类并不能解决装箱/拆箱惩罚的问题。即使您要创建一个名为`IntCollection`的定制集合，并设计为只对`System.Int32`项进行操作，您也必须分配某种类型的对象来保存数据(例如，`System.Array`和`ArrayList`)。

`public class IntCollection : IEnumerable`

`{`

`private ArrayList arInts = new ArrayList();`

`// Get an int (performs unboxing!).`

`public int GetInt(int pos)`

`{ return (int)arInts[pos]; }`

`// Insert an int (performs boxing)!`

`public void AddInt(int i)`

`{ arInts.Add(i); }`

`public void ClearInts()`

`{ arInts.Clear(); }`

`public int Count`

`{ get { return arInts.Count; } }`

`IEnumerator IEnumerable.GetEnumerator()`

`{ return arInts.GetEnumerator(); }`

`}`

无论您选择哪种类型来保存整数，您都无法使用非泛型容器来摆脱装箱的困境。

### 泛型集合初探

当您使用泛型集合类时，您纠正了所有以前的问题，包括装箱/取消装箱惩罚和缺乏类型安全性。此外，构建定制(通用)集合类的需求变得非常少。您可以使用一个通用集合类并指定类型的类型，而不必构建可以包含人、车和整数的唯一类。

考虑下面的方法，它使用泛型`List<T>`类(在`System.Collections.Generic`名称空间中)以强类型的方式包含各种类型的数据(此时不要担心泛型语法的细节):

`static void UseGenericList()`

`{`

`Console.WriteLine("***** Fun with Generics *****\n");`

`// This List<> can hold only Person objects.`

`List<Person> morePeople = new List<Person>();`

`morePeople.Add(new Person ("Frank", "Black", 50));`

`Console.WriteLine(morePeople[0]);`

`// This List<> can hold only integers.`

`List<int> moreInts = new List<int>();`

`moreInts.Add(10);`

`moreInts.Add(2);`

`int sum = moreInts[0] + moreInts[1];`

`// Compile-time error! Can’t add Person object`

`// to a list of ints!`

`// moreInts.Add(new Person());`

`}`

第一个`List<T>`对象只能包含`Person`对象。因此，当从容器中提取项时，您不需要执行强制转换，这使得这种方法更加类型安全。第二个`List<T>`只能包含整数，全部分配在堆栈上；换句话说，不存在您在非泛型`ArrayList`中发现的隐藏装箱或取消装箱。下面是泛型容器相对于非泛型容器的优势列表:

*   泛型提供了更好的性能，因为它们在存储值类型时不会导致装箱或取消装箱的损失。
*   泛型是类型安全的，因为它们只能包含您指定的类型。
*   泛型极大地减少了构建自定义集合类型的需要，因为您在创建泛型容器时指定了“类型的类型”。

Source Code

您可以在 [`Chapter 9`](09.html) 子目录中找到 IssuesWithNonGenericCollections 项目。

## 泛型类型参数的作用

中可以找到泛型类、接口、结构和委托。这些库可能是任何。NET 命名空间。还要注意，泛型的用途远不止定义一个集合类。当然，出于各种原因，你会在本书的剩余部分看到许多不同的泛型。

Note

只有类、结构、接口和委托可以通用地编写；枚举类型不能。

当您看到列在。NET Framework 文档或 Visual Studio 对象浏览器，您会注意到一对尖括号，中间夹着一个字母或其他标记。图 [9-1](#Fig1) 显示了 Visual Studio 对象浏览器显示了位于`System.Collections.Generic`名称空间内的许多通用项，包括突出显示的`List<T>`类。

![A978-1-4842-1332-2_9_Fig1_HTML.jpg](A978-1-4842-1332-2_9_Fig1_HTML.jpg)

图 9-1。

Generic items supporting type parameters

从形式上来说，您将这些令牌称为类型参数；然而，用更加用户友好的术语来说，您可以简单地称它们为占位符。你可以将符号`<T>`读作“of T”。因此，你可以将`IEnumerable<T>`读作“T”的`IEnumerable`，或者换句话说，“T”类型的`IEnumerable`

Note

类型参数(占位符)的名称无关紧要，这取决于创建泛型项的开发人员。但是，通常 T 用于表示类型，TKey 或 K 用于键，而 TValue 或 V 用于值。

当创建泛型对象、实现泛型接口或调用泛型成员时，由您来决定是否向类型参数提供值。在这一章和正文的其余部分，你会看到许多例子。然而，为了做好准备，让我们看看与泛型类型和成员交互的基础知识。

### 为泛型类/结构指定类型参数

创建泛型类或结构的实例时，在声明变量和调用构造函数时指定类型参数。正如您在前面的代码示例中看到的，`UseGenericList()`定义了两个`List<T>`对象。

`// This List<> can hold only Person objects.`

`List<Person> morePeople = new List<Person>();`

您可以将前面的代码片段理解为“一个`T`的`List<>`，其中`T`的类型为`Person`”或者，更简单地说，你可以把它理解为“一个人对象的列表”指定了泛型项的类型参数之后，就不能再更改了(记住，泛型都是关于类型安全的)。当您为泛型类或结构指定类型参数时，所有出现的占位符现在都将替换为您提供的值。

如果您要使用 Visual Studio 对象浏览器查看泛型`List<T>`类的完整声明，您将会看到占位符`T`贯穿于`List<T>`类型的定义中。以下是部分清单(注意`bold`中的项目):

`// A partial listing of the List<T> class.`

`namespace System.Collections.Generic`

`{`

`public class List<T> :`

`IList<T>, ICollection<T>, IEnumerable<T>, IReadOnlyList<T>`

`IList, ICollection, IEnumerable`

`{`

`...`

`public void Add(``T`T2】

`public ReadOnlyCollection<``T`T2】

`public int BinarySearch(``T`T2】

`public bool Contains(``T`T2】

`public void CopyTo(``T`T2】

`public int FindIndex(System.Predicate<``T`T2】

`public``T``FindLast(System.Predicate<``T`T4】

`public bool Remove(``T`T2】

`public int RemoveAll(System.Predicate<``T`T2】

`public``T`T2】

`public bool TrueForAll(System.Predicate<``T`T2】

`public``T`T2】

`}`

`}`

当你创建一个指定`Person`对象的`List<T>`时，就好像`List<T>`类型被定义如下:

`namespace System.Collections.Generic`

`{`

`public class List<``Person`T2】

`IList<``Person``>, ICollection<``Person``>, IEnumerable<``Person``>, IReadOnlyList<``Person``>`

`IList, ICollection, IEnumerable`

`{`

`...`

`public void Add(``Person`T2】

`public ReadOnlyCollection<``Person`T2】

`public int BinarySearch(``Person`T2】

`public bool Contains(``Person`T2】

`public void CopyTo(``Person`T2】

`public int FindIndex(System.Predicate<``Person`T2】

`public Person FindLast(System.Predicate<``Person`T2】

`public bool Remove(``Person`T2】

`public int RemoveAll(System.Predicate<``Person`T2】

`public``Person`T2】

`public bool TrueForAll(System.Predicate<``Person`T2】

`public``Person`T2】

`}`

`}`

当然，当您创建一个通用的`List<T>`变量时，编译器并不会真的创建一个`List<T>`类的新实现。相反，它将只处理您实际调用的泛型类型的成员。

### 为泛型成员指定类型参数

对于一个非泛型类或结构来说，支持少量的泛型成员(例如，方法和属性)是可以的。在这些情况下，您还需要在调用方法时指定占位符值。例如，`System.Array`支持几种泛型方法。具体来说，非泛型静态`Sort()`方法现在有了一个名为`Sort<T>()`的泛型对应方法。考虑下面的代码片段，其中`T`的类型是`int`:

`int[] myInts = { 10, 4, 2, 33, 93 };`

`// Specify the placeholder to the generic`

`// Sort<>() method.`

`Array.Sort<int>(myInts);`

`foreach (int i in myInts)`

`{`

`Console.WriteLine(i);`

`}`

### 为泛型接口指定类型参数

当您构建需要支持各种框架行为(例如，克隆、排序和枚举)的类或结构时，通常会实现泛型接口。在第八章的[中，你学习了一些非通用接口，比如`IComparable`、`IEnumerable`、`IEnumerator`和`IComparer`。回想一下，非泛型`IComparable`接口是这样定义的:](08.html)

`public interface IComparable`

`{`

`int CompareTo(object obj);`

`}`

在《T2》第 8 章中，你也在你的`Car`类中实现了这个接口，以支持标准数组中的排序。然而，代码需要几次运行时检查和转换操作，因为参数是一个通用的`System.Object`。

`public class Car : IComparable`

`{`

`...`

`// IComparable implementation.`

`int IComparable.CompareTo(object obj)`

`{`

`Car temp = obj as Car;`

`if (temp != null)`

`{`

`if (this.CarID > temp.CarID)`

`return 1;`

`if (this.CarID < temp.CarID)`

`return -1;`

`else`

`return 0;`

`}`

`else`

`throw new ArgumentException("Parameter is not a Car!");`

`}`

`}`

现在假设您使用这个接口的通用对应物。

`public interface IComparable<T>`

`{`

`int CompareTo(T obj);`

`}`

在这种情况下，您的实现代码将被大大清理。

`public class Car : IComparable<Car>`

`{`

`...`

`// IComparable<T> implementation.`

`int IComparable<Car>.CompareTo(Car obj)`

`{`

`if (this.CarID > obj.CarID)`

`return 1;`

`if (this.CarID < obj.CarID)`

`return -1;`

`else`

`return 0;`

`}`

`}`

这里，您不需要检查传入的参数是否是一个`Car`，因为它只能是一个`Car`！如果有人传入不兼容的数据类型，您会得到一个编译时错误。现在您已经更好地掌握了如何与通用项交互，以及类型参数(也称为占位符)的角色，您已经准备好检查`System.Collections.Generic`名称空间的类和接口了。

## 系统。Collections .泛型命名空间

当您正在构建一个. NET 应用程序，并且需要一种方法来管理内存中的数据时，`System.Collections.Generic`类最有可能满足您的需求。在这一章的开始，我简要地提到了一些由非泛型集合类实现的核心非泛型接口。毫不奇怪，`System.Collections.Generic`名称空间为它们中的许多定义了通用替换。

事实上，您可以找到许多扩展其非泛型对应物的泛型接口。这可能看起来很奇怪；然而，通过这样做，实现类也将支持在它们的非泛型兄弟中找到的遗留功能。比如`IEnumerable<T>`扩展`IEnumerable`。表 [9-4](#Tab4) 记录了你在使用通用集合类时会遇到的核心通用接口。

表 9-4。

Key Interfaces Supported by Classes of System.Collections.Generic

<colgroup><col> <col></colgroup> 
| 系统。集合.通用接口 | 生命的意义 |
| --- | --- |
| `ICollection<T>` | 定义所有泛型集合类型的一般特征(例如，大小、枚举和线程安全) |
| `IComparer<T>` | 定义与对象进行比较的方式 |
| `IDictionary<TKey, TValue>` | 允许泛型集合对象使用键值对来表示其内容 |
| `IEnumerable<T>` | 返回给定对象的`IEnumerator<T>`接口 |
| `IEnumerator<T>` | 对一般集合启用`foreach`样式的迭代 |
| `IList<T>` | 提供在对象的顺序列表中添加、移除和索引项的行为 |
| `ISet<T>` | 为集合的抽象提供基本接口 |

名称空间还定义了几个实现这些关键接口的类。表 [9-5](#Tab5) 描述了这个名称空间的一些常用类，它们实现的接口，以及它们的基本功能。

表 9-5。

Classes of System.Collections.Generic

<colgroup><col> <col> <col></colgroup> 
| 通用类 | 支持的关键接口 | 生命的意义 |
| --- | --- | --- |
| `Dictionary<TKey, TValue>` | `ICollection<T>`、`IDictionary<TKey`、`TValue>`、`IEnumerable<T>` | 这表示键和值的一般集合。 |
| `LinkedList<T>` | `ICollection<T>`，`IEnumerable<T>` | 这代表了一个双向链表。 |
| `List<T>` | `ICollection<T>`、`IEnumerable<T>`、`IList<T>` | 这是一个可动态调整大小的项目顺序列表。 |
| `Queue<T>` | `ICollection`(不是错别字！这是非通用集合接口)，`IEnumerable<T>` | 这是先进先出(FIFO)列表的一般实现。 |
| `SortedDictionary<TKey, TValue>` | `ICollection<T>`、`IDictionary<TKey`、`TValue>`、`IEnumerable<T>` | 这是一组排序的键值对的一般实现。 |
| `SortedSet<T>` | `ICollection<T>`、`IEnumerable<T>`、`ISet<T>` | 这表示对象的集合，这些对象按排序顺序维护，没有重复。 |
| `Stack<T>` | `ICollection`(不是错别字！这是非通用集合接口)，`IEnumerable<T>` | 这是后进先出(LIFO)列表的一般实现。 |

`System.Collections.Generic`名称空间还定义了许多与特定容器协同工作的辅助类和结构。例如，`LinkedListNode<T>`类型表示泛型`LinkedList<T>`中的一个节点，当试图使用不存在的键从容器中获取一个项目时会引发`KeyNotFoundException`异常，等等。

同样值得指出的是，`mscorlib.dll`和`System.dll`并不是唯一向`System.Collections.Generic`命名空间添加新类型的程序集。例如，`System.Core.dll`将`HashSet<T>`类添加到组合中。请务必查阅。NET Framework 文档，了解关于名称空间的全部细节。

无论如何，您的下一个任务是学习如何使用这些通用集合类。但是，在此之前，请允许我举例说明 C#语言的一个特性(首先在。NET 3.5)，它简化了用数据填充通用(和非通用)收集容器的方式。

### 了解集合初始化语法

在[第 4 章](04.html)中，你学习了对象初始化语法，它允许你在构造时设置新变量的属性。与此密切相关的是集合初始化语法。C#语言的这一特性使得通过使用与填充基本数组类似的语法来用项目填充许多容器(如`ArrayList`或`List<T>`)成为可能。

Note

您只能将集合初始化语法应用于支持`Add()`方法的类，该方法由`ICollection<T>` / `ICollection`接口形式化。

考虑下面的例子:

`// Init a standard array.`

`int[] myArrayOfInts = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };`

`// Init a generic List<> of ints.`

`List<int> myGenericList = new List<int> { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };`

`// Init an ArrayList with numerical data.`

`ArrayList myList = new ArrayList { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 };`

如果您的容器正在管理一个类集合或一个结构，您可以将对象初始化语法与集合初始化语法结合起来，以生成一些功能代码。您可能还记得第 5 章的[中的`Point`类，它定义了两个名为`X`和`Y`的属性。如果您想构建一个通用的`Point`对象的`List<T>`，您可以编写如下代码:](05.html)

`List<Point> myListOfPoints = new List<Point>`

`{`

`new Point { X = 2, Y = 2 },`

`new Point { X = 3, Y = 3 },`

`new Point(PointColor.BloodRed){ X = 4, Y = 4 }`

`};`

`foreach (var pt in myListOfPoints)`

`{`

`Console.WriteLine(pt);`

`}`

同样，这种语法的好处是您可以节省大量的击键次数。如果您不介意格式，嵌套的花括号可能会变得难以阅读，想象一下如果您没有集合初始化语法，填充下面的`Rectangle`的`List<T>`所需的代码量(您可能还记得在《T4》第 4 章中，您创建了一个包含封装了`Point`对象的两个属性的`Rectangle`类)。

`List<Rectangle> myListOfRects = new List<Rectangle>`

`{`

`new Rectangle {TopLeft = new Point { X = 10, Y = 10 },`

`BottomRight = new Point { X = 200, Y = 200}},`

`new Rectangle {TopLeft = new Point { X = 2, Y = 2 },`

`BottomRight = new Point { X = 100, Y = 100}},`

`new Rectangle {TopLeft = new Point { X = 5, Y = 5 },`

`BottomRight = new Point { X = 90, Y = 75}}`

`};`

`foreach (var r in myListOfRects)`

`{`

`Console.WriteLine(r);`

`}`

### 使用列表<t>类</t>

创建一个名为 FunWithGenericCollections 的新控制台应用程序项目。请注意，您的初始 C#代码文件已经导入了`System.Collections.Generic`名称空间。

您将研究的第一个泛型类是`List<T>`，您已经在本章中见过一两次了。在`System.Collections.Generic`命名空间中，`List<T>`类肯定是您最常用的类型，因为它允许您动态地调整容器内容的大小。为了说明这种类型的基本原理，考虑一下您的`Program`类中的以下方法，它利用`List<T>`来操作本章前面显示的一组`Person`对象；您可能还记得这些`Person`对象定义了三个属性(`Age`、`FirstName`和`LastName`)和一个定制的`ToString()`实现:

`static void UseGenericList()`

`{`

`// Make a List of Person objects, filled with`

`// collection/object init syntax.`

`List<Person> people = new List<Person>()`

`{`

`new Person {FirstName= "Homer", LastName="Simpson", Age=47},`

`new Person {FirstName= "Marge", LastName="Simpson", Age=45},`

`new Person {FirstName= "Lisa", LastName="Simpson", Age=9},`

`new Person {FirstName= "Bart", LastName="Simpson", Age=8}`

`};`

`// Print out # of items in List.`

`Console.WriteLine("Items in list: {0}", people.Count);`

`// Enumerate over list.`

`foreach (Person p in people)`

`Console.WriteLine(p);`

`// Insert a new person.`

`Console.WriteLine("\n->Inserting new person.");`

`people.Insert(2, new Person { FirstName = "Maggie", LastName = "Simpson", Age = 2 });`

`Console.WriteLine("Items in list: {0}", people.Count);`

`// Copy data into a new array.`

`Person[] arrayOfPeople = people.ToArray();`

`for (int i = 0; i < arrayOfPeople.Length; i++)`

`{`

`Console.WriteLine("First Names: {0}", arrayOfPeople[i].FirstName);`

`}`

`}`

这里，您使用初始化语法用对象填充您的`List<T>`，作为多次调用`Add()`的简写符号。在打印出集合中的条目数量(以及枚举每个条目)之后，调用`Insert()`。如您所见，`Insert()`允许您在指定的索引处将一个新项目插入到`List<T>`中。

最后，注意对`ToArray()`方法的调用，它基于原始`List<T>`的内容返回一个`Person`对象的数组。从此数组中，使用数组的索引器语法再次循环遍历这些项。如果您从`Main()`中调用这个方法，您会得到以下输出:

`***** Fun with Generic Collections *****`

`Items in list: 4`

`Name: Homer Simpson, Age: 47`

`Name: Marge Simpson, Age: 45`

`Name: Lisa Simpson, Age: 9`

`Name: Bart Simpson, Age: 8`

`->Inserting new person.`

`Items in list: 5`

`First Names: Homer`

`First Names: Marge`

`First Names: Maggie`

`First Names: Lisa`

`First Names: Bart`

`List<T>`类定义了许多感兴趣的额外成员，所以请务必参考。NET Framework 文档了解更多信息。接下来，让我们看看几个更通用的集合，具体来说就是`Stack<T>`、`Queue<T>`和`SortedSet<T>`。这将使您能够很好地理解关于如何保存自定义应用程序数据的基本选择。

### 使用堆栈<t>类</t>

`Stack<T>`类表示使用后进先出方式维护项目的集合。如您所料，`Stack<T>`定义了名为`Push()`和`Pop()`的成员来将项目放入堆栈或从堆栈中移除项目。下面的方法创建了一个`Person`对象的堆栈:

`static void UseGenericStack()`

`{`

`Stack<Person> stackOfPeople = new Stack<Person>();`

`stackOfPeople.Push(new Person`

`{ FirstName = "Homer", LastName = "Simpson", Age = 47 });`

`stackOfPeople.Push(new Person`

`{ FirstName = "Marge", LastName = "Simpson", Age = 45 });`

`stackOfPeople.Push(new Person`

`{ FirstName = "Lisa", LastName = "Simpson", Age = 9 });`

`// Now look at the top item, pop it, and look again.`

`Console.WriteLine("First person is: {0}", stackOfPeople.Peek());`

`Console.WriteLine("Popped off {0}", stackOfPeople.Pop());`

`Console.WriteLine("\nFirst person is: {0}", stackOfPeople.Peek());`

`Console.WriteLine("Popped off {0}", stackOfPeople.Pop());`

`Console.WriteLine("\nFirst person item is: {0}", stackOfPeople.Peek());`

`Console.WriteLine("Popped off {0}", stackOfPeople.Pop());`

`try`

`{`

`Console.WriteLine("\nnFirst person is: {0}", stackOfPeople.Peek());`

`Console.WriteLine("Popped off {0}", stackOfPeople.Pop());`

`}`

`catch (InvalidOperationException ex)`

`{`

`Console.WriteLine("\nError! {0}", ex.Message);`

`}`

`}`

在这里，您构建了一个包含三个人的堆栈，按照他们名字的顺序添加:Homer、Marge 和 Lisa。当你窥视堆栈时，你总是首先看到顶部的对象；因此，对`Peek()`的第一次调用揭示了第三个`Person`对象。在一系列的`Pop()`和`Peek()`调用之后，堆栈最终清空，此时额外的`Peek()`和`Pop()`调用引发一个系统异常。您可以在这里看到它的输出:

`***** Fun with Generic Collections *****`

`First person is: Name: Lisa Simpson, Age: 9`

`Popped off Name: Lisa Simpson, Age: 9`

`First person is: Name: Marge Simpson, Age: 45`

`Popped off Name: Marge Simpson, Age: 45`

`First person item is: Name: Homer Simpson, Age: 47`

`Popped off Name: Homer Simpson, Age: 47`

`Error! Stack empty.`

### 使用队列<t>类</t>

队列是确保以先进先出的方式访问项目的容器。可悲的是，我们人类整天都在排队:在银行排队，在电影院排队，在早晨的咖啡馆排队。当您需要建立一个场景模型，在这个场景中，项目是按照先来先服务的原则处理的，您会发现`Queue<T>`类符合这个要求。除了被支持的接口所提供的功能外，`Queue`还定义了表 [9-6](#Tab6) 中所示的关键成员。

表 9-6。

Members of the Queue<T> Type

<colgroup><col> <col></colgroup> 
| 选择队列成员 | 生命的意义 |
| --- | --- |
| `Dequeue()` | 移除并返回`Queue<T>`开头的对象 |
| `Enqueue()` | 将一个对象添加到`Queue<T>`的末尾 |
| `Peek()` | 返回`Queue<T>`开头的对象，但不删除它 |

现在让我们将这些方法付诸实践。您可以再次利用您的`Person`类，构建一个`Queue<T>`对象来模拟排队等候点咖啡的人群。首先，假设您有以下静态帮助器方法:

`static void GetCoffee(Person p)`

`{`

`Console.WriteLine("{0} got coffee!", p.FirstName);`

`}`

现在假设您有这个额外的 helper 方法，它在内部调用`GetCoffee()`:

`static void UseGenericQueue()`

`{`

`// Make a Q with three people.`

`Queue<Person> peopleQ = new Queue<Person>();`

`peopleQ.Enqueue(new Person {FirstName= "Homer",`

`LastName="Simpson", Age=47});`

`peopleQ.Enqueue(new Person {FirstName= "Marge",`

`LastName="Simpson", Age=45});`

`peopleQ.Enqueue(new Person {FirstName= "Lisa",`

`LastName="Simpson", Age=9});`

`// Peek at first person in Q.`

`Console.WriteLine("{0} is first in line!", peopleQ.Peek().FirstName);`

`// Remove each person from Q.`

`GetCoffee(peopleQ.Dequeue());`

`GetCoffee(peopleQ.Dequeue());`

`GetCoffee(peopleQ.Dequeue());`

`// Try to de-Q again?`

`try`

`{`

`GetCoffee(peopleQ.Dequeue());`

`}`

`catch(InvalidOperationException e)`

`{`

`Console.WriteLine("Error! {0}", e.Message);`

`}`

`}`

这里，您使用`Enqueue()`方法将三个项目插入到`Queue<T>`类中。对`Peek()`的调用允许您查看(但不能删除)当前在`Queue`中的第一个项目。最后，对`Dequeue()`的调用从行中删除项目，并将其发送到`GetCoffee()`辅助函数进行处理。请注意，如果试图从空队列中移除项，将会引发运行时异常。以下是调用此方法时收到的输出:

`***** Fun with Generic Collections *****`

`Homer is first in line!`

`Homer got coffee!`

`Marge got coffee!`

`Lisa got coffee!`

`Error! Queue empty.`

### 使用 SortedSet <t>类</t>

`SortedSet<T>`类很有用，因为它能自动确保在插入或删除项目时对集合中的项目进行排序。但是，您确实需要通知`SortedSet<T>`类您希望它如何对对象进行排序，方法是将实现通用`IComparer<T>`接口的对象作为构造函数参数传入。

首先创建一个名为`SortPeopleByAge`的新类，它实现了`IComparer<T>`，其中`T`的类型是`Person`。回想一下，这个接口定义了一个名为`Compare()`的方法，在这个方法中，您可以编写任何需要进行比较的逻辑。下面是该类的一个简单实现:

`class SortPeopleByAge : IComparer<Person>`

`{`

`public int Compare(Person firstPerson, Person secondPerson)`

`{`

`if (firstPerson.Age > secondPerson.Age)`

`return 1;`

`if (firstPerson.Age < secondPerson.Age)`

`return -1;`

`else`

`return 0;`

`}`

`}`

现在用下面的新方法更新您的`Program`类，我假设您将从`Main()`调用它:

`static void UseSortedSet()`

`{`

`// Make some people with different ages.`

`SortedSet<Person> setOfPeople = new SortedSet<Person>(new SortPeopleByAge())`

`{`

`new Person {FirstName= "Homer", LastName="Simpson", Age=47},`

`new Person {FirstName= "Marge", LastName="Simpson", Age=45},`

`new Person {FirstName= "Lisa",  LastName="Simpson", Age=9},`

`new Person {FirstName= "Bart",  LastName="Simpson", Age=8}`

`};`

`// Note the items are sorted by age!`

`foreach (Person p in setOfPeople)`

`{`

`Console.WriteLine(p);`

`}`

`Console.WriteLine();`

`// Add a few new people, with various ages.`

`setOfPeople.Add(new Person { FirstName = "Saku",  LastName = "Jones", Age = 1 });`

`setOfPeople.Add(new Person { FirstName = "Mikko", LastName = "Jones", Age = 32 });`

`// Still sorted by age!`

`foreach (Person p in setOfPeople)`

`{`

`Console.WriteLine(p);`

`}`

`}`

当您运行应用程序时，对象列表现在总是基于`Age`属性的值进行排序，而不管您插入或移除对象的顺序。

`***** Fun with Generic Collections *****`

`Name: Bart Simpson, Age: 8`

`Name: Lisa Simpson, Age: 9`

`Name: Marge Simpson, Age: 45`

`Name: Homer Simpson, Age: 47`

`Name: Saku Jones, Age: 1`

`Name: Bart Simpson, Age: 8`

`Name: Lisa Simpson, Age: 9`

`Name: Mikko Jones, Age: 32`

`Name: Marge Simpson, Age: 45`

`Name: Homer Simpson, Age: 47`

### 使用字典<tkey tvalue="">类</tkey>

另一个方便的泛型集合是`Dictionary<TKey,TValue>`类型，它允许您保存任意数量的对象，这些对象可以通过一个惟一的键来引用。因此，您可以使用唯一的文本键(例如，“给我第二个对象”)，而不是使用数字标识符从`List<T>`获取项目(例如，“给我我键入为 Homer 的对象”)。

像其他集合对象一样，您可以通过手动调用通用的`Add()`方法来填充一个`Dictionary<TKey,TValue>`。但是，您也可以使用集合初始化语法填充一个`Dictionary<TKey,TValue>`。请注意，在填充这个集合对象时，键名必须是唯一的。如果多次错误地指定了同一个键，将会收到运行时异常。

考虑以下用各种对象填充`Dictionary<K,V>`的方法。注意，当您创建`Dictionary<TKey,TValue>`对象时，您指定键类型(`TKey`)和底层对象类型(`TValue`)作为构造函数参数。这里，您使用了一个`string`数据类型作为键(虽然这不是必需的；key 可以是任何类型)和一个`Person`类型作为值。

`private static void UseDictionary()`

`{`

`// Populate using Add() method`

`Dictionary<string, Person> peopleA = new Dictionary<string, Person>();`

`peopleA.Add("Homer", new Person { FirstName = "Homer", LastName = "Simpson", Age = 47 });`

`peopleA.Add("Marge", new Person { FirstName = "Marge", LastName = "Simpson", Age = 45 });`

`peopleA.Add("Lisa", new Person { FirstName = "Lisa", LastName = "Simpson", Age = 9 });`

`// Get Homer.`

`Person homer = peopleA["Homer"];`

`Console.WriteLine(homer);`

`// Populate with initialization syntax.`

`Dictionary<string, Person> peopleB = new Dictionary<string, Person>()`

`{`

`{ "Homer", new Person { FirstName = "Homer", LastName = "Simpson", Age = 47 } },`

`{ "Marge", new Person { FirstName = "Marge", LastName = "Simpson", Age = 45 } },`

`{ "Lisa",  new Person { FirstName = "Lisa",  LastName = "Simpson", Age = 9 } }`

`};`

`// Get Lisa.`

`Person lisa = peopleB["Lisa"];`

`Console.WriteLine(lisa);`

`}`

也可以使用当前版本中引入的相关初始化语法来填充`Dictionary<TKey,TValue>`。特定于这种类型的容器(毫不奇怪地称为字典初始化)。类似于前面代码示例中用于填充`personB`对象的语法，您仍然为集合对象定义一个初始化范围；但是，您可以使用索引器来指定键，并将其分配给新对象，如下所示:

`// Populate with dictionary initialization syntax.`

`Dictionary<string, Person> peopleC = new Dictionary<string, Person>()`

`{`

`["Homer"] = new Person { FirstName = "Homer", LastName = "Simpson", Age = 47 },`

`["Marge"] = new Person { FirstName = "Marge", LastName = "Simpson", Age = 45 },`

`["Lisa"]  = new Person { FirstName = "Lisa",  LastName = "Simpson", Age = 9 }`

`};`

Note

您可以在 [`Chapter 9`](09.html) 子目录中找到 FunWithGenericCollections 项目。

## 系统。Collections.ObjectModel 命名空间

既然您已经理解了如何使用主要的泛型类，那么您可以简单地检查一个额外的以集合为中心的名称空间，`System.Collections.ObjectModel`。这是一个相对较小的名称空间，包含少量的类。表 [9-7](#Tab7) 记录了你最应该知道的两个类别。

表 9-7。

Useful Members of System.Collections.ObjectModel

<colgroup><col> <col></colgroup> 
| 系统。集合. ObjectModel 类型 | 生命的意义 |
| --- | --- |
| `ObservableCollection<T>` | 表示一个动态数据集合，该集合在添加、移除项或刷新整个列表时提供通知 |
| `ReadOnlyObservableCollection<T>` | 表示只读版本的`ObservableCollection<T>` |

`ObservableCollection<T>`类是有用的，因为当它的内容以某种方式改变时，它能够通知外部对象(正如您可能猜到的，使用`ReadOnlyObservableCollection<T>`类似，但本质上是只读的)。

### 使用 ObservableCollection

创建一个名为 FunWithObservableCollection 的新控制台应用程序项目，并将名称空间`System.Collections.ObjectModel`导入到初始 C#代码文件中。在许多方面，使用`ObservableCollection<T>`与使用`List<T>`是相同的，因为这两个类实现了相同的核心接口。`ObservableCollection<T>`类的独特之处在于它支持一个名为`CollectionChanged`的事件。每当插入新项、移除(或重新定位)当前项或修改整个集合时，都会触发此事件。

像任何事件一样，`CollectionChanged`是根据委托定义的，在本例中是`NotifyCollectionChangedEventHandler`。这个委托可以调用任何以一个对象作为第一个参数，以一个`NotifyCollectionChangedEventArgs`作为第二个参数的方法。考虑下面的`Main()`方法，它填充一个包含`Person`对象的可观察集合并连接`CollectionChanged`事件:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`// Make a collection to observe and add a few Person objects.`

`ObservableCollection<Person> people = new ObservableCollection<Person>()`

`{`

`new Person{ FirstName = "Peter", LastName = "Murphy", Age = 52 },`

`new Person{ FirstName = "Kevin", LastName = "Key", Age = 48 },`

`};`

`// Wire up the CollectionChanged event.`

`people.CollectionChanged += people_CollectionChanged;`

`}`

`static void people_CollectionChanged(object sender,`

`System.Collections.Specialized.NotifyCollectionChangedEventArgs e)`

`{`

`throw new NotImplementedException();`

`}`

`}`

传入的`NotifyCollectionChangedEventArgs`参数定义了两个重要的属性，`OldItems`和`NewItems`，这将为您提供一个列表，其中列出了事件触发前集合中的当前项目以及变更中涉及的新项目。但是，您只希望在正确的情况下检查这些列表。回想一下，当添加、删除、重定位或重置项目时，会触发`CollectionChanged`事件。要发现这些动作中的哪一个触发了事件，您可以使用`NotifyCollectionChangedEventArgs`的`Action`属性。可以针对`NotifyCollectionChangedAction`枚举的以下任何成员测试`Action`属性:

`public enum NotifyCollectionChangedAction`

`{`

`Add = 0,`

`Remove = 1,`

`Replace = 2,`

`Move = 3,`

`Reset = 4,`

`}`

下面是一个`CollectionChanged`事件处理程序的实现，当一个项目被插入或删除到手边的集合时，它将遍历旧的和新的集合:

`static void people_CollectionChanged(object sender,`

`System.Collections.Specialized.NotifyCollectionChangedEventArgs e)`

`{`

`// What was the action that caused the event?`

`Console.WriteLine("Action for this event: {0}", e.Action);`

`// They removed something.`

`if (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Remove)`

`{`

`Console.WriteLine("Here are the OLD items:");`

`foreach (Person p in e.OldItems)`

`{`

`Console.WriteLine(p.ToString());`

`}`

`Console.WriteLine();`

`}`

`// They added something.`

`if (e.Action == System.Collections.Specialized.NotifyCollectionChangedAction.Add)`

`{`

`// Now show the NEW items that were inserted.`

`Console.WriteLine("Here are the NEW items:");`

`foreach (Person p in e.NewItems)`

`{`

`Console.WriteLine(p.ToString());`

`}`

`}`

`}`

现在，假设您已经更新了您的`Main()`方法来添加和删除一个项目，您将看到类似如下的输出:

`Action for this event: Add`

`Here are the NEW items:`

`Name: Fred Smith, Age: 32`

`Action for this event: Remove`

`Here are the OLD items:`

`Name: Peter Murphy, Age: 52`

中各种以集合为中心的名称空间的检查。NET 基础类库。作为本章的总结，现在您将研究如何构建自己的自定义泛型方法和自定义泛型类型。

Source Code

您可以在 [`Chapter 9`](09.html) 子目录中找到 FunWithObservableCollection 项目。

## 创建自定义泛型方法

虽然大多数开发人员通常使用基类库中的现有泛型类型，但也可以构建自己的泛型成员和自定义泛型类型。让我们看看如何将自定义泛型合并到您自己的项目中。第一步是构建一个通用的交换方法。首先创建一个名为 CustomGenericMethods 的新控制台应用程序。

当您构建自定义泛型方法时，您实现了传统方法重载的增压版本。在第 2 章中，你学到了重载是定义一个方法的多个版本的行为，这些版本在参数的数量或类型上有所不同。

虽然重载在面向对象语言中是一个有用的特性，但有一个问题是，你很容易用大量本质上做同样事情的方法来结束。例如，假设您需要构建一些方法，这些方法可以使用一个简单的交换例程来交换两段数据。您可以从编写一个可以对整数进行操作的新方法开始，如下所示:

`// Swap two integers.`

`static void Swap(ref int a, ref int b)`

`{`

`int temp;`

`temp = a;`

`a = b;`

`b = temp;`

`}`

目前为止，一切顺利。但是现在假设您还需要交换两个`Person`对象；这需要创作一个新版本的`Swap()`。

`// Swap two Person objects.`

`static void Swap(ref Person a, ref Person b)`

`{`

`Person temp;`

`temp = a;`

`a = b;`

`b = temp;`

`}`

毫无疑问，你可以看到这将走向何方。如果您还需要交换浮点数、位图、汽车、按钮等等，您将不得不构建更多的方法，这将成为维护的噩梦。你可以构建一个操作`object`参数的单一(非泛型)方法，但是你会面临你在本章前面检查过的所有问题，包括装箱、拆箱、缺乏类型安全、显式强制转换等等。

每当你有一组重载的方法，它们只有传入的参数不同，这是你的线索，泛型可以让你的生活更容易。考虑下面的通用`Swap<T>`方法，它可以交换任意两个`T`:

`// This method will swap any two items.`

`// as specified by the type parameter <T>.`

`static void Swap<T>(ref T a, ref T b)`

`{`

`Console.WriteLine("You sent the Swap() method a {0}",`

`typeof(T));`

`T temp;`

`temp = a;`

`a = b;`

`b = temp;`

`}`

请注意，泛型方法是如何通过在方法名之后、参数列表之前指定类型参数来定义的。这里，您声明了`Swap<T>()`方法可以对任意两个类型为`<T>`的参数进行操作。为了增加一点趣味，您还可以使用 C#的`typeof()`操作符将所提供的占位符的类型名称打印到控制台。现在考虑下面的`Main()`方法，它交换整数和字符串:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Custom Generic Methods *****\n");`

`// Swap 2 ints.`

`int a = 10, b = 90;`

`Console.WriteLine("Before swap: {0}, {1}", a, b);`

`Swap<int>(ref a, ref b);`

`Console.WriteLine("After swap: {0}, {1}", a, b);`

`Console.WriteLine();`

`// Swap 2 strings.`

`string s1 = "Hello", s2 = "There";`

`Console.WriteLine("Before swap: {0} {1}!", s1, s2);`

`Swap<string>(ref s1, ref s2);`

`Console.WriteLine("After swap: {0} {1}!", s1, s2);`

`Console.ReadLine();`

`}`

输出如下所示:

`***** Fun with Custom Generic Methods *****`

`Before swap: 10, 90`

`You sent the Swap() method a System.Int32`

`After swap: 90, 10`

`Before swap: Hello There!`

`You sent the Swap() method a System.String`

`After swap: There Hello!`

这种方法的主要好处是您只需要维护一个版本的`Swap<T>()`,但是它可以以类型安全的方式对给定类型的任意两个项目进行操作。更好的是，基于栈的项留在栈上，而基于堆的项留在堆上！

### 类型参数的推断

当您调用泛型方法(如`Swap<T>`)时，如果(且仅当)泛型方法需要参数，您可以选择省略类型参数，因为编译器可以根据成员参数推断类型参数。例如，您可以通过向`Main()`添加以下代码来交换两个`System.Boolean`值:

`// Compiler will infer System.Boolean.`

`bool b1 = true, b2 = false;`

`Console.WriteLine("Before swap: {0}, {1}", b1, b2);`

`Swap(ref b1, ref b2);`

`Console.WriteLine("After swap: {0}, {1}", b1, b2);`

即使编译器能够根据用于声明`b1`和`b2`的数据类型发现正确的类型参数，您也应该养成总是显式指定类型参数的习惯。

`Swap<string>(ref b1, ref b2);`

这让你的程序员同事清楚，这个方法确实是通用的。此外，只有当泛型方法至少有一个参数时，类型参数的推断才有效。例如，假设您的`Program`类中有以下泛型方法:

`static void DisplayBaseClass<T>()`

`{`

`// BaseType is a method used in reflection,`

`// which will be examined in Chapter`[`15`T3】](15.html)

`Console.WriteLine("Base class of {0} is: {1}.",`

`typeof(T), typeof(T).BaseType);`

`}`

在这种情况下，您必须在调用时提供类型参数。

`static void Main(string[] args)`

`{`

`...`

`// Must supply type parameter if`

`// the method does not take params.`

`DisplayBaseClass<int>();`

`DisplayBaseClass<string>();`

`// Compiler error! No params? Must supply placeholder!`

`// DisplayBaseClass();`

`Console.ReadLine();`

`}`

目前，通用的`Swap<T>`和`DisplayBaseClass<T>`方法是在应用程序的`Program`类中定义的。当然，与任何方法一样，如果您愿意的话，可以在单独的类类型(`MyGenericMethods`)中自由定义这些成员。

`public static class MyGenericMethods`

`{`

`public static void Swap<T>(ref T a, ref T b)`

`{`

`Console.WriteLine("You sent the Swap() method a {0}",`

`typeof(T));`

`T temp;`

`temp = a;`

`a = b;`

`b = temp;`

`}`

`public static void DisplayBaseClass<T>()`

`{`

`Console.WriteLine("Base class of {0} is: {1}.",`

`typeof(T), typeof(T).BaseType);`

`}`

`}`

静态的`Swap<T>`和`DisplayBaseClass<T>`方法已经在一个新的静态类类型中确定了作用域，所以您需要在调用任一成员时指定类型的名称，如下例所示:

`MyGenericMethods.Swap<int>(ref a, ref b);`

当然，泛型方法不需要是静态的。如果`Swap<T>`和`DisplayBaseClass<T>`是实例级的(并且定义在一个非静态类中)，你只需创建一个`MyGenericMethods`的实例，并使用对象变量调用它们。

`MyGenericMethods c = new MyGenericMethods();`

`c.Swap<int>(ref a, ref b);`

Source Code

您可以在 [`Chapter 9`](09.html) 子目录中找到 CustomGenericMethods 项目。

## 创建自定义泛型结构和类

现在，您已经了解了如何定义和调用泛型方法，是时候将注意力转向在名为 GenericPoint 的新控制台应用程序项目中构造泛型结构了(构建泛型类的过程是相同的)。假设您已经构建了一个通用的`Point`结构，它支持表示(x，y)坐标的底层存储的单一类型参数。然后调用者可以创建如下的`Point<T>`类型:

`// Point using ints.`

`Point<int> p = new Point<int>(10, 10);`

`// Point using double.`

`Point<double> p2 = new Point<double>(5.4, 3.3);`

这里是`Point<T>`的完整定义，下面是一些分析:

`// A generic Point structure.`

`public struct Point<T>`

`{`

`// Generic state date.`

`private T xPos;`

`private T yPos;`

`// Generic constructor.`

`public Point(T xVal, T yVal)`

`{`

`xPos = xVal;`

`yPos = yVal;`

`}`

`// Generic properties.`

`public T X`

`{`

`get { return xPos; }`

`set { xPos = value; }`

`}`

`public T Y`

`{`

`get { return yPos; }`

`set { yPos = value; }`

`}`

`public override string ToString()`

`{`

`return string.Format("[{0}, {1}]", xPos, yPos);`

`}`

`// Reset fields to the default value of the`

`// type parameter.`

`public void ResetPoint()`

`{`

`xPos = default(T);`

`yPos = default(T);`

`}`

`}`

### 泛型代码中的默认关键字

如您所见，`Point<T>`在字段数据的定义、构造函数参数和属性定义中利用了它的类型参数。注意，除了覆盖`ToString()`，`Point<T>`还定义了一个名为`ResetPoint()`的方法，该方法使用了一些您还没有见过的新语法。

`// The "default" keyword is overloaded in C#.`

`// When used with generics, it represents the default`

`// value of a type parameter.`

`public void ResetPoint()`

`{`

`X = default(T);`

`Y = default(T);`

`}`

随着泛型的引入，C# `default`关键字被赋予了双重身份。除了在`switch`构造中使用之外，它还可以用于将类型参数设置为默认值。这很有帮助，因为泛型类型事先不知道实际的占位符，这意味着它不能安全地假定默认值是什么。类型参数的默认值如下:

*   数值的默认值为`0`。
*   引用类型有一个默认值`null`。
*   结构的字段被设置为`0`(对于值类型)或`null`(对于引用类型)。

对于`Point<T>`，您可以直接将`X`和`Y`的值设置为`0`，因为假设调用者只提供数字数据是安全的。然而，您也可以通过使用`default(T)`语法来增加泛型类型的整体灵活性。无论如何，你现在可以练习`Point<T>`的方法了。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Generic Structures *****\n");`

`// Point using ints.`

`Point<int> p = new Point<int>(10, 10);`

`Console.WriteLine("p.ToString()={0}", p.ToString());`

`p.ResetPoint();`

`Console.WriteLine("p.ToString()={0}", p.ToString());`

`Console.WriteLine();`

`// Point using double.`

`Point<double> p2 = new Point<double>(5.4, 3.3);`

`Console.WriteLine("p2.ToString()={0}", p2.ToString());`

`p2.ResetPoint();`

`Console.WriteLine("p2.ToString()={0}", p2.ToString());`

`Console.ReadLine();`

`}`

以下是输出:

`***** Fun with Generic Structures *****`

`p.ToString()=[10, 10]`

`p.ToString()=[0, 0]`

`p2.ToString()=[5.4, 3.3]`

`p2.ToString()=[0, 0]`

Source Code

你可以在 [`Chapter 9`](09.html) 子目录中找到 GenericPoint 项目。

## 约束类型参数

如本章所示，任何泛型项都至少有一个类型参数，您需要在与泛型类型或成员交互时指定该类型参数。仅这一点就允许您构建一些类型安全的代码；然而。NET 平台允许您使用`where`关键字来非常具体地了解给定类型参数必须是什么样子。

使用该关键字，可以向给定的类型参数添加一组约束，C#编译器将在编译时检查这些约束。具体来说，你可以约束一个类型参数，如表 [9-8](#Tab8) 所述。

表 9-8。

Possible Constraints for Generic Type Parameters

<colgroup><col> <col></colgroup> 
| 通用约束 | 生命的意义 |
| --- | --- |
| `where T : struct` | 类型参数`<T>`在其继承链中必须有`System.ValueType`(即`<T>`必须是一个结构)。 |
| `where T : class` | 类型参数`<T>`的继承链中不能有`System.ValueType`(即`<T>`必须是引用类型)。 |
| `where T : new()` | 类型参数`<T>`必须有默认的构造函数。如果您的泛型类型必须创建类型参数的实例，这将很有帮助，因为您无法假定自己知道自定义构造函数的格式。请注意，在多约束类型中，该约束必须列在最后。 |
| `where T : NameOfBaseClass` | 类型参数`<T>`必须从`NameOfBaseClass`指定的类中派生。 |
| `where T : NameOfInterface` | 类型参数`<T>`必须实现`NameOfInterface`指定的接口。您可以用逗号分隔的列表分隔多个接口。 |

除非您需要构建一些极其类型安全的自定义集合，否则您可能永远不需要在 C#项目中使用`where`关键字。不管怎样，下面几个(部分)代码示例说明了如何使用`where`关键字。

### 使用 where 关键字的示例

首先假设您已经创建了一个自定义泛型类，并且希望确保类型参数有一个默认的构造函数。当自定义泛型类需要创建`T`的实例时，这可能是有用的，因为默认构造函数是所有类型可能共有的唯一构造函数。同样，以这种方式约束`T`可以让您获得编译时检查；如果`T`是一个引用类型，程序员记得在类定义中重定义默认构造函数(您可能记得当您定义自己的构造函数时，默认构造函数在类中被移除了)。

`// MyGenericClass derives from object, while`

`// contained items must have a default ctor.`

`public class MyGenericClass<T> where T : new()`

`{`

`...`

`}`

注意,`where`子句指定了哪个类型参数被约束，后面跟着一个冒号操作符。在冒号操作符之后，您列出了每个可能的约束(在本例中，是一个默认的构造函数)。这是另一个例子:

`// MyGenericClass derives from object, while`

`// contained items must be a class implementing IDrawable`

`// and must support a default ctor.`

`public class MyGenericClass<T> where T : class, IDrawable, new()`

`{`

`...`

`}`

在这种情况下，`T`有三个要求。它必须是引用类型(不是结构)，用`class`标记。第二，`T`必须实现`IDrawable`接口。第三，它还必须有一个默认的构造函数。多个约束列在逗号分隔的列表中；然而，你应该知道`new()`约束必须总是列在最后！因此，下面的代码不会编译:

`// Error! new() constraint must be listed last!`

`public class MyGenericClass<T> where T : new(), class, IDrawable`

`{`

`...`

`}`

如果您曾经创建了一个指定多个类型参数的定制泛型集合类，那么您可以使用单独的`where`子句为每个类型参数指定一组唯一的约束。

`// <K> must extend SomeBaseClass and have a default ctor,`

`// while <T> must be a structure and implement the`

`// generic IComparable interface.`

`public class MyGenericClass<K, T> where K : SomeBaseClass, new()`

`where T : struct, IComparable<T>`

`{`

`...`

`}`

您很少会遇到需要构建完整的自定义泛型集合类的情况；然而，您也可以在泛型方法上使用`where`关键字。例如，如果您想要指定您的泛型`Swap<T>()`方法只能在结构上操作，您应该像这样更新方法:

`// This method will swap any structure, but not classes.`

`static void Swap<T>(ref T a, ref T b) where T : struct`

`{`

`...`

`}`

注意，如果您以这种方式约束`Swap()`方法，您将不再能够交换`string`对象(如示例代码所示),因为`string`是一个引用类型。

### 缺乏对经营者的约束

在本章接近尾声的时候，我想对泛型方法和约束再做一点评论。您可能会惊讶地发现，在创建泛型方法时，如果应用任何 C#操作符(`+`、`-`、`*`、`==`等)，都会出现编译器错误。)上的类型参数。例如，想象一下一个可以对泛型类型进行加、减、乘、除的类有多有用。

`// Compiler error! Cannot apply`

`// operators to type parameters!`

`public class BasicMath<T>`

`{`

`public T Add(T arg1, T arg2)`

`{ return arg1 + arg2; }`

`public T Subtract(T arg1, T arg2)`

`{ return arg1 - arg2; }`

`public T Multiply(T arg1, T arg2)`

`{ return arg1 * arg2; }`

`public T Divide(T arg1, T arg2)`

`{ return arg1 / arg2; }`

`}`

不幸的是，前面的`BasicMath`类无法编译。虽然这看起来是一个主要的限制，但是你需要记住泛型是通用的。当然，数字数据可以很好地与 C#的二元操作符一起工作。然而，为了便于讨论，如果`<T>`是一个定制类或结构类型，编译器可以假设该类支持`+`、`-`、`*`和`/`操作符。理想情况下，C#允许泛型类型受支持的运算符约束，如下例所示:

`// Illustrative code only!`

`public class BasicMath<T> where T : operator +, operator -,`

`operator *, operator /`

`{`

`public T Add(T arg1, T arg2)`

`{ return arg1 + arg2; }`

`public T Subtract(T arg1, T arg2)`

`{ return arg1 - arg2; }`

`public T Multiply(T arg1, T arg2)`

`{ return arg1 * arg2; }`

`public T Divide(T arg1, T arg2)`

`{ return arg1 / arg2; }`

`}`

唉，当前版本的 C#不支持运算符约束。然而，通过定义一个支持这些操作符的接口(C#接口可以定义操作符!)来达到预期的效果是可能的(尽管这需要更多的工作)!)然后指定泛型类的接口约束。无论如何，这总结了本书对构建定制泛型类型的初步看法。在第 10 章中，我将在研究。NET 委托类型。

## 摘要

本章从检查`System.Collections`和`System.Collections.Specialized`的非泛型集合类型开始，包括与许多非泛型容器相关的各种问题，包括缺乏类型安全性以及装箱和取消装箱操作的运行时开销。如上所述，由于这些原因，现代。NET 程序通常会利用`System.Collections.Generic`和`System.Collections.ObjectModel`中的通用集合类。

正如您所看到的，泛型项允许您指定占位符(类型参数)，这些占位符是您在对象创建(或调用，在泛型方法的情况下)时指定的。虽然您通常会简单地使用。NET 基础类库，您也将能够创建自己的泛型类型(和泛型方法)。当您这样做时，您可以选择指定任意数量的约束(使用`where`关键字)来提高类型安全级别，并确保您对保证展示某些基本功能的已知数量的类型执行操作。

最后要注意的是，记住泛型出现在。NET 基础类库。在这里，您特别关注了泛型集合。然而，当您阅读本书的剩余部分时(当您按照自己的方式深入平台时)，您肯定会发现泛型类、结构和委托位于给定的名称空间中。同样，要注意非泛型类的泛型成员！