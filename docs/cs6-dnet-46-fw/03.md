# 3.核心 C#编程构造，第一部分

本章介绍了一些在您探索 C#编程语言时必须熟悉的小范围独立主题，从而开始了您对 C #编程语言的正式研究。NET 框架。首先要理解如何构建程序的应用对象，并检查可执行程序入口点的组成:`Main()`方法。接下来，您将研究基本的 C#数据类型(以及它们在`System`名称空间中的等价类型)，包括对`System.String`和`System.Text.StringBuilder`类的研究。

在你了解了基本的细节之后。NET 数据类型，然后您将研究许多数据类型转换技术，包括收缩操作、扩大操作以及关键字`checked`和`unchecked`的使用。

本章还将研究 C# `var`关键字的作用，它允许你隐式地定义一个局部变量。正如您将在本书后面看到的，当使用 LINQ 技术集时，隐式类型非常有用，如果不是偶尔强制的话。您将通过快速检查 C#关键字和操作符来结束本章，这些关键字和操作符允许您使用各种循环和决策结构来控制应用的流程。

## 一个简单 C#程序的剖析

C#要求所有的程序逻辑都包含在一个类型定义中(回想一下第一章，类型是一个通用术语，指集合{类、接口、结构、枚举、委托}的成员)。与许多其他语言不同，在 C#中不可能创建全局函数或全局数据点。相反，所有数据成员和所有方法都必须包含在类型定义中。首先，创建一个名为 SimpleCSharpApp 的新控制台应用项目。您可能同意初始`Program.cs`文件中的代码相当平淡无奇。

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`using System.Threading.Tasks;`

`namespace SimpleCSharpApp`

`{`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`}`

`}`

`}`

鉴于此，用下面的代码语句更新您的`Program`类的`Main()`方法:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`// Display a simple message to the user.`

`Console.WriteLine("***** My First C# App *****");`

`Console.WriteLine("Hello World!");`

`Console.WriteLine();`

`// Wait for Enter key to be pressed before shutting down.`

`Console.ReadLine();`

`}`

`}`

Note

C#是一种区分大小写的编程语言。所以 main 不等同于 Main，ReadLine 不等同于 Readline。请注意，所有 C#关键字都是小写的(例如，`public`、`lock`、`class`、`dynamic`)，而名称空间、类型和成员名称(按照惯例)以首字母大写开始，并且所有嵌入单词的首字母都是大写的(例如，`Console.WriteLine`、`System.Windows.MessageBox`、`System.Data.SqlClient`)。作为一个经验法则，每当你收到一个关于“未定义符号”的编译器错误时，一定要首先检查你的拼写和大小写！

前面的代码包含一个支持名为`Main()`的单一方法的类类型的定义。默认情况下，Visual Studio 命名定义`Main() Program`的类；但是，如果您愿意，您可以自由更改。每个可执行的 C#应用(控制台程序、Windows 桌面程序或 Windows 服务)都必须包含一个定义`Main()`方法的类，该方法用于表示应用的入口点。

从形式上讲，定义`Main()`方法的类被称为应用对象。虽然单个可执行应用可能有多个 application 对象(这在执行单元测试时很有用)，但您必须通过命令行编译器的`/main`选项或通过位于 Visual Studio 项目属性编辑器的“应用”选项卡上的“启动对象”下拉列表框，通知编译器应该将哪个`Main()`方法用作入口点(参见[第 2 章](02.html))。

请注意，`Main()`的签名带有`static`关键字，这将在[第 5 章](05.html)中详细讨论。目前，只需理解静态成员的作用域是类级别(而不是对象级别)，因此无需首先创建新的类实例就可以调用静态成员。

除了关键字`static`之外，这个`Main()`方法还有一个参数，这个参数恰好是一个字符串数组(`string[] args`)。尽管您目前并不想处理这个数组，但是这个参数可能包含任意数量的传入命令行参数(稍后您将看到如何访问它们)。最后，这个`Main()`方法已经设置了一个`void`返回值，这意味着在退出方法范围之前，不需要使用`return`关键字显式定义返回值。

`Program`的逻辑在`Main()`内。这里，您使用了在`System`名称空间中定义的`Console`类。它的一组成员中有一个静态的`WriteLine()`，正如您可能想到的，它向标准输出发送一个文本字符串和回车。您还调用了`Console.ReadLine()`,以确保在调试会话期间 Visual Studio IDE 启动的命令提示符保持可见，直到您按下 Enter 键。(如果没有添加这一行，您的应用将在调试会话期间立即终止，您将无法读取输出！)你将很快了解到更多关于`System.Console`类的知识。

### Main()方法的变体

默认情况下，Visual Studio 将生成一个`Main()`方法，该方法有一个`void`返回值和一个`string`类型的数组作为单个输入参数。然而，这并不是`Main()`的唯一可能形式。允许使用以下任何签名构造应用的入口点(假设它包含在 C#类或结构定义中):

`// int return type, array of strings as the parameter.`

`static int Main(string[] args)`

`{`

`// Must return a value before exiting!`

`return 0;`

`}`

`// No return type, no parameters.`

`static void Main()`

`{`

`}`

`// int return type, no parameters.`

`static int Main()`

`{`

`// Must return a value before exiting!`

`return 0;`

`}`

Note

`Main()`方法也可以被定义为 public，而不是 private，如果你没有提供一个特定的访问修饰符，这是假设的。Visual Studio 自动将程序的`Main()`方法定义为隐式私有。

显然，您选择如何构造`Main()`将基于两个问题。首先，当`Main()`已经完成并且你的程序终止时，你想给系统返回值吗？如果是这样，你需要返回一个`int`数据类型，而不是`void`。第二，您需要处理任何用户提供的命令行参数吗？如果是这样，它们将被存储在`string`的数组中。让我们更详细地检查所有选项。

### 指定应用错误代码

虽然绝大多数的`Main()`方法将返回`void`作为返回值，但是从`Main()`返回`int`的能力使 C#与其他基于 C 的语言保持一致。按照惯例，返回值`0`表示程序已经成功终止，而另一个值(比如`-1`)表示一个错误条件(注意，值`0`是自动返回的，即使您构造了一个原型化的`Main()`方法来返回`void`)。

在 Windows 操作系统上，应用的返回值存储在名为`%ERRORLEVEL%`的系统环境变量中。如果你要创建一个以编程方式启动另一个可执行文件的应用(这个主题在第 18 章的[中讨论过)，你可以使用静态`System.Diagnostics.Process.ExitCode`属性获得`%ERRORLEVEL%`的值。](18.html)

假设应用的返回值是在应用终止时传递给系统的，那么应用显然不可能在运行时获得并显示其最终的错误代码。然而，为了说明如何在程序终止时查看这个错误级别，首先更新`Main()`方法，如下所示:

`// Note we are now returning an int, rather than void.`

`static int Main(string[] args)`

`{`

`// Display a message and wait for Enter key to be pressed.`

`Console.WriteLine("***** My First C# App *****");`

`Console.WriteLine("Hello World!");`

`Console.WriteLine();`

`Console.ReadLine();`

`// Return an arbitrary error code.`

`return -1;`

`}`

现在让我们在批处理文件的帮助下捕获`Main()`的返回值。使用 Windows 资源管理器，导航到包含已编译应用的文件夹(例如，`C:\SimpleCSharpApp\bin\Debug`)。将一个新的文本文件(名为`SimpleCSharpApp.bat`)添加到`Debug`文件夹中，该文件包含以下说明(如果您以前没有创作过`*.bat`文件，请不要关心这些细节；这是一个测试。。。这只是一个测试):

`@echo off`

`rem A batch file for SimpleCSharpApp.exe`

`rem which captures the app’s return value.`

`SimpleCSharpApp`

`@if "%ERRORLEVEL%" == "0" goto success`

`:fail`

`echo This application has failed!`

`echo return value = %ERRORLEVEL%`

`goto end`

`:success`

`echo This application has succeeded!`

`echo return value = %ERRORLEVEL%`

`goto end`

`:end`

`echo All Done.`

此时，打开命令提示符并导航到包含可执行文件和新的`*.bat`文件的文件夹。通过输入批处理逻辑的名称并按 Enter 键来执行批处理逻辑。假设您的`Main()`方法正在返回`-1`，您应该会发现如下所示的输出。如果`Main()`方法返回了`0`，您将会看到消息“该应用已经成功！”打印到控制台。

`***** My First C# App *****`

`Hello World!`

`This application has failed!`

`return value = -1`

`All Done.`

同样，绝大多数(如果不是全部的话)C#应用将使用`void`作为来自`Main()`的返回值，正如您所记得的，它隐式返回错误代码零。为此，本文中使用的`Main()`方法(超出当前示例)将确实返回`void`(并且其余项目肯定不需要利用批处理文件来捕获返回代码)。

### 处理命令行参数

现在您已经更好地理解了`Main()`方法的返回值，让我们检查一下`string`数据的传入数组。假设您现在想要更新您的应用来处理任何可能的命令行参数。一种方法是使用 C# `for`循环。(请注意，C#的迭代结构将在本章末尾详细讨论。)

`static int Main(string[] args)`

`{`

`...`

`// Process any incoming args.`

`for(int i = 0; i < args.Length; i++)`

`Console.WriteLine("Arg: {0}", args[i]);`

`Console.ReadLine();`

`return -1;`

`}`

在这里，您使用`System.Array`的`Length`属性来检查`string`的数组是否包含一些条目。正如你将在《T4》第四章中看到的，所有 C#数组实际上都是`System.Array`类的别名，因此，共享一组公共成员。当您循环数组中的每一项时，它的值会打印到控制台窗口。在命令行提供参数同样简单，如下所示:

`C:\SimpleCSharpApp\bin\Debug>SimpleCSharpApp.exe /arg1 -arg2`

`***** My First C# App *****`

`Hello World!`

`Arg: /arg1`

`Arg: -arg2`

作为标准`for`循环的替代方法，您可以使用 C# `foreach`关键字迭代一个传入的`string`数组。下面是一些示例用法(但同样，你将在本章后面看到循环结构的细节):

`// Notice you have no need to check the size of the array when using "foreach".`

`static int Main(string[] args)`

`{`

`...`

`// Process any incoming args using foreach.`

`foreach(string arg in args)`

`Console.WriteLine("Arg: {0}", arg);`

`Console.ReadLine();`

`return -1;`

`}`

最后，您还可以使用`System.Environment`类型的静态`GetCommandLineArgs()`方法来访问命令行参数。该方法的返回值是一个由`string`组成的数组。第一个索引标识应用本身的名称，而数组中的其余元素包含各个命令行参数。注意，当使用这种方法时，不再需要将`Main()`定义为将`string`数组作为输入参数，尽管这样做没有坏处。

`static int Main(string[] args)`

`{`

`...`

`// Get arguments using System.Environment.`

`string[] theArgs = Environment.GetCommandLineArgs();`

`foreach(string arg in theArgs)`

`Console.WriteLine("Arg: {0}", arg);`

`Console.ReadLine();`

`return -1;`

`}`

当然，由您来决定您的程序将响应哪些命令行参数(如果有的话)以及它们必须如何被格式化(比如用一个`-`或`/`前缀)。在这里，我只是传递了一系列直接打印到命令提示符下的选项。然而，假设您正在创建一个新的视频游戏，并编写您的应用来处理一个名为`-godmode`的选项。如果用户用这个标志启动你的应用，你知道他实际上是一个骗子，你可以采取适当的行动。

### 用 Visual Studio 指定命令行参数

在现实世界中，最终用户在启动程序时可以选择提供命令行参数。但是，在开发周期中，出于测试目的，您可能希望指定可能的命令行标志。若要使用 Visual Studio 执行此操作，请在解决方案资源管理器中双击“属性”图标，然后选择左侧的“调试”选项卡。在那里，使用命令行参数文本框指定值(见图 [3-1](#Fig1) )并保存更改。

![A978-1-4842-1332-2_3_Fig1_HTML.jpg](img/A978-1-4842-1332-2_3_Fig1_HTML.jpg)

图 3-1。

Setting command arguments via Visual Studio

在您建立了这样的命令行参数之后，当在 Visual Studio IDE 中调试或运行您的应用时，它们将自动传递给`Main()`方法。

## 一个有趣的旁白:该系统的一些额外成员。环境类

除了`GetCommandLineArgs()`之外，`Environment`类还公开了许多非常有用的方法。具体来说，这个类允许您获取有关当前承载您的。NET 应用使用各种静态成员。为了说明`System.Environment`的用处，更新您的`Main()`方法来调用一个名为`ShowEnvironmentDetails()`的帮助器方法。

`static int Main(string[] args)`

`{`

`...`

`// Helper method within the Program class.`

`ShowEnvironmentDetails();`

`Console.ReadLine();`

`return -1;`

`}`

在你的`Program`类中实现这个方法来调用`Environment`类型的各种成员。

`static void ShowEnvironmentDetails()`

`{`

`// Print out the drives on this machine,`

`// and other interesting details.`

`foreach (string drive in Environment.GetLogicalDrives())`

`Console.WriteLine("Drive: {0}", drive);`

`Console.WriteLine("OS: {0}", Environment.OSVersion);`

`Console.WriteLine("Number of processors: {0}",`

`Environment.ProcessorCount);`

`Console.WriteLine(".NET Version: {0}",`

`Environment.Version);`

`}`

以下输出显示了调用此方法的可能测试运行。当然，如果您没有通过 Visual Studio 调试选项卡指定命令行参数，您将不会发现它们被打印到控制台。

`***** My First C# App *****`

`Hello World!`

`Arg: -godmode`

`Arg: -arg1`

`Arg: /arg2`

`Drive: C:\`

`Drive: D:\`

`OS: Microsoft Windows NT 6.2.9200.0`

`Number of processors: 8`

`.NET Version: 4.0.30319.42000`

`Environment`类型定义的成员不同于上一个示例中显示的成员。表 [3-1](#Tab1) 记录了一些感兴趣的附加属性；但是，请务必查看。NET Framework 4.6 SDK 文档以了解完整的详细信息。

表 3-1。

Select Properties of System.Environment

<colgroup><col> <col></colgroup> 
| 财产 | 生命的意义 |
| --- | --- |
| `ExitCode` | 获取或设置应用的退出代码 |
| `Is64BitOperatingSystem` | 返回一个布尔值，表示主机是否运行 64 位操作系统 |
| `MachineName` | 获取当前计算机的名称 |
| `NewLine` | 获取当前环境的换行符 |
| `SystemDirectory` | 返回系统目录的完整路径 |
| `UserName` | 返回启动该应用的用户名 |
| `Version` | 返回一个代表。NET 平台 |

Source Code

SimpleCSharpApp 项目位于 [`Chapter 3`](03.html) 子目录中。

## 系统。控制台类

在本书前几章中创建的几乎所有示例应用都大量使用了`System.Console`类。虽然控制台用户界面(CUI)确实不如图形用户界面(GUI)或 web 应用那样吸引人，但是将早期的示例限制在控制台程序将使您能够专注于 C#的语法和。NET 平台，而不是处理构建桌面 GUI 或网站的复杂性。

顾名思义，`Console`类封装了基于控制台的应用的输入、输出和错误流操作。表 [3-2](#Tab2) 列出了一些(但肯定不是全部)感兴趣的成员。正如您所看到的，`Console`类确实提供了一些成员，可以为简单的命令行应用增添趣味，比如改变背景和前景色以及发出哔哔声(各种频率！).

表 3-2。

Select Members of System.Console

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `Beep()` | 此方法强制控制台发出指定频率和持续时间的嘟嘟声。 |
| `BackgroundColor` | 这些属性设置当前输出的背景/前景色。 |
| `ForegroundColor` | 它们可以被赋予`ConsoleColor`枚举的任何成员。 |
| `BufferHeight` | 这些属性控制控制台缓冲区的高度/宽度。 |
| `BufferWidth` |   |
| `Title` | 此属性获取或设置当前控制台的标题。 |
| `WindowHeight` | 这些属性控制控制台相对于已建立缓冲区的尺寸。 |
| `WindowWidth` |   |
| `WindowTop` |   |
| `WindowLeft` |   |
| `Clear()` | 此方法清除已建立的缓冲区和控制台显示区域。 |

### 控制台类的基本输入和输出

除了表 [3-2](#Tab2) 中的成员之外，`Console`类型还定义了一组捕获输入和输出的方法，所有这些方法都是静态的，因此通过在方法名前面加上类名(`Console`)来调用。正如您所看到的，`WriteLine()`将一个文本字符串(包括回车)抽取到输出流中。`Write()`方法将文本抽取到输出流中，不需要回车。`ReadLine()`允许您从输入流接收信息，直到按下回车键，而`Read()`用于从输入流中捕获单个字符。

为了说明使用`Console`类的基本 I/O，创建一个名为 BasicConsoleIO 的新控制台应用项目，并更新您的`Main()`方法以调用名为`GetUserData()`的助手方法。

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Basic Console I/O *****");`

`GetUserData();`

`Console.ReadLine();`

`}`

`private static void GetUserData()`

`{`

`}`

`}`

Note

Visual Studio 支持许多“代码片段”,这些代码片段在激活后会插入代码。在本文的前几章中，`cw`代码片段非常有用，因为它会自动扩展到`Console.WriteLine()`！为了验证这一点，在您的`Main()`方法中的某个地方键入`cw`，并按两次 Tab 键(遗憾的是，没有`Console.ReadLine()`的代码片段)。若要查看所有代码段，请在 C#代码文件中右击，然后选择“插入代码段”菜单选项。

在`Program`类中实现这个方法，逻辑提示用户输入一些信息，并将每一项回显到标准输出流中。例如，您可以要求用户输入姓名和年龄(为简单起见，将其视为文本值，而不是预期的数值)，如下所示:

`static void GetUserData()`

`{`

`// Get name and age.`

`Console.Write("Please enter your name: ");`

`string userName = Console.ReadLine();`

`Console.Write("Please enter your age: ");`

`string userAge = Console.ReadLine();`

`// Change echo color, just for fun.`

`ConsoleColor prevColor = Console.ForegroundColor;`

`Console.ForegroundColor = ConsoleColor.Yellow;`

`// Echo to the console.`

`Console.WriteLine("Hello {0}! You are {1} years old.",`

`userName, userAge);`

`// Restore previous color.`

`Console.ForegroundColor = prevColor;`

`}`

毫不奇怪，当您运行这个应用时，输入数据被打印到控制台(使用自定义颜色启动！).

### 格式化控制台输出

在这前几章中，您可能已经注意到在各种字符串文字中出现了大量的标记，如`{0}`和`{1}`。那个。NET 平台支持的字符串格式有点类似于 c 语言的`printf()`语句。简而言之，当您定义一个包含数据段的字符串文字时，其值直到运行时才知道，您可以使用这个花括号语法在文字中指定一个占位符。在运行时，传入`Console.WriteLine()`的值会替换每个占位符。

`WriteLine()`的第一个参数代表一个字符串文字，它包含由`{0}`、`{1}`、`{2}`等指定的可选占位符。请注意，花括号占位符的第一个序号总是以`0`开头。`WriteLine()`的其余参数只是插入到各自占位符中的值。

Note

如果唯一编号的花括号占位符比填充参数多，将在运行时收到格式异常。但是，如果填充参数多于占位符，未使用的填充参数将被忽略。

允许给定的占位符在给定的字符串中重复出现。例如，如果你是披头士的粉丝，想要构建字符串`"9, Number 9, Number 9"`，你可以这样写:

`// John says...`

`Console.WriteLine("{0}, Number {0}, Number {0}", 9);`

另外，要知道可以将每个占位符放在字符串中的任何位置，并且不需要按照递增的顺序。例如，考虑下面的代码片段:

`// Prints: 20, 10, 30`

`Console.WriteLine("{1}, {0}, {2}", 10, 20, 30);`

### 格式化数字数据

如果需要对数字数据进行更精细的格式化，每个占位符可以选择包含各种格式字符。表 [3-3](#Tab3) 显示了最常见的格式化选项。

表 3-3。

.NET Numerical Format Characters

<colgroup><col> <col></colgroup> 
| 字符串格式字符 | 生命的意义 |
| --- | --- |
| `C`或`c` | 用于格式化货币。默认情况下，旗帜会将当地文化符号作为前缀(美元符号[$]代表美国英语)。 |
| `D`或`d` | 用于格式化十进制数。该标志还可以指定用于填充该值的最小位数。 |
| `E`或`e` | 用于指数记数法。大小写控制指数常数是大写(`E`)还是小写(`e`)。 |
| `F`或`f` | 用于定点格式化。该标志还可以指定用于填充该值的最小位数。 |
| `G`或`g` | 代表将军。此字符可用于将数字格式化为固定格式或指数格式。 |
| `N`或`n` | 用于基本的数字格式(带逗号)。 |
| `X`或`x` | 用于十六进制格式。如果您使用大写的`X`，您的十六进制格式也将包含大写字符。 |

这些格式字符使用冒号标记作为给定占位符值的后缀(例如，`{0:C}`、`{1:d}`、`{2:X}`)。举例来说，更新`Main()`方法来调用名为`FormatNumericalData()`的新助手函数。在您的`Program`类中实现这个方法，以多种方式格式化一个固定的数值。

`// Now make use of some format tags.`

`static void FormatNumericalData()`

`{`

`Console.WriteLine("The value 99999 in various formats:");`

`Console.WriteLine("c format: {0:c}", 99999);`

`Console.WriteLine("d9 format: {0:d9}", 99999);`

`Console.WriteLine("f3 format: {0:f3}", 99999);`

`Console.WriteLine("n format: {0:n}", 99999);`

`// Notice that upper- or lowercasing for hex`

`// determines if letters are upper- or lowercase.`

`Console.WriteLine("E format: {0:E}", 99999);`

`Console.WriteLine("e format: {0:e}", 99999);`

`Console.WriteLine("X format: {0:X}", 99999);`

`Console.WriteLine("x format: {0:x}", 99999);`

`}`

下面的输出显示了调用`FormatNumericalData()`方法的结果:

`The value 99999 in various formats:`

`c format: $99,999.00`

`d9 format: 000099999`

`f3 format: 99999.000`

`n format: 99,999.00`

`E format: 9.999900E+004`

`e format: 9.999900e+004`

`X format: 1869F`

`x format: 1869f`

在整篇文章中，您会看到其他需要的格式示例；然而，如果你有兴趣深入研究。NET 字符串格式。此外，请在。NET Framework 4.6 SDK 文档。

Source Code

BasicConsoleIO 项目位于 [`Chapter 3`](03.html) 子目录中。

### 格式化控制台应用之外的数字数据

最后要注意的是。NET 字符串格式化字符不仅限于控制台程序。当调用静态`string.Format()`方法时，可以使用相同的格式化语法。当您需要在运行时编写文本数据以用于任何类型的应用(例如，桌面 GUI 应用、ASP.NET web 应用等)时，这可能会很有帮助。

`string.Format()`方法返回一个新的`string`对象，该对象根据提供的标志进行格式化。在这一点上，你可以自由地使用你认为合适的文本数据。例如，假设您正在构建一个图形化的 WPF 桌面应用，并且需要格式化一个字符串以便在消息框中显示。下面的代码演示了如何做到这一点，但是请注意，在您引用供您的项目使用的`PresentationFramework.dll`程序集之前，这些代码不会编译(有关使用 Visual Studio 引用库的信息，请参见[第 2 章](02.html))。

`static void DisplayMessage()`

`{`

`// Using string.Format() to format a string literal.`

`string userMessage = string.Format("100000 in hex is {0:x}", 100000);`

`// You need to reference PresentationFramework.dll`

`// in order to compile this line of code!`

`System.Windows.MessageBox.Show(userMessage);`

`}`

Note

。NET 4.6 引入了一种替代花括号占位符的语法，称为字符串插值语法。您将在本章的后面部分研究这种方法。

## 系统数据类型和相应的 C#关键字

与任何编程语言一样，C#为基本数据类型定义了关键字，这些关键字用于表示局部变量、类数据成员变量、方法返回值和参数。然而，与其他编程语言不同，这些关键字不仅仅是简单的编译器可识别的标记。相反，C#数据类型关键字实际上是在`System`名称空间中成熟类型的简写符号。表 [3-4](#Tab4) 列出了每个系统数据类型、其范围、相应的 C#关键字以及该类型是否符合通用语言规范(CLS)。

表 3-4。

The Intrinsic Data Types of C#

<colgroup><col> <col> <col> <col> <col></colgroup> 
| C#速记 | CLS 顺从吗？ | 系统类型 | 范围 | 生命的意义 |
| --- | --- | --- | --- | --- |
| `bool` | 是 | `System.Boolean` | 对还是错 | 代表真理或谬误 |
| `sbyte` | 不 | `System.SByte` | –128 至 127 | 有符号的 8 位数字 |
| `byte` | 是 | `System.Byte` | 0 到 255 | 无符号 8 位数 |
| `short` | 是 | `System.Int16` | –32768 至 32767 | 有符号的 16 位数字 |
| `ushort` | 不 | `System.UInt16` | 0 到 65，535 | 无符号 16 位数 |
| `int` | 是 | `System.Int32` | -2147483648 至 2147483647 | 有符号的 32 位数字 |
| `uint` | 不 | `System.UInt32` | 0 到 4，294，967，295 | 无符号 32 位数字 |
| `long` | 是 | `System.Int64` | -9 223 372 036 854 775 808 至 9 223 372 036 854 775 807 | 带符号的 64 位数字 |
| `ulong` | 不 | `System.UInt64` | 0 到 18446744073709551615 | 无符号 64 位数字 |
| `char` | 是 | `System.Char` | U+0000 至 U+ffff | 单个 16 位 Unicode 字符 |
| `float` | 是 | `System.Single` | -3.4 10 <sup>38</sup> 至+3.4 10 <sup>38</sup> | 32 位浮点数 |
| `double` | 是 | `System.Double` | 5.0 10<sup>–324</sup>至 1.7 10 <sup>308</sup> | 64 位浮点数 |
| `decimal` | 是 | `System.Decimal` | (-7.9 x 10 <sup>28</sup> 至 7.9 x 10 <sup>28</sup> )/(10 <sup>0 至 28</sup> | 128 位有符号数 |
| `string` | 是 | `System.String` | 受系统内存限制 | 表示一组 Unicode 字符 |
| `Object` | 是 | `System.Object` | 可以在对象变量中存储任何数据类型 | 中所有类型的基类。净宇宙 |

Note

回忆起从[第 1 章](01.html)得知 CLS 顺从。任何托管编程语言都可以使用. NET 代码。如果您从您的程序中公开不符合 CLS 标准的数据，其他。NET 语言可能无法利用它。

默认情况下，浮点数被视为`double`。要声明一个`float`变量，对原始数值(`5.3F`)使用后缀`f`或`F`，对浮点数使用后缀`m`或`M`声明一个小数(`300.5M`)。最后，原始整数默认为`int`数据类型。将底层数据类型设置为一个`long`，后缀`l`或`L` ( `4L`)。

### 变量声明和初始化

当您声明局部变量(例如，成员范围内的变量)时，可以通过指定数据类型后跟变量名来实现。首先，创建一个名为 BasicDataTypes 的新控制台应用项目。用从`Main()`内部调用的以下 helper 方法更新`Program`类:

`static void LocalVarDeclarations()`

`{`

`Console.WriteLine("=> Data Declarations:");`

`// Local variables are declared as so:`

`// dataType varName;`

`int myInt;`

`string myString;`

`Console.WriteLine();`

`}`

请注意，在赋值初始值之前使用局部变量是一种编译器错误。考虑到这一点，在声明时给本地数据点分配一个初始值是一个好的做法。您可以在一行中完成，也可以将声明和赋值分成两个代码语句来完成。

`static void LocalVarDeclarations()`

`{`

`Console.WriteLine("=> Data Declarations:");`

`// Local variables are declared and initialized as follows:`

`// dataType varName = initialValue;`

`int myInt = 0;`

`// You can also declare and assign on two lines.`

`string myString;`

`myString = "This is my character data";`

`Console.WriteLine();`

`}`

也允许在一行代码中声明同一基础类型的多个变量，如以下三个`bool`变量:

`static void LocalVarDeclarations()`

`{`

`Console.WriteLine("=> Data Declarations:");`

`int myInt = 0;`

`string myString;`

`myString = "This is my character data";`

`// Declare 3 bools on a single line.`

`bool b1 = true, b2 = false, b3 = b1;`

`Console.WriteLine();`

`}`

由于 C# `bool`关键字只是`System.Boolean`结构的简写符号，所以也可以使用全名来分配任何数据类型(当然，对于任何 C#数据类型关键字也是如此)。下面是`LocalVarDeclarations()`的最终实现，它说明了声明一个局部变量的各种方法:

`static void LocalVarDeclarations()`

`{`

`Console.WriteLine("=> Data Declarations:");`

`// Local variables are declared and initialized as follows:`

`// dataType varName = initialValue;`

`int myInt = 0;`

`string myString;`

`myString = "This is my character data";`

`// Declare 3 bools on a single line.`

`bool b1 = true, b2 = false, b3 = b1;`

`// Use System.Boolean data type to declare a bool.`

`System.Boolean b4 = false;`

`Console.WriteLine("Your data: {0}, {1}, {2}, {3}, {4}, {5}",`

`myInt, myString, b1, b2, b3, b4);`

`Console.WriteLine();`

`}`

### 内部数据类型和新运算符

所有内在数据类型都支持默认构造函数(见第五章)。此功能允许您使用`new`关键字创建一个变量，该关键字会自动将变量设置为其默认值。

*   `bool`变量被设置为`false`。
*   数值数据被设置为`0`(或者在浮点数据类型的情况下设置为`0.0`)。
*   `char`变量被设置为单个空字符。
*   `BigInteger`变量被设置为`0`。
*   `DateTime`变量被设置为`1/1/0001 12:00:00 AM`。
*   对象引用(包括`string` s)被设置为`null`。

Note

前面列表中提到的`BigInteger`数据类型将在稍后解释。

尽管在创建基本数据类型变量时使用`new`关键字更麻烦，但下面是语法上格式良好的 C#代码:

`static void NewingDataTypes()`

`{`

`Console.WriteLine("=> Using new to create variables:");`

`bool b = new bool();              // Set to false.`

`int i = new int();                // Set to 0.`

`double d = new double();          // Set to 0.`

`DateTime dt = new DateTime();     // Set to 1/1/0001 12:00:00 AM`

`Console.WriteLine("{0}, {1}, {2}, {3}", b, i, d, dt);`

`Console.WriteLine();`

`}`

### 数据类型类层次结构

有趣的是，即使是原始人。NET 数据类型是按类层次结构排列的。如果你是遗产领域的新手，你会在第 6 章中发现全部细节。在此之前，只需理解位于类层次结构顶部的类型提供了一些授予派生类型的默认行为。这些核心系统类型之间的关系如图 [3-2](#Fig2) 所示。

![A978-1-4842-1332-2_3_Fig2_HTML.gif](img/A978-1-4842-1332-2_3_Fig2_HTML.gif)

图 3-2。

The class hierarchy of system types

注意，每个类型最终都是从`System.Object`派生出来的，它定义了一组方法(例如，`ToString()`、`Equals()`、`GetHashCode()`)，这些方法对。NET 基础类库(这些方法在[第 6 章](06.html)中有详细介绍)。

还要注意，许多数字数据类型都是从名为`System.ValueType`的类中派生出来的。`ValueType`的后代被自动分配到堆栈上，因此具有可预测的生命周期，并且非常高效。另一方面，继承链中没有`System.ValueType`的类型(比如`System.Type`、`System.String`、`System.Array`、`System.Exception`和`System.Delegate`)不会被分配到堆栈中，而是被分配到垃圾收集堆中。(你可以在[第 4 章](04.html)中找到更多关于这种区别的信息。)

不要太纠结于`System.Object`和`System.ValueType`的细节，只要理解因为 C#关键字(比如`int`)只是对应系统类型(在本例中为`System.Int32`)的简写符号，下面是完全合法的语法，假设`System.Int32`(c#`int`)最终从`System.Object`派生而来，因此可以调用它的任何公共成员，如这个额外的助手函数所示:

`static void ObjectFunctionality()`

`{`

`Console.WriteLine("=> System.Object Functionality:");`

`// A C# int is really a shorthand for System.Int32,`

`// which inherits the following members from System.Object.`

`Console.WriteLine("12.GetHashCode() = {0}", 12.GetHashCode());`

`Console.WriteLine("12.Equals(23) = {0}", 12.Equals(23));`

`Console.WriteLine("12.ToString() = {0}", 12.ToString());`

`Console.WriteLine("12.GetType() = {0}", 12.GetType());`

`Console.WriteLine();`

`}`

如果您要从`Main()`中调用这个方法，您会发现如下所示的输出:

`=> System.Object Functionality:`

`12.GetHashCode() = 12`

`12.Equals(23) = False`

`12.ToString() = 12`

`12.GetType() = System.Int32`

### 数字数据类型的成员

要继续试验固有的 C#数据类型，请理解。NET 支持的`MaxValue`和`MinValue`属性提供了关于给定类型可以存储的范围的信息。除了`MinValue` / `MaxValue`属性之外，一个给定的数值系统类型可以定义更多有用的成员。例如，`System.Double`类型允许您获得ε和无穷大的值(这可能会引起那些数学爱好者的兴趣)。举例来说，考虑下面的助手函数:

`static void DataTypeFunctionality()`

`{`

`Console.WriteLine("=> Data type Functionality:");`

`Console.WriteLine("Max of int: {0}", int.MaxValue);`

`Console.WriteLine("Min of int: {0}", int.MinValue);`

`Console.WriteLine("Max of double: {0}", double.MaxValue);`

`Console.WriteLine("Min of double: {0}", double.MinValue);`

`Console.WriteLine("double.Epsilon: {0}", double.Epsilon);`

`Console.WriteLine("double.PositiveInfinity: {0}",`

`double.PositiveInfinity);`

`Console.WriteLine("double.NegativeInfinity: {0}",`

`double.NegativeInfinity);`

`Console.WriteLine();`

`}`

### 系统成员。布尔代数学体系的

接下来，考虑`System.Boolean`数据类型。C# `bool`可以接受的唯一有效赋值是来自集合{ `true | false` }。鉴于这一点，应该清楚的是`System.Boolean`不支持`MinValue` / `MaxValue`属性集，而是支持`TrueString` / `FalseString`(分别产生字符串`"True"`或`"False"`)。这里有一个例子:

`Console.WriteLine("bool.FalseString: {0}", bool.FalseString);`

`Console.WriteLine("bool.TrueString: {0}", bool.TrueString);`

### 系统成员。茶

C#文本数据由关键字`string`和`char`表示，它们是`System.String`和`System.Char`的简单简写符号，两者都是 Unicode。您可能已经知道，`string`代表一组连续的字符(例如`"Hello"`，而`char`可以代表`string`中的一个槽(例如`’H’`)。

除了保存单点字符数据的能力之外，`System.Char`类型还为您提供了大量的功能。使用`System.Char`的静态方法，您能够确定一个给定的字符是数字、字母、标点符号还是其他什么。考虑以下方法:

`static void CharFunctionality()`

`{`

`Console.WriteLine("=> char type Functionality:");`

`char myChar = ’a’;`

`Console.WriteLine("char.IsDigit(’a’): {0}", char.IsDigit(myChar));`

`Console.WriteLine("char.IsLetter(’a’): {0}", char.IsLetter(myChar));`

`Console.WriteLine("char.IsWhiteSpace(’Hello There’, 5): {0}",`

`char.IsWhiteSpace("Hello There", 5));`

`Console.WriteLine("char.IsWhiteSpace(’Hello There’, 6): {0}",`

`char.IsWhiteSpace("Hello There", 6));`

`Console.WriteLine("char.IsPunctuation(’?’): {0}",`

`char.IsPunctuation(’?’));`

`Console.WriteLine();`

`}`

如前面的方法所示，`System.Char`的许多成员有两个调用约定:一个单独的字符或一个带有数字索引的字符串，该数字索引指定了要测试的字符的位置。

### 解析字符串数据中的值

那个。NET 数据类型提供了在给定文本等价的情况下生成其基础类型的变量的能力(例如，解析)。当您想要将一些用户输入数据(例如从基于 GUI 的下拉列表框中选择的数据)转换成数值时，这种技术非常有用。考虑下面名为`ParseFromStrings()`的方法中的解析逻辑。

`static void ParseFromStrings()`

`{`

`Console.WriteLine("=> Data type parsing:");`

`bool b = bool.Parse("True");`

`Console.WriteLine("Value of b: {0}", b);`

`double d = double.Parse("99.884");`

`Console.WriteLine("Value of d: {0}", d);`

`int i = int.Parse("8");`

`Console.WriteLine("Value of i: {0}", i);`

`char c = Char.Parse("w");`

`Console.WriteLine("Value of c: {0}", c);`

`Console.WriteLine();`

`}`

### 系统。日期时间和系统。时间间隔

名称空间定义了一些没有 C#关键字的有用的数据类型，比如结构 T1 和 T2。(我将把对`System.Guid`和`System.Void`的研究留给感兴趣的读者，如图 [3-2](#Fig2) 所示，但是请注意`System`名称空间中的这两种数据类型在大多数应用中很少有用。)

`DateTime`类型包含表示特定日期(月、日、年)和时间值的数据，这两种数据都可以使用提供的成员以多种方式进行格式化。`TimeSpan`结构允许您使用各种成员轻松定义和转换时间单位。

`static void UseDatesAndTimes()`

`{`

`Console.WriteLine("=> Dates and Times:");`

`// This constructor takes (year, month, day).`

`DateTime dt = new DateTime(2015, 10, 17);`

`// What day of the month is this?`

`Console.WriteLine("The day of {0} is {1}", dt.Date, dt.DayOfWeek);`

`// Month is now December.`

`dt = dt.AddMonths(2);`

`Console.WriteLine("Daylight savings: {0}", dt.IsDaylightSavingTime());`

`// This constructor takes (hours, minutes, seconds).`

`TimeSpan ts = new TimeSpan(4, 30, 0);`

`Console.WriteLine(ts);`

`// Subtract 15 minutes from the current TimeSpan and`

`// print the result.`

`Console.WriteLine(ts.Subtract(new TimeSpan(0, 15, 0)));`

`}`

### System.Numerics.dll 议会

`System.Numerics`名称空间定义了一个名为`BigInteger`的结构。顾名思义，`BigInteger`数据类型可以在需要表示大量数值时使用，这些数值不受固定上限或下限的约束。

Note

`System.Numerics`名称空间定义了第二个名为`Complex`的结构，它允许您对复杂的数字数据进行数学建模(例如，虚数、实数、双曲正切)。请参考。NET Framework 4.6 SDK 文档。

而你们中的许多人。NET 应用可能永远不需要使用`BigInteger`结构，如果你发现需要定义一个巨大的数值，你的第一步就是在你的项目中引用`System.Numerics.dll`程序集。如果您想要遵循当前示例，请执行以下任务:

Select the Project ➤ Add Reference menu option of Visual Studio.   Locate and select the `System.Numerics.dll` assembly within the list of presented libraries found in the Framework tab on the left side.   Click the OK button.  

完成之后，将下面的`using`指令添加到文件中，它将使用`BigInteger`数据类型:

`// BigInteger lives here!`

`using System.Numerics;`

此时，您可以使用`new`操作符创建一个`BigInteger`变量。在构造函数中，可以指定一个数值，包括浮点数据。然而，回想一下，当您定义一个文字整数(比如`500`)时，运行时会将数据类型默认为`int`。同样，文字浮点数据(如`55.333`)将默认为`double`。那么，如何将`BigInteger`设置为一个巨大的值，而不溢出用于原始数值的默认数据类型呢？

最简单的方法是将大量数值建立为文本文字，可以通过静态的`Parse()`方法将其转换为`BigInteger`变量。如果需要的话，你也可以将一个字节数组直接传递给`BigInteger`类的构造函数。

Note

在你给一个`BigInteger`变量赋值后，你不能改变它，因为数据是不可变的。然而，`BigInteger`类定义了许多成员，这些成员将根据您的数据修改返回新的`BigInteger`对象(比如前面代码示例中使用的静态`Multiply()`方法)。

在任何情况下，在你定义了一个`BigInteger`变量之后，你会发现这个类定义了类似的成员作为其他内在的 C#数据类型(例如`float`、`int`)。此外，`BigInteger`类定义了几个静态成员，允许您将基本的数学表达式(如加法和乘法)应用于`BigInteger`变量。下面是一个使用`BigInteger`类的例子:

`static void UseBigInteger()`

`{`

`Console.WriteLine("=> Use BigInteger:");`

`BigInteger biggy =`

`BigInteger.Parse("9999999999999999999999999999999999999999999999");`

`Console.WriteLine("Value of biggy is {0}", biggy);`

`Console.WriteLine("Is biggy an even value?: {0}", biggy.IsEven);`

`Console.WriteLine("Is biggy a power of two?: {0}", biggy.IsPowerOfTwo);`

`BigInteger reallyBig = BigInteger.Multiply(biggy,`

`BigInteger.Parse("8888888888888888888888888888888888888888888"));`

`Console.WriteLine("Value of reallyBig is {0}", reallyBig);`

`}`

同样重要的是要注意到，`BigInteger`数据类型响应 C#固有的数学运算符，如`+`、`-`和`*`。因此，您可以编写以下代码，而不是调用`BigInteger.Multiply()`将两个巨大的数字相乘:

`BigInteger reallyBig2 = biggy * reallyBig;`

至此，我希望您理解表示基本数据类型的 C#关键字在。NET 基本类库，每个类库都公开一个固定的功能。虽然我没有详细介绍这些数据类型的每个成员，但是您可以根据自己的需要深入研究这些细节。请务必查阅。NET Framework 4.6 SDK 文档，了解有关各种。NET 数据类型—您可能会对内置功能的数量感到惊讶。

Source Code

BasicDataTypes 项目位于 [`Chapter 3`](03.html) 子目录下。

## 使用字符串数据

`System.String`提供了许多您期望从这样一个实用程序类中得到的方法，包括返回字符数据长度、在当前字符串中查找子字符串以及在大写/小写之间进行转换的方法。表 [3-5](#Tab5) 列出了一些(但绝不是全部)有趣的成员。

表 3-5。

Select Members of System.String

<colgroup><col> <col></colgroup> 
| 字符串成员 | 生命的意义 |
| --- | --- |
| `Length` | 该属性返回当前字符串的长度。 |
| `Compare()` | 这个静态方法比较两个字符串。 |
| `Contains()` | 此方法确定字符串是否包含特定的子字符串。 |
| `Equals()` | 此方法测试两个 string 对象是否包含相同的字符数据。 |
| `Format()` | 这个静态方法使用其他原语(例如，数字数据、其他字符串)和本章前面讨论过的`{0}`符号来格式化字符串。 |
| `Insert()` | 此方法在给定的字符串中插入一个字符串。 |
| `PadLeft()` | 这些方法用于用一些字符填充字符串。 |
| `PadRight()` |   |
| `Remove()` | 这些方法用于接收经过修改(字符被删除或替换)的字符串副本。 |
| `Replace()` |   |
| `Split()` | 该方法返回一个包含该实例中子字符串的`String`数组，这些子字符串由指定的`char`数组或`string`数组的元素分隔。 |
| `Trim()` | 此方法从当前字符串的开头和结尾移除一组指定字符的所有匹配项。 |
| `ToUpper()` | 这些方法分别以大写或小写格式创建当前字符串的副本。 |
| `ToLower()` |   |

### 基本字符串操作

与`System.String`的成员一起工作正如你所料。只需声明一个`string`变量，并通过点运算符使用提供的功能。请注意，`System.String`的一些成员是静态成员，因此在类(而不是对象)级别被调用。假设您已经创建了一个名为 FunWithStrings 的新控制台应用项目。编写下面的方法，该方法应该从`Main()`内部调用:

`static void BasicStringFunctionality()`

`{`

`Console.WriteLine("=> Basic String functionality:");`

`string firstName = "Freddy";`

`Console.WriteLine("Value of firstName: {0}", firstName);`

`Console.WriteLine("firstName has {0} characters.", firstName.Length);`

`Console.WriteLine("firstName in uppercase: {0}", firstName.ToUpper());`

`Console.WriteLine("firstName in lowercase: {0}", firstName.ToLower());`

`Console.WriteLine("firstName contains the letter y?: {0}",`

`firstName.Contains("y"));`

`Console.WriteLine("firstName after replace: {0}", firstName.Replace("dy", ""));`

`Console.WriteLine();`

`}`

这里没有太多要说的，因为这个方法只是在一个本地`string`变量上调用各种成员，比如`ToUpper()`和`Contains()`，以产生各种格式和转换。以下是初始输出:

`***** Fun with Strings *****`

`=> Basic String functionality:`

`Value of firstName: Freddy`

`firstName has 6 characters.`

`firstName in uppercase: FREDDY`

`firstName in lowercase: freddy`

`firstName contains the letter y?: True`

`firstName after replace: Fred`

虽然这个输出看起来不太令人惊讶，但是通过调用`Replace()`方法看到的输出有点误导。实际上，`firstName`变量一点都没变；相反，你会收到一个修改后的新的`string`。过一会儿，您将重新审视字符串不可变的本质。

### 串并置

`string`变量可以通过 C# `+`(以及`+=`)操作符连接在一起构建更大的`string`。您可能知道，这种技术的正式名称是字符串连接。考虑以下新的助手函数:

`static void StringConcatenation()`

`{`

`Console.WriteLine("=> String concatenation:");`

`string s1 = "Programming the ";`

`string s2 = "PsychoDrill (PTP)";`

`string s3 = s1 + s2;`

`Console.WriteLine(s3);`

`Console.WriteLine();`

`}`

您可能有兴趣知道 C# `+`符号是由编译器处理的，以发出对静态`String.Concat()`方法的调用。考虑到这一点，可以通过直接调用`String.Concat()`来执行字符串连接(尽管这样做并没有带来任何好处——事实上，您已经招致了额外的击键！).

`static void StringConcatenation()`

`{`

`Console.WriteLine("=> String concatenation:");`

`string s1 = "Programming the ";`

`string s2 = "PsychoDrill (PTP)";`

`string s3 = String.Concat(s1, s2);`

`Console.WriteLine(s3);`

`Console.WriteLine();`

`}`

### 转义字符

与其他基于 C 的语言一样，C#字符串可能包含各种转义字符，这些字符限定了字符数据应该如何输出到输出流。每个转义字符都以反斜杠开头，后跟一个特定的标记。如果你对这些转义字符背后的含义有点生疏，表 [3-6](#Tab6) 列出了更常见的选项。

表 3-6。

String Literal Escape Characters

<colgroup><col> <col></colgroup> 
| 性格；角色；字母 | 生命的意义 |
| --- | --- |
| `\’` | 在字符串中插入单引号。 |
| `\"` | 在字符串中插入双引号。 |
| `\\` | 在字符串中插入反斜杠。这在定义文件或网络路径时非常有用。 |
| `\a` | 触发系统警报(嘟嘟声)。对于控制台程序，这可以是给用户的音频提示。 |
| `\n` | 插入新行(在 Windows 平台上)。 |
| `\r` | 插入一个回车。 |
| `\t` | 在字符串中插入水平制表符。 |

例如，要打印每个单词之间包含一个制表符的字符串，可以使用`\t`转义字符。或者假设您想要创建一个包含引号的字符串文字，另一个定义目录路径，最后一个在打印字符数据后插入三个空行的字符串文字。要做到这一点而不出现编译器错误，您需要使用`\"`、`\\`和`\n`转义字符。此外，为了骚扰你周围 10 英尺范围内的任何人，请注意，我在每个字符串文字中嵌入了一个警报(触发一个嘟嘟声)。请考虑以下几点:

`static void EscapeChars()`

`{`

`Console.WriteLine("=> Escape characters:\a");`

`string strWithTabs = "Model\tColor\tSpeed\tPet Name\a ";`

`Console.WriteLine(strWithTabs);`

`Console.WriteLine("Everyone loves \"Hello World\"\a ");`

`Console.WriteLine("C:\\MyApp\\bin\\Debug\a ");`

`// Adds a total of 4 blank lines (then beep again!).`

`Console.WriteLine("All finished.\n\n\n\a ");`

`Console.WriteLine();`

`}`

### 定义逐字字符串

当您在一个字符串前面加上`@`符号时，您就创建了一个逐字的字符串。使用逐字字符串，您可以禁用对文字转义字符的处理，并按原样打印出一个`string`。这在使用代表目录和网络路径的`string`时非常有用。因此，您可以简单地编写以下代码，而不是使用`\\`转义字符:

`// The following string is printed verbatim,`

`// thus all escape characters are displayed.`

`Console.WriteLine(@"C:\MyApp\bin\Debug");`

另请注意，逐字字符串可用于为跨多行的字符串保留空白。

`// White space is preserved with verbatim strings.`

`string myLongString = @"This is a very`

`very`

`very`

`long string";`

`Console.WriteLine(myLongString);`

使用逐字字符串，您还可以通过将`"`标记加倍来直接将双引号插入到文字字符串中。

`Console.WriteLine(@"Cerebus said ""Darrr! Pret-ty sun-sets""");`

### 字符串和等式

正如在第 4 章的[中充分解释的，引用类型是在垃圾收集托管堆上分配的对象。默认情况下，当您对引用类型执行相等测试时(通过 C# `==`和`!=`操作符)，如果引用指向内存中的同一个对象，您将返回`true`。然而，即使`string`数据类型确实是一个引用类型，相等操作符已经被重新定义来比较`string`对象的值，而不是它们引用的内存中的对象。](04.html)

`static void StringEquality()`

`{`

`Console.WriteLine("=> String equality:");`

`string s1 = "Hello!";`

`string s2 = "Yo!";`

`Console.WriteLine("s1 = {0}", s1);`

`Console.WriteLine("s2 = {0}", s2);`

`Console.WriteLine();`

`// Test these strings for equality.`

`Console.WriteLine("s1 == s2: {0}", s1 == s2);`

`Console.WriteLine("s1 == Hello!: {0}", s1 == "Hello!");`

`Console.WriteLine("s1 == HELLO!: {0}", s1 == "HELLO!");`

`Console.WriteLine("s1 == hello!: {0}", s1 == "hello!");`

`Console.WriteLine("s1.Equals(s2): {0}", s1.Equals(s2));`

`Console.WriteLine("Yo.Equals(s2): {0}", "Yo!".Equals(s2));`

`Console.WriteLine();`

`}`

C#相等运算符对`string`对象执行区分大小写、逐个字符的相等测试。因此，`"Hello!"`不等于`"HELLO!"`，这也与`"hello!"`不同。此外，记住`string`和`System.String`之间的联系，注意您可以使用`String`的`Equals()`方法以及内置的等式操作符来测试等式。最后，假设每个字符串文字(比如`"Yo"`)都是一个有效的`System.String`实例，那么您就能够从固定的字符序列中访问以字符串为中心的功能。

### 字符串是不可变的

`System.String`的一个有趣的方面是，当你给一个`string`对象赋值初始值后，字符数据就不能被改变了。乍一看，这似乎是一个彻头彻尾的谎言，因为您总是将字符串重新分配给新值，并且因为`System.String`类型定义了许多方法，这些方法似乎以某种方式修改字符数据(例如大写和小写)。然而，如果你更仔细地观察幕后发生的事情，你会注意到`string`类型的方法实际上是以修改后的格式返回给你一个新的`string`对象。

`static void StringsAreImmutable()`

`{`

`// Set initial string value.`

`string s1 = "This is my string.";`

`Console.WriteLine("s1 = {0}", s1);`

`// Uppercase s1?`

`string upperString = s1.ToUpper();`

`Console.WriteLine("upperString = {0}", upperString);`

`// Nope! s1 is in the same format!`

`Console.WriteLine("s1 = {0}", s1);`

`}`

如果您检查下面的相关输出，您可以验证原始的`string`对象(`s1`)在调用`ToUpper()`时没有大写。相反，您会得到一个修改后的`string`副本。

`s1 = This is my string.`

`upperString = THIS IS MY STRING.`

`s1 = This is my string.`

当您使用 C#赋值操作符时，不变性法则同样适用。举例来说，实现下面的`StringsAreImmutable2()`方法:

`static void StringsAreImmutable2()`

`{`

`string s2 = "My other string";`

`s2 = "New string value";`

`}`

现在，编译你的应用，并将程序集加载到`ildasm.exe`(参见[第 1 章](01.html))。下面的输出显示了如果您要为`StringsAreImmutable2()`方法生成 CIL 代码，您会发现什么:

`.method private hidebysig static void StringsAreImmutable2() cil managed`

`{`

`// Code size 14 (0xe)`

`.maxstack 1`

`.locals init ([0] string s2)`

`IL_0000:  nop`

`IL_0001:  ldstr       "My other string"`

`IL_0006:  stloc.0`

`IL_0007:  ldstr       "New string value"`

`IL_000c:  stloc.0`

`IL_000d:  ret`

`} // end of method Program::StringAreImmutable2`

尽管您还没有检查 CIL 的底层细节，但是请注意对`ldstr` (load string)操作码的大量调用。简单地说，CIL 的`ldstr`操作码在托管堆上加载一个新的`string`对象。包含值`"My other string"`的前一个`string`对象最终将被垃圾回收。

那么，你从这种洞察力中能收集到什么呢？简而言之，`string`类可能效率低下，如果误用会导致代码膨胀，尤其是在执行字符串连接或处理大量文本数据时。如果您需要表示基本的字符数据，比如美国社会保险号、名字或姓氏，或者应用中使用的简单文本，那么`string`类是最佳选择。

然而，如果您正在构建一个大量使用频繁变化的文本数据的应用(比如一个字处理程序)，那么使用`string`对象来表示字处理数据将是一个坏主意，因为您将最有可能(并且经常是间接地)最终制作不必要的字符串数据副本。那么，程序员要做什么呢？很高兴你问了。

### 系统。Text.StringBuilder 类型

鉴于`string`类型在鲁莽使用时可能效率低下，因此。NET 基础类库提供了`System.Text`命名空间。在这个(相对较小的)名称空间中有一个名为`StringBuilder`的类。例如，像`System.String`类一样，`StringBuilder`定义了允许你替换或格式化段的方法。当您希望在 C#代码文件中使用此类型时，第一步是确保将以下命名空间导入到代码文件中(对于新的 Visual Studio 项目，这应该已经是这样的情况):

`// StringBuilder lives here!`

`using System.Text;`

`StringBuilder`的独特之处在于，当您调用这种类型的成员时，您是在直接修改对象的内部字符数据(使其更有效)，而不是以修改后的格式获得数据的副本。当您创建一个`StringBuilder`的实例时，您可以通过许多构造函数之一提供对象的初始启动值。如果你是构造函数的新手，只需理解构造函数允许你在应用`new`关键字时创建一个具有初始状态的对象。考虑`StringBuilder`的以下用法:

`static void FunWithStringBuilder()`

`{`

`Console.WriteLine("=> Using the StringBuilder:");`

`StringBuilder sb = new StringBuilder("**** Fantastic Games ****");`

`sb.Append("\n");`

`sb.AppendLine("Half Life");`

`sb.AppendLine("Morrowind");`

`sb.AppendLine("Deus Ex" + "2");`

`sb.AppendLine("System Shock");`

`Console.WriteLine(sb.ToString());`

`sb.Replace("2", " Invisible War");`

`Console.WriteLine(sb.ToString());`

`Console.WriteLine("sb has {0} chars.", sb.Length);`

`Console.WriteLine();`

`}`

这里，我构造了一个设置为初始值`"**** Fantastic Games ****"`的`StringBuilder`。正如你所看到的，我附加到内部缓冲区，并能够随意替换或删除字符。默认情况下，`StringBuilder`最初只能容纳 16 个字符或更少的字符串(但是如果需要会自动扩展)；但是，这个默认的起始值可以通过一个额外的构造函数参数来更改。

`// Make a StringBuilder with an initial size of 256.`

`StringBuilder sb = new StringBuilder("**** Fantastic Games ****", 256);`

如果您添加的字符超过了指定的限制，`StringBuilder`对象会将其数据复制到一个新的实例中，并按照指定的限制增加缓冲区。

### 字符串插值

本章中说明的花括号语法(`{0}`、`{1}`等等)已经存在于。NET 平台从 1.0 版本开始。从当前版本开始，C#程序员可以使用另一种语法来构建包含变量占位符的字符串。形式上，这被称为字符串插值。虽然该操作的输出与传统的字符串格式语法相同，但这种新方法允许您直接嵌入变量本身，而不是将它们作为逗号分隔的列表附加上去。

考虑您的`Program`类(`StringInterpolation()`)的以下附加方法，它使用每种方法构建一个`string`变量:

`static void StringInterpolation()`

`{`

`// Some local variables we will plug into our larger string`

`int age = 4;`

`string name = "Soren";`

`// Using curly bracket syntax.`

`string greeting = string.Format("Hello {0} you are {1} years old.", name, age);`

`// Using string interpolation`

`string greeting2 = $"Hello {name} you are {age} years old.";`

`}`

在`greeting2`变量中，注意您正在构造的字符串是如何以美元符号前缀(`$`)开始的。接下来，注意花括号仍然用于标记变量占位符；但是，您可以将变量直接放入作用域中，而不是使用数字标记。假定的优点是，这种新的格式化语法更容易以线性(从左到右)方式阅读，因为您不需要“跳到末尾”来查看运行时要插入的值列表。

这种新语法还有一个有趣的方面:字符串插值中使用的花括号是一个有效的作用域。因此，您可以对变量使用点操作来更改它们的状态。考虑对每个汇编的`string`变量进行更新。

`string greeting = string.Format("Hello {0} you are {1} years old.", name.ToUpper(), age);`

`string greeting2 = $"Hello {name.ToUpper()} you are {age} years old.";`

在这里，我通过调用`ToUpper()`将名称大写。请注意，在字符串插值方法中，调用此方法时不要添加分号终止符。鉴于此，您不能将花括号作用域用作包含多行可执行代码的完全成熟的方法作用域。相反，您可以使用点运算符调用对象上的单个成员，并定义一个简单的通用表达式，如`{age += 1}`。

同样值得注意的是，在这个新语法中，您仍然可以在字符串中使用转义字符。因此，如果您想插入一个制表符，您可以将一个`\t`标记作为前缀，如下所示:

`string greeting = string.Format("\tHello {0} you are {1} years old.", name.ToUpper(), age);`

`string greeting2 = $"\tHello {name.ToUpper()} you are {age} years old.";`

正如您所料，在动态构建您的`string`变量时，您可以自由使用这两种方法。但是，请记住，如果您使用的是。NET 平台，字符串插值语法将导致编译器错误。因此，如果您需要确保您的 C#代码可以在多个版本的编译器下编译，那么坚持使用传统的数字占位符方法会更安全。

Source Code

FunWithStrings 项目位于 [`Chapter 3`](03.html) 子目录中。

## 缩小和扩大数据类型转换

现在，您已经了解了如何使用内部 C#数据类型，让我们来研究数据类型转换的相关主题。假设您有一个名为 TypeConversions 的新控制台应用项目，它定义了以下类:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with type conversions *****");`

`// Add two shorts and print the result.`

`short numb1 = 9, numb2 = 10;`

`Console.WriteLine("{0} + {1} = {2}",`

`numb1, numb2, Add(numb1, numb2));`

`Console.ReadLine();`

`}`

`static int Add(int x, int y)`

`{`

`return x + y;`

`}`

`}`

注意，`Add()`方法期望被发送两个`int`参数。然而，`Main()`方法实际上发送了两个`short`变量。虽然这看起来像是数据类型完全不匹配，但程序编译和执行时没有错误，返回预期的结果 19。

编译器认为这段代码在语法上是正确的，因为它不可能丢失数据。鉴于 a 的最大值`short` (32，767)正好在 a 的最大范围`int` (2，147，483，647)内，编译器隐式地将每个`short`扩展为一个`int`。从形式上讲，加宽是用来定义不会导致数据丢失的隐式向上转换的术语。

Note

中查找“类型转换表”。NET Framework 4.6 SDK 文档，如果您想了解每种 C#数据类型允许的扩大(和缩小，下面讨论)转换。

虽然在前面的例子中，这种隐式扩展对您有利，但在其他时候，这种“特性”可能是编译时错误的来源。例如，假设您已经将值设置为`numb1`和`numb2`，这两个值(相加后)超过了`short`的最大值。另外，假设您将`Add()`方法的返回值存储在一个新的本地`short`变量中，而不是直接将结果打印到控制台。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with type conversions *****");`

`// Compiler error below!`

`short numb1 = 30000, numb2 = 30000;`

`short answer = Add(numb1, numb2);`

`Console.WriteLine("{0} + {1} = {2}",`

`numb1, numb2, answer);`

`Console.ReadLine();`

`}`

在这种情况下，编译器会报告以下错误:

`Cannot implicitly convert type ’int’ to ’short’. An explicit conversion exists (are you missing a cast?)`

问题是，尽管`Add()`方法能够返回值为 60，000 的`int`(因为这符合`System.Int32`的范围)，但是该值不能存储在`short`中，因为它溢出了该数据类型的界限。从形式上讲，CLR 无法应用收缩操作。正如您所猜测的，缩小与扩大在逻辑上是相反的，因为较大的值存储在较小的数据类型变量中。

需要指出的是，所有收缩转换都会导致编译器错误，即使您可以推断收缩转换确实应该成功。例如，以下代码也会导致编译器错误:

`// Another compiler error!`

`static void NarrowingAttempt()`

`{`

`byte myByte = 0;`

`int myInt = 200;`

`myByte = myInt;`

`Console.WriteLine("Value of myByte: {0}", myByte);`

`}`

这里，`int`变量(`myInt`)中包含的值安全地在一个`byte`的范围内；因此，您可能希望收缩操作不会导致运行时错误。然而，考虑到 C#是一种考虑到类型安全的语言，您确实会收到一个编译器错误。

当您想要通知编译器您愿意处理由于收缩操作而可能丢失的数据时，您必须使用 C#转换运算符`()`应用显式转换。考虑下面对`Program`类型的更新:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with type conversions *****");`

`short numb1 = 30000, numb2 = 30000;`

`// Explicitly cast the int into a short (and allow loss of data).`

`short answer = (short)Add(numb1, numb2);`

`Console.WriteLine("{0} + {1} = {2}",`

`numb1, numb2, answer);`

`NarrowingAttempt();`

`Console.ReadLine();`

`}`

`static int Add(int x, int y)`

`{`

`return x + y;`

`}`

`static void NarrowingAttempt()`

`{`

`byte myByte = 0;`

`int myInt = 200;`

`// Explicitly cast the int into a byte (no loss of data).`

`myByte = (byte)myInt;`

`Console.WriteLine("Value of myByte: {0}", myByte);`

`}`

`}`

此时，代码编译完毕；但是，相加的结果是完全不正确的。

`***** Fun with type conversions *****`

`30000 + 30000 = -5536`

`Value of myByte: 200`

正如您刚刚看到的，显式强制转换允许您强制编译器应用收缩转换，即使这样做可能会导致数据丢失。在`NarrowingAttempt()`方法的情况下，这不是问题，因为值 200 可以在`byte`的范围内紧密配合。但是在`Main()`内的两个`short`相加的情况下，最终结果是完全不能接受的(30000+30000 =–5536？).

如果您正在构建一个数据丢失总是不可接受的应用，C#提供了`checked`和`unchecked`关键字来确保数据丢失不会不被发现。

### 选中的关键字

让我们从学习关键字`checked`的作用开始。假设您在`Program`中有一个新方法，它试图添加两个`byte`，每个都被赋予一个低于最大值(255)的安全值。如果您要将这些类型的值相加(将返回的`int`转换为`byte`，您会认为结果将是每个成员的精确总和。

`static void ProcessBytes()`

`{`

`byte b1 = 100;`

`byte b2 = 250;`

`byte sum = (byte)Add(b1, b2);`

`// sum should hold the value 350\. However, we find the value 94!`

`Console.WriteLine("sum = {0}", sum);`

`}`

如果您要查看这个应用的输出，您可能会惊讶地发现`sum`包含值 94(而不是预期的 350)。原因很简单。假定`System.Byte`只能保存 0 到 255 之间的值(包括 0 和 255，总共 256 个槽)，`sum`现在包含溢出值(350–256 = 94)。默认情况下，如果您不采取纠正措施，上溢/下溢情况会正确发生。

要处理应用中的上溢或下溢情况，有两种选择。您的第一选择是利用您的智慧和编程技能来手动处理所有上溢/下溢情况。当然，这种技术的问题是一个简单的事实，即你是人，即使你尽了最大的努力也可能导致你没有注意到的错误。

谢天谢地，C#提供了`checked`关键字。当您在`checked`关键字的范围内包装一个语句(或一个语句块)时，C#编译器会发出额外的 CIL 指令来测试两个数字数据类型的加、乘、减或除时可能导致的溢出情况。

如果发生溢出，您将收到一个运行时异常:`System.OverflowException`。[第 7 章](07.html)将检查结构化异常处理的所有细节以及`try`和`catch`关键字的使用。在这一点上不要太纠结于细节，观察下面的更新:

`static void ProcessBytes()`

`{`

`byte b1 = 100;`

`byte b2 = 250;`

`// This time, tell the compiler to add CIL code`

`// to throw an exception if overflow/underflow`

`// takes place.`

`try`

`{`

`byte sum = checked((byte)Add(b1, b2));`

`Console.WriteLine("sum = {0}", sum);`

`}`

`catch (OverflowException ex)`

`{`

`Console.WriteLine(ex.Message);`

`}`

`}`

注意，`Add()`的返回值已经被包装在`checked`关键字的范围内。因为总和大于一个`byte`，这触发了一个运行时异常。注意通过`Message`属性打印出来的错误消息。

`Arithmetic operation resulted in an overflow.`

如果希望对代码语句块强制进行溢出检查，可以通过定义如下的“检查范围”来实现:

`try`

`{`

`checked`

`{`

`byte sum = (byte)Add(b1, b2);`

`Console.WriteLine("sum = {0}", sum);`

`}`

`}`

`catch (OverflowException ex)`

`{`

`Console.WriteLine(ex.Message);`

`}`

在这两种情况下，将自动评估有问题的代码是否存在可能的溢出条件，如果遇到这种情况，将触发溢出异常。

### 设置项目范围的溢出检查

如果您正在创建一个永远不允许静默溢出发生的应用，您可能会发现自己处在一个恼人的位置，即在`checked`关键字的范围内包装许多行代码。作为替代，C#编译器支持`/checked`标志。启用后，你所有的算法都将被计算溢出，而不需要使用 C# `checked`关键字。如果已经发现溢出，您仍然会收到一个运行时异常。

若要使用 Visual Studio 启用此标志，请打开项目的属性页，然后单击“生成”选项卡上的“高级”按钮。从出现的对话框中，选择“检查算术溢出/下溢”复选框(见图 [3-3](#Fig3) )。

![A978-1-4842-1332-2_3_Fig3_HTML.jpg](img/A978-1-4842-1332-2_3_Fig3_HTML.jpg)

图 3-3。

Enabling project-wide overflow/underflow data checking

当您创建调试版本时，启用此设置会很有帮助。在所有溢出异常被挤出代码库之后，您可以为后续的构建禁用`/checked`标志(这可以提高应用的运行时性能)。

### 未检查的关键字

现在，假设您已经启用了这个项目范围的设置，如果您有一个可以接受数据丢失的代码块，您该怎么办呢？考虑到`/checked`标志将评估所有的算术逻辑，C#提供了`unchecked`关键字来根据具体情况禁止抛出溢出异常。该关键字的用法与`checked`关键字的用法相同，因为您可以指定一条语句或一组语句。

`// Assuming /checked is enabled,`

`// this block will not trigger`

`// a runtime exception.`

`unchecked`

`{`

`byte sum = (byte)(b1 + b2);`

`Console.WriteLine("sum = {0} ", sum);`

`}`

所以，总结一下 C# `checked`和`unchecked`关键字，记住。NET 运行时将忽略算术溢出/下溢。当你想有选择地处理离散语句时，使用`checked`关键字。如果您想在整个应用中捕获溢出错误，启用`/checked`标志。最后，如果您有一个溢出是可接受的代码块(因此不应该触发运行时异常)，可以使用`unchecked`关键字。

Source Code

TypeConversions 项目位于 [`Chapter 3`](03.html) 子目录中。

## 理解隐式类型的局部变量

直到本章的这一点，当你已经定义了局部变量，你已经明确地指定了每个被声明变量的基础数据类型。

`static void DeclareExplicitVars()`

`{`

`// Explicitly typed local variables`

`// are declared as follows:`

`// dataType variableName = initialValue;`

`int myInt = 0;`

`bool myBool = true;`

`string myString = "Time, marches on...";`

`}`

虽然许多人(包括你自己)会认为显式指定每个变量的数据类型总是好的做法，但 C#语言确实提供了使用`var`关键字隐式输入局部变量。`var`关键字可以用来代替指定特定的数据类型(例如`int`、`bool`或`string`)。当您这样做时，编译器将根据用于初始化本地数据点的初始值自动推断基础数据类型。

为了说明隐式类型的作用，创建一个名为 ImplicitlyTypedLocalVars 的新控制台应用项目。请注意，前面方法中的局部变量现在可以声明如下:

`static void DeclareImplicitVars()`

`{`

`// Implicitly typed local variables`

`// are declared as follows:`

`// var variableName = initialValue;`

`var myInt = 0;`

`var myBool = true;`

`var myString = "Time, marches on...";`

`}`

Note

严格来说，`var`不是 C#关键字。允许在没有编译时错误的情况下声明名为`var`的变量、参数和字段。然而，当`var`标记被用作数据类型时，编译器会根据上下文将其视为关键字。

在这种情况下，给定初始赋值，编译器能够推断出`myInt`实际上是一个`System.Int32`，`myBool`是一个`System.Boolean`，`myString`确实是类型`System.String`。您可以通过反射打印类型名来验证这一点。正如你将在第 15 章中看到的更多细节，反射是在运行时决定一个类型的组成的行为。例如，使用反射，可以确定隐式类型化局部变量的数据类型。使用以下代码语句更新您的方法:

`static void DeclareImplicitVars()`

`{`

`// Implicitly typed local variables.`

`var myInt = 0;`

`var myBool = true;`

`var myString = "Time, marches on...";`

`// Print out the underlying type.`

`Console.WriteLine("myInt is a: {0}", myInt.GetType().Name);`

`Console.WriteLine("myBool is a: {0}", myBool.GetType().Name);`

`Console.WriteLine("myString is a: {0}", myString.GetType().Name);`

`}`

Note

请注意，您可以对任何类型使用这种隐式类型，包括数组、泛型类型(参见第 9 章)和您自己的自定义类型。在本书的过程中，你会看到其他隐式类型的例子。

如果您要从`Main()`中调用`DeclareImplicitVars()`方法，您会发现如下所示的输出:

`***** Fun with Implicit Typing *****`

`myInt is a: Int32`

`myBool is a: Boolean`

`myString is a: String`

### 对隐式类型变量的限制

关于`var`关键字的使用有各种限制。首先，隐式类型化只适用于方法或属性范围内的局部变量。使用`var`关键字定义自定义类型的返回值、参数或字段数据是非法的。例如，下面的类定义将导致各种编译时错误:

`class ThisWillNeverCompile`

`{`

`// Error! var cannot be used as field data!`

`private var myInt = 10;`

`// Error! var cannot be used as a return value`

`// or parameter type!`

`public var MyMethod(var x, var y){}`

`}`

此外，用关键字`var`声明的局部变量必须在声明时被赋予一个初始值，而不能被赋予初始值`null`。这最后一个限制应该是有意义的，因为编译器不能仅仅根据`null`来推断变量将指向内存中的哪种类型。

`// Error! Must assign a value!`

`var myData;`

`// Error! Must assign value at exact time of declaration!`

`var myInt;`

`myInt = 0;`

`// Error! Can’t assign null as initial value!`

`var myObj = null;`

然而，允许在初始赋值后将推断的局部变量赋值给`null`(假设它是引用类型)。

`// OK, if SportsCar is a reference type!`

`var myCar = new SportsCar();`

`myCar = null;`

此外，允许将隐式类型的局部变量的值赋给其他变量的值，无论是否是隐式类型的。

`// Also OK!`

`var myInt = 0;`

`var anotherInt = myInt;`

`string myString = "Wake up!";`

`var myData = myString;`

此外，如果方法返回类型与`var`定义的数据点是相同的底层类型，那么允许向调用者返回隐式类型的局部变量。

`static int GetAnInt()`

`{`

`var retVal = 9;`

`return retVal;`

`}`

### 隐式类型数据是强类型数据

请注意，局部变量的隐式类型化会产生强类型数据。因此，`var`关键字的使用与脚本语言(如 JavaScript 或 Perl)或 COM `Variant`数据类型使用的技术不同，在 COM`Variant`数据类型中，变量可以在程序的生存期内保存不同类型的值(通常称为动态类型)。

Note

C#允许使用名为-surprise，surprise-`dynamic`的关键字进行动态输入。你将在第 16 章中学习这方面的语言。

相反，类型推断保留了 C#语言的强类型特征，并且只影响编译时的变量声明。之后，数据点被视为是用该类型声明的；将不同类型的值赋给该变量将导致编译时错误。

`static void ImplicitTypingIsStrongTyping()`

`{`

`// The compiler knows "s" is a System.String.`

`var s = "This variable can only hold string data!";`

`s = "This is fine...";`

`// Can invoke any member of the underlying type.`

`string upper = s.ToUpper();`

`// Error! Can’t assign numerical data to a string!`

`s = 44;`

`}`

### 隐式类型化局部变量的有用性

既然您已经看到了用于声明隐式类型化局部变量的语法，我相信您一定想知道什么时候使用这种结构。首先，仅仅为了声明局部变量而使用`var`并没有带来什么好处。这样做可能会让阅读您代码的其他人感到困惑，因为快速确定底层数据类型变得更加困难，因此理解变量的整体功能也更加困难。所以，如果你知道你需要一个`int`，那就声明一个`int`！

然而，正如你将在第 12 章开始看到的，LINQ 技术集利用了查询表达式，可以根据查询本身的格式动态生成结果集。在这些情况下，隐式类型非常有用，因为您不需要显式定义查询可能返回的类型，而这在某些情况下实际上是不可能做到的。不要纠结于下面的 LINQ 示例代码，看看您是否能弄清楚`subset`的底层数据类型:

`static void LinqQueryOverInts()`

`{`

`int[] numbers = { 10, 20, 30, 40, 1, 2, 3, 8 };`

`// LINQ query!`

`var subset = from i in numbers where i < 10 select i;`

`Console.Write("Values in subset: ");`

`foreach (var i in subset)`

`{`

`Console.Write("{0} ", i);`

`}`

`Console.WriteLine();`

`// Hmm...what type is subset?`

`Console.WriteLine("subset is a: {0}", subset.GetType().Name);`

`Console.WriteLine("subset is defined in: {0}", subset.GetType().Namespace);`

`}`

您可能会假设`subset`数据类型是一个整数数组。看起来是这样，但事实上，它是一种低级的 LINQ 数据类型，除非你已经做了很长时间的 LINQ 或者你在`ildasm.exe`中打开编译后的图像，否则你永远不会知道它。好消息是，当您使用 LINQ 时，您很少(如果曾经)关心查询返回值的底层类型；您只需将值赋给隐式类型的局部变量。

事实上，可以说只有在定义从 LINQ 查询返回的数据时才使用`var`关键字。记住，如果你知道你需要一个`int`，就声明一个`int`！过度使用隐式类型(通过`var`关键字)被大多数开发人员认为是产品代码中糟糕的风格。

Source Code

ImplicitlyTypedLocalVars 项目可以在 [`Chapter 3`](03.html) 子目录中找到。

## C#迭代构造

所有编程语言都提供了重复代码块的方法，直到满足终止条件。不管你过去使用过哪种语言，我想 C#迭代语句应该不会引起太多的关注，也不需要太多的解释。C#提供了以下四种迭代构造:

*   `for`循环
*   `foreach/in`循环
*   `while`循环
*   `do/while`循环

让我们使用一个名为 IterationsAndDecisions 的新控制台应用项目，依次快速检查每个循环构造。

Note

我将保持这一章的最后一节简明扼要，因为我假设你有使用类似关键字的经验(`if`、`for`、`switch`等)。)在你目前的编程语言中。如果需要更多信息，请在中查找主题“迭代语句(C#参考)”、“跳转语句(C#参考)”和“选择语句(C#参考)”。NET Framework 4.6 SDK 文档。

### for 循环

当您需要迭代固定次数的代码块时，`for`语句提供了很大的灵活性。本质上，您可以指定一段代码重复多少次，以及终止条件。无需赘述这一点，下面是一个语法示例:

`// A basic for loop.`

`static void ForLoopExample()`

`{`

`// Note! "i" is only visible within the scope of the for loop.`

`for(int i = 0; i < 4; i++)`

`{`

`Console.WriteLine("Number is: {0} ", i);`

`}`

`// "i" is not visible here.`

`}`

在构建 C# `for`语句时，您所有的 C、C++和 Java 技巧仍然有效。您可以创建复杂的终止条件，构建无限循环，反向循环(通过`--`操作符)，并使用`goto`、`continue`和`break`跳转关键字。

### foreach 循环

C# `foreach`关键字允许你遍历容器中的所有条目，而不需要测试上限。然而，与`for`循环不同的是，`foreach`循环只会以线性(n+1)的方式遍历容器(因此，你不能向后遍历容器，跳过每三个元素，等等)。

然而，当您只是需要一个一个地浏览集合时，`foreach`循环是完美的选择。这里有两个使用`foreach`的例子——一个遍历字符串数组，另一个遍历整数数组。注意，`in`关键字之前的数据类型代表容器中的数据类型。

`// Iterate array items using foreach.`

`static void ForEachLoopExample()`

`{`

`string[] carTypes = {"Ford", "BMW", "Yugo", "Honda" };`

`foreach (string c in carTypes)`

`Console.WriteLine(c);`

`int[] myInts = { 10, 20, 30, 40 };`

`foreach (int i in myInts)`

`Console.WriteLine(i);`

`}`

关键字`in`之后的项可以是一个简单的数组(见这里),或者更具体地说，可以是实现`IEnumerable`接口的任何类。正如你将在[第 9 章](09.html)中看到的。NET 基类库附带了许多集合，这些集合包含通用抽象数据类型(ADT)的实现。这些项目中的任何一个(比如通用的`List<T>`)都可以在`foreach`循环中使用。

### 在 foreach 构造中使用隐式类型

也可以在一个`foreach`循环结构中使用隐式类型。如你所料，编译器会正确地推断出正确的“类型”回想一下本章前面展示的 LINQ 示例方法。假设您不知道`subset`变量的确切底层数据类型，您可以使用隐式类型迭代结果集。

`static void LinqQueryOverInts()`

`{`

`int[] numbers = { 10, 20, 30, 40, 1, 2, 3, 8 };`

`// LINQ query!`

`var subset = from i in numbers where i < 10 select i;`

`Console.Write("Values in subset: ");`

`foreach (var i in subset)`

`{`

`Console.Write("{0} ", i);`

`}`

`}`

### while 和 do/while 循环结构

如果您想执行一个语句块，直到达到某个终止条件，那么`while`循环结构非常有用。在一个`while`循环的范围内，您需要确保这个终止事件确实被建立；否则，你会陷入死循环。在下面的例子中，消息`"In while loop"`将持续打印，直到用户在命令提示符下输入`yes`终止循环:

`static void WhileLoopExample()`

`{`

`string userIsDone = "";`

`// Test on a lower-class copy of the string.`

`while(userIsDone.ToLower() != "yes")`

`{`

`Console.WriteLine("In while loop");`

`Console.Write("Are you done? [yes] [no]: ");`

`userIsDone = Console.ReadLine();`

`}`

`}`

与`while`循环密切相关的是`do` / `while`语句。像一个简单的`while`循环一样，`do` / `while`在你需要执行某个动作不确定的次数时使用。不同的是`do` / `while`循环保证至少执行一次相应的代码块。相反，如果终止条件从一开始就是假的，那么简单的`while`循环可能永远不会执行。

`static void DoWhileLoopExample()`

`{`

`string userIsDone = "";`

`do`

`{`

`Console.WriteLine("In do/while loop");`

`Console.Write("Are you done? [yes] [no]: ");`

`userIsDone = Console.ReadLine();`

`}while(userIsDone.ToLower() != "yes"); // Note the semicolon!`

`}`

## 决策结构和关系/等式操作符

既然可以迭代语句块，下一个相关的概念就是如何控制程序执行的流程。C#定义了两个简单的构造来根据各种突发事件改变程序的流程。

*   `if/else`声明
*   `switch`声明

### if/else 语句

首先是`if` / `else`语句。与 C 和 C++不同，C#中的`if` / `else`语句只对布尔表达式进行操作，而不是像`–1`或`0`这样的特殊值。

### 等式和关系运算符

C# `if` / `else`语句通常涉及使用表 [3-7](#Tab7) 中所示的 C#运算符来获得一个文字布尔值。

表 3-7。

C# Relational and Equality Operators

<colgroup><col> <col> <col></colgroup> 
| C#等式/关系运算符 | 用法示例 | 生命的意义 |
| --- | --- | --- |
| `==` | `if(age == 30)` | 仅当每个表达式都相同时，才返回`true` |
| `!=` | `if("Foo" != myStr)` | 仅当每个表达式不同时才返回`true` |
| `<` | `if(bonus < 2000)` | 如果表达式 A ( `bonus`)小于、大于、小于或等于或大于或等于表达式 B ( `2000`)，则返回`true` |
| `>` | `if(bonus > 2000)` |   |
| `<=` | `if(bonus <= 2000)` |   |
| `>=` | `if(bonus >= 2000)` |   |

同样，C 和 C++程序员需要知道，测试不等于零的条件的老把戏在 C#中不起作用。假设您想要查看您正在使用的`string`是否长于零个字符。你可能会想这样写:

`static void IfElseExample()`

`{`

`// This is illegal, given that Length returns an int, not a bool.`

`string stringData = "My textual data";`

`if(stringData.Length)`

`{`

`Console.WriteLine("string is greater than 0 characters");`

`}`

`}`

如果您想要使用`String.Length`属性来确定真或假，您需要修改您的条件表达式来解析为布尔值。

`// Legal, as this resolves to either true or false.`

`if(stringData.Length > 0)`

`{`

`Console.WriteLine("string is greater than 0 characters");`

`}`

### 条件运算符

一个`if`语句也可以由复杂的表达式组成，并且可以包含`else`语句来执行更复杂的测试。语法与 C ++和 Java 相同。为了构建复杂的表达式，C#提供了一组预期的条件逻辑运算符，如表 [3-8](#Tab8) 所示。

表 3-8。

C# Conditional Operators

<colgroup><col> <col> <col></colgroup> 
| 操作员 | 例子 | 生命的意义 |
| --- | --- | --- |
| `&&` | `if(age == 30 && name == "Fred")` | 和运算符。如果所有表达式都是`true`，则返回`true`。 |
| `&#124;&#124;` | `if(age == 30 &#124;&#124; name == "Fred")` | 或操作员。如果至少有一个表达式是`true`，则返回`true`。 |
| `!` | `if(!myBool)` | 不是操作员。如果`false`返回`true`，如果`true`返回`false`。 |

Note

必要时，`&&`和`||`操作器都“短路”。这意味着在一个复杂表达式被确定为`false`之后，剩余的子表达式将不会被检查。如果你需要测试所有的表达式，你可以使用相关的`&`和`|`操作符。

### switch 语句

C#提供的另一个简单的选择结构是`switch`语句。与其他基于 C 的语言一样，`switch`语句允许您基于一组预定义的选项来处理程序流。例如，下面的`Main()`逻辑基于两个可能的选择之一打印一个特定的字符串消息(案例`default`处理一个无效的选择)。

`// Switch on a numerical value.`

`static void SwitchExample()`

`{`

`Console.WriteLine("1 [C#], 2 [VB]");`

`Console.Write("Please pick your language preference: ");`

`string langChoice = Console.ReadLine();`

`int n = int.Parse(langChoice);`

`switch (n)`

`{`

`case 1:`

`Console.WriteLine("Good choice, C# is a fine language.");`

`break;`

`case 2:`

`Console.WriteLine("VB: OOP, multithreading, and more!");`

`break;`

`default:`

`Console.WriteLine("Well...good luck with that!");`

`break;`

`}`

`}`

Note

C#要求每个包含可执行语句的 case(包括`default`)都有一个终止`break`或`goto`以避免失败。

C# `switch`语句的一个很好的特性是，除了数值数据之外，您还可以计算`string`数据。下面是一个更新的`switch`语句，它做了同样的事情(注意，使用这种方法不需要将用户数据解析成数值):

`static void SwitchOnStringExample()`

`{`

`Console.WriteLine("C# or VB");`

`Console.Write("Please pick your language preference: ");`

`string langChoice = Console.ReadLine();`

`switch (langChoice)`

`{`

`case "C#":`

`Console.WriteLine("Good choice, C# is a fine language.");`

`break;`

`case "VB":`

`Console.WriteLine("VB: OOP, multithreading and more!");`

`break;`

`default:`

`Console.WriteLine("Well...good luck with that!");`

`break;`

`}`

`}`

也可以打开枚举数据类型。正如你将在[第 4 章](04.html)中看到的，C# `enum`关键字允许你定义一组定制的名称-值对。为了激起您的兴趣，考虑下面的最后一个助手函数，它在`System.DayOfWeek enum`上执行一个`switch`测试。您会注意到一些我还没有检查的语法，但是重点是切换`enum`本身的问题；缺失的部分将在后面的章节中补上。

`static void SwitchOnEnumExample()`

`{`

`Console.Write("Enter your favorite day of the week: ");`

`DayOfWeek favDay;`

`try`

`{`

`favDay = (DayOfWeek)Enum.Parse(typeof(DayOfWeek), Console.ReadLine());`

`}`

`catch (Exception)`

`{`

`Console.WriteLine("Bad input!");`

`return;`

`}`

`switch (favDay)`

`{`

`case DayOfWeek.Friday:`

`Console.WriteLine("Yes, Friday rules!");`

`break;`

`case DayOfWeek.Monday:`

`Console.WriteLine("Another day, another dollar");`

`break;`

`case DayOfWeek.Saturday:`

`Console.WriteLine("Great day indeed.");`

`break;`

`case DayOfWeek.Sunday:`

`Console.WriteLine("Football!!");`

`break;`

`case DayOfWeek.Thursday:`

`Console.WriteLine("Almost Friday...");`

`break;`

`case DayOfWeek.Tuesday:`

`Console.WriteLine("At least it is not Monday");`

`break;`

`case DayOfWeek.Wednesday:`

`Console.WriteLine("A fine day.");`

`break;`

`}`

`}`

Source Code

IterationsAndDecisions 项目位于 [`Chapter 3`](03.html) 子目录中。

## 摘要

本章的目标是向你展示 C#编程语言的许多核心方面。您研究了您可能有兴趣构建的任何应用中的常见结构。在研究了 application 对象的角色之后，您了解到每个 C#可执行程序都必须有一个定义`Main()`方法的类型，该方法充当程序的入口点。在`Main()`的范围内，您通常会创建任意数量的对象，这些对象协同工作，为您的应用注入活力。

接下来，您深入研究了 C#内置数据类型的细节，并开始理解每个数据类型关键字(例如，`int`)实际上是在`System`名称空间中成熟类型的简写符号(在本例中是`System.Int32`)。鉴于此，每种 C#数据类型都有许多内置成员。同样，您还了解了扩大和缩小的作用，以及关键字`checked`和`unchecked`的作用。

本章最后介绍了使用`var`关键字的隐式类型的作用。如前所述，隐式类型最有用的地方是在使用 LINQ 编程模型时。最后，您快速检查了 C#支持的各种迭代和决策结构。

现在你已经了解了一些基本的细节，下一章([第 4 章](04.html))将完成你对核心语言特性的检查。在那之后，你将为从第五章的[开始研究 C#的面向对象特性做好充分准备。](05.html)