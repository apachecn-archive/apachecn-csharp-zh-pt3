# 15.类型反射、后期绑定和基于属性的编程

如[第 14 章](14.html)所示，组件是部署的基本单位。净宇宙。使用 Visual Studio(和许多其他 ide)的集成对象浏览器，您能够检查项目引用的程序集集合中的类型。此外，像`ildasm.exe`这样的外部工具允许您查看给定的底层 CIL 代码、类型元数据和程序集清单。NET 二进制。除了设计时对。NET 程序集，您也能够使用`System.Reflection`命名空间以编程方式获得相同的信息。为此，本章的首要任务是界定反思的作用和必要性。NET 元数据。

本章的剩余部分研究了许多密切相关的主题，所有这些主题都依赖于反射服务。例如，您将了解. NET 客户端如何使用动态加载和后期绑定来激活它在编译时不了解的类型。您还将了解如何将自定义元数据插入到您的。NET 程序集通过使用系统提供的和自定义的属性。为了把所有这些(看似深奥的)主题放在正确的位置，本章最后演示了如何构建几个可以插入到可扩展的桌面 GUI 应用程序中的“管理单元对象”。

## 类型元数据的必要性

使用元数据完整描述类型(类、接口、结构、枚举和委托)的能力是。NET 平台。众多。NET 技术(如 Windows Communication Foundation(WCF)和对象序列化)要求能够在运行时发现类型的格式。此外，跨语言的互操作性、众多的编译器服务和 IDE 的智能感知功能都依赖于具体的类型描述。

回想一下，`ildasm.exe`实用程序允许您使用 Ctrl+M 键盘选项查看一个程序集的类型元数据(参见[第 1 章](01.html))。因此，如果您使用`ildasm.exe`打开本书过程中创建的任何`*.dll`或`*.exe`程序集(例如在[第 14 章](14.html)中创建的`CarLibrary.dll`)，并按 Ctrl+M，您将找到相关的类型元数据(参见图 [15-1](#Fig1) )。

![A978-1-4842-1332-2_15_Fig1_HTML.jpg](img/A978-1-4842-1332-2_15_Fig1_HTML.jpg)

图 15-1。

Viewing an assembly’s metadata using ildasm.exe

如你所见，`ildasm.exe`的显示。NET 类型元数据是冗长的(实际的二进制格式要简洁得多)。事实上，如果我要列出代表`CarLibrary.dll`程序集的整个元数据描述，它将跨越几页。考虑到这种行为是对纸张的严重浪费，让我们来看一下`CarLibrary.dll`程序集的一些关键元数据描述。

Note

不要太在意每一段。NET 元数据。更重要的是。NET 元数据描述性很强，列出了在给定代码库中找到的每个内部定义(和外部引用)的类型。

### 查看 EngineState 枚举的(部分)元数据

当前程序集中定义的每个类型都使用一个`TypeDef #n`标记(其中`TypeDef`是类型定义的缩写)进行记录。如果所描述的类型使用在单独的。NET 程序集，引用的类型使用一个`TypeRef #n`标记(其中`TypeRef`是类型引用的缩写)来记录。`TypeRef`标记是一个指针(如果你愿意的话)，指向外部程序集中被引用类型的完整元数据定义。简单地说，。NET 元数据是一组清楚地标记所有类型定义(`TypeDef` s)和引用类型(`TypeRef` s)的表格，所有这些都可以使用`ildasm.exe`的元数据窗口查看。

就`CarLibrary.dll`而言，一个`TypeDef`是`CarLibrary.EngineState`枚举的元数据描述(你的数字可能不同；`TypeDef`编号基于 C#编译器处理文件的顺序)。

`TypeDef #2 (02000003)`

`-------------------------------------------------------`

`TypDefName: CarLibrary.EngineState (02000003)`

`Flags     : [Public] [AutoLayout] [Class] [Sealed] [AnsiClass] (00000101)`

`Extends   : 01000001 [TypeRef] System.Enum`

`Field #1 (04000006)`

`-------------------------------------------------------`

`Field Name: value__ (04000006)`

`Flags     : [Public] [SpecialName] [RTSpecialName] (00000606)`

`CallCnvntn: [FIELD]`

`Field type: I4`

`Field #2 (04000007)`

`-------------------------------------------------------`

`Field Name: engineAlive (04000007)`

`Flags     : [Public] [Static] [Literal] [HasDefault] (00008056)`

`DefltValue: (I4) 0`

`CallCnvntn: [FIELD]`

`Field type: ValueClass CarLibrary.EngineState`

`...`

这里，`TypDefName`标记用于建立给定类型的名称，在本例中是自定义的`CarLibrary.EngineState`枚举。`Extends`元数据标记用于记录给定。NET 类型(在本例中是引用类型，`System.Enum`)。枚举的每个字段都用`Field #n`标记。为了简洁，我简单地列出了`CarLibrary.EngineState.engineAlive`的元数据。

### 查看汽车类型的(部分)元数据

下面是`Car`类的部分转储，说明了以下内容:

*   如何定义字段？网络元数据
*   方法是如何通过？网络元数据
*   中如何表示自动属性。网络元数据

`TypeDef #3 (02000004)`

`-------------------------------------------------------`

`TypDefName: CarLibrary.Car (02000004)`

`Flags : [Public] [AutoLayout] [Class] [Abstract]`

`[AnsiClass] [BeforeFieldInit] (00100081)`

`Extends : 01000002 [TypeRef] System.Object`

`...`

`Field #2 (0400000a)`

`-------------------------------------------------------`

`Field Name: <PetName>k__BackingField (0400000A)`

`Flags     : [Private] (00000001)`

`CallCnvntn: [FIELD]`

`Field type: String`

`...`

`Method #1 (06000001)`

`-------------------------------------------------------`

`MethodName: get_PetName (06000001)`

`Flags      : [Public] [HideBySig] [ReuseSlot] [SpecialName] (00000886)`

`RVA        : 0x000020d0`

`ImplFlags  : [IL] [Managed] (00000000)`

`CallCnvntn: [DEFAULT]`

`hasThis`

`ReturnType: String`

`No arguments.`

`...`

`Method #2 (06000002)`

`-------------------------------------------------------`

`MethodName: set_PetName (06000002)`

`Flags     : [Public] [HideBySig] [ReuseSlot] [SpecialName] (00000886)`

`RVA       : 0x000020e7`

`ImplFlags : [IL] [Managed] (00000000)`

`CallCnvntn: [DEFAULT]`

`hasThis`

`ReturnType: Void`

`1 Arguments`

`Argument #1: String`

`1 Parameters`

`(1) ParamToken : (08000001) Name : value flags: [none] (00000000)`

`...`

`Property #1 (17000001)`

`-------------------------------------------------------`

`Prop.Name : PetName (17000001)`

`Flags     : [none] (00000000)`

`CallCnvntn: [PROPERTY]`

`hasThis`

`ReturnType: String`

`No arguments.`

`DefltValue:`

`Setter : (06000002) set_PetName`

`Getter : (06000001) get_PetName`

`0 Others`

`...`

首先，请注意，`Car`类元数据标记了该类型的基类(`System.Object`)，并包括描述该类型如何构造的各种标志(例如，`[Public]`、`[Abstract]`等等)。方法(如`Car`的构造函数)是根据它们的参数、返回值和名称来描述的。

请注意自动属性是如何产生编译器生成的私有支持字段(名为`<PetName>k BackingField`)和两个编译器生成的方法(在读写属性的情况下)的，在本例中，这两个方法名为`get_PetName()`和`set_PetName()`。最后，使用将实际属性映射到内部 get/set 方法。NET 元数据`Getter` / `Setter`令牌。

### 检查 TypeRef

回想一下，程序集的元数据将不仅描述内部类型的集合(`Car`、`EngineState`等)。)以及内部类型引用的任何外部类型。例如，假设`CarLibrary.dll`已经定义了两个枚举，您可以为`System.Enum`类型找到一个`TypeRef`块，如下所示:

`TypeRef #1 (01000001)`

`-------------------------------------------------------`

`Token:              0x01000001`

`ResolutionScope:    0x23000001`

`TypeRefName:        System.Enum`

### 记录定义程序集

`ildasm.exe`元数据窗口也允许您查看。使用`Assembly`标记描述程序集本身的. NET 元数据。正如您从下面的(部分)清单中看到的,`Assembly`表中记录的信息是(惊喜，惊喜！)可以通过清单图标查看的相同信息。以下是`CarLibrary.dll`(版本 2.0.0.0)清单的部分转储:

`Assembly`

`-------------------------------------------------------`

`Token: 0x20000001`

`Name : CarLibrary`

`Public Key    : 00 24 00 00 04 80 00 00 // Etc...`

`Hash Algorithm : 0x00008004`

`Major Version: 0x00000002`

`Minor Version: 0x00000000`

`Build Number: 0x00000000`

`Revision Number: 0x00000000`

`Locale: <null>`

`Flags : [PublicKey] ...`

### 记录引用的程序集

除了`Assembly`令牌和一组`TypeDef`和`TypeRef`块之外。NET 元数据还利用`AssemblyRef #n`标记来记录每个外部程序集。假设`CarLibrary.dll`使用了`System.Windows.Forms.MessageBox`类，您可以为`System.Windows.Forms`程序集找到一个`AssemblyRef`，如下面的代码所示:

`AssemblyRef #2 (23000002)`

`-------------------------------------------------------`

`Token: 0x23000002`

`Public Key or Token: b7 7a 5c 56 19 34 e0 89`

`Name: System.Windows.Forms`

`Version: 4.0.0.0`

`Major Version: 0x00000004`

`Minor Version: 0x00000000`

`Build Number: 0x00000000`

`Revision Number: 0x00000000`

`Locale: <null>`

`HashValue Blob:`

`Flags: [none] (00000000)`

### 记录字符串文字

最后一个有趣的地方是。NET 元数据是这样一个事实，即代码库中的每个字符串都记录在`User Strings`标记下。

`User Strings`

`-------------------------------------------------------`

`70000001 : (11) L"Jamming {0}"`

`70000019 : (13) L"Quiet time..."`

`70000035 : (23) L"CarLibrary Version 2.0!"`

`70000065 : (14) L"Ramming speed!"`

`70000083 : (19) L"Faster is better..."`

`700000ab : ( 4) L"Eek!"`

`700000cd : (27) L"Your engine block exploded!"`

Note

如最后一个元数据列表所示，请始终注意，所有字符串都清楚地记录在程序集元数据中。如果您使用字符串来捕获密码、信用卡号或其他敏感信息，这可能会带来巨大的安全后果。

您脑海中的下一个问题可能是(在最好的情况下)“我如何在我的应用程序中利用这些信息？”或者(在最坏的情况下)“我为什么要关心元数据？”为了回应这两种观点，请允许我介绍。网络反射服务。请注意，在本章结束之前，接下来几页中介绍的主题的有用性可能有点让人摸不着头脑。所以抓紧了。

Note

您还会发现 MetaInfo 窗口显示了许多`CustomAttribute`标记，它记录了代码库中应用的属性。您将了解到。NET 属性。

## 理解反射

在。NET universe，反射是运行时类型发现的过程。使用反射服务，您能够使用友好的对象模型以编程方式获得由`ildasm.exe`显示的相同元数据信息。例如，通过反射，您可以获得包含在给定的`*.dll`或`*.exe`程序集内的所有类型的列表，包括由给定类型定义的方法、字段、属性和事件。您还可以动态地发现给定类型支持的接口集、方法的参数以及其他相关细节(基类、命名空间信息、清单数据等等)。

像任何名称空间一样，`System.Reflection`(在`mscorlib.dll`中定义)包含许多相关的类型。表 [15-1](#Tab1) 列出了一些你应该熟悉的核心项目。

表 15-1。

A Sampling of Members of the `System.Reflection` Namespace

<colgroup><col> <col></colgroup> 
| 类型 | 生命的意义 |
| --- | --- |
| `Assembly` | 这个抽象类包含许多允许您加载、调查和操作程序集的成员。 |
| `AssemblyName` | 此类允许您发现程序集标识背后的大量细节(版本信息、区域性信息等)。 |
| `EventInfo` | 这个抽象类保存给定事件的信息。 |
| `FieldInfo` | 这个抽象类保存给定字段的信息。 |
| `MemberInfo` | 这是一个抽象基类，定义了`EventInfo`、`FieldInfo`、`MethodInfo`和`PropertyInfo`类型的通用行为。 |
| `MethodInfo` | 这个抽象类包含给定方法的信息。 |
| `Module` | 这个抽象类允许您访问多文件程序集中的给定模块。 |
| `ParameterInfo` | 这个类保存给定参数的信息。 |
| `PropertyInfo` | 这个抽象类保存给定属性的信息。 |

了解如何利用`System.Reflection`名称空间以编程方式读取。NET 元数据，您需要首先接受`System.Type`类。

### 系统。类型类别

`System.Type`类定义了许多可用于检查类型元数据的成员，其中许多成员从`System.Reflection`名称空间返回类型。例如，`Type.GetMethods()`返回一组`MethodInfo`对象，`Type.GetFields()`返回一组`FieldInfo`对象，依此类推。`System.Type`曝光的全套成员相当膨胀；然而，表 [15-2](#Tab2) 提供了由`System.Type`支持的成员的部分快照(参见。NET Framework 4.6 SDK 文档以了解完整的详细信息)。

表 15-2。

Select Members of `System.` `Type`

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `IsAbstract``IsArray``IsClass``IsCOMObject``IsEnum``IsGenericTypeDefinition``IsGenericParameter``IsInterface``IsPrimitive``IsNestedPrivate``IsNestedPublic``IsSealed``IsValueType` | 这些属性(以及其他属性)允许您发现所引用的`Type`的一些基本特征(例如，如果它是一个抽象实体、一个数组、一个嵌套类等等)。 |
| `GetConstructors()` `GetEvents()` `GetFields()` `GetInterfaces()` `GetMembers()` `GetMethods()` `GetNestedTypes()` `GetProperties()` | 这些方法(以及其他方法)允许您获得一个表示项目(接口、方法、属性等)的数组。)你感兴趣。每个方法返回一个相关的数组(例如，`GetFields()`返回一个`FieldInfo`数组，`GetMethods()`返回一个`MethodInfo`数组，等等)。).请注意，这些方法都有单数形式(例如，`GetMethod()`、`GetProperty()`等)。)允许您按名称检索特定的项，而不是所有相关项的数组。 |
| `FindMembers()` | 该方法根据搜索条件返回一个`MemberInfo`数组。 |
| `GetType()` | 这个静态方法返回一个给定字符串名称的`Type`实例。 |
| `InvokeMember()` | 该方法允许给定项目的“后期绑定”。在本章的后面你会学到后期绑定。 |

### 使用系统获取类型引用。Object.GetType()

您可以通过多种方式获得`Type`类的实例。然而，有一件事你不能做，那就是使用`new`关键字直接创建一个`Type`对象，因为`Type`是一个抽象类。关于您的第一个选择，回想一下`System.Object`定义了一个名为`GetType()`的方法，它返回一个代表当前对象元数据的`Type`类的实例。

`// Obtain type information using a SportsCar instance.`

`SportsCar sc = new SportsCar();`

`Type t = sc.GetType();`

显然，只有当您知道要反射的类型(在本例中为`SportsCar`)的编译时知识，并且当前在内存中有该类型的实例时，这种方法才有效。考虑到这个限制，像`ildasm.exe`这样的工具不通过直接调用每个类型的`System.Object.GetType()`来获取类型信息应该是有意义的，因为`ildasm.exe`不是针对你的定制程序集编译的。

### 使用 typeof()获取类型引用

获取类型信息的下一种方法是使用 C# `typeof`操作符，如下所示:

`// Get the type using typeof.`

`Type t = typeof(SportsCar);`

与`System.Object.GetType()`不同，`typeof`操作符非常有用，因为您不需要首先创建一个对象实例来提取类型信息。然而，你的代码库必须仍然有你感兴趣的类型的编译时知识，因为`typeof`期望类型的强类型名称。

### 使用系统获取类型引用。Type.GetType()

为了以更灵活的方式获得类型信息，您可以调用`System.Type`类的静态`GetType()`成员，并指定您感兴趣的类型的完全限定字符串名称。使用这种方法，您不需要了解从中提取元数据的类型的编译时知识，因为`Type.GetType()`采用了无所不在的`System.String`的一个实例。

Note

当我说您在调用`Type.GetType()`时不需要编译时知识时，我指的是这个方法可以接受任何字符串值(而不是强类型变量)。当然，您仍然需要知道“stringified”格式的类型名！

`Type.GetType()`方法已被重载，允许您指定两个布尔参数，其中一个控制如果找不到类型是否应该抛出异常，另一个确定字符串的大小写。为了说明这一点，请思考以下几点:

`// Obtain type information using the static Type.GetType() method`

`// (don’t throw an exception if SportsCar cannot be found and ignore case).`

`Type t = Type.GetType("CarLibrary.SportsCar", false, true);`

在前面的例子中，请注意您传递到`GetType()`中的字符串没有提到包含该类型的程序集。在这种情况下，假设该类型是在当前执行的程序集中定义的。但是，当您想要获取外部私有程序集中某个类型的元数据时，字符串参数的格式是使用该类型的完全限定名，后跟一个逗号，再后跟包含该类型的程序集的友好名称，如下所示:

`// Obtain type information for a type within an external assembly.`

`Type t = Type.GetType("CarLibrary.SportsCar, CarLibrary");`

同样，要知道传入`Type.GetType()`的字符串可能会指定一个加号(`+`)来表示嵌套类型。假设您想要获取嵌套在名为`JamesBondCar`的类中的枚举(`SpyOptions`)的类型信息。为此，您应该编写以下代码:

`// Obtain type information for a nested enumeration`

`// within the current assembly.`

`Type t = Type.GetType("CarLibrary.JamesBondCar+SpyOptions");`

## 构建自定义元数据查看器

为了说明反射的基本过程(以及`System.Type`的用处)，让我们创建一个名为 MyTypeViewer 的控制台应用程序项目。这个程序将显示`mscorlib.dll`中任何类型的方法、属性、字段和支持的接口的详细信息(除了一些其他感兴趣的点)。NET 应用程序可以自动访问这个核心框架类库)或 MyTypeViewer 本身中的类型。一旦创建了应用程序，一定要导入`System.Reflection`名称空间。

`// Need to import this namespace to do any reflection!`

`using System.Reflection;`

### 反思方法

`Program`类将被更新以定义许多静态方法，每个方法接受一个`System.Type`参数并返回`void`。首先是`ListMethods()`，它(正如您可能猜到的那样)打印由传入类型定义的每个方法的名称。注意`Type.GetMethods()`如何返回一个`System.Reflection.MethodInfo`对象的数组，可以使用一个标准的`foreach`循环对其进行枚举，如下所示:

`// Display method names of type.`

`static void ListMethods(Type t)`

`{`

`Console.WriteLine("***** Methods *****");`

`MethodInfo[] mi = t.GetMethods();`

`foreach(MethodInfo m in mi)`

`Console.WriteLine("->{0}", m.Name);`

`Console.WriteLine();`

`}`

这里，您只是使用`MethodInfo.Name`属性打印方法的名称。正如您可能猜到的，`MethodInfo`有许多额外的成员，允许您确定方法是静态的、虚拟的、泛型的还是抽象的。同样，`MethodInfo`类型允许您获得方法的返回值和参数集。您将很快完善`ListMethods()`的实现。

如果愿意，还可以构建一个合适的 LINQ 查询来枚举每个方法的名称。回想一下第 12 章，对象的 LINQ 允许你构建强类型查询，这些查询可以应用于内存中的对象集合。一个好的经验法则是，无论何时发现循环或决策编程逻辑块，都可以利用相关的 LINQ 查询。例如，您可以将前面的方法重写为:

`static void ListMethods(Type t)`

`{`

`Console.WriteLine("***** Methods *****");`

`var methodNames = from n in t.GetMethods() select n.Name;`

`foreach (var name in methodNames)`

`Console.WriteLine("->{0}", name);`

`Console.WriteLine();`

`}`

### 反思字段和属性

`ListFields()`的实现也差不多。唯一值得注意的区别是对`Type.GetFields()`的调用和由此产生的`FieldInfo`数组。同样，为了简单起见，使用 LINQ 查询只打印出每个字段的名称。

`// Display field names of type.`

`static void ListFields(Type t)`

`{`

`Console.WriteLine("***** Fields *****");`

`var fieldNames = from f in t.GetFields() select f.Name;`

`foreach (var name in fieldNames)`

`Console.WriteLine("->{0}", name);`

`Console.WriteLine();`

`}`

显示类型属性的逻辑是相似的。

`// Display property names of type.`

`static void ListProps(Type t)`

`{`

`Console.WriteLine("***** Properties *****");`

`var propNames = from p in t.GetProperties() select p.Name;`

`foreach (var name in propNames)`

`Console.WriteLine("->{0}", name);`

`Console.WriteLine();`

`}`

### 反思实现的接口

接下来，您将编写一个名为`ListInterfaces()`的方法，该方法将打印传入类型支持的任何接口的名称。这里唯一有趣的一点是对`GetInterfaces()`的调用返回了一个`System.Type`的数组！鉴于接口确实是类型，这应该是有意义的。

`// Display implemented interfaces.`

`static void ListInterfaces(Type t)`

`{`

`Console.WriteLine("***** Interfaces *****");`

`var ifaces = from i in t.GetInterfaces() select i;`

`foreach(Type i in ifaces)`

`Console.WriteLine("->{0}", i.Name);`

`}`

Note

要知道大多数的`System.Type` ( `GetMethods()`，`GetInterfaces()`等的“get”方法。)已被重载，以允许您从`BindingFlags`枚举中指定值。这提供了对应该搜索什么的更高级别的控制(例如，仅静态成员、仅公共成员、包括私有成员等)。).请参考。NET Framework 4.6 SDK 文档了解详细信息。

### 展示各种零碎的东西

最后但同样重要的是，您有一个最终的 helper 方法，它将简单地显示关于传入类型的各种统计信息(指示类型是否是泛型、基类是什么、类型是否是密封的，等等)。

`// Just for good measure.`

`static void ListVariousStats(Type t)`

`{`

`Console.WriteLine("***** Various Statistics *****");`

`Console.WriteLine("Base class is: {0}", t.BaseType);`

`Console.WriteLine("Is type abstract? {0}", t.IsAbstract);`

`Console.WriteLine("Is type sealed? {0}", t.IsSealed);`

`Console.WriteLine("Is type generic? {0}", t.IsGenericTypeDefinition);`

`Console.WriteLine("Is type a class type? {0}", t.IsClass);`

`Console.WriteLine();`

`}`

### 实现 Main()

`Program`类的`Main()`方法提示用户输入类型的完全限定名。一旦获得这个字符串数据，就将它传递给`Type.GetType()`方法，并将提取的`System.Type`发送给每个助手方法。这个过程一直重复，直到用户输入 Q 来终止应用程序。

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Welcome to MyTypeViewer *****");`

`string typeName = "";`

`do`

`{`

`Console.WriteLine("\nEnter a type name to evaluate");`

`Console.Write("or enter Q to quit: ");`

`// Get name of type.`

`typeName = Console.ReadLine();`

`// Does user want to quit?`

`if (typeName.ToUpper() == "Q")`

`{`

`break;`

`}`

`// Try to display type.`

`try`

`{`

`Type t = Type.GetType(typeName);`

`Console.WriteLine("");`

`ListVariousStats(t);`

`ListFields(t);`

`ListProps(t);`

`ListMethods(t);`

`ListInterfaces(t);`

`}`

`catch`

`{`

`Console.WriteLine("Sorry, can’t find type");`

`}`

`} while (true);`

`}`

至此，`MyTypeViewer.exe`准备试驾了。例如，运行您的应用程序并输入以下完全限定的名称(注意您调用`Type.GetType()`的方式需要区分大小写的字符串名称):

*   `System.Int32`
*   `System.Collections.ArrayList`
*   `System.Threading.Thread`
*   `System.Void`
*   `System.IO.BinaryWriter`
*   `System.Math`
*   `System.Console`
*   `MyTypeViewer.Program`

例如，下面是指定`System.Math`时的部分输出:

`***** Welcome to MyTypeViewer *****`

`Enter a type name to evaluate`

`or enter Q to quit: System.Math`

`***** Various Statistics *****`

`Base class is: System.Object`

`Is type abstract? True`

`Is type sealed? True`

`Is type generic? False`

`Is type a class type? True`

`***** Fields *****`

`->PI`

`->E`

`***** Properties *****`

`***** Methods *****`

`->Acos`

`->Asin`

`->Atan`

`->Atan2`

`->Ceiling`

`->Ceiling`

`->Cos`

`...`

### 思考泛型类型

当您调用`Type.GetType()`来获取泛型类型的元数据描述时，您必须使用一种特殊的语法，包括一个“反勾”字符(```)，后跟一个表示该类型支持的类型参数数量的数值。例如，如果您想打印出`System.Collections.Generic.List<T>`的元数据描述，您需要将以下字符串传递到您的应用程序中:

`System.Collections.Generic.List`1`

这里，您使用的是`1`的数值，因为`List<T>`只有一个类型参数。然而，如果你想反射`Dictionary<TKey, TValue>`，你可以提供值`2`，就像这样:

`System.Collections.Generic.Dictionary`2`

### 反映方法参数和返回值

到目前为止，一切顺利！让我们对当前的应用程序做一个小小的改进。具体来说，您将更新`ListMethods()` helper 函数，不仅列出给定方法的名称，还列出返回类型和传入参数类型。类型为这些任务提供了`ReturnType`属性和`GetParameters()`方法。在下面修改过的代码中，请注意，您正在使用嵌套的`foreach`循环(没有使用 LINQ)构建一个包含每个参数的类型和名称的字符串:

`static void ListMethods(Type t)`

`{`

`Console.WriteLine("***** Methods *****");`

`MethodInfo[] mi = t.GetMethods();`

`foreach (MethodInfo m in mi)`

`{`

`// Get return type.`

`string retVal = m.ReturnType.FullName;`

`string paramInfo = "( ";`

`// Get params.`

`foreach (ParameterInfo pi in m.GetParameters())`

`{`

`paramInfo += string.Format("{0} {1} ", pi.ParameterType, pi.Name);`

`}`

`paramInfo += " )";`

`// Now display the basic method sig.`

`Console.WriteLine("->{0} {1} {2}", retVal, m.Name, paramInfo);`

`}`

`Console.WriteLine();`

`}`

如果您现在运行这个更新的应用程序，您会发现给定类型的方法更加详细。如果您输入您的好朋友`System.Object`作为程序的输入，将显示以下方法:

`***** Methods *****`

`->System.String ToString ( )`

`->System.Boolean Equals ( System.Object obj )`

`->System.Boolean Equals ( System.Object objA System.Object objB )`

`->System.Boolean ReferenceEquals ( System.Object objA System.Object objB )`

`->System.Int32 GetHashCode ( )`

`->System.Type GetType ( )`

`ListMethods()`的当前实现很有帮助，因为您可以使用`System.Reflection`对象模型直接研究每个参数和方法返回类型。作为一个极端的捷径，请注意所有的`XXXInfo`类型(`MethodInfo`、`PropertyInfo`、`EventInfo`等)。)已经覆盖了`ToString()`以显示所请求项目的签名。因此，您也可以如下实现`ListMethods()`(再次使用 LINQ，您只需选择所有`MethodInfo`对象，而不仅仅是`Name`值):

`static void ListMethods(Type t)`

`{`

`Console.WriteLine("***** Methods *****");`

`var methodNames = from n in t.GetMethods() select n;`

`foreach (var name in methodNames)`

`Console.WriteLine("->{0}", name);`

`Console.WriteLine();`

`}`

有趣的东西，是吧？显然,`System.Reflection`命名空间和`System.Type`类允许你反映一个类型的许多其他方面，超出了`MyTypeViewer`当前显示的内容。正如您所希望的，您可以获得类型的事件，获得给定成员的任何泛型参数的列表，并收集许多其他细节。

尽管如此，此时您已经创建了一个(有点功能的)对象浏览器。当然，主要的限制是，除了当前的程序集(`MyTypeViewer`)或始终可访问的`mscorlib.dll`)之外，您无法进行反射。这就引出了一个问题，“我如何构建可以加载(并反射)编译时未引用的程序集的应用程序？”很高兴你问了。

Source Code

您可以在 [`Chapter 15`](15.html) 子目录中找到 MyTypeViewer 项目。

## 动态加载程序集

在第 14 章中，你已经了解了 CLR 在探测外部引用的程序集时是如何查询程序集清单的。但是，很多时候您需要以编程方式动态加载程序集，即使清单中没有所述程序集的记录。从形式上讲，按需加载外部程序集的行为称为动态加载。

`System.Reflection`定义一个名为`Assembly`的类。使用此类，您可以动态加载程序集，以及发现有关程序集本身的属性。使用`Assembly`类型，你可以动态加载私有或共享的程序集，也可以加载位于任意位置的程序集。本质上，`Assembly`类提供了一些方法(特别是`Load()`和`LoadFrom()`)，允许您以编程方式提供与客户端`*.config`文件中相同的信息。

为了演示动态加载，创建一个名为 ExternalAssemblyReflector 的新控制台应用程序项目。您的任务是构造一个`Main()`方法，该方法提示输入要动态加载的程序集的友好名称。您将把`Assembly`引用传递到一个名为`DisplayTypes()`的帮助器方法中，该方法将简单地打印它包含的每个类、接口、结构、枚举和委托的名称。代码非常简单。

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`using System.Reflection;`

`using System.IO; // For FileNotFoundException definition.`

`namespace ExternalAssemblyReflector`

`{`

`class Program`

`{`

`static void DisplayTypesInAsm(Assembly asm)`

`{`

`Console.WriteLine("\n***** Types in Assembly *****");`

`Console.WriteLine("->{0}", asm.FullName);`

`Type[] types = asm.GetTypes();`

`foreach (Type t in types)`

`Console.WriteLine("Type: {0}", t);`

`Console.WriteLine("");`

`}`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** External Assembly Viewer *****");`

`string asmName = "";`

`Assembly asm = null;`

`do`

`{`

`Console.WriteLine("\nEnter an assembly to evaluate");`

`Console.Write("or enter Q to quit: ");`

`// Get name of assembly.`

`asmName = Console.ReadLine();`

`// Does user want to quit?`

`if (asmName.ToUpper() == "Q")`

`{`

`break;`

`}`

`// Try to load assembly.`

`try`

`{`

`asm = Assembly.Load(asmName);`

`DisplayTypesInAsm(asm);`

`}`

`catch`

`{`

`Console.WriteLine("Sorry, can’t find assembly.");`

`}`

`} while (true);`

`}`

`}`

`}`

请注意，静态的`Assembly.Load()`方法只被传递了您想要加载到内存中的程序集的友好名称。因此，如果您想通过`CarLibrary.dll`进行反射，您需要将`CarLibrary.dll`二进制文件复制到 ExternalAssemblyReflector 应用程序的`\bin\Debug`目录中，以运行这个程序。一旦您这样做了，您将会发现类似如下的输出:

`***** External Assembly Viewer *****`

`Enter an assembly to evaluate`

`or enter Q to quit: CarLibrary`

`***** Types in Assembly *****`

`->CarLibrary, Version=2.0.0.0, Culture=neutral, PublicKeyToken=33a2bc294331e8b9`

`Type: CarLibrary.MusicMedia`

`Type: CarLibrary.EngineState`

`Type: CarLibrary.Car`

`Type: CarLibrary.SportsCar`

`Type: CarLibrary.MiniVan`

如果您想让 ExternalAssemblyReflector 更加灵活，您可以更新代码，使用`Assembly.LoadFrom()`而不是`Assembly.Load()`来加载外部程序集，如下所示:

`try`

`{`

`asm = Assembly.LoadFrom(asmName);`

`DisplayTypesInAsm(asm);`

`}`

这样，您可以输入想要查看的程序集的绝对路径(如`C:\MyApp\MyAsm.dll`)。本质上，`Assembly.LoadFrom()`允许您以编程方式提供一个`<codeBase>`值。经过这样的调整，您现在可以传入控制台应用程序项目的完整路径。因此，如果`CarLibrary.dll`位于`C:\MyCode`下，您可以输入以下内容:

`***** External Assembly Viewer *****`

`Enter an assembly to evaluate`

`or enter Q to quit: C:\MyCode\CarLibrary.dll`

`***** Types in Assembly *****`

`->CarLibrary, Version=2.0.0.0, Culture=neutral, PublicKeyToken=33a2bc294331e8b9`

`Type: CarLibrary.EngineState`

`Type: CarLibrary.Car`

`Type: CarLibrary.SportsCar`

`Type: CarLibrary.MiniVan`

Source Code

ExternalAssemblyReflector 项目位于 [`Chapter 15`](15.html) 子目录中。

## 反映共享程序集

`Assembly.Load()`方法已经多次重载。一种变体允许您指定区域性值(对于本地化程序集)，以及版本号和公钥标记值(对于共享程序集)。总的来说，标识组件的项目集称为显示名称。显示名称的格式是以逗号分隔的名称-值对字符串，以程序集的友好名称开头，后跟可选的限定符(可以按任何顺序出现)。下面是要遵循的模板(可选项目出现在括号中):

`Name (,Version = major.minor.build.revision) (,Culture = culture token)`

`(,PublicKeyToken= public key token)`

当你设计一个显示名时，约定`PublicKeyToken=null`表明需要绑定和匹配一个非强名称的程序集。此外，`Culture=""`表示匹配目标计算机的默认区域性，例如:

`// Load version 1.0.0.0 of CarLibrary using the default culture.`

`Assembly a =`

`Assembly.Load(@"CarLibrary, Version=1.0.0.0, PublicKeyToken=null, Culture=""");`

还要注意,`System.Reflection`名称空间提供了`AssemblyName`类型，这允许您在一个方便的对象变量中表示前面的字符串信息。通常，这个类与`System.Version`一起使用，后者是一个封装程序集版本号的面向对象包装器。一旦建立了显示名称，就可以将它传递给重载的`Assembly.Load()`方法，如下所示:

`// Make use of AssemblyName to define the display name.`

`AssemblyName asmName;`

`asmName = new AssemblyName();`

`asmName.Name = "CarLibrary";`

`Version v = new Version("1.0.0.0");`

`asmName.Version = v;`

`Assembly a = Assembly.Load(asmName);`

要从 GAC 加载共享程序集，`Assembly.Load()`参数必须指定一个`PublicKeyToken`值。例如，假设您有一个名为 SharedAsmReflector 的新控制台应用程序项目，并希望加载由。NET 基础类库。鉴于该程序集中的类型数量相当大，下面的应用程序使用简单的 LINQ 查询，仅打印出公共枚举的名称:

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`using System.Reflection;`

`using System.IO;`

`namespace SharedAsmReflector`

`{`

`public class SharedAsmReflector`

`{`

`private static void DisplayInfo(Assembly a)`

`{`

`Console.WriteLine("***** Info about Assembly *****");`

`Console.WriteLine("Loaded from GAC? {0}", a.GlobalAssemblyCache);`

`Console.WriteLine("Asm Name: {0}", a.GetName().Name);`

`Console.WriteLine("Asm Version: {0}", a.GetName().Version);`

`Console.WriteLine("Asm Culture: {0}",`

`a.GetName().CultureInfo.DisplayName);`

`Console.WriteLine("\nHere are the public enums:");`

`// Use a LINQ query to find the public enums.`

`Type[] types = a.GetTypes();`

`var publicEnums = from pe in types where pe.IsEnum &&`

`pe.IsPublic select pe;`

`foreach (var pe in publicEnums)`

`{`

`Console.WriteLine(pe);`

`}`

`}`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** The Shared Asm Reflector App *****\n");`

`// Load System.Windows.Forms.dll from GAC.`

`string displayName = null;`

`displayName = "System.Windows.Forms," +`

`"Version=4.0.0.0," +`

`"PublicKeyToken=b77a5c561934e089," +`

`@"Culture=""";`

`Assembly asm = Assembly.Load(displayName);`

`DisplayInfo(asm);`

`Console.WriteLine("Done!");`

`Console.ReadLine();`

`}`

`}`

`}`

Source Code

SharedAsmReflector 项目位于 [`Chapter 15`](15.html) 子目录中。

此时，您应该理解如何使用`System.Reflection`名称空间的一些核心成员在运行时发现元数据。当然，我意识到尽管有“酷的因素”，你可能不需要经常在你工作的地方构建定制的对象浏览器。但是，请记住，反射服务是许多常见编程活动的基础，包括后期绑定。

## 了解后期绑定

简而言之，后期绑定是一种技术，在这种技术中，您能够创建给定类型的实例，并在运行时调用其成员，而无需硬编码编译时了解其存在。当您正在生成后期绑定到外部程序集中的类型的应用程序时，您没有理由设置对该程序集的引用；因此，调用方的清单没有程序集的直接列表。

乍一看，并不容易看出后期绑定的价值。的确，如果您可以“早期绑定”到一个对象(例如，添加一个程序集引用并使用 C# `new`关键字分配类型)，您应该选择这样做。出于一个原因，早期绑定允许您在编译时确定错误，而不是在运行时。尽管如此，后期绑定在您可能构建的任何可扩展应用程序中确实扮演着重要角色。在本章末尾的“构建可扩展的应用程序”一节中，您将有机会构建这样一个“可扩展的”程序在此之前，让我们检查一下`Activator`类的作用。

### 系统。活化剂类别

`System.Activator`类(在`mscorlib.dll`中定义)是。NET 后期绑定过程。对于当前示例，您只对`Activator.CreateInstance()`方法感兴趣，该方法用于创建后期绑定类型的实例。此方法已被重载多次，以提供很大的灵活性。`CreateInstance()`成员最简单的变体是接受一个有效的`Type`对象，该对象描述了您想要动态分配到内存中的实体。

创建一个名为 LateBindingApp 的新控制台应用程序项目，并通过 C# `using`关键字导入`System.IO`和`System.Reflection`名称空间。现在，更新`Program`类，如下所示:

`// This program will load an external library,`

`// and create an object using late binding.`

`public class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Late Binding *****");`

`// Try to load a local copy of CarLibrary.`

`Assembly a = null;`

`try`

`{`

`a = Assembly.Load("CarLibrary");`

`}`

`catch(FileNotFoundException ex)`

`{`

`Console.WriteLine(ex.Message);`

`return;`

`}`

`if(a != null)`

`CreateUsingLateBinding(a);`

`Console.ReadLine();`

`}`

`static void CreateUsingLateBinding(Assembly asm)`

`{`

`try`

`{`

`// Get metadata for the Minivan type.`

`Type miniVan = asm.GetType("CarLibrary.MiniVan");`

`// Create a Minivan instance on the fly.`

`object obj = Activator.CreateInstance(miniVan);`

`Console.WriteLine("Created a {0} using late binding!", obj);`

`}`

`catch(Exception ex)`

`{`

`Console.WriteLine(ex.Message);`

`}`

`}`

`}`

现在，在运行这个应用程序之前，您需要使用 Windows 资源管理器将一个`CarLibrary.dll`副本手动放置到这个新应用程序的`bin\Debug`文件夹中。原因是您正在调用`Assembly.Load()`，因此，CLR 将只在客户端文件夹中探测(如果您愿意，您可以使用`Assembly.LoadFrom()`输入程序集的路径；但是，没有必要这样做)。

Note

不要在这个例子中使用 Visual Studio 添加对`CarLibrary.dll`的引用！它将在客户端的清单中记录这个库。后期绑定的全部意义在于，您试图创建一个在编译时未知的对象。

注意，`Activator.CreateInstance()`方法返回一个`System.Object`，而不是一个强类型的`MiniVan`。因此，如果您在`obj`变量上应用点操作符，您将看不到`MiniVan`类的任何成员。乍一看，您可能认为可以通过显式强制转换来解决这个问题，如下所示:

`// Cast to get access to the members of MiniVan?`

`// Nope! Compiler error!`

`object obj = (MiniVan)Activator.CreateInstance(minivan);`

但是，因为您的程序没有添加对`CarLibrary.dll`的引用，所以您不能使用 C# `using`关键字来导入`CarLibrary`名称空间，因此，您不能在转换操作期间使用`MiniVan`！请记住，后期绑定的要点是创建没有编译时知识的对象实例。考虑到这一点，如何调用存储在`System.Object`引用中的`MiniVan`对象的底层方法呢？答案当然是通过使用反射。

### 调用不带参数的方法

假设您想要调用`MiniVan`的`TurboBoost()`方法。正如您所记得的，这个方法将把引擎的状态设置为“dead ”,并显示一个信息消息框。第一步是使用`Type.GetMethod()`为`TurboBoost()`方法获取一个`MethodInfo`对象。从产生的`MethodInfo`中，您可以使用`Invoke(). MethodInfo.Invoke()`调用`MiniVan.TurboBoost`，这需要您发送所有参数给由`MethodInfo`表示的方法。这些参数由一组`System.Object`类型表示(因为给定方法的参数可以是任意数量的各种实体)。

鉴于`TurboBoost()`不需要任何参数，可以简单地通过`null`(意思是“这个方法没有参数”)。更新您的`CreateUsingLateBinding()`方法如下:

`static void CreateUsingLateBinding(Assembly asm)`

`{`

`try`

`{`

`// Get metadata for the Minivan type.`

`Type miniVan = asm.GetType("CarLibrary.MiniVan");`

`// Create the Minivan on the fly.`

`object obj = Activator.CreateInstance(miniVan);`

`Console.WriteLine("Created a {0} using late binding!", obj);`

`// Get info for TurboBoost.`

`MethodInfo mi = miniVan.GetMethod("TurboBoost");`

`// Invoke method (’null’ for no parameters).`

`mi.Invoke(obj, null);`

`}`

`catch(Exception ex)`

`{`

`Console.WriteLine(ex.Message);`

`}`

`}`

此时，一旦调用`TurboBoost()`方法，您将看到如图 [15-2](#Fig2) 所示的消息框。

![A978-1-4842-1332-2_15_Fig2_HTML.jpg](img/A978-1-4842-1332-2_15_Fig2_HTML.jpg)

图 15-2。

Late-bound method invocation

### 调用带参数的方法

当您想要使用后期绑定来调用需要参数的方法时，您应该将参数打包成一个松散类型的`object`数组。回想一下`CarLibrary.dll`的 2.0.0.0 版本在`Car`类中定义了以下方法:

`public void TurnOnRadio(bool musicOn, MusicMedia mm)`

`{`

`if (musicOn)`

`MessageBox.Show(string.Format("Jamming {0}", mm));`

`else`

`MessageBox.Show("Quiet time...");`

`}`

这个方法有两个参数:一个布尔值表示汽车的音乐系统应该打开还是关闭，一个枚举表示音乐播放器的类型。回想一下，该枚举的结构如下:

`public enum MusicMedia`

`{`

`musicCd, // 0`

`musicTape, // 1`

`musicRadio, // 2`

`musicMp3 // 3`

`}`

这里有一个`Program`类的新方法，它调用`TurnOnRadio()`。请注意，您正在使用`MusicMedia`枚举的底层数值来指定一个“收音机”媒体播放器。

`static void InvokeMethodWithArgsUsingLateBinding(Assembly asm)`

`{`

`try`

`{`

`// First, get a metadata description of the sports car.`

`Type sport = asm.GetType("CarLibrary.SportsCar");`

`// Now, create the sports car.`

`object obj = Activator.CreateInstance(sport);`

`// Invoke TurnOnRadio() with arguments.`

`MethodInfo mi = sport.GetMethod("TurnOnRadio");`

`mi.Invoke(obj, new object[] { true, 2 });`

`}`

`catch (Exception ex)`

`{`

`Console.WriteLine(ex.Message);`

`}`

`}`

理想情况下，此时，您可以看到反射、动态加载和后期绑定之间的关系。可以肯定的是，反射 API 提供了许多超出这里所讨论的特性，但是如果您感兴趣的话，您应该准备好深入研究更多的细节。

同样，您可能仍然想知道什么时候应该在自己的应用程序中使用这些技术。本章的结论应该阐明这个问题；然而，下一个研究的主题是。网络属性。

Source Code

LateBindingApp 项目在 [`Chapter 15`](15.html) 子目录中。

## 理解的作用。网络属性

如本章开头所述，. NET 编译器的一个作用是为所有定义和引用的类型生成元数据描述。除了任何程序集中包含的标准元数据之外。NET 平台为程序员提供了一种使用属性将附加元数据嵌入程序集中的方法。简而言之，属性只不过是可以应用于给定类型(类、接口、结构等)的代码注释。)、成员(属性、方法等。)、程序集或模块。

。NET 属性是扩展抽象基类`System.Attribute`的类类型。当你探索。NET 命名空间，您会发现许多可以在应用程序中使用的预定义属性。此外，您可以自由构建定制属性，通过创建一个从`Attribute`派生的新类型来进一步限定您的类型的行为。

那个。NET 基类库在各种命名空间中提供了许多属性。表 [15-3](#Tab3) 给出了一些——但绝不是全部——预定义属性的快照。

表 15-3。

A Tiny Sampling of Predefined Attributes

<colgroup><col> <col></colgroup> 
| 属性 | 生命的意义 |
| --- | --- |
| `[CLSCompliant]` | 强制带批注的项目符合公共语言规范(CLS)的规则。回想一下，CLS 兼容的类型保证可以在所有。NET 编程语言。 |
| `[DllImport]` | 允许。NET 代码调用任何基于非托管 C 或 C++的代码库，包括底层操作系统的 API。请注意，在与基于 COM 的软件通信时，不使用`[DllImport]`。 |
| `[Obsolete]` | 标记不推荐使用的类型或成员。如果其他程序员试图使用这样的项目，他们将收到一个编译器警告，描述他们的方法的错误。 |
| `[Serializable]` | 将类或结构标记为“可序列化”，这意味着它能够将其当前状态保存到流中。 |
| `[NonSerialized]` | 指定在序列化过程中不应保持类或结构中的给定字段。 |
| `[ServiceContract]` | 将方法标记为由 WCF 服务实现的协定。 |

请理解，当您在代码中应用属性时，嵌入的元数据基本上是无用的，直到另一个软件明确地反映了这些信息。如果不是这样，嵌入在程序集中的元数据的格式回复将被忽略，并且完全无害。

### 属性消费者

正如您所猜测的。NET 4.6 Framework SDK 附带了许多实用程序，它们确实在寻找各种属性。C#编译器(`csc.exe`)本身已经被预编程，以便在编译周期中发现各种属性的存在。例如，如果 C#编译器遇到了`[CLSCompliant]`属性，它将自动检查属性化的项，以确保它只公开符合 CLS 的构造。作为另一个例子，如果 C#编译器发现一个具有`[Obsolete]`属性的项，它将在 Visual Studio 错误列表窗口中显示一个编译器警告。

除了开发工具之外。NET 基础类库是预编程的，以反映特定的属性。例如，如果你想把一个对象的状态保存到文件中，你所需要做的就是用`[Serializable]`属性注释你的类或结构。如果`BinaryFormatter`类的`Serialize()`方法遇到这个属性，对象会自动以紧凑的二进制格式保存到文件中。

最后，您可以自由地构建应用程序，这些应用程序被编程为反映您自己的自定义属性以及。NET 基础类库。通过这样做，您基本上能够创建一组“关键字”,这些关键字被一组特定的程序集所理解。

### 在 C#中应用属性

为了演示在 C#中应用属性的过程，创建一个名为 applying attributes 的新控制台应用程序项目。假设您想要构建一个名为`Motorcycle`的类，它可以以二进制格式持久化。为此，只需将`[Serializable]`属性应用于类定义。如果你有一个不应该被持久化的字段，你可以应用`[NonSerialized]`属性。

`// This class can be saved to disk.`

`[Serializable]`

`public class Motorcycle`

`{`

`// However, this field will not be persisted.`

`[NonSerialized]`

`float weightOfCurrentPassengers;`

`// These fields are still serializable.`

`bool hasRadioSystem;`

`bool hasHeadSet;`

`bool hasSissyBar;`

`}`

Note

属性适用于“下一个”项目。例如，`Motorcycle`类中唯一未序列化的字段是`weightOfCurrentPassengers`。剩下的字段是可序列化的，因为整个类已经用`[Serializable]`进行了注释。

此时，不要关心对象序列化的实际过程([第 20 章](20.html)讨论细节)。请注意，当您想要应用一个属性时，属性的名称被夹在方括号中。

一旦编译了这个类，就可以使用`ildasm.exe`查看额外的元数据。注意，这些属性是使用`serializable`标记(见`Motorcycle`类内的红色三角形)和`notserialized`标记(在`weightOfCurrentPassengers`字段上)记录的；见图 [15-3](#Fig3) 。

![A978-1-4842-1332-2_15_Fig3_HTML.jpg](img/A978-1-4842-1332-2_15_Fig3_HTML.jpg)

图 15-3。

Attributes shown in `ildasm.exe`

正如您可能猜到的那样，一个单一的项目可以有多个属性。假设您有一个遗留的 C#类类型(`HorseAndBuggy`)，它被标记为可序列化的，但是现在被认为对于当前的开发已经过时了。您可以用`[Obsolete]`属性来标记这个类，而不是从您的代码库中删除这个类定义(并冒着破坏现有软件的风险)。要将多个属性应用于单个项目，只需使用逗号分隔的列表，如下所示:

`[Serializable, Obsolete("Use another vehicle!")]`

`public class HorseAndBuggy`

`{`

`// ...`

`}`

或者，您也可以将多个属性应用于单个项目，方法是按如下方式堆叠每个属性(最终结果是相同的):

`[Serializable]`

`[Obsolete("Use another vehicle!")]`

`public class HorseAndBuggy`

`{`

`// ...`

`}`

### C#属性速记符号

如果你在咨询。NET Framework 4.6 SDK 文档，您可能已经注意到，`[Obsolete]`属性的实际类名是`ObsoleteAttribute`，而不是`Obsolete`。作为命名约定，所有。NET 属性(包括您可能自己创建的自定义属性)的后缀是`Attribute`标记。然而，为了简化应用属性的过程，C#语言不要求您键入`Attribute`后缀。考虑到这一点，下面的`HorseAndBuggy`类型的迭代与前面的相同(它只是涉及到更多的击键):

`[SerializableAttribute]`

`[ObsoleteAttribute("Use another vehicle!")]`

`public class HorseAndBuggy`

`{`

`// ...`

`}`

要知道这是 C#提供的一种礼貌。不全是。支持. NET 的语言支持这种速记属性语法。

### 为属性指定构造函数参数

请注意，`[Obsolete]`属性能够接受看起来像是构造函数参数的内容。如果您通过在代码编辑器中右键单击项目并选择 Go To Definition 菜单选项来查看`[Obsolete]`属性的正式定义，您会发现这个类确实提供了一个接收`System.String`的构造函数。

`public sealed class ObsoleteAttribute : Attribute`

`{`

`public ObsoleteAttribute(string message, bool error);`

`public ObsoleteAttribute(string message);`

`public ObsoleteAttribute();`

`public bool IsError { get; }`

`public string Message { get; }`

`}`

请理解，当您向属性提供构造函数参数时，该属性不会被分配到内存中，直到参数被另一个类型或外部工具反射。在属性级别定义的字符串数据只是作为元数据的格式回复存储在程序集中。

### 作用中的过时属性

既然`HorseAndBuggy`已经被标记为过时，如果您要分配这种类型的实例:

`static void Main(string[] args)`

`{`

`HorseAndBuggy mule = new HorseAndBuggy();`

`}`

您会发现提供的字符串数据被提取并显示在 Visual Studio 的错误列表窗口中，当您将鼠标光标悬停在过时类型上时，这些数据也会显示在有问题的代码行上(参见图 [15-4](#Fig4) )。

![A978-1-4842-1332-2_15_Fig4_HTML.jpg](img/A978-1-4842-1332-2_15_Fig4_HTML.jpg)

图 15-4。

Attributes in action

在这种情况下，反映在`[Obsolete]`属性上的“另一块软件”是 C#编译器。理想情况下，在这一点上，你应该了解以下关键点。网络属性:

*   属性是从`System.Attribute`派生的类。
*   属性导致嵌入的元数据。
*   属性基本上是无用的，直到另一个代理反映出来。
*   在 C#中，使用方括号应用属性。

接下来，让我们看看如何构建自己的定制属性和一个定制软件来反映嵌入的元数据。

Source Code

ApplyingAttributes 项目位于 [`Chapter 15`](15.html) 子目录中。

## 构建自定义属性

构建定制属性的第一步是创建一个从`System.Attribute`派生的新类。与本书通篇使用的汽车主题保持一致，假设您已经创建了一个名为`AttributedCarLibrary`的新 C#类库项目。这个程序集将定义一些车辆，每辆车都使用一个名为`VehicleDescriptionAttribute`的自定义属性进行描述，如下所示:

`// A custom attribute.`

`public sealed class VehicleDescriptionAttribute : System.Attribute`

`{`

`public string Description { get; set; }`

`public VehicleDescriptionAttribute(string vehicalDescription)`

`{`

`Description = vehicalDescription;`

`}`

`public VehicleDescriptionAttribute(){ }`

`}`

如您所见，`VehicleDescriptionAttribute`维护了一段使用自动属性(`Description`)操作的字符串数据。除了这个类是从`System.Attribute`派生出来的这个事实之外，这个类的定义并没有什么独特之处。

Note

出于安全原因，将所有自定义属性设计为密封的被认为是. NET 的最佳实践。事实上，Visual Studio 提供了一个名为`Attribute`的代码片段，它会将新的`System.Attribute`派生类转储到您的代码窗口中。参见[第 2 章](02.html)关于使用代码片段的完整解释；但是，回想一下，您可以通过键入代码片段的名称并按 Tab 键两次来展开代码片段。

### 应用自定义属性

鉴于`VehicleDescriptionAttribute`是从`System.Attribute`衍生而来的，你现在可以给你的车辆添加你认为合适的注释了。出于测试目的，将以下类定义添加到新的类库中:

`// Assign description using a "named property."`

`[Serializable]`

`[VehicleDescription(Description = "My rocking Harley")]`

`public class Motorcycle`

`{`

`}`

`[Serializable]`

`[Obsolete ("Use another vehicle!")]`

`[VehicleDescription("The old gray mare, she ain’t what she used to be...")]`

`public class HorseAndBuggy`

`{`

`}`

`[VehicleDescription("A very long, slow, but feature-rich auto")]`

`public class Winnebago`

`{`

`}`

### 命名属性语法

请注意，`Motorcycle`的描述使用一种新的以属性为中心的语法命名属性。在第一个`[VehicleDescription]`属性的构造函数中，使用`Description`属性设置底层字符串数据。如果这个属性被一个外部代理反射，那么这个值就被输入到`Description`属性中(只有当这个属性提供了一个可写的。净资产)。

相比之下，`HorseAndBuggy`和`Winnebago`类型不使用命名属性语法，只是通过自定义构造函数传递字符串数据。在任何情况下，一旦编译了`AttributedCarLibrary`程序集，您就可以使用`ildasm.exe`来查看为您的类型注入的元数据描述。例如，图 [15-5](#Fig5) 显示了`Winnebago`类的嵌入式描述，特别是`ildasm.exe`中`beforefieldinit`项内的数据。

![A978-1-4842-1332-2_15_Fig5_HTML.jpg](img/A978-1-4842-1332-2_15_Fig5_HTML.jpg)

图 15-5。

Embedded vehicle description data

### 限制属性使用

默认情况下，自定义属性可以应用于代码的任何方面(方法、类、属性等等)。因此，如果这样做有意义的话，您可以使用`VehicleDescription`来限定方法、属性或字段(等等)。

`[VehicleDescription("A very long, slow, but feature-rich auto")]`

`public class Winnebago`

`{`

`[VehicleDescription("My rocking CD player")]`

`public void PlayMusic(bool On)`

`{`

`...`

`}`

`}`

在某些情况下，这正是您需要的行为。但是，在其他时候，您可能希望构建一个只能应用于选定代码元素的自定义属性。如果您想要约束一个定制属性的范围，您将需要在您的定制属性的定义上应用`[AttributeUsage]`属性。`[AttributeUsage]`属性允许您从`AttributeTargets`枚举中提供值的任意组合(通过一个`OR`操作)，如下所示:

`// This enumeration defines the possible targets of an attribute.`

`public enum AttributeTargets`

`{`

`All, Assembly, Class, Constructor,`

`Delegate, Enum, Event, Field, GenericParameter,`

`Interface, Method, Module, Parameter,`

`Property, ReturnValue, Struct`

`}`

此外，`[AttributeUsage]`还允许您有选择地设置一个命名属性(`AllowMultiple`)，指定该属性是否可以在同一个项目上多次应用(默认为`false`)。同样，`[AttributeUsage]`允许您使用`Inherited`命名的属性(默认为`true`)来确定属性是否应该被派生类继承。

要确定`[VehicleDescription]`属性只能在一个类或结构上应用一次，可以按如下方式更新`VehicleDescriptionAttribute`定义:

`// This time, we are using the AttributeUsage attribute`

`// to annotate our custom attribute.`

`[AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct,`

`Inherited = false)]`

`public sealed class VehicleDescriptionAttribute : System.Attribute`

`{`

`...`

`}`

这样，如果开发人员试图将`[VehicleDescription]`属性应用到类或结构之外的任何东西上，他或她就会收到一个编译时错误。

## 程序集级属性

还可以使用`[assembly:]`标签将属性应用于给定程序集中的所有类型。例如，假设您希望确保程序集中定义的每个公共类型的每个公共成员都符合 CLS 标准。

Note

第 1 章提到了符合 CLS 标准的组件的作用。回想一下，所有人都可以使用符合 CLS 标准的程序集。开箱即用的. NET 编程语言。如果创建公开不符合 CLS 标准的编程构造(如无符号数据或指针参数)的公共类型的公共成员，则其他。NET 语言可能无法使用您的功能。因此，如果您正在构建需要被各种各样的。NET 语言，检查是否符合 CLS 是必须的。

为此，只需在任何 C#源代码文件的顶部添加下面的程序集级属性。请注意，所有程序集或模块级属性都必须在任何命名空间范围之外列出！如果将程序集级或模块级属性添加到项目中，建议遵循以下文件布局:

`// List "using" statements first.`

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`// Now list any assembly- or module-level attributes.`

`// Enforce CLS compliance for all public types in this assembly.`

`[assembly: CLSCompliant(true)]`

`// Now, your namespace(s) and types.`

`namespace AttributedCarLibrary`

`{`

`// Types...`

`}`

如果您现在添加了一点 CLS 规范之外的代码(例如无符号数据的暴露点):

`// Ulong types don’t jibe with the CLS.`

`public class Winnebago`

`{`

`public ulong notCompliant;`

`}`

向您发出编译器警告。

### Visual Studio AssemblyInfo.cs 文件

默认情况下，Visual Studio 项目接收一个名为`AssemblyInfo.cs`的文件，可以通过展开解决方案资源管理器的属性图标来查看该文件(参见图 [15-6](#Fig6) )。

![A978-1-4842-1332-2_15_Fig6_HTML.jpg](img/A978-1-4842-1332-2_15_Fig6_HTML.jpg)

图 15-6。

The AssemblyInfo.cs file

这个文件是放置要在程序集级别应用的属性的方便位置。你可能还记得第 14 章，在考试的时候。NET 程序集，清单包含程序集级元数据，其中大部分来自表 [15-4](#Tab4) 中所示的程序集级属性。

表 15-4。

Select Assembly-Level Attributes

<colgroup><col> <col></colgroup> 
| 属性 | 生命的意义 |
| --- | --- |
| `[AssemblyCompany]` | 保存基本的公司信息 |
| `[AssemblyCopyright]` | 持有产品或组件的任何版权信息 |
| `[AssemblyCulture]` | 提供有关程序集支持哪些区域性或语言的信息 |
| `[AssemblyDescription]` | 保存对组成程序集的产品或模块的友好描述 |
| `[AssemblyKeyFile]` | 指定包含用于对程序集签名的密钥对的文件的名称(即建立强名称) |
| `[AssemblyProduct]` | 提供产品信息 |
| `[AssemblyTrademark]` | 提供商标信息 |
| `[AssemblyVersion]` | 指定程序集的版本信息，格式为`<major.minor.build.revision>` |

Source Code

AttributedCarLibrary 项目包含在 [`Chapter 15`](15.html) 子目录中。

## 使用早期绑定反映属性

请记住，在另一个软件反映出它的值之前，一个属性是毫无用处的。一旦发现了给定的属性，该软件就可以采取任何必要的行动。现在，像任何应用程序一样，这个“软件的另一部分”可以使用早期绑定或晚期绑定来发现自定义属性的存在。如果您想利用早期绑定，您将需要客户端应用程序有一个正在讨论的属性的编译时定义(在本例中为`VehicleDescriptionAttribute`)。鉴于`AttributedCarLibrary`程序集已经将这个自定义属性定义为一个公共类，早期绑定是最好的选择。

为了演示反射自定义属性的过程，创建一个名为 VehicleDescriptionAttributeReader 的新 C#控制台应用程序项目。接下来，添加对`AttributedCarLibrary`组件的引用。最后，用下面的代码更新初始的`*.cs`文件:

`// Reflecting on attributes using early binding.`

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`using AttributedCarLibrary;`

`namespace VehicleDescriptionAttributeReader`

`{`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Value of VehicleDescriptionAttribute *****\n");`

`ReflectOnAttributesUsingEarlyBinding();`

`Console.ReadLine();`

`}`

`private static void ReflectOnAttributesUsingEarlyBinding()`

`{`

`// Get a Type representing the Winnebago.`

`Type t = typeof(Winnebago);`

`// Get all attributes on the Winnebago.`

`object[] customAtts = t.GetCustomAttributes(false);`

`// Print the description.`

`foreach (VehicleDescriptionAttribute v in customAtts)`

`Console.WriteLine("-> {0}\n", v.Description);`

`}`

`}`

`}`

`Type.GetCustomAttributes()`方法返回一个对象数组，表示应用于由`Type`表示的成员的所有属性(布尔参数控制搜索是否应该沿着继承链向上扩展)。一旦获得了属性列表，迭代每个`VehicleDescriptionAttribute`类并打印出`Description`属性获得的值。

Source Code

VehicleDescriptionAttributeReader 项目包含在 [`Chapter 15`](15.html) 子目录中。

## 使用后期绑定反射属性

前面的例子使用早期绑定来打印出`Winnebago`类型的车辆描述数据。这是可能的，因为`VehicleDescriptionAttribute`类类型被定义为`AttributedCarLibrary`程序集中的公共成员。还可以利用动态加载和后期绑定来反映属性。

创建一个名为 VehicleDescriptionAttributeReaderLateBinding 的新项目，并将`AttributedCarLibrary.dll`复制到项目的`\bin\Debug`目录中。现在，更新你的`Program`类如下:

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`using System.Reflection;`

`namespace VehicleDescriptionAttributeReaderLateBinding`

`{`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Value of VehicleDescriptionAttribute *****\n");`

`ReflectAttributesUsingLateBinding();`

`Console.ReadLine();`

`}`

`private static void ReflectAttributesUsingLateBinding()`

`{`

`try`

`{`

`// Load the local copy of AttributedCarLibrary.`

`Assembly asm = Assembly.Load("AttributedCarLibrary");`

`// Get type info of VehicleDescriptionAttribute.`

`Type vehicleDesc =`

`asm.GetType("AttributedCarLibrary.VehicleDescriptionAttribute");`

`// Get type info of the Description property.`

`PropertyInfo propDesc = vehicleDesc.GetProperty("Description");`

`// Get all types in the assembly.`

`Type[] types = asm.GetTypes();`

`// Iterate over each type and obtain any VehicleDescriptionAttributes.`

`foreach (Type t in types)`

`{`

`object[] objs = t.GetCustomAttributes(vehicleDesc, false);`

`// Iterate over each VehicleDescriptionAttribute and print`

`// the description using late binding.`

`foreach (object o in objs)`

`{`

`Console.WriteLine("-> {0}: {1}\n",`

`t.Name, propDesc.GetValue(o, null));`

`}`

`}`

`}`

`catch (Exception ex)`

`{`

`Console.WriteLine(ex.Message);`

`}`

`}`

`}`

`}`

如果您能够按照本章中的示例进行操作，这段代码应该(或多或少)是不言自明的。唯一有趣的地方是使用了`PropertyInfo.GetValue()`方法，该方法用于触发属性的访问器。以下是当前示例的输出:

`***** Value of VehicleDescriptionAttribute *****`

`-> Motorcycle: My rocking Harley`

`-> HorseAndBuggy: The old gray mare, she ain’t what she used to be...`

`-> Winnebago: A very long, slow, but feature-rich auto`

Source Code

车辆描述属性读取绑定项目包含在 [`Chapter 15`](15.html) 子目录中。

## 正确看待反射、后期绑定和自定义属性

尽管您已经看到了这些技术的大量实例，但您可能仍然想知道何时在程序中使用反射、动态加载、后期绑定和自定义属性。可以肯定的是，这些主题可能看起来有点像编程的学术方面(这可能是也可能不是一件坏事，取决于你的观点)。为了帮助将这些主题映射到真实世界的情况，您需要一个可靠的示例。现在假设您在一个编程团队中，该团队正在构建一个具有以下需求的应用程序:

*   该产品必须可以通过使用额外的第三方工具进行扩展。

可扩展的确切含义是什么？好吧，考虑一下 Visual Studio IDE。当开发该应用程序时，各种“挂钩”被插入到代码库中，以允许其他软件供应商将定制模块“嵌入”(或插入)到 IDE 中。显然，Visual Studio 开发团队没有办法设置对外部。NET 程序集(因此，没有早期绑定)，那么应用程序将如何提供所需的钩子呢？这里有一个解决这个问题的可能方法:

First, an extendable application must provide some input mechanism to allow the user to specify the module to plug in (such as a dialog box or command-line flag). This requires dynamic loading.   Second, an extendable application must be able to determine whether the module supports the correct functionality (such as a set of required interfaces) to be plugged into the environment. This requires reflection.   Finally, an extendable application must obtain a reference to the required infrastructure (such as a set of interface types) and invoke the members to trigger the underlying functionality. This may require late binding.  

简单地说，如果可扩展的应用程序已经被预编程为查询特定的接口，它能够在运行时确定该类型是否可以被激活。一旦通过了验证测试，所讨论的类型就可以支持为其功能提供多态结构的附加接口。这正是 Visual Studio 团队所采用的方法，不管您怎么想，这一点也不难！

## 构建可扩展的应用程序

在接下来的几节中，我将带您看一个完整的示例，该示例说明了构建可扩展的 Windows 窗体应用程序的过程，该应用程序可以通过外部程序集的功能来扩充。如果您没有使用 Windows Forms API 构建 GUI 的经验，您可能希望加载所提供的解决方案代码，并按照说明进行操作。

Note

Windows 窗体是。NET 平台。然而，自从。在. NET 3.0 中，Windows 演示基础(WPF) API 已经成为一种经常被人们所青睐的 GUI 框架。虽然这是真的，但在本文中，我将使用 Windows 窗体作为一些客户端 GUI 示例，因为相关代码比相应的 WPF 代码更直观一些。

如果您不熟悉构建 Windows 窗体应用程序的过程，请随意打开提供的示例代码并跟着做。作为路线图，可扩展的应用程序需要以下组件:

*   `CommonSnappableTypes.dll`:此程序集包含将由每个管理单元对象使用的类型定义，并将由 Windows 窗体应用程序直接引用。
*   `CSharpSnapIn.dll`:用 C#写的一个管理单元，利用了`CommonSnappableTypes.dll`的类型。
*   `VbSnapIn.dll`:用 Visual Basic 编写的管理单元，利用了`CommonSnappableTypes.dll`的类型。
*   此 Windows 窗体应用程序将是可执行的应用程序，可通过每个管理单元的功能进行扩展。

同样，这个应用程序将使用动态加载、反射和后期绑定来动态获取它事先不知道的程序集的功能。

### 建设 CommonSnappableTypes.dll

首要任务是创建一个程序集，其中包含给定管理单元必须利用的类型，以便插入到可扩展的 Windows 窗体应用程序中。CommonSnappableTypes 类库项目定义了两种类型:

`namespace CommonSnappableTypes`

`{`

`public interface IAppFunctionality`

`{`

`void DoIt();`

`}`

`[AttributeUsage(AttributeTargets.Class)]`

`public sealed class CompanyInfoAttribute : System.Attribute`

`{`

`public string CompanyName { get; set; }`

`public string CompanyUrl { get; set; }`

`}`

`}`

`IAppFunctionality`接口为可扩展的 Windows 窗体应用程序可以使用的所有管理单元提供了一个多态接口。假设这个例子纯粹是说明性的，您提供一个名为`DoIt()`的方法。更真实的接口(或一组接口)可能允许对象生成脚本代码，将图像呈现到应用程序的工具箱上，或者集成到宿主应用程序的主菜单中。

`CompanyInfoAttribute`类型是一个定制属性，可以应用于任何想要嵌入容器的类类型。从这个类的定义可以看出，`[CompanyInfo]`允许管理单元的开发人员提供一些关于组件起点的基本细节。

### 构建 C#管理单元

接下来，您需要创建一个实现`IAppFunctionality`接口的类型。同样，为了关注可扩展应用程序的整体设计，一个简单的类型是合适的。假设一个名为 CSharpSnapIn 的新 C#类库项目定义了一个名为`CSharpModule`的类类型。鉴于该类必须利用 CommonSnappableTypes 中定义的类型，请确保添加对 CommonSnappableTypes 程序集的引用(以及`System.Windows.Forms.dll`以显示一条值得注意的消息)。话虽如此，代码如下:

`using System;`

`using System.Collections.Generic;`

`using System.Linq;`

`using System.Text;`

`using CommonSnappableTypes;`

`using System.Windows.Forms;`

`namespace CSharpSnapIn`

`{`

`[CompanyInfo(CompanyName = "FooBar",`

`CompanyUrl = "`[`www.FooBar.com`](http://www.foobar.com/)T2】

`public class CSharpModule : IAppFunctionality`

`{`

`void IAppFunctionality.DoIt()`

`{`

`MessageBox.Show("You have just used the C# snap-in!");`

`}`

`}`

`}`

注意，当支持`IAppFunctionality`接口时，我选择了使用显式接口实现(参见[第 9 章](09.html))。这不是必需的；然而，这个想法是，系统中唯一需要与这个接口类型直接交互的部分是宿主 Windows 应用程序。通过显式实现这个接口，`DoIt()`方法不会直接从`CSharpModule`类型中暴露出来。

### 构建 Visual Basic 管理单元

现在，为了模拟更喜欢 Visual Basic 而不是 C#的第三方供应商的角色，创建一个新的 Visual Basic 类库(VbSnapIn ),该类库引用与以前的 CSharpSnapIn 项目相同的外部程序集。

Note

默认情况下，Visual Basic 项目不会在解决方案资源管理器中显示 References 文件夹。若要在 VB 项目中添加引用，请使用 Visual Studio 的项目➤“添加引用”菜单选项。

代码(再次)故意简单。

`Imports System.Windows.Forms`

`Imports CommonSnappableTypes`

`<CompanyInfo(CompanyName:="Chucky’s Software", CompanyUrl:="`[`www.ChuckySoft.com`](http://www.chuckysoft.com/)T2】

`Public Class VbSnapIn`

`Implements IAppFunctionality`

`Public Sub DoIt() Implements CommonSnappableTypes.IAppFunctionality.DoIt`

`MessageBox.Show("You have just used the VB snap in!")`

`End Sub`

`End Class`

请注意，在 Visual Basic 的语法中应用属性需要尖括号(`< >`)，而不是方括号(`[ ]`)。还要注意，`Implements`关键字用于实现给定类或结构的接口类型。

### 构建可扩展的 Windows 窗体应用程序

最后一步是创建一个新的 C# Windows 窗体应用程序(MyExtendableApp ),它允许用户使用标准的 Windows 打开对话框选择一个管理单元。如果您以前没有创建过 Windows 窗体应用程序，您可能希望简单地打开本书源代码中提供的完整代码示例。但是，如果您确实想自己构建 GUI，请从 Visual Studio 的“新建项目”对话框中选择一个 Windows 窗体应用程序项目，开始本章的最后一个项目(参见图 [15-7](#Fig7) )。

![A978-1-4842-1332-2_15_Fig7_HTML.jpg](img/A978-1-4842-1332-2_15_Fig7_HTML.jpg)

图 15-7。

Creating a new Windows Forms project with Visual Studio Note

附录 A 提供了 Windows 窗体 API 的概述。

现在，添加一个对`CommonSnappableTypes.dll`汇编的引用，而不是对`CSharpSnapIn.dll`或`VbSnapIn.dll`代码库的引用。同样，将`System.Reflection`和`CommonSnappableTypes`名称空间导入到表单的主要代码文件中(可以通过右键单击表单设计器并选择 View Code 打开该文件)。请记住，该应用程序的整个目标是使用后期绑定和反射来确定由第三方供应商创建的独立二进制文件的“可捕捉性”。

同样，此时我不会费心检查 Windows 窗体开发的所有细节。然而，GUI 由一个放置在表单设计器上的`MenuStrip`组件组成；该组件定义了一个名为 File 的最顶层菜单项，该菜单项提供了一个名为 Snap In Module 的子菜单。同样，主窗口将包含一个`ListBox`类型(我将其重命名为`lstLoadedSnapIns`)，用于显示用户加载的每个管理单元的名称。图 [15-8](#Fig8) 显示了最终的图形用户界面。

![A978-1-4842-1332-2_15_Fig8_HTML.jpg](img/A978-1-4842-1332-2_15_Fig8_HTML.jpg)

图 15-8。

GUI for MyExtendableApp

处理“文件管理模块”菜单项(只需在设计时编辑器中双击菜单项即可创建)的`Click`事件的代码会显示一个文件打开对话框，并提取所选文件的路径。假设用户没有选择`CommonSnappableTypes.dll`程序集(因为这纯粹是基础设施)，然后路径被发送到一个名为`LoadExternalModule()`的助手函数中进行处理(接下来实现)。如果找不到实现`IAppFunctionality`的类，这个方法将返回`false`。

`private void snapInModuleToolStripMenuItem_Click(object sender,`

`EventArgs e)`

`{`

`// Allow user to select an assembly to load.`

`OpenFileDialog dlg = new OpenFileDialog();`

`if (dlg.ShowDialog() == DialogResult.OK)`

`{`

`if(dlg.FileName.Contains("CommonSnappableTypes"))`

`MessageBox.Show("CommonSnappableTypes has no snap-ins!");`

`else if(!LoadExternalModule(dlg.FileName))`

`MessageBox.Show("Nothing implements IAppFunctionality!");`

`}`

`}`

`LoadExternalModule()`方法执行以下任务:

*   将选定的程序集动态加载到内存中
*   确定程序集是否包含任何实现`IAppFunctionality`的类型
*   使用后期绑定创建类型

如果找到实现`IAppFunctionality`的类型，则调用`DoIt()`方法，并将该类型的完全限定名添加到`ListBox`(注意，`foreach`循环将迭代程序集中的所有类型，以考虑单个程序集有多个管理单元的可能性)。

`private bool LoadExternalModule(string path)`

`{`

`bool foundSnapIn = false;`

`Assembly theSnapInAsm = null;`

`try`

`{`

`// Dynamically load the selected assembly.`

`theSnapInAsm = Assembly.LoadFrom(path);`

`}`

`catch(Exception ex)`

`{`

`MessageBox.Show(ex.Message);`

`return foundSnapIn;`

`}`

`// Get all IAppFunctionality-compatible classes in assembly.`

`var theClassTypes = from t in theSnapInAsm.GetTypes()`

`where t.IsClass &&`

`(t.GetInterface("IAppFunctionality") != null)`

`select t;`

`// Now, create the object and call DoIt() method.`

`foreach (Type t in theClassTypes)`

`{`

`foundSnapIn = true;`

`// Use late binding to create the type.`

`IAppFunctionality itfApp =`

`(IAppFunctionality)theSnapInAsm.CreateInstance(t.FullName, true);`

`itfApp.DoIt();`

`lstLoadedSnapIns.Items.Add(t.FullName);`

`}`

`return foundSnapIn;`

`}`

此时，您可以运行您的应用程序了。当您选择`CSharpSnapIn.dll`或`VbSnapIn.dll`组件时，您应该看到显示的正确信息。最后一项任务是显示由`[CompanyInfo]`属性提供的元数据。为此，在退出`foreach`作用域之前，更新`LoadExternalModule()`以调用名为`DisplayCompanyData()`的新辅助函数。注意，这个方法只有一个参数`System.Type`。

`private bool LoadExternalModule(string path)`

`{`

`...`

`foreach (Type t in theClassTypes)`

`{`

`...`

`// Show company info.`

`DisplayCompanyData(t);`

`}`

`return foundSnapIn;`

`}`

使用传入类型，简单地反映在`[CompanyInfo]`属性上，就像这样:

`private void DisplayCompanyData(Type t)`

`{`

`// Get [CompanyInfo] data.`

`var compInfo = from ci in t.GetCustomAttributes(false) where`

`(ci.GetType() == typeof(CompanyInfoAttribute))`

`select ci;`

`// Show data.`

`foreach (CompanyInfoAttribute c in compInfo)`

`{`

`MessageBox.Show(c.CompanyUrl,`

`string.Format("More info about {0} can be found at", c.CompanyName));`

`}`

`}`

图 [15-9](#Fig9) 显示了一种可能的运行方式。

![A978-1-4842-1332-2_15_Fig9_HTML.jpg](img/A978-1-4842-1332-2_15_Fig9_HTML.jpg)

图 15-9。

Snapping in external assemblies

太棒了！这就结束了示例应用程序。我希望您可以看到，本章中介绍的主题在现实世界中可以相当有帮助，并且不限于世界的工具构建者。

Source Code

[`Chapter 15`](15.html) 子目录下的 ExtendableApp 文件夹包含 CommonSnappableTypes、CSharpSnapIn、VbSnapIn、MyExtendableApp 项目。

## 摘要

反射是健壮的 OO 环境的一个有趣的方面。在的世界里。NET 中，反射服务的关键围绕着`System.Type`类和`System.Reflection`名称空间。正如您所看到的，反射是在运行时将一个类型放在放大镜下以理解给定项目的谁、什么、哪里、何时、为什么以及如何的过程。

后期绑定是创建一个类型的实例并调用其成员的过程，而事先不知道这些成员的具体名称。后期绑定通常是动态加载的直接结果，动态加载允许您以编程方式将. NET 程序集加载到内存中。正如本章的可扩展应用程序示例所示，这是工具构建者和工具消费者使用的一种强大技术。

本章还研究了基于属性的编程的作用。当您用属性修饰您的类型时，结果是基础程序集元数据的增加。