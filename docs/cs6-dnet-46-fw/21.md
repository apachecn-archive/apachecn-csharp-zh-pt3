# 21.ADO.NET 第一部分:连接层

的。NET 平台定义了许多命名空间，允许您与关系数据库系统进行交互。总的来说，这些名称空间被称为 ADO.NET。在这一章中，您将了解 about 的整体作用以及核心类型和名称空间，然后您将继续讨论 about 数据提供者的主题。的。NET 平台支持许多数据提供程序(都是作为。NET 框架并可从第三方来源获得)，其中每一个都被优化以与特定的数据库管理系统(例如，Microsoft SQL Server、Oracle 和 MySQL)通信。

在理解了各种数据提供者提供的通用功能之后，您将会看到数据提供者工厂模式。正如您将看到的，使用`System.Data.Common`名称空间中的类型(和一个相关的`App.config`文件)，您可以构建一个单一的代码库，它可以动态地挑选底层数据提供者，而不需要重新编译或重新部署应用程序的代码库。

也许最重要的是，本章将让您有机会构建一个定制的数据访问库程序集(`AutoLotDAL.dll`)，它封装了在名为`AutoLot`的定制数据库上执行的各种数据库操作。最后，您将通过研究数据库事务这一主题来结束本文。

Note

你将在第 22 章中扩展这个库的功能，然后在第 23 章中使用实体框架(EF)从头开始创建它。为什么要创造两次？即使像 Entity Framework 这样的对象关系映射框架(ORM)使得创建数据访问代码变得更加简单(和快速), ORM 仍然使用 ADO.NET 作为核心数据访问技术。在对数据访问问题进行故障诊断时，对 ADO.NET 工作原理的透彻理解是至关重要的，尤其是当它是由框架创建而不是由您编写时。此外，您会遇到 EF 无法解决的场景(比如执行 SQL BulkCopy)，您需要了解 ADO.NET 来解决这些问题。

## ADO.NET 的高层次定义

如果您有 Microsoft 以前基于 COM 的数据访问模型(活动数据对象[ADO])的背景，并且刚刚开始使用。尽管这两个系统之间确实存在一些关系(例如，每个系统都有连接和命令对象的概念)，但是一些熟悉的 ADO 类型(例如，`Recordset`)已经不存在了。此外，您可以发现许多新的 ADO.NET 类型在传统的 ADO 下没有直接的对等物(例如，数据适配器)。

ADO.NET 在建造时就考虑到了这个不相连的世界。在 ORM 被广泛采用之前，这通常是通过使用`DataSet` s 来实现的。`DataSet` s 代表任意数量的相关数据表的本地副本，每个数据表都包含一个行和列的集合。使用一个`DataSet`，调用组件(比如一个 web 页面或桌面可执行文件)能够在与数据源断开连接时操作和更新一个`DataSet`的内容，并使用一个相关的数据适配器将任何修改的数据发送回去进行处理。

Note

ORM 不使用`DataSet` s，而是使用普通的 C#对象列表(也称为 POCOs)。这一章和下一章将详细介绍 ADO.NET 是如何工作的。这个基础很重要，即使你计划直接转向一个 ORM，比如实体框架。英孚，NHibernate，和另一个 ORMS。NET 世界是建立在 ADO.NET 之上的，所以如果你需要解决一个问题，你的代码似乎不能像你期望的那样工作，知道 ADO.NET 是如何工作的是一个很大的优势。接下来的章节使用了用 EF 开发的数据访问库。

从编程的角度来看，point 的大部分由一个名为`System.Data.dll`的核心组件代表。在这个二进制文件中，您会发现许多名称空间(见图 [21-1](#Fig1) )，其中许多表示特定 ADO.NET 数据提供者的类型(暂时定义)。

![A978-1-4842-1332-2_21_Fig1_HTML.jpg](A978-1-4842-1332-2_21_Fig1_HTML.jpg)

图 21-1。

System.Data.dll is the core ADO.NET assembly

事实证明，大多数 Visual Studio 项目模板都会自动引用这个关键的数据访问程序集。你也应该明白还有其他的 ADO。超过`System.Data.dll`的以. NET 为中心的程序集，您可能需要使用“添加引用”对话框在当前项目中手动引用这些程序集。

### ADO.NET 的三张脸

您可以以三种概念上独特的方式使用 ADO.NET 库:连接、断开或通过 ORM，如实体框架。当您使用连接层(本章的主题)时，您的代码库显式地连接到底层数据存储和从底层数据存储断开。以这种方式使用 ADO.NET 时，通常使用连接对象、命令对象和数据读取器对象与数据存储进行交互。

断开层(你将在第 22 章的[中了解到更多)允许你操作一组`DataTable`对象(包含在`DataSet`中)，作为外部数据的客户端副本。当您使用相关的数据适配器对象获得一个`DataSet`时，连接会自动代表您打开和关闭。正如您所猜测的，这种方法有助于快速释放其他调用者的连接，并且对提高系统的可伸缩性大有帮助。](22.html)

在调用者收到一个`DataSet`之后，它能够遍历和操作内容，而不会产生网络流量的成本。此外，如果调用者希望将更改提交回数据存储，则使用数据适配器(与一组 SQL 语句一起)来更新数据源；此时，重新打开连接以进行数据库更新，然后立即再次关闭。

最后，在[第 23 章](23.html)中，将向您介绍一个被称为实体框架(EF)的数据访问 API。使用 EF，您可以使用客户端对象与关系数据库进行交互，这些客户端对象封装了视图中的一些底层数据库细节。同样，EF 编程模型允许您使用强类型 LINQ 查询与关系数据库交互，使用 LINQ 语法到实体。

## 了解 ADO.NET 数据提供者

ADO.NET 不提供与多个数据库管理系统(DBMSs)通信的单一对象集。相反，ADO.NET 支持多个数据提供者，每个数据提供者都经过优化，可以与特定的 DBMS 交互。这种方法的第一个好处是，您可以对特定的数据提供程序进行编程，以访问特定 DBMS 的任何独特功能。第二个好处是，特定的数据提供者可以直接连接到所讨论的 DBMS 的底层引擎，而无需在各层之间设置中间映射层。

简单地说，数据提供者是在给定的名称空间中定义的一组类型，它们知道如何与特定类型的数据源进行通信。无论您使用哪种数据提供程序，都定义了一组提供核心功能的类类型。表 [21-1](#Tab1) 记录了一些核心的公共类型，它们的基类(都在`System.Data.Common`命名空间中定义)，以及它们实现的关键接口(每个都在`System.Data`命名空间中定义)。

表 21-1。

The Core Objects of an ADO.NET Data Provider

<colgroup><col> <col> <col> <col></colgroup> 
| 对象的类型 | 基础类 | 相关接口 | 生命的意义 |
| --- | --- | --- | --- |
| `Connection` | `DbConnection` | `IDbConnection` | 提供连接到数据存储和从数据存储断开连接的能力。连接对象还提供对相关事务对象的访问。 |
| `Command` | `DbCommand` | `IDbCommand` | 表示 SQL 查询或存储过程。命令对象还提供对提供程序的数据读取器对象的访问。 |
| `DataReader` | `DbDataReader` | `IDataReader`，`IDataRecord` | 使用服务器端游标提供对数据的只进、只读访问。 |
| `DataAdapter` | `DbDataAdapter` | `IDataAdapter`，`IDbDataAdapter` | 在调用者和数据存储器之间传输。数据适配器包含一个连接和一组四个内部命令对象，用于从数据存储中选择、插入、更新和删除信息。 |
| `Parameter` | `DbParameter` | `IDataParameter`，`IDbDataParameter` | 表示参数化查询中的命名参数。 |
| `Transaction` | `DbTransaction` | `IDbTransaction` | 封装数据库事务。 |

尽管这些核心类的具体名称在数据提供者之间会有所不同(例如，`SqlConnection`与`OdbcConnection`)，但是每个类都是从实现相同接口(例如，`IDbConnection`)的同一个基类(在连接对象的情况下是`DbConnection`)中派生出来的。考虑到这一点，您可以正确地假设，在您学会如何使用一个数据提供者之后，其余的提供者都很简单。

Note

当您引用 ADO.NET 下的一个连接对象时，您实际上是在引用一个特定的`DbConnection`派生类型；没有按字面意义命名的连接类。同样的想法也适用于命令对象、数据适配器对象等等。作为命名约定，特定数据提供者中的对象以相关 DBMS 的名称为前缀(例如，`SqlConnection`、`SqlConnection`和`SqlDataReader`)。

图 [21-2](#Fig2) 展示了 ADO.NET 数据提供商背后的大图景。请注意该图如何说明客户端程序集实际上可以是任何类型的。NET 应用:控制台程序、Windows 窗体应用、ASP.NET 网页、WPF 应用、WCF 服务、Web API 服务、。NET 代码库等等。

![A978-1-4842-1332-2_21_Fig2_HTML.gif](A978-1-4842-1332-2_21_Fig2_HTML.gif)

图 21-2。

ADO.NET data providers provide access to a given DBMS

除了图 [21-2](#Fig2) 所示的对象之外，数据提供者将为您提供其他类型；然而，这些核心对象定义了所有数据提供者的公共基线。

### 微软提供的 ADO.NET 数据提供者

微软的。NET 发行版附带了许多数据提供程序，包括一个用于 Oracle、SQL Server 和 OLE DB/ODBC 风格的连接的提供程序。表 [21-2](#Tab2) 记录了每个微软 ADO.NET 数据提供者的名称空间和包含程序集。

表 21-2。

Microsoft ADO.NET Data Providers

<colgroup><col> <col> <col></colgroup> 
| 数据提供者 | 命名空间 | 装配 |
| --- | --- | --- |
| 成为 DB | 系统。Data.OleDb | System.Data.dll |
| Microsoft SQL Server LocalDb | 系统。Data.SqlClient | System.Data.dll |
| 开放式数据库连接性 | 系统。Data.Odbc | System.Data.dll |

Note

虽然 Oracle provider 仍然附带了。NET 框架，建议使用 Oracle 提供的 Oracle Developer Tools for Visual Studio。事实上，如果您打开服务器资源管理器并选择新建连接，然后选择 Oracle 数据库，Visual Studio 会告诉您使用 Oracle 数据工具，并提供一个下载链接。

没有直接映射到 Jet 引擎(以及 Microsoft Access)的特定数据提供程序。如果要与 Access 数据文件进行交互，可以使用 OLE DB 或 ODBC 数据提供程序。

OLE DB 数据提供程序由在`System.Data.OleDb`命名空间中定义的类型组成，它允许您访问位于任何支持传统的基于 COM 的 OLE DB 协议的数据存储中的数据。只需调整连接字符串的`Provider`段，就可以使用这个提供程序与任何 OLE DB 兼容的数据库进行通信。

但是，OLE DB 访问接口在幕后与各种 COM 对象进行交互，这可能会影响应用程序的性能。总的来说，只有当您与未定义特定的 DBMS 进行交互时，OLE DB 数据提供程序才有用。NET 数据提供程序。然而，考虑到现在任何一个名副其实的 DBMS 都应该有一个定制的 ADO.NET 数据提供者供下载，您应该考虑将`System.Data.OleDb`作为一个在。NET 4.6 世界。(随着在中引入的数据提供者工厂模型的出现，情况更是如此。NET 2.0，您很快就会了解到。)

Note

在一种情况下，使用类型`System.Data.OleDb`是必要的:当您需要与 Microsoft SQL Server 或更早版本通信时。`System.Data.SqlClient`名称空间只能与 Microsoft SQL Server 或更高版本通信。

Microsoft SQL Server 数据提供程序提供对 Microsoft SQL Server 数据存储区的直接访问，并且仅提供对 SQL Server 数据存储区(7.0 版及更高版本)的直接访问。`System.Data.SqlClient`名称空间包含 SQL Server 提供程序使用的类型，并提供与 OLE DB 提供程序相同的基本功能。主要区别在于，SQL Server 提供程序绕过了 OLE DB 层，提供了许多性能优势。Microsoft SQL Server 数据提供程序还允许您访问这个特定 DBMS 的独特功能。

剩下的由微软提供的提供者(`System.Data.Odbc`)提供对 ODBC 连接的访问。在`System.Data.Odbc`名称空间中定义的 ODBC 类型通常只有在您需要与没有自定义的给定 DBMS 通信时才有用。NET 数据提供程序。这是真的，因为 ODBC 是一种广泛使用的模型，它提供了对许多数据存储的访问。

### 关于 System.Data.OracleClient.dll 的一句话

早期版本的。NET 平台附带了一个名为`System.Data.OracleClient.dll`的程序集，顾名思义，它提供了一个与 Oracle 数据库通信的数据提供者。截至。但是，在. NET 4.0 中，此程序集已被标记为过时，最终将被弃用。Oracle 客户端仍然包含在中。NET 4.6，但是不要期望它会永远包含在内，这是明智的。

乍一看，这可能会让你担心 ADO.NET 正慢慢地专注于以微软为中心的数据存储；然而，事实并非如此。Oracle 提供了自己的定制。NET 程序集，它遵循与 Microsoft 提供的数据提供程序相同的总体设计准则。如果你需要这个。NET 程序集，您可以访问以下网站:

[T2`http://www.oracle.com/technetwork/topics/dotnet/index-085163.html`](http://www.oracle.com/technetwork/topics/dotnet/index-085163.html)

### 获取第三方 ADO.NET 数据提供商

除了 Microsoft 提供的数据提供程序(以及 Oracle 的自定义。NET 库)，许多第三方数据提供者为各种开放源码和商业数据库而存在。虽然您最有可能直接从数据库供应商处获得 ADO.NET 数据提供程序，但是您应该注意以下网站:

[T2`https://msdn.microsoft.com/en-us/library/dd363565.aspx`](https://msdn.microsoft.com/en-us/library/dd363565.aspx)

该网站是记录每个已知 ADO.NET 数据提供商并提供更多信息和下载链接的众多网站之一。在这里，您会发现许多 ADO.NET 提供者，包括 SQLite、IBM DB2、MySQL、Postgres、Sybase 等等。

考虑到大量的 ADO.NET 数据提供程序，本书中的示例将使用 Microsoft SQL Server 数据提供程序(`System.Data.SqlClient.dll`)。回想一下，此提供程序允许您与 Microsoft SQL Server 版和更高版本进行通信，包括 SQL Server Express Edition 和 LocalDb。如果您打算使用 ADO.NET 与另一个 DBMS 进行交互，那么一旦您理解了后面几页中介绍的内容，您应该不会有任何问题。

## 其他 ADO.NET 命名空间

除了。NET 命名空间定义特定数据提供程序的类型。NET 基础类库提供了许多额外的 ADO。以. NET 为中心的名称空间，其中一些你可以在表 [21-3](#Tab3) 中看到(同样，[第 23 章](23.html)将讨论特定于实体框架的程序集和名称空间)。

表 21-3。

Select Additional ADO.NET-Centric Namespaces

<colgroup><col> <col></colgroup> 
| 命名空间 | 生命的意义 |
| --- | --- |
| `Microsoft.SqlServer.Server` | 此命名空间提供有助于 CLR 和 SQL Server 2005 及更高版本的 integration services 的类型。 |
| `System.Data` | 这个名称空间定义了所有数据提供者使用的核心 ADO.NET 类型，包括公共接口和许多代表断开层的类型(例如，`DataSet`和`DataTable`)。 |
| `System.Data.Common` | 此命名空间包含所有 ADO.NET 数据提供程序之间共享的类型，包括公共抽象基类。 |
| `System.Data.Sql` | 此命名空间包含允许您发现当前本地网络上安装的 Microsoft SQL Server 实例的类型。 |
| `System.Data.SqlTypes` | 此命名空间包含 Microsoft SQL Server 使用的本机数据类型。您总是可以使用相应的 CLR 数据类型，但是`SqlTypes`被优化为与 SQL Server 一起工作(例如，如果您的 SQL Server 数据库包含一个整数值，您可以使用`int`或`SqlTypes.SqlInt32`来表示它)。 |

注意，这一章没有检查每个 ADO.NET 命名空间中的每个类型(这个任务本身就需要一本大书)；然而，理解`System.Data`名称空间中的类型是非常重要的。

## 系统的类型。数据命名空间

在所有的 ADO.NET 名称空间中，`System.Data`是最小的公分母。如果不在数据访问应用程序中指定此命名空间，就无法构建 ADO.NET 应用程序。此命名空间包含所有 among 数据提供程序共享的类型，而不考虑基础数据存储。除了许多以数据库为中心的异常(例如，`NoNullAllowedException`、`RowNotInTableException`和`MissingPrimaryKeyException`)，`System.Data`包含表示各种数据库原语(例如，表、行、列和约束)的类型，以及由数据提供者对象实现的公共接口。表 [21-4](#Tab4) 列出了一些你应该知道的核心类型。

表 21-4。

Core Members of the System.Data Namespace

<colgroup><col> <col></colgroup> 
| 类型 | 生命的意义 |
| --- | --- |
| `Constraint` | 代表给定`DataColumn`对象的约束 |
| `DataColumn` | 表示一个`DataTable`对象中的一列 |
| `DataRelation` | 表示两个`DataTable`对象之间的父子关系 |
| `DataRow` | 代表一个`DataTable`对象中的一行 |
| `DataSet` | 表示由任意数量的相关`DataTable`对象组成的数据的内存缓存 |
| `DataTable` | 表示内存中数据的表格块 |
| `DataTableReader` | 允许您将`DataTable`视为消防水龙带光标(仅向前，只读数据访问) |
| `DataView` | 表示用于排序、过滤、搜索、编辑和导航的`DataTable`的定制视图 |
| `IDataAdapter` | 定义数据适配器对象的核心行为 |
| `IDataParameter` | 定义参数对象的核心行为 |
| `IDataReader` | 定义数据读取器对象的核心行为 |
| `IDbCommand` | 定义命令对象的核心行为 |
| `IDbDataAdapter` | 扩展`IDataAdapter`以提供数据适配器对象的附加功能 |
| `IDbTransaction` | 定义事务对象的核心行为 |

当针对 ADO.NET 的非连接层编程时，你使用了`System.Data`中的绝大多数类。在下一章中，您将了解`DataSet`及其相关群组(例如`DataTable`、`DataRelation`和`DataRow`)的细节，以及如何使用它们(和相关的数据适配器)来表示和操作远程数据的客户端副本。

但是，您的下一个任务是对`System.Data`的核心接口进行高层次的检查；这可以帮助您理解任何数据提供者提供的通用功能。您还将在本章中了解到具体的细节；然而，现在最好关注每种接口类型的整体行为。

### IDbConnection 接口的作用

`IDbConnection`类型由数据提供者的连接对象实现。此接口定义了一组用于配置到特定数据存储的连接的成员。它还允许您获取数据提供者的事务对象。下面是`IDbConnection`的正式定义:

`public interface IDbConnection : IDisposable`

`{`

`string ConnectionString { get; set; }`

`int ConnectionTimeout { get; }`

`string Database { get; }`

`ConnectionState State { get; }`

`IDbTransaction BeginTransaction();`

`IDbTransaction BeginTransaction(IsolationLevel il);`

`void ChangeDatabase(string databaseName);`

`void Close();`

`IDbCommand CreateCommand();`

`void Open();`

`}`

Note

像许多其他类型一样。NET 基础类库中，`Close()`方法在功能上等同于通过使用 scope 在 C#中直接或间接调用`Dispose()`方法(参见[第十三章](13.html))。

### IDbTransaction 接口的作用

由`IDbConnection`定义的重载的`BeginTransaction()`方法提供了对提供者的事务对象的访问。您可以使用由`IDbTransaction`定义的成员以编程方式与事务性会话和底层数据存储进行交互。

`public interface IDbTransaction : IDisposable`

`{`

`IDbConnection Connection { get; }`

`IsolationLevel IsolationLevel { get; }`

`void Commit();`

`void Rollback();`

`}`

### IDbCommand 接口的作用

接下来是`IDbCommand`接口，它将由数据提供者的命令对象实现。与其他数据访问对象模型一样，命令对象允许对 SQL 语句、存储过程和参数化查询进行编程操作。命令对象还通过重载的`ExecuteReader()`方法提供对数据提供者的数据读取器类型的访问。

`public interface IDbCommand : IDisposable`

`{`

`IDbConnection Connection { get; set; }`

`IDbTransaction Transaction { get; set; }`

`string CommandText { get; set; }`

`int CommandTimeout { get; set; }`

`CommandType CommandType { get; set; }`

`IDataParameterCollection Parameters { get; }`

`UpdateRowSource UpdatedRowSource { get; set; }`

`void Prepare();`

`void Cancel();`

`IDbDataParameter CreateParameter();`

`int ExecuteNonQuery();`

`IDataReader ExecuteReader();`

`IDataReader ExecuteReader(CommandBehavior behavior);`

`object ExecuteScalar();`

`}`

### IDbDataParameter 和 IDataParameter 接口的作用

注意，`IDbCommand`的`Parameters`属性返回一个实现了`IDataParameterCollection`的强类型集合。该接口提供对一组符合`IDbDataParameter`的类类型(例如，参数对象)的访问。

`public interface IDbDataParameter : IDataParameter`

`{`

`byte Precision { get; set; }`

`byte Scale { get; set; }`

`int Size { get; set; }`

`}`

`IDbDataParameter`扩展`IDataParameter`接口以获得以下附加行为:

`public interface IDataParameter`

`{`

`DbType DbType { get; set; }`

`ParameterDirection Direction { get; set; }`

`bool IsNullable { get; }`

`string ParameterName { get; set; }`

`string SourceColumn { get; set; }`

`DataRowVersion SourceVersion { get; set; }`

`object Value { get; set; }`

`}`

正如您将看到的，`IDbDataParameter`和`IDataParameter`接口的功能允许您通过特定的 ADO.NET 参数对象来表示 SQL 命令(包括存储过程)中的参数，而不是通过硬编码的字符串文字。

### IDbDataAdapter 和 IDataAdapter 接口的作用

您使用数据适配器将`DataSet`推入给定的数据存储或从给定的数据存储中拉出。`IDbDataAdapter`接口定义了以下一组属性，您可以使用这些属性来维护相关选择、插入、更新和删除操作的 SQL 语句:

`public interface IDbDataAdapter : IDataAdapter`

`{`

`IDbCommand SelectCommand { get; set; }`

`IDbCommand InsertCommand { get; set; }`

`IDbCommand UpdateCommand { get; set; }`

`IDbCommand DeleteCommand { get; set; }`

`}`

除了这四个属性之外，ADO.NET 数据适配器还会选择基本接口`IDataAdapter`中定义的行为。这个接口定义了数据适配器类型的关键功能:使用`Fill()`和`Update()`方法在调用者和底层数据存储之间传输`DataSet`的能力。`IDataAdapter`接口还允许您使用`TableMappings`属性将数据库列名映射到更加用户友好的显示名称。

`public interface IDataAdapter`

`{`

`MissingMappingAction MissingMappingAction { get; set; }`

`MissingSchemaAction MissingSchemaAction { get; set; }`

`ITableMappingCollection TableMappings { get; }`

`DataTable[] FillSchema(DataSet dataSet, SchemaType schemaType);`

`int Fill(DataSet dataSet);`

`IDataParameter[] GetFillParameters();`

`int Update(DataSet dataSet);`

`}`

### IDataReader 和 IDataRecord 接口的作用

下一个需要注意的关键接口是`IDataReader`，它表示给定数据读取器对象支持的常见行为。当您从 ADO.NET 数据提供者那里获得一个与`IDataReader`兼容的类型时，您可以以只进、只读的方式迭代结果集。

`public interface IDataReader : IDisposable, IDataRecord`

`{`

`int Depth { get; }`

`bool IsClosed { get; }`

`int RecordsAffected { get; }`

`void Close();`

`DataTable GetSchemaTable();`

`bool NextResult();`

`bool Read();`

`}`

最后，`IDataReader`扩展了`IDataRecord`，它定义了许多成员，允许您从流中提取强类型值，而不是强制转换从数据读取器的重载索引器方法中检索的通用`System.Object`。下面是`IDataRecord interface`的定义:

`public interface IDataRecord`

`{`

`int FieldCount { get; }`

`object this[ int i ] { get; }`

`object this[ string name ] { get; }`

`string GetName(int i);`

`string GetDataTypeName(int i);`

`Type GetFieldType(int i);`

`object GetValue(int i);`

`int GetValues(object[] values);`

`int GetOrdinal(string name);`

`bool GetBoolean(int i);`

`byte GetByte(int i);`

`long GetBytes(int i, long fieldOffset, byte[] buffer, int bufferoffset, int length);`

`char GetChar(int i);`

`long GetChars(int i, long fieldoffset, char[] buffer, int bufferoffset, int length);`

`Guid GetGuid(int i);`

`short GetInt16(int i);`

`int GetInt32(int i);`

`long GetInt64(int i);`

`float GetFloat(int i);`

`double GetDouble(int i);`

`string GetString(int i);`

`Decimal GetDecimal(int i);`

`DateTime GetDateTime(int i);`

`IDataReader GetData(int i);`

`bool IsDBNull(int i);`

`}`

Note

在从数据读取器获取值之前，您可以使用`IDataReader.IsDBNull()`方法以编程方式发现指定的字段是否设置为`null`(以避免触发运行时异常)。还记得 C#支持可空数据类型(参见第 4 章[，这是与数据库表中可能是`null`的数据列交互的理想选择。](04.html)

## 使用接口抽象数据提供者

至此，您应该对所有这些工具的共同功能有了更好的了解。NET 数据提供程序。回想一下，尽管实现类型的确切名称在不同的数据提供者之间会有所不同，但是您可以以类似的方式针对这些类型进行编程——这就是基于接口的多态性的美妙之处。例如，如果您定义一个采用`IDbConnection`参数的方法，您可以传入任何 ADO.NET 连接对象，如下所示:

`public static void OpenConnection(IDbConnection cn)`

`{`

`// Open the incoming connection for the caller.`

`connection.Open();`

`}`

Note

接口不是严格要求的；使用抽象基类(如`DbConnection`)作为参数或返回值，可以达到相同的抽象级别。

这同样适用于成员返回值。例如，考虑以下简单的 C#控制台应用程序项目(名为 MyConnectionFactory)，该项目允许您基于自定义枚举的值获取特定的连接对象。出于诊断目的，您只需使用反射服务打印底层连接对象，然后输入以下代码:

`using System;`

`using static System.Console;`

`// Need these to get definitions of common interfaces,`

`// and various connection objects for our test.`

`using System.Data;`

`using System.Data.SqlClient;`

`using System.Data.Odbc;`

`using System.Data.OleDb;`

`namespace MyConnectionFactory`

`{`

`// A list of possible providers.`

`enum DataProvider`

`{ SqlServer, OleDb, Odbc, None }`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`WriteLine("**** Very Simple Connection Factory *****\n");`

`// Get a specific connection.`

`IDbConnection myConnection = GetConnection(DataProvider.SqlServer);`

`WriteLine($"Your connection is a {myConnection.GetType().Name}");`

`// Open, use and close connection...`

`ReadLine();`

`}`

`// This method returns a specific connection object`

`// based on the value of a DataProvider enum.`

`static IDbConnection GetConnection(DataProvider dataProvider)`

`{`

`IDbConnection connection = null;`

`switch (dataProvider)`

`{`

`case DataProvider.SqlServer:`

`connection = new SqlConnection();`

`break;`

`case DataProvider.OleDb:`

`connection = new OleDbConnection();`

`break;`

`case DataProvider.Odbc:`

`connection = new OdbcConnection();`

`break;`

`}`

`return connection;`

`}`

`}`

`}`

Note

Visual Studio 2015 介绍`use static`。通过在你的其他`using`语句中添加`use static System.Console;`，你可以简单地写`WriteLine("some text")`而不是`Console.WriteLine("some text")`。对于本章和后续章节中的所有控制台项目，我将通过在文件顶部添加`using static System.Console;`来使用更短的版本。

使用`System.Data`的通用接口(或者，就此而言，`System.Data.Common`的抽象基类)的好处是，您有更好的机会构建一个灵活的代码库，可以随着时间的推移而发展。例如，今天您可能正在构建一个面向 Microsoft SQL Server 的应用程序；但是，几个月后，您的公司可能会切换到不同的数据库。如果您构建一个解决方案，对 Microsoft SQL Server 特定类型的`System.Data.SqlClient`进行硬编码，那么如果后端数据库管理系统发生变化，您显然需要编辑、重新编译和重新部署程序集。

### 使用应用程序配置文件增加灵活性

为了增加您的 ADO.NET 应用程序的灵活性，您可以合并一个客户端的`*.config`文件，该文件在`<appSettings>`元素中使用自定义的键值对。回想一下《T4》第 14 章中的内容，您可以通过使用`System.Configuration`名称空间中的类型以编程方式获取存储在`*.config`文件中的定制数据。例如，假设您已经在配置文件中指定了数据提供程序值，如下例所示:

`<configuration>`

`<appSettings>`

`<!--``This key value maps to one of our enum values.`T2】

`<add key="provider" value="SqlServer"/>`

`</appSettings>`

`<startup>`

`<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6"/>`

`</startup>`

`</configuration>`

这样，您可以更新`Main()`以编程方式获得底层数据提供者。这样做实质上构建了一个连接对象工厂，允许您更改提供者，但不需要您重新编译您的代码库(您只需更改`*.config`文件)。以下是`Main()`的相关更新:

`static void Main(string[] args)`

`{`

`WriteLine("**** Very Simple Connection Factory *****\n");`

`// Read the provider key.`

`string dataProviderString = ConfigurationManager.AppSettings["provider"];`

`// Transform string to enum.`

`DataProvider dataProvider = DataProvider.None;`

`if (Enum.IsDefined(typeof (DataProvider), dataProviderString))`

`{`

`dataProvider = (DataProvider) Enum.Parse(typeof (DataProvider), dataProviderString);`

`}`

`else`

`{`

`WriteLine("Sorry, no provider exists!");`

`ReadLine();`

`return;`

`}`

`// Get a specific connection.`

`IDbConnection myConnection = GetConnection(dataProvider);`

`WriteLine($"Your connection is a {myConnection?.GetType().Name ?? "unrecognized type"}");`

`// Open, use and close connection...`

`ReadLine();`

`}`

Note

要使用`ConfigurationManager`类型，一定要设置对`System.Configuration.dll`程序集的引用，并导入`System.Configuration`名称空间。

至此，您已经编写了一些允许您动态指定底层连接的 point 代码。然而，一个明显的问题是，这种抽象只在`MyConnectionFactory.exe`应用程序中使用。如果您要在. NET 代码库(例如，`MyConnectionFactory.dll`)内重新编写这个示例，您将能够构建任意数量的客户机，这些客户机可以使用抽象层获得各种连接对象。

然而，获得连接对象只是使用 ADO.NET 的一个方面。要创建一个有价值的数据提供者工厂库，您还必须考虑命令对象、数据读取器、数据适配器、事务对象和其他以数据为中心的类型。构建这样一个代码库并不困难，但是需要大量的代码和时间。

自从发布以来。在. NET 2.0 中，Redmond 的好心人已经将这种精确的功能直接构建到。NET 基础类库。一会儿您将检查这个正式的 API 但是，首先您需要创建一个自定义数据库，以便在本章(以及后面的许多章节)中使用。

Source Code

您可以在 [`Chapter 21`](21.html) 子目录中找到 MyConnectionFactory 项目。

## 创建汽车人数据库

在学习本章的过程中，您将对一个名为`AutoLot`的简单 SQL Server 测试数据库执行查询。为了与本书通篇使用的汽车主题保持一致，该数据库将包含三个相互关联的表(`Inventory`、`Orders`和`Customers`)，这些表包含代表一家虚构的汽车销售公司的订单信息的各种数据。

本书假设您有一份 Microsoft SQL Server (7.0 或更高版本)或一份 Microsoft SQL Server Express Edition。本书中的示例将使用 SQL Server 2014 Express。如果您没有这两种软件，请到这里下载一份:

[T2`http://www.microsoft.com/en-us/server-cloud/products/sql-server-editions/overview.aspx`](http://www.microsoft.com/en-us/server-cloud/products/sql-server-editions/overview.aspx)

这个轻量级数据库服务器非常适合您在本书中的需求:它是免费的，它提供了一个 GUI 前端(SQL Server 管理工具)来创建和管理您的数据库，并且它与 Visual Studio/Visual Community Edition 集成。为了说明最后一点，本节的剩余部分将引导您使用 Visual Studio 构建`AutoLot`数据库。

Note

在本书的其余部分，您将使用`AutoLot`数据库。

### 创建库存表

要开始构建测试数据库，请启动 Visual Studio，并使用 IDE 的“视图”菜单打开服务器资源管理器。接下来，右键单击数据连接节点并选择创建新的 SQL Server 数据库菜单选项(参见图 [21-3](#Fig3) )。

![A978-1-4842-1332-2_21_Fig3_HTML.jpg](A978-1-4842-1332-2_21_Fig3_HTML.jpg)

图 21-3。

Creating a new SQL Server database within Visual Studio

在出现的对话框中，您需要在“服务器名称”文本区域中输入一个值，该文本区域表示将在其中创建数据库的机器。服务器名由机器标识符和实例名组成。如果您已经在机器上安装了 Microsoft SQL Server(完整版或快速版),请输入`(local)`—包括括号——或一个句点后跟一个反斜杠和实例名(如果使用默认实例，则为空)。比如在我的机器上，我需要输入`.\SQLEXPRESS2014`。

将您的新数据库命名为`AutoLot` (Windows 身份验证应该没问题；见图 [21-4](#Fig4) 。

![A978-1-4842-1332-2_21_Fig4_HTML.jpg](A978-1-4842-1332-2_21_Fig4_HTML.jpg)

图 21-4。

Creating a new SQL Server Express database with Visual Studio

此时，`AutoLot`数据库没有任何数据库对象(例如，表、存储过程等等)。要插入一个新的数据库表，右击表节点并选择添加新表(见图 [21-5](#Fig5) )。

![A978-1-4842-1332-2_21_Fig5_HTML.jpg](A978-1-4842-1332-2_21_Fig5_HTML.jpg)

图 21-5。

Adding the Inventory table

使用表格编辑器添加四列(`CarId`、`Make`、`Color`和`PetName`)。将`CarId`设为`int`类型，其他属性设为`nvarchar(50)`类型。确保`CarId`列已被设置为主键(通过右键单击`CarId`行并选择设置主键来实现)并作为标识规范(在属性选项卡中通过将标识添加到 SQL 或通过将标识列添加到表设计器来更改，如图 [21-6](#Fig6) 所示)。另外，注意除了`CarId`之外的所有列都可以被赋值为空值。图 [21-6](#Fig6) 显示了最终的工作台设置。

![A978-1-4842-1332-2_21_Fig6_HTML.jpg](A978-1-4842-1332-2_21_Fig6_HTML.jpg)

图 21-6。

Designing the Inventory table

创建完表模式后，在 T-SQL 窗口中命名表`Inventory`，然后点击更新按钮保存您的工作(如图 [21-6](#Fig6) 所示)。在下一个屏幕上(图 [21-7](#Fig7) ，点击更新数据库提交动作。

![A978-1-4842-1332-2_21_Fig7_HTML.jpg](A978-1-4842-1332-2_21_Fig7_HTML.jpg)

图 21-7。

Committing the Inventory table to the database

### 将测试记录添加到库存表中

要向第一个表中添加记录，请右键单击库存表图标并选择显示表数据。注意:如果没有看到`Inventory`表，右键单击`Tables`文件夹，然后单击刷新。输入一些你选择的新车(为了有趣，一定要包括一些颜色和品牌相同的汽车)。记住`CarId`字段是一个标识列，所以数据库会为您创建一个惟一的值。图 [21-8](#Fig8) 显示了一个可能的库存清单。

![A978-1-4842-1332-2_21_Fig8_HTML.jpg](A978-1-4842-1332-2_21_Fig8_HTML.jpg)

图 21-8。

Populating the Inventory table

### 创作 GetPetName()存储过程

在本章的后面，你将学习如何使用 ADO.NET 来调用存储过程。您可能已经知道，存储过程是存储在特定数据库中的例程，经常对表数据进行操作以产生返回值。您将添加一个单独的存储过程，它将根据提供的`CarId`值返回汽车的昵称。为此，在服务器资源管理器中右键单击`AutoLot`数据库的存储过程节点，并选择 Add New Stored Procedure。在弹出的编辑器中输入以下内容:

`CREATE PROCEDURE GetPetName`

`@carID int,`

`@petName char(10) output`

`AS`

`SELECT @petName = PetName from Inventory where CarId = @carID`

Note

存储过程不必使用输出参数返回数据，如下所示；然而，这样做为讨论`SqlParameter`的`Direction`属性打下了基础，我将在本章的后面介绍。

当您单击 Update 保存您的过程时，它将根据您的`CREATE PROCEDURE`语句自动命名为`GetPetName`。这样做之后，您应该会在服务器资源管理器中看到您的新存储过程(参见图 [21-9](#Fig9) )。

![A978-1-4842-1332-2_21_Fig9_HTML.jpg](A978-1-4842-1332-2_21_Fig9_HTML.jpg)

图 21-9。

The GetPetName stored procedure

### 创建客户和订单表

`AutoLot`数据库将有两个额外的表:`Customers`和`Orders`。`Customers`表(顾名思义)将包含一个客户列表，由三列表示:`CustId`(应该设置为主键)、`FirstName`和`LastName`。您可以按照与创建`Inventory`表相同的步骤来创建`Customers`表；确保使用图 [21-10](#Fig10) 所示的模式创建`Customers`表。

![A978-1-4842-1332-2_21_Fig10_HTML.jpg](A978-1-4842-1332-2_21_Fig10_HTML.jpg)

图 21-10。

Designing the Customers table

保存并命名表格后，添加一些客户记录(参见图 [21-11](#Fig11) )。

![A978-1-4842-1332-2_21_Fig11_HTML.jpg](A978-1-4842-1332-2_21_Fig11_HTML.jpg)

图 21-11。

Populating the Customers table

您将使用您的最终表`Orders`来表示给定客户有兴趣购买的汽车。通过将`OrderId`值映射到`CarId` / `CustId`值来实现这一点。图 [21-12](#Fig12) 显示了你的最终表的结构(同样，注意`OrderId`是主键)。

![A978-1-4842-1332-2_21_Fig12_HTML.jpg](A978-1-4842-1332-2_21_Fig12_HTML.jpg)

图 21-12。

Designing the Orders table

现在将数据添加到您的`Orders`表中。您还没有创建任何表关系，因此您必须手动确保您输入的值存在于每个表中。为每个`CustId`值选择一个唯一的`CarId`(参见图 [21-13](#Fig13) 基于之前显示的样本数据的条目)。

![A978-1-4842-1332-2_21_Fig13_HTML.jpg](A978-1-4842-1332-2_21_Fig13_HTML.jpg)

图 21-13。

Populating the Orders table

例如，本文中使用的条目表明戴夫·布伦纳(`CustId = 1`)对黑色宝马(`CarId = 5`)感兴趣，而帕特·沃顿(`CustId = 4`)对粉红色宝马(`CarId = 7`)感兴趣。

### 在 Visual Studio 中创建表关系

最后一个任务是在`Customers`、`Orders`和`Inventory`表之间建立父子表关系。右键单击“订单”表，然后选择“打开表定义”。在列网格的右侧，右键单击外键并选择添加新外键，如图 [21-14](#Fig14) 所示。

![A978-1-4842-1332-2_21_Fig14_HTML.jpg](A978-1-4842-1332-2_21_Fig14_HTML.jpg)

图 21-14。

Creating a new foreign key

外键的默认名称是`FK_<CurrentTable>_ToTable`。这种情况下进入`FK_Orders_ToTable`。将 ToTable 替换为`Inventory`。在撰写本文时，外键的属性网格有一个问题，因此您必须手动更新 SQL。在 T-SQL 编辑器窗口中，更新以下行:

`CONSTRAINT [FK_Orders_Inventory] FOREIGN KEY ([Column]) REFERENCES [ToTable]([ToTableColumn])`

致以下内容:

`CONSTRAINT [FK_Orders_Inventory] FOREIGN KEY ([CarId]) REFERENCES [Inventory]([CarId]),`

将约束复制到 T-SQL 编辑器窗口中的新行，并更新它以匹配以下内容(确保库存约束后跟逗号):

`CONSTRAINT [FK_Orders_Customers] FOREIGN KEY ([CustId]) REFERENCES [dbo].[Customers] ([CustId]),`

该表的完整 SQL 应该如下所示(根据您使用的 SQL Server 版本，可能会有一些微小的差异):

`CREATE TABLE [dbo].[Orders] (`

`[OrderId] INT IDENTITY (1, 1) NOT NULL,`

`[CustId]  INT NOT NULL,`

`[CarId]   INT NOT NULL,`

`PRIMARY KEY CLUSTERED ([OrderId] ASC),`

`CONSTRAINT [FK_Orders_Inventory] FOREIGN KEY ([CarId])`

`REFERENCES [Inventory]([CarId]),`

`CONSTRAINT [FK_Orders_Customers] FOREIGN KEY ([CustId])`

`REFERENCES [Customers]([CustId]),`

`);`

在设计器中点击 Update，然后在下面的对话框中点击 Update，关系被添加到`AutoLot`数据库中。如果在更新数据库时遇到错误，这意味着您输入到 orders 表中的数据不正确。例如，您在订单中输入了 Customers 表中不存在的 CustId。请更正数据并再次更新数据库。

至此，`AutoLot`数据库完成！当然，这与真实世界的企业数据库相去甚远，但它将满足您在本书剩余部分的需求。既然您已经有了一个要测试的数据库，那么您可以深入研究 ADO.NET 数据提供者工厂模型的细节了。

## ADO.NET 数据提供者工厂模型

那个。NET 数据提供程序工厂模式允许您使用通用的数据访问类型构建一个单一的代码库。此外，使用应用程序配置文件(和`<connectionStrings>`子元素)，您可以以声明方式获得提供者和连接字符串，而无需重新编译或重新部署使用 ADO.NET API 的程序集。

为了理解数据提供者工厂实现，从表 [21-1](#Tab1) 中回忆一下，数据提供者中的每个类都是从`System.Data.Common`名称空间中定义的相同基类中派生出来的。

*   `DbCommand`:所有命令类的抽象基类
*   `DbConnection`:所有连接类的抽象基类
*   `DbDataAdapter`:所有数据适配器类的抽象基类
*   `DbDataReader`:所有数据读取器类的抽象基类
*   `DbParameter`:所有参数类的抽象基类
*   `DbTransaction`:所有交易类的抽象基类

每个微软提供的数据提供者都包含一个从`System.Data.Common.DbProviderFactory`派生的类类型。这个基类定义了几个检索特定于提供程序的数据对象的方法。以下是`DbProviderFactory`的成员:

`public abstract class DbProviderFactory`

`{`

`..public virtual bool CanCreateDataSourceEnumerator { get;};`

`public virtual DbCommand CreateCommand();`

`public virtual DbCommandBuilder CreateCommandBuilder();`

`public virtual DbConnection CreateConnection();`

`public virtual DbConnectionStringBuilder CreateConnectionStringBuilder();`

`public virtual DbDataAdapter CreateDataAdapter();`

`public virtual DbParameter CreateParameter();`

`public virtual CodeAccessPermission CreatePermission(PermissionState state);`

`public virtual DbDataSourceEnumerator CreateDataSourceEnumerator();`

`}`

为了获得数据提供者的`DbProviderFactory`派生类型，`System.Data.Common`名称空间提供了一个名为`DbProviderFactories`的类类型(注意这个类型名称中的复数形式)。可以使用静态的`GetFactory()`方法获取指定数据提供者的特定`DbProviderFactory`对象；通过指定一个表示。包含提供者功能的. NET 命名空间，如下所示:

`static void Main(string[] args)`

`{`

`// Get the factory for the SQL data provider.`

`DbProviderFactory sqlFactory =`

`DbProviderFactories.GetFactory("System.Data.SqlClient");`

`...`

`}`

当然，您可以从客户端的`*.config`文件中读取这些信息，而不是使用硬编码的字符串文字来获得工厂(很像前面的`MyConnectionFactory`示例)。您将很快学会如何做到这一点；目前，一旦获得了数据提供者的工厂，就可以获得相关的特定于提供者的数据对象(例如，连接、命令和数据读取器)。

Note

实际上，您可以将发送给`DbProviderFactories.GetFactory()`的参数视为数据提供者的名称。NET 命名空间。实际上，`machine.config`值使用这个字符串值从全局程序集缓存中动态加载正确的库。

### 完整的数据提供者工厂示例

作为一个完整的例子，您可以创建一个新的 C#控制台应用程序(名为 DataProviderFactory ),打印出`AutoLot`数据库的汽车库存。对于这个初始示例，您将直接在`DataProviderFactory.exe`程序集内硬编码数据访问逻辑(暂时保持简单)。然而，当您开始深入研究 ADO.NET 编程模型的细节时，您会将您的数据逻辑隔离到一个特定的。NET 代码库，您将在本书的剩余部分使用它。

首先添加对`System.Configuration.dll`程序集的引用，并导入`System.Configuration`名称空间。接下来，更新`App.config`文件以包含一个空的`<appSettings>`元素。添加一个名为`provider`的新键，它映射到您想要获得的数据提供者的名称空间名称(`System.Data.SqlClient`)。此外，定义一个连接字符串，该字符串表示到`AutoLot`数据库的连接(在 SQL Server Express 的本地实例上)。

`<?xml version="1.0" encoding="utf-8" ?>`

`<configuration>`

`<appSettings>`

`<!--``Which provider?`T2】

`<add key="provider" value="System.Data.SqlClient" />`

`<!--``Which connection string?`T2】

`<add key="connectionString" value= "Data Source=(local)\SQLEXPRESS2014;`

`Initial Catalog=AutoLot;Integrated Security=True"/>`

`</appSettings>`

`<startup>`

`<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6"/>`

`</startup>`

`</configuration>`

Note

您将很快更详细地了解连接字符串；但是，如果在服务器资源管理器中选择您的`AutoLot`数据库图标，您可以从 Visual Studio 属性窗口的连接字符串属性中复制并粘贴正确的连接字符串。

现在您已经有了一个合适的`*.config`文件，您可以使用`ConfigurationManager.AppSettings`索引器读入`provider`和`connectionString`值。`provider`值将被传递到`DbProviderFactories.GetFactory()`以获得数据提供者特定的工厂类型。您将使用`connectionString`值来设置`DbConnection`派生类型的`ConnectionString`属性。

假设您已经导入了`System.Data`、`System.Data.Common`和`static System .Console`名称空间，您可以像这样更新您的`Main()`方法:

`static void Main(string[] args)`

`{`

`WriteLine("***** Fun with Data Provider Factories *****\n");`

`// Get Connection string/provider from *.config.`

`string dataProvider =`

`ConfigurationManager.AppSettings["provider"];`

`string connectionString =`

`ConfigurationManager.AppSettings["connectionString"];`

`// Get the factory provider.`

`DbProviderFactory factory = DbProviderFactories.GetFactory(dataProvider);`

`// Now get the connection object.`

`using (DbConnection connection = factory.CreateConnection())`

`{`

`if (connection == null)`

`{`

`ShowError("Connection");`

`return;`

`}`

`WriteLine($"Your connection object is a: {connection.GetType().Name}");`

`connection.ConnectionString = connectionString;`

`connection.Open();`

`// Make command object.`

`DbCommand command = factory.CreateCommand();`

`if (command == null)`

`{`

`ShowError("Command");`

`return;`

`}`

`WriteLine($"Your command object is a: {command.GetType().Name}");`

`command.Connection = connection;`

`command.CommandText = "Select * From Inventory";`

`// Print out data with data reader.`

`using (DbDataReader dataReader = command.ExecuteReader())`

`{`

`WriteLine($"Your data reader object is a: {dataReader.GetType().Name}");`

`WriteLine("\n***** Current Inventory *****");`

`while (dataReader.Read())`

`WriteLine($"-> Car #{dataReader["CarId"]} is a {dataReader["Make"]}.");`

`}`

`}`

`ReadLine();`

`}`

`private static void ShowError(string objectName)`

`{`

`WriteLine($"There was an issue creating the {objectName}");`

`ReadLine();`

`}`

请注意，出于诊断目的，您使用反射服务来打印基础连接、命令和数据读取器的名称。如果您运行这个应用程序，您将在打印到控制台的`AutoLot`数据库的`Inventory`表中找到以下当前数据:

`***** Fun with Data Provider Factories *****`

`Your connection object is a: SqlConnection`

`Your command object is a: SqlCommand`

`Your data reader object is a: SqlDataReader`

`***** Current Inventory *****`

`-> Car #1 is a VW.`

`-> Car #2 is a Ford.`

`-> Car #3 is a Saab.`

`-> Car #4 is a Yugo.`

`-> Car #5 is a BMW.`

`-> Car #6 is a BMW.`

`-> Car #7 is a BMW.`

现在更改`*.config`文件，将`System.Data.OleDb`指定为数据提供者(并使用`Provider`段更新您的连接字符串，并将集成安全值从`true`更改为`SSPI`，如下所示:

`<configuration>`

`<appSettings>`

`<!-- Which provider? -->`

`<add key="provider" value="System.Data.OleDb" />`

`<!-- Which connection string? -->`

`<add key="cnStr" value=`

`"Provider=SQLOLEDB;Data Source=(local)\SQLEXPRESS2014;`

`Integrated Security=SSPI;Initial Catalog=AutoLot"/>`

`</appSettings>`

`<startup>`

`<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6"/>`

`</startup>`

`</configuration>`

这样做表明`System.Data.OleDb`类型在幕后使用，并给出以下输出:

`***** Fun with Data Provider Factories *****`

`Your connection object is a: OleDbConnection`

`Your command object is a: OleDbCommand`

`Your data reader object is a: OleDbDataReader`

`***** Current Inventory *****`

`-> Car #1 is a VW.`

`-> Car #2 is a Ford.`

`-> Car #3 is a Saab.`

`-> Car #4 is a Yugo.`

`-> Car #5 is a BMW.`

`-> Car #6 is a BMW.`

`-> Car #7 is a BMW.`

当然，根据您使用 ADO.NET 的经验，您可能有点不确定连接、命令和数据读取器对象实际上是做什么的。暂时不要纠结细节(毕竟这一章还有好几页呢！).至此，知道您可以使用 point 数据提供者工厂模型来构建一个可以以声明方式使用各种数据提供者的单一代码库就足够了。

### 数据提供者工厂模型的一个潜在缺点

尽管这是一个强大的模型，但是您必须确保代码库只使用通过抽象基类成员对所有提供程序通用的类型和方法。因此，在创作您的代码库时，您只能使用由`DbConnection`、`DbCommand`和其他类型的`System.Data.Common`名称空间公开的成员。

考虑到这一点，您可能会发现这种一般化的方法会阻止您直接访问特定 DBMS 的一些附加功能。如果您必须能够调用基础提供者的特定成员(例如，`SqlConnection`)，您可以使用显式强制转换来实现，如下例所示:

`using (DbConnection connection = factory.CreateConnection())`

`{`

`if (connection == null)`

`{`

`ShowError("Connection");`

`return;`

`}`

`WriteLine($"Your connection object is a: {connection.GetType().Name}");`

`connection.ConnectionString = connectionString;`

`connection.Open();`

`var sqlConnection = connection as SqlConnection;`

`if (sqlConnection != null)`

`{`

`// Print out which version of SQL Server is used.`

`WriteLine(sqlConnection.ServerVersion);`

`}`

`//Remainder removed for brevity`

`}`

然而，当这样做时，您的代码库变得有点难以维护(并且不太灵活)，因为您必须添加许多运行时检查。尽管如此，如果您需要以最灵活的方式构建数据访问库，数据提供者工厂模型为您提供了一个很好的机制。

### <connectionstrings>元素</connectionstrings>

目前，您的连接字符串数据在您的`*.config`文件的`<appSettings>`元素中。应用程序配置文件可以定义一个名为`<connectionStrings>`的元素。在这个元素中，您可以定义任意数量的名称-值对，这些名称-值对可以使用`ConfigurationManager.ConnectionStrings`索引器以编程方式读入内存。这种方法的一个优点(相对于使用`<appSettings>`元素和`ConfigurationManager.AppSettings`索引器)是您可以用一致的方式为一个应用程序定义多个连接字符串。

要看到这一点，请按如下方式更新当前的`App.config`文件(注意，每个连接字符串都是使用`name`和`connectionString`属性记录的，而不是使用`<appSettings>`中的`key`和`value`属性记录的):

`<configuration>`

`<appSettings>`

`<!-- Which provider? -->`

`<add key="provider" value="System.Data.SqlClient" />`

`</appSettings>`

`<!--``Here are the connection strings.`T2】

`<connectionStrings>`

`<add name ="AutoLotSqlProvider" connectionString =`

`"Data Source=(local)\SQLEXPRESS2014;`

`Integrated Security=SSPI;Initial Catalog=AutoLot"/>`

`<add name ="AutoLotOleDbProvider" connectionString =`

`"Provider=SQLOLEDB;Data Source=(local)\SQLEXPRESS2014;`

`Integrated Security=SSPI;Initial Catalog=AutoLot"/>`

`</connectionStrings>`

`<startup>`

`<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6"/>`

`</startup>`

`</configuration>`

您现在可以更新您的`Main()`方法，如下所示:

`static void Main(string[] args)`

`{`

`WriteLine("***** Fun with Data Provider Factories *****\n");`

`string dataProvider =`

`ConfigurationManager.AppSettings["provider"];`

`string connectionString =`

`ConfigurationManager.ConnectionStrings["AutoLotSqlProvider"].ConnectionString;`

`...`

`}`

此时，您有了一个应用程序，它可以使用中性代码库显示数据库`AutoLot`的`Inventory`表的结果。将提供者名称和连接字符串卸载到外部`*.config`文件意味着数据提供者工厂模型可以在后台动态加载正确的提供者。有了第一个示例，您现在可以深入了解使用 ADO.NET 的关联图层的细节。

Note

现在您已经理解了 ADO.NET 数据提供者工厂的角色，本书中剩下的例子将通过显式使用`System.Data.SqlClient`名称空间中的类型来关注手头的任务。如果您使用不同的数据库管理系统(如 Oracle)，您需要相应地更新您的代码库。

Source Code

您可以在 [`Chapter 21`](21.html) 子目录中找到 DataProviderFactory 项目。

## 了解 ADO.NET 的连接层

回想一下，ADO.NET 的连接图层允许您使用数据提供者的连接、命令和数据读取器对象与数据库进行交互。您已经在前面的 DataProviderFactory 应用程序中使用了这些对象，现在您将再次浏览这个过程，这次使用一个扩展的示例。当您想要连接到数据库并使用数据读取器对象读取记录时，需要执行以下步骤:

Allocate, configure, and open your connection object.   Allocate and configure a command object, specifying the connection object as a constructor argument or with the `Connection` property.   Call `ExecuteReader()` on the configured command class.   Process each record using the `Read()` method of the data reader.  

首先，创建一个名为 namedAutoLotDataReader 的新控制台应用程序项目，并导入`System.Data`和`System.Data.SqlClient`名称空间。下面是`Main()`内的完整代码(分析随后):

`class Program`

`{`

`static void Main(string[] args)`

`{`

`WriteLine("***** Fun with Data Readers *****\n");`

`// Create and open a connection.`

`using (SqlConnection connection = new SqlConnection())`

`{`

`connection.ConnectionString =`

`@"Data Source=(local)\SQLEXPRESS2014;Integrated Security=SSPI;" +`

`"Initial Catalog=AutoLot";`

`connection.Open();`

`// Create a SQL command object.`

`string sql = "Select * From Inventory";`

`SqlCommand myCommand = new SqlCommand(sql, connection);`

`// Obtain a data reader a la ExecuteReader().`

`using (SqlDataReader myDataReader = myCommand.ExecuteReader())`

`{`

`// Loop over the results.`

`while (myDataReader.Read())`

`{`

`WriteLine($"-> Make: {myDataReader["Make"]}, PetName: {myDataReader["PetName"]}, Color: {myDataReader["Color"]}.");`

`}`

`}`

`}`

`ReadLine();`

`}`

`}`

### 使用连接对象

使用数据提供者的第一步是使用 connection 对象(您记得，它是从`DbConnection`派生的)与数据源建立会话。。NET 连接对象提供有格式化的连接字符串；该字符串包含许多名称-值对，用分号分隔。您可以使用这些信息来标识要连接的计算机的名称、所需的安全设置、该计算机上的数据库名称以及其他特定于数据提供程序的信息。

正如您可以从前面的代码中推断的那样，`Initial Catalog`名称指的是您想要与之建立会话的数据库。`Data Source`名称标识维护数据库的机器的名称。在这里，`(local)`允许您定义单个令牌来指定当前的本地机器(不管所述机器的字面名称)，而`\SQLEXPRESS2014`令牌通知 SQL Server 提供者您正在连接到带有 SQLEXPRESS2014 命名实例的 SQL Server Express edition。如果您在设置为本地计算机默认实例的 Microsoft SQL Server 上创建了`AutoLot`，请指定`Data Source=(local)`。

Note

还有另一种机制使用`(LocalDb)`作为服务器名。这将存储包含项目/解决方案的数据库。您仍然可以通过使用`(LocalDb)\MSSQLLocalDB`作为服务器名(或`(LocalDb)\v11.0`，这取决于您使用 Visual Studio 的 starter 模板的版本)来通过服务器资源管理器访问数据库。

除此之外，您可以提供任意数量的表示安全凭证的令牌。这里，您将`Integrated Security`设置为`SSPI`(相当于 SQL Server 连接字符串的`true`)，它使用当前的 Windows 帐户凭证进行用户身份验证。

Note

在中查找数据提供者的连接对象的`ConnectionString`属性。NET Framework 4.6 SDK 文档，了解有关特定 DBMS 的每个名称-值对的更多信息。

建立连接字符串后，可以调用`Open()`来建立与 DBMS 的连接。除了`ConnectionString`、`Open()`和`Close()`成员之外，连接对象还提供了许多成员，允许您配置关于连接的附加设置，比如超时设置和事务信息。表 [21-5](#Tab5) 列出了`DbConnection`基类的一些(但不是全部)成员。

表 21-5。

Members of the DbConnection Type

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `BeginTransaction()` | 您使用此方法开始数据库事务。 |
| `ChangeDatabase()` | 您可以使用此方法在打开的连接上更改数据库。 |
| `ConnectionTimeout` | 此只读属性返回建立连接时，在终止连接并生成错误之前等待的时间(默认值为 15 秒)。如果您想更改默认值，请在连接字符串中指定一个`Connect Timeout`段(例如`Connect Timeout=30`)。 |
| `Database` | 此只读属性获取由 connection 对象维护的数据库的名称。 |
| `DataSource` | 此只读属性获取由 connection 对象维护的数据库的位置。 |
| `GetSchema()` | 该方法返回一个包含来自数据源的模式信息的`DataTable`对象。 |
| `State` | 这个只读属性获取连接的当前状态，由`ConnectionState`枚举表示。 |

`DbConnection`类型的属性本质上通常是只读的，只有当您想要在运行时获得连接的特征时才有用。当您需要覆盖默认设置时，您必须改变构造字符串本身。例如，以下连接字符串将`connection timeout`设置从 15 秒到 30 秒:

`static void Main(string[] args)`

`{`

`WriteLine("***** Fun with Data Readers *****\n");`

`using(SqlConnection connection = new SqlConnection())`

`{`

`connection.ConnectionString =`

`@"Data Source=(local)\SQLEXPRESS2014;" +`

`"Integrated Security=SSPI;Initial Catalog=AutoLot;Connect Timeout=30";`

`connection.Open();`

`// New helper function (see below).`

`ShowConnectionStatus(connection);`

`...`

`}`

在前面的代码中，您将连接对象作为参数传递给名为`ShowConnectionStatus()`的`Program`类中的一个新的静态帮助器方法，实现如下:

`static void ShowConnectionStatus(SqlConnection connection)`

`{`

`// Show various stats about current connection object.`

`WriteLine("***** Info about your connection *****");`

`WriteLine($"Database location: {connection.DataSource}");`

`WriteLine($"Database name: {connection.Database}");`

`WriteLine($"Timeout: {connection.ConnectionTimeout}");`

`WriteLine($"Connection state: {connection.State}\n");`

`}`

虽然这些属性中的大多数都是不言自明的，但是`State`属性值得特别一提。您可以将`ConnectionState`枚举的任何值赋给该属性，如下所示:

`public enum ConnectionState`

`{`

`Broken, Closed,`

`Connecting, Executing,`

`Fetching, Open`

`}`

然而，唯一有效的`ConnectionState`值是`ConnectionState.Open, ConnectionState.Connecting`和`ConnectionState.Closed`(该枚举的其余成员保留供将来使用)。此外，关闭当前连接状态为`ConnectionState.Closed`的连接总是安全的。

### 使用 ConnectionStringBuilder 对象

以编程方式处理连接字符串可能很麻烦，因为它们通常被表示为字符串文字，这很难维护，而且很容易出错。Microsoft 提供的 ADO.NET 数据提供程序支持连接字符串生成器对象，这允许您使用强类型属性建立名称-值对。考虑以下对当前`Main()`方法的更新:

`static void Main(string[] args)`

`{`

`WriteLine("***** Fun with Data Readers *****\n");`

`// Create a connection string via the builder object.`

`var cnStringBuilder = new SqlConnectionStringBuilder`

`{`

`InitialCatalog = "AutoLot",`

`DataSource = @"(local)\SQLEXPRESS2014",`

`ConnectTimeout = 30,`

`IntegratedSecurity = true`

`};`

`using(SqlConnection connection = new SqlConnection())`

`{`

`connection.ConnectionString = cnStringBuilder.ConnectionString;`

`connection.Open();`

`ShowConnectionStatus(connection);`

`...`

`}`

`ReadLine();`

`}`

在这个迭代中，您创建一个`SqlConnectionStringBuilder`的实例，相应地设置属性，并使用`ConnectionString`属性获得内部字符串。另请注意，您使用了该类型的默认构造函数。如果您愿意，您还可以通过传入一个现有的连接字符串作为起点来创建您的数据提供者的连接字符串生成器对象的实例(当您从一个`App.config`文件中动态读取这些值时，这会很有帮助)。使用初始字符串数据对对象进行合并后，可以使用相关属性更改特定的名称-值对，如下例所示:

`static void Main(string[] args)`

`{`

`WriteLine("***** Fun with Data Readers *****\n");`

`// Assume you really obtained the``connectionString`T2】

`string connectionString = @"Data Source=(local)\SQLEXPRESS;" +`

`"Integrated Security=SSPI;Initial Catalog=AutoLot";`

`SqlConnectionStringBuilder cnStringBuilder =`

`new SqlConnectionStringBuilder(connectionString);`

`// Change timeout value.`

`cnStringBuilder.ConnectTimeout = 5;`

`...`

`}`

### 使用命令对象

既然您已经更好地理解了 connection 对象的角色，下一步工作就是检查如何向相关数据库提交 SQL 查询。`SqlCommand`类型(从`DbCommand`派生而来)是 SQL 查询、表名或存储过程的面向对象表示。使用`CommandType`属性指定命令的类型，该属性可以从`CommandType`枚举中获取任何值，如下所示:

`public enum CommandType`

`{`

`StoredProcedure,`

`TableDirect,`

`Text // Default value.`

`}`

当您创建一个命令对象时，您可以将 SQL 查询建立为一个构造函数参数，或者直接使用`CommandText`属性。同样，当您创建一个命令对象时，您需要指定您想要使用的连接。同样，您可以通过构造函数参数或使用`Connection`属性来实现。考虑以下代码片段:

`// Create command object via ctor args.`

`string sql = "Select * From Inventory";`

`SqlCommand myCommand = new SqlCommand(sql, connection);`

`// Create another command object via properties.`

`SqlCommand testCommand = new SqlCommand();`

`testCommand.Connection = connection;`

`testCommand.CommandText = sql;`

要知道，在这一点上，您并没有真正地将 SQL 查询提交给`AutoLot`数据库，而是准备了命令对象的状态以备将来使用。表 [21-6](#Tab6) 突出显示了`DbCommand`类型的一些附加成员。

表 21-6。

Members of the DbCommand Type

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `CommandTimeout` | 获取或设置在终止尝试并生成错误之前执行命令时等待的时间。默认值为 30 秒。 |
| `Connection` | 获取或设置此`DbCommand`实例使用的`DbConnection`。 |
| `Parameters` | 获取用于参数化查询的`DbParameter`对象的集合。 |
| `Cancel()` | 取消命令的执行。 |
| `ExecuteReader()` | 执行 SQL 查询并返回数据提供者的`DbDataReader`对象，该对象提供对查询结果的只进、只读访问。 |
| `ExecuteNonQuery()` | 执行 SQL 非查询(例如，插入、更新、删除或创建表)。 |
| `ExecuteScalar()` | 一个轻量级版本的`ExecuteReader()`方法，它是专门为单独查询设计的(例如，获取记录计数)。 |
| `Prepare()` | 在数据源上创建命令的准备(或编译)版本。正如您可能知道的，准备好的查询执行起来稍微快一些，当您需要多次执行相同的查询(通常每次使用不同的参数)时，准备好的查询非常有用。 |

## 使用数据读取器

建立活动连接和 SQL 命令后，下一步是向数据源提交查询。正如您可能猜到的，您有许多方法可以做到这一点。`DbDataReader`类型(实现了`IDataReader`)是从数据存储中获取信息的最简单快捷的方式。回想一下，数据读取器表示只读、只进的数据流，一次返回一条记录。鉴于此，数据读取器只有在向基础数据存储提交 SQL 选择语句时才有用。

当您需要快速迭代大量数据并且不需要维护内存中的表示时，数据读取器非常有用。例如，如果您请求将一个表中的 20，000 条记录存储在一个文本文件中，那么将这些信息保存在一个`DataSet`中会占用大量内存(因为一个`DataSet`同时将整个查询结果保存在内存中)。

一个更好的方法是创建一个数据读取器，尽可能快地旋转每条记录。但是，请注意，数据读取器对象(与数据适配器对象不同，您将在后面研究数据适配器对象)会保持与其数据源的打开连接，直到您显式关闭该连接。

您通过调用`ExecuteReader()`从命令对象获得数据读取器对象。数据读取器表示它从数据库中读取的当前记录。数据读取器有一个索引器方法(例如，C#中的`[]`语法),允许您访问当前记录中的一列。您可以通过名称或从零开始的整数来访问该列。

数据读取器的以下使用利用了`Read()`方法来确定何时到达记录的末尾(使用一个`false`返回值)。对于从数据库中读取的每个传入记录，使用类型索引器打印出每辆汽车的品牌、昵称和颜色。还要注意，一旦处理完记录，就调用`Close()`，这释放了连接对象。

`static void Main(string[] args)`

`{`

`...`

`// Obtain a data reader via ExecuteReader().`

`using(SqlDataReader myDataReader = myCommand.ExecuteReader())`

`{`

`// Loop over the results.`

`while (myDataReader.Read())`

`{`

`WriteLine($"-> Make: { myDataReader["Make"]}, PetName: { myDataReader["PetName"]}, Color: { myDataReader["Color"]}.");`

`}`

`}`

`ReadLine();`

`}`

在前面的代码片段中，您重载了数据读取器对象的索引器，以接受一个`string`(表示列的名称)或一个`int`(表示列的序号位置)。因此，您可以用下面的更新清理当前的阅读器逻辑(并避免硬编码的字符串名称)(注意`FieldCount`属性的使用):

`while (myDataReader.Read())`

`{`

`WriteLine("***** Record *****");`

`for (int i = 0; i < myDataReader.FieldCount; i++)`

`{`

`WriteLine($"{myDataReader.GetName(i)} = { myDataReader.GetValue(i)} ");`

`}`

`WriteLine();`

`}`

如果您在此时编译并运行您的项目，您应该会在`AutoLot`数据库的`Inventory`表中看到所有汽车的列表。以下输出显示了我自己版本的`AutoLot`的最初几条记录:

`***** Fun with Data Readers *****`

`***** Info about your connection *****`

`Database location: (local)\SQLEXPRESS2014`

`Database name: AutoLot`

`Timeout: 30`

`Connection state: Open`

`***** Record *****`

`CarId = 1`

`Make = VW`

`Color = Black`

`PetName = Zippy`

`***** Record *****`

`CarId = 2`

`Make = Ford`

`Color = Rust`

`PetName = Rusty`

### 使用数据读取器获取多个结果集

数据读取器对象可以使用单个命令对象获得多个结果集。例如，如果您想获得来自`Inventory`表的所有行，以及来自`Customers`表的所有行，您可以使用分号分隔符指定这两个 SQL `Select`语句，如下所示:

`string sql = "Select * From Inventory;Select * from Customers";`

获得数据读取器后，可以使用`NextResult()`方法迭代每个结果集。请注意，您总是自动返回第一个结果集。因此，如果您想要读取每个表的行，您可以构建以下迭代结构:

`do`

`{`

`while (myDataReader.Read())`

`{`

`WriteLine("***** Record *****");`

`for (int i = 0; i < myDataReader.FieldCount; i++)`

`{`

`WriteLine($"{myDataReader.GetName(i)} = {myDataReader.GetValue(i)}");`

`}`

`WriteLine();`

`}`

`} while (myDataReader.NextResult());`

此时，您应该更清楚数据读取器对象为表带来的功能。永远记住，数据读取器只能处理 SQL `Select`语句；您不能使用它们通过`Insert`、`Update`或`Delete`请求来修改现有的数据库表。修改现有数据库需要对命令对象进行额外的调查。

Source Code

您可以在 [`Chapter 21`](21.html) 子目录中找到 AutoLotDataReader 项目。

## 构建可重用的数据访问库

`ExecuteReader()`方法提取数据读取器对象，该对象允许您使用只进、只读信息流来检查 SQL `Select`语句的结果。但是，当您想要提交导致给定表修改的 SQL 语句(或任何其他非查询 SQL 语句，如创建表或授予权限)时，您可以调用命令对象的`ExecuteNonQuery()`方法。这个方法根据命令文本的格式执行插入、更新和删除操作。

Note

从技术上讲，非查询是不返回结果集的 SQL 语句。因此，`Select`语句是查询，而`Insert`、`Update`和`Delete`语句不是查询。鉴于此，`ExecuteNonQuery()`返回一个代表受影响的行数的`int`，而不是一组新的记录。

接下来，您将学习如何只通过调用`ExecuteNonQuery()`来修改现有的数据库；您的下一个目标是构建一个定制的数据访问库，它可以封装对`AutoLot`数据库的操作过程。在生产级环境中，您的 ADO.NET 逻辑几乎总是被隔离到. NET `*.dll`汇编中，原因很简单:代码重用！本章的第一个例子没有做到这一点，只是为了让你可以专注于手头的任务；然而，为每个需要与`AutoLot`数据库交互的应用程序编写相同的连接逻辑、相同的数据读取逻辑和相同的命令逻辑是浪费时间。

将数据访问逻辑隔离到. NET 代码库意味着使用任何种类的前端(例如，基于控制台、基于桌面或基于 web)的多个应用程序可以以独立于语言的方式引用手边的库。因此，如果您使用 C#创作您的数据库，其他开发人员可以在。他们选择的网络语言。

在本章中，您的数据库(`AutoLotDAL.dll`)将包含一个单独的名称空间(`AutoLotConnectedLayer`)，它使用 ADO.NET 的连接类型与`AutoLot`进行交互。在下一章中，您将添加一个新的名称空间(`AutoLotDisconnectionLayer`)到这个相同的`*.dll`中，它包含使用断开层与`AutoLot`通信的类型。在第 23 章中，你将使用实体框架创建一个完整的数据访问层。在本书的剩余部分，多个应用程序将利用这个库。

首先创建一个名为 AutoLotDAL(AutoLot 数据访问层的缩写)的新 C#类库项目，并删除默认的类文件。使用项目➤新文件夹菜单选项添加一个新文件夹(确保您在解决方案资源管理器中选择了该项目)，并将该文件夹命名为`ConnectedLayer`。在这个新文件夹中，添加一个名为`InventoryDAL.cs`的新类，并将该类更改为`public`。这个类将定义各种成员来与`AutoLot`数据库的`Inventory`表交互。最后，导入以下内容。NET 命名空间:

`using System;`

`// You will use the SQL server`

`// provider; however, it would also be`

`// permissible to use the ADO.NET`

`// factory pattern for greater flexibility.`

`using System.Data;`

`using System.Data.SqlClient;`

`using System.Collections.Generic;`

`namespace AutoLotDAL.ConnectedLayer`

`{`

`public class InventoryDAL`

`{`

`}`

`}`

Note

你可能还记得《T2》第 13 章中的内容，当对象使用管理原始资源的类型(例如，一个数据库连接)时，实现`IDisposable`并创建一个合适的终结器是一个好的实践。在生产环境中，像`InventoryDAL`这样的类也会这样做；然而，你不会在这里这样做，所以你可以继续关注 ADO.NET 的细节。

### 添加连接逻辑

您必须注意的第一项任务是定义一些方法，允许调用者使用有效的连接字符串连接到数据源和从数据源断开连接。您将硬编码您的`AutoLotDAL.dll`程序集以使用`System.Data.SqlClient`的类型，因此您需要定义一个私有成员变量`SqlConnection`，它是在创建`InventoryDAL`对象时分配的。同样，定义一个名为`OpenConnection()`的方法和另一个名为`CloseConnection()`的方法来与这个成员变量交互。

`public class InventoryDAL`

`{`

`// This member will be used by all methods.`

`private SqlConnection _sqlConnection = null;`

`public void OpenConnection(string connectionString)`

`{`

`_sqlConnection = new SqlConnection {ConnectionString = connectionString};`

`_sqlConnection.Open();`

`}`

`public void CloseConnection()`

`{`

`_sqlConnection.Close();`

`}`

`}`

为了简洁起见，您的`InventoryDAL`类型不会测试可能的异常，也不会在各种情况下抛出自定义异常(例如，格式错误的连接字符串)。如果您要构建一个工业级的数据访问库，您肯定会希望使用结构化异常处理技术来解决任何运行时异常。

### 添加插入逻辑

向`Inventory`表中插入一条新记录就像格式化 SQL `Insert`语句(基于用户输入)并使用命令对象调用`ExecuteNonQuery()`一样简单。您可以通过向名为`InsertAuto()`的`InventoryDAL`类型添加一个公共方法来看到这一点，该方法接受映射到`Inventory`表的四列(`CarId`、`Color`、`Make`和`PetName`)的四个参数。您可以使用这些参数来格式化字符串类型，以便插入新记录。最后，使用您的`SqlConnection`对象来执行 SQL 语句。

`public void InsertAuto(int id, string color, string make, string petName)`

`{`

`// Format and execute SQL statement.`

`string sql = "Insert Into Inventory" +`

`$"(Make, Color, PetName) Values (’{make}’, ’{color}’, ’{petName}’)";`

`// Execute using our connection.`

`using (SqlCommand command = new SqlCommand(sql, _sqlConnection))`

`{`

`command.ExecuteNonQuery();`

`}`

`}`

这个方法在语法上很好，但是您可以提供一个重载版本，允许调用者传入一个表示新行数据的强类型类。向您的项目添加一个名为`Models`的新文件夹，并添加一个名为`NewCar`的新`public`类。定义下面这个新的`NewCar`类，它代表了`Inventory`表中的一个新行:

`public class NewCar`

`{`

`public int CarId { get; set; }`

`public string Color { get; set; }`

`public string Make { get; set; }`

`public string PetName { get; set; }`

`}`

现在将以下版本的`InsertAuto()`添加到您的`InventoryDAL`类中(在类的顶部为`AutoLotDAL.Models`添加一个`using`):

`public void InsertAuto(NewCar car)`

`{`

`// Format and execute SQL statement.`

`string sql = "Insert Into Inventory" +`

`"( Make, Color, PetName) Values" +`

`$"(’{car.Make}’, ’{car.Color}’, ’{car.PetName}’)";`

`// Execute using our connection.`

`using (SqlCommand command = new SqlCommand(sql, _sqlConnection))`

`{`

`command.ExecuteNonQuery();`

`}`

`}`

定义表示关系数据库中记录的类是构建数据访问库的常用方法。事实上，正如你将在第 23 章中看到的，ADO.NET 实体框架可以自动生成允许你与数据库数据交互的强类型类。与此相关的是，ADO.NET 的非连接层(参见第 22 章)生成强类型`DataSet`对象来表示关系数据库中给定表的数据。

Note

您可能知道，从安全角度来看，使用字符串连接构建 SQL 语句是有风险的(想想:SQL 注入攻击)。构建命令文本的首选方式是使用参数化查询，稍后您将了解到这一点。

### 添加删除逻辑

删除现有记录就像插入新记录一样简单。与您为`InsertAuto()`创建代码时不同，这次您将了解一个重要的`try` / `catch`作用域，该作用域处理尝试删除`Customers`表中某个人当前订购的汽车的可能性。将以下方法添加到`InventoryDAL`类类型中:

`public void DeleteCar(int id)`

`{`

`// Delete the car with the specified CarId`

`string sql = $"Delete from Inventory where CarId = ’{id}’";`

`using(SqlCommand command = new SqlCommand(sql, _sqlConnection))`

`{`

`try`

`{`

`command.ExecuteNonQuery();`

`}`

`catch(SqlException ex)`

`{`

`Exception error = new Exception("Sorry! That car is on order!", ex);`

`throw error;`

`}`

`}`

`}`

### 添加更新逻辑

当涉及到更新`Inventory`表中现有记录的行为时，您必须决定的第一件事是您希望允许调用者更改什么，是汽车的颜色、昵称、品牌，还是以上所有内容。给予调用者完全灵活性的一种方法是定义一个方法，该方法采用一个`string`类型来表示任何类型的 SQL 语句，但这充其量也是有风险的。

理想情况下，您希望有一组允许调用者以多种方式更新记录的方法。但是，对于这个简单的数据访问库，您将定义一个方法，允许调用者更新给定汽车的昵称，如下所示:

`public void UpdateCarPetName(int id, string newPetName)`

`{`

`// Update the PetName of the car with the specified CarId.`

`string sql = $"Update Inventory Set PetName = ’{newPetName}’ Where CarId = ’{id}’";`

`using (SqlCommand command = new SqlCommand(sql, _sqlConnection))`

`{`

`command.ExecuteNonQuery();`

`}`

`}`

### 添加选择逻辑

接下来，您需要添加一个选择方法。正如您在本章前面所看到的，数据提供程序的数据读取器对象允许使用只读、只进的服务器端游标来选择记录。当您调用`Read()`方法时，您可以以合适的方式处理每条记录。虽然这一切都很好，但是您需要考虑如何将这些记录返回到应用程序的调用层。

一种方法是用通过`Read()`方法获得的数据填充并返回一个多维数组(或者其他类似的返回值，比如一个通用的`List<NewCar>`对象)。下面是使用后一种方法从`Inventory`表中获取数据的第二种方法:

`public List<NewCar> GetAllInventoryAsList()`

`{`

`// This will hold the records.`

`List<NewCar> inv = new List<NewCar>();`

`// Prep command object.`

`string sql = "Select * From Inventory";`

`using (SqlCommand command = new SqlCommand(sql, _sqlConnection))`

`{`

`SqlDataReader dataReader = command.ExecuteReader();`

`while (dataReader.Read())`

`{`

`inv.Add(new NewCar`

`{`

`CarId = (int)dataReader["CarId"],`

`Color = (string)dataReader["Color"],`

`Make = (string)dataReader["Make"],`

`PetName = (string)dataReader["PetName"]`

`});`

`}`

`dataReader.Close();`

`}`

`return inv;`

`}`

还有一种方法是返回一个`System.Data.DataTable`对象，它实际上是 ADO.NET 断开层的一部分。你将在下一章找到断开层的完整覆盖；然而，目前，您应该理解一个`DataTable`是一个类类型，它表示一个表格数据块(例如，电子表格上的一个网格)。

在内部，`DataTable`类将数据表示为行和列的集合。虽然您可以以编程方式填充这些集合，但是`DataTable`类型提供了一个名为`Load()`的方法，该方法使用一个数据读取器对象自动填充这些集合！考虑以下方法，这些方法将来自`Inventory`的数据作为`DataTable`返回:

`public DataTable GetAllInventoryAsDataTable()`

`{`

`// This will hold the records.`

`DataTable dataTable = new DataTable();`

`// Prep command object.`

`string sql = "Select * From Inventory";`

`using (SqlCommand cmd = new SqlCommand(sql, _sqlConnection))`

`{`

`SqlDataReader dataReader = cmd.ExecuteReader();`

`// Fill the DataTable with data from the reader and clean up.`

`dataTable.Load(dataReader);`

`dataReader.Close();`

`}`

`return dataTable;`

`}`

### 使用参数化命令对象

目前，`InventoryDAL`类型的插入、更新和删除逻辑对每个 SQL 查询使用硬编码的字符串。如您所知，您可以使用参数化查询将 SQL 参数视为对象，而不是简单的文本块。以更加面向对象的方式处理 SQL 查询有助于减少打字错误的数量(给定强类型属性)；另外，参数化查询的执行速度通常比文字 SQL 字符串快得多，因为它们只被解析一次(而不是每次 SQL 字符串被分配给`CommandText`属性)。参数化查询还有助于防范 SQL 注入攻击(一个众所周知的数据访问安全问题)。

为了支持参数化查询，ADO.NET 命令对象维护单个参数对象的集合。默认情况下，此集合为空，但是您可以插入任意数量的 parameter 对象，这些对象映射到 SQL 查询中的占位符参数。当您想要将 SQL 查询中的参数与 command 对象的 parameters 集合中的成员相关联时，您可以在 SQL 文本参数前面加上符号`@`(至少在使用 Microsoft SQL Server 时是这样；并非所有 DBMSs 都支持这种表示法)。

### 使用 DbParameter 类型指定参数

在构建参数化查询之前，您需要熟悉`DbParameter`类型(它是提供者的特定参数对象的基类)。该类维护许多属性，这些属性允许您配置参数的名称、大小和数据类型，以及其他特征，包括参数的行进方向。表 [21-7](#Tab7) 描述了`DbParameter`型的一些关键特性。

表 21-7。

Key Members of the DbParameter Type

<colgroup><col> <col></colgroup> 
| 财产 | 生命的意义 |
| --- | --- |
| `DbType` | 获取或设置参数的本机数据类型，表示为 CLR 数据类型 |
| `Direction` | 获取或设置参数是仅输入、仅输出、双向还是返回值参数 |
| `IsNullable` | 获取或设置参数是否接受空值 |
| `ParameterName` | 获取或设置`DbParameter`的名称 |
| `Size` | 获取或设置数据的最大参数大小(以字节为单位)；这仅对文本数据有用 |
| `Value` | 获取或设置参数的值 |

现在让我们看看如何通过重写下面版本的`InsertAuto()`方法来填充命令对象的兼容`DBParameter`的对象的集合，以利用参数对象(您可以对您剩余的方法执行类似的重写；然而，对于这个例子来说，这是不必要的):

`public void InsertAuto(int id, string color, string make, string petName)`

`{`

`// Note the "placeholders" in the SQL query.`

`string sql = "Insert Into Inventory" +`

`"(Make, Color, PetName) Values" +`

`"(@Make, @Color, @PetName)";`

`// This command will have internal parameters.`

`using (SqlCommand command = new SqlCommand(sql, _sqlConnection))`

`{`

`// Fill params collection.`

`SqlParameter parameter = new SqlParameter`

`{`

`ParameterName = "@Make",`

`Value = make,`

`SqlDbType = SqlDbType.Char,`

`Size = 10`

`};`

`command.Parameters.Add(parameter);`

`parameter = new SqlParameter`

`{`

`ParameterName = "@Color",`

`Value = color,`

`SqlDbType = SqlDbType.Char,`

`Size = 10`

`};`

`command.Parameters.Add(parameter);`

`parameter = new SqlParameter`

`{`

`ParameterName = "@PetName",`

`Value = petName,`

`SqlDbType = SqlDbType.Char,`

`Size = 10`

`};`

`command.Parameters.Add(parameter);`

`command.ExecuteNonQuery();`

`}`

`}`

再次注意，您的 SQL 查询包含四个嵌入的占位符符号，每个符号都以`@`标记为前缀。您可以使用`SqlParameter`类型通过`ParameterName`属性映射每个占位符，并以强类型的方式指定各种细节(例如，它的值、数据类型和大小)。每个参数对象被水合后，通过调用`Add()`添加到命令对象的集合中。

Note

此示例使用各种属性建立一个参数对象。但是，请注意，parameter 对象支持许多重载的构造函数，这些构造函数允许您设置各种属性的值(这将导致更紧凑的代码库)。还要注意，Visual Studio 提供了许多图形设计器，它们会为你生成大量以参数为中心的代码(参见第 22 章和[第 23 章](23.html))。

虽然构建参数化查询通常需要更多代码，但最终结果是以更方便的方式以编程方式调整 SQL 语句，并获得更好的整体性能。当涉及到 SQL 查询时，您可以自由地使用这种技术，但是当您想要触发存储过程时，参数化查询被证明是最有帮助的。

### 执行存储过程

回想一下，存储过程是存储在数据库中的 SQL 代码的命名块。您可以构造存储过程，以便它们返回一组行或标量数据类型，或者执行任何其他有意义的操作(例如，插入、更新或删除)；您也可以让它们接受任意数量的可选参数。最终结果是一个工作单元，其行为类似于一个典型的函数，只是它位于一个数据存储上，而不是一个二进制业务对象上。目前，`AutoLot`数据库定义了一个名为`GetPetName`的存储过程，格式如下:

`GetPetName`

`@carID int,`

`@petName char(10) output`

`AS`

`SELECT @petName = PetName from Inventory where CarId = @carID`

现在考虑下面的`InventoryDAL`类型的最后一个方法，它调用您的存储过程:

`public string LookUpPetName(int carID)`

`{`

`string carPetName;`

`// Establish name of stored proc.`

`using (SqlCommand command = new SqlCommand("GetPetName", _sqlConnection))`

`{`

`command.CommandType = CommandType.StoredProcedure;`

`// Input param.`

`SqlParameter param = new SqlParameter`

`{`

`ParameterName = "@carID",`

`SqlDbType = SqlDbType.Int,`

`Value = carID,`

`Direction = ParameterDirection.Input`

`};`

`command.Parameters.Add(param);`

`// Output param.`

`param = new SqlParameter`

`{`

`ParameterName = "@petName",`

`SqlDbType = SqlDbType.Char,`

`Size = 10,`

`Direction = ParameterDirection.Output`

`};`

`command.Parameters.Add(param);`

`// Execute the stored proc.`

`command.ExecuteNonQuery();`

`// Return output param.`

`carPetName = (string)command.Parameters["@petName"].Value;`

`}`

`return carPetName;`

`}`

调用存储过程的一个重要方面是要记住一个命令对象可以代表一个 SQL 语句(默认)`or`存储过程的名称。当您想要通知一个命令对象它将调用一个存储过程时，您可以传入该过程的名称(作为一个构造函数参数或者通过使用`CommandText`属性)，并且必须将`CommandType`属性设置为值`CommandType.StoredProcedure`。(如果您未能做到这一点，您将会收到一个运行时异常，因为默认情况下命令对象需要一个 SQL 语句。)

`SqlCommand command = new SqlCommand("GetPetName", _sqlConnection);`

`command.CommandType = CommandType.StoredProcedure;`

接下来，请注意 parameter 对象的`Direction`属性允许您指定传递给存储过程的每个参数的行进方向(例如，输入参数、输出参数、输入/输出参数或返回值)。和前面一样，将每个参数对象添加到命令对象的参数集合中。

`// Input param.`

`SqlParameter param = new SqlParameter`

`{`

`ParameterName = "@carID",`

`SqlDbType = SqlDbType.Int,`

`Value = carID,`

`Direction = ParameterDirection.Input`

`};`

`command.Parameters.Add(param);`

在存储过程通过调用`ExecuteNonQuery()`完成之后，您可以通过研究命令对象的参数集合并相应地进行转换来获得输出参数的值。

`// Return output param.`

`carPetName = (string)command.Parameters["@petName"].Value;`

至此，`AutoLotDAL.dll`数据访问库的初始迭代就完成了！您可以使用这个组件构建任何类型的前端来显示和编辑您的数据(例如，基于控制台、桌面 GUI 或基于 HTML 的 web 应用程序)。您还没有研究如何构建图形用户界面，所以接下来您将从新的控制台应用程序测试您的数据库。

Source Code

你可以在 [`Chapter 21`](21.html) 子目录中找到 AutoLotDAL 项目。

## 创建基于控制台 UI 的前端

创建一个名为 AutoLotCUIClient 的新控制台应用程序项目。创建新项目后，一定要添加对`AutoLotDAL.dll`程序集和`System.Configuration.dll`的引用。如果您正在使用随书提供的示例代码，您可以从 [`Chapter 21`](21.html) 子目录中引用 AutoLotDAL 项目。如果您正在为每个样品创建新的解决方案，请导航到您的自动校准解决方案，并在`build`目录中找到`AutoLotDAL.dll`文件。接下来，将下面的`using`语句添加到 C#代码文件中:

`using AutoLotDAL.ConnectedLayer;`

`using AutoLotDAL.Models;`

`using System.Configuration;`

`using System.Data;`

`using static System.Console;`

打开项目中的`App.config`文件(或者添加一个新文件，如果还不存在的话)并添加`<connectionStrings>`元素，您将使用它来连接到您的`AutoLot`数据库实例，如下例所示:

`<configuration>`

`<connectionStrings>`

`<add name ="AutoLotSqlProvider" connectionString =`

`"Data Source=(local)\SQLEXPRESS2014;`

`Integrated Security=SSPI;Initial Catalog=AutoLot"/>`

`</connectionStrings>`

`<startup>`

`<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6" />`

`</startup>`

`</configuration>`

### 实现 Main()方法

`Main()`方法负责提示用户特定的操作过程，并使用`switch`语句执行该请求。该程序允许用户输入以下命令:

*   `I`:在`Inventory`表中插入一条新记录
*   `U`:更新`Inventory`表中已有的记录
*   `D`:从`Inventory`表中删除一条现有记录
*   `L`:使用数据阅读器显示当前库存
*   `S`:向用户显示这些选项
*   `P`:从`carID`中查找昵称
*   `Q`:退出程序

每个可能的选项都由`Program`类中唯一的静态方法处理。下一个片段展示了`Main()`的完整实现。注意，从`do` / `while`循环中调用的每个方法(除了`ShowInstructions()`方法)都将一个`InventoryDAL`对象作为其唯一的参数。

`static void Main(string[] args)`

`{`

`WriteLine("***** The AutoLot Console UI *****\n");`

`// Get connection string from App.config.`

`string connectionString =`

`ConfigurationManager.ConnectionStrings["AutoLotSqlProvider"].ConnectionString;`

`bool userDone = false;`

`string userCommand = "";`

`// Create our InventoryDAL object.`

`InventoryDAL invDAL = new InventoryDAL();`

`invDAL.OpenConnection(connectionString);`

`// Keep asking for input until user presses the Q key.`

`try`

`{`

`ShowInstructions();`

`do`

`{`

`Write("\nPlease enter your command: ");`

`userCommand = ReadLine();`

`WriteLine();`

`switch (userCommand?.ToUpper()??"")`

`{`

`case "I":`

`InsertNewCar(invDAL);`

`break;`

`case "U":`

`UpdateCarPetName(invDAL);`

`break;`

`case "D":`

`DeleteCar(invDAL);`

`break;`

`case "L":`

`ListInventory(invDAL);`

`break;`

`case "S":`

`ShowInstructions();`

`break;`

`case "P":`

`LookUpPetName(invDAL);`

`break;`

`case "Q":`

`userDone = true;`

`break;`

`default:`

`WriteLine("Bad data! Try again");`

`break;`

`}`

`} while (!userDone);`

`}`

`catch (Exception ex)`

`{`

`WriteLine(ex.Message);`

`}`

`finally`

`{`

`invDAL.CloseConnection();`

`}`

`}`

### 实现 ShowInstructions()方法

`ShowInstructions()`方法做了您所期望的事情，如下所示:

`private static void ShowInstructions()`

`{`

`WriteLine("I: Inserts a new car.");`

`WriteLine("U: Updates an existing car.");`

`WriteLine("D: Deletes an existing car.");`

`WriteLine("L: Lists current inventory.");`

`WriteLine("S: Shows these instructions.");`

`WriteLine("P: Looks up pet name.");`

`WriteLine("Q: Quits program.");`

`}`

### 实现 ListInventory()方法

根据您构建数据访问库的方式，您可以用两种方式中的任何一种来实现`ListInventory()`方法。回想一下，`InventoryDAL`的`GetAllInventoryAsDataTable()`方法返回一个`DataTable`对象。您可以像这样实现这种方法:

`private static void ListInventory(InventoryDAL invDAL)`

`{`

`// Get the list of inventory.`

`DataTable dt = invDAL.GetAllInventoryAsDataTable();`

`// Pass DataTable to helper function to display.`

`DisplayTable(dt);`

`}`

`DisplayTable()`助手方法使用传入的`DataTable`的`Rows`和`Columns`属性显示表格数据(同样，您将在下一章了解`DataTable`对象的全部细节，所以不要为细节而烦恼)。

`private static void DisplayTable(DataTable dt)`

`{`

`// Print out the column names.`

`for (int curCol = 0; curCol < dt.Columns.Count; curCol++)`

`{`

`Write($"{dt.Columns[curCol].ColumnName}\t");`

`}`

`WriteLine("\n----------------------------------");`

`// Print the DataTable.`

`for (int curRow = 0; curRow < dt.Rows.Count; curRow++)`

`{`

`for (int curCol = 0; curCol < dt.Columns.Count; curCol++)`

`{`

`Write($"{dt.Rows[curRow][curCol]}\t");`

`}`

`WriteLine();`

`}`

`}`

如果你想调用`InventoryDAL`的`GetAllInventoryAsList()`方法，你可以实现一个名为`ListInventoryViaList()`的方法，就像这样(你需要为`AutoLotDAL.Models`添加一个`using`):

`private static void ListInventoryViaList(InventoryDAL invDAL)`

`{`

`// Get the list of inventory.`

`List<NewCar> record = invDAL.GetAllInventoryAsList();`

`WriteLine("CarId:\tMake:\tColor:\tPetName:");`

`foreach (NewCar c in record)`

`{`

`WriteLine($"{c.CarId}\t{c.Make}\t{c.Color}\t{c.PetName}");`

`}`

`}`

### 实现 DeleteCar()方法

删除现有汽车非常简单，只需向用户询问汽车的 ID，并将其传递给`InventoryDAL`类型的`DeleteCar()`方法，如下所示:

`private static void DeleteCar(InventoryDAL invDAL)`

`{`

`// Get ID of car to delete.`

`Write("Enter ID of Car to delete: ");`

`int id = int.Parse(ReadLine()??"0");`

`// Just in case you have a referential integrity violation` `!`

`try`

`{`

`invDAL.DeleteCar(id);`

`}`

`catch(Exception ex)`

`{`

`WriteLine(ex.Message);`

`}`

`}`

### 实现 InsertNewCar()方法

将一条新记录插入到`Inventory`表中是一件简单的事情，要求用户提供新的数据位(使用`ReadLine()`调用)并将这些数据传递给`InventoryDAL`的`InsertAuto()`方法，如下所示:

`private static void InsertNewCar(InventoryDAL invDAL)`

`{`

`Write("Enter Car ID: ");`

`var newCarId = int.Parse(ReadLine()??"0");`

`Write("Enter Car Color: ");`

`var newCarColor = ReadLine();`

`Write("Enter Car Make: ");`

`var newCarMake = ReadLine();`

`Write("Enter Pet Name: ");`

`var newCarPetName = ReadLine();`

`// Now pass to data access library.`

`invDAL.InsertAuto(newCarId, newCarColor, newCarMake, newCarPetName);`

`}`

回想一下，您重载了`InsertAuto()`以获取一个`NewCar`对象，而不是一组独立的参数。因此，您可以这样实现`InsertNewCar()`:

`private static void InsertNewCar(InventoryDAL invDAL)`

`{`

`// First get the user data.`

`..//omitted for brevity`

`// Now pass to data access library.`

`var c = new NewCar`

`{`

`CarId = newCarId,`

`Color = newCarColor,`

`Make = newCarMake,`

`PetName = newCarPetName`

`};`

`invDAL.InsertAuto(c);`

`}`

### 实现 UpdateCarPetName()方法

下面的`UpdateCarPetName()`实现看起来类似:

`private static void UpdateCarPetName(InventoryDAL invDAL)`

`{`

`// First get the user data.`

`Write("Enter Car ID: ");`

`var carID = int.Parse(ReadLine()??"0");`

`Write("Enter New Pet Name: ");`

`var newCarPetName = ReadLine();`

`// Now pass to data access library.`

`invDAL.UpdateCarPetName(carID, newCarPetName);`

`}`

### 实现 LookUpPetName()

获取给定汽车的昵称与前面的方法类似；这是因为数据访问库封装了所有较低级别的 ADO.NET 调用。

`private static void LookUpPetName(InventoryDAL invDAL)`

`{`

`// Get ID of car to look up.`

`Write("Enter ID of Car to look up: ");`

`int id = int.Parse(ReadLine()??"0");`

`WriteLine($"Petname of {id} is {invDAL.LookUpPetName(id).TrimEnd()}.");`

`}`

这样，你的基于控制台的前端就完成了！是时候运行你的程序并测试每个方法了。下面是测试`L`、`P`和`Q`命令的部分输出:

`***** The AutoLot Console UI *****`

`I: Inserts a new car.`

`U: Updates an existing car.`

`D: Deletes an existing car.`

`L: Lists current inventory.`

`S: Shows these instructions.`

`P: Looks up pet name.`

`Q: Quits program.`

`Please enter your command: L`

`CarId:  Make:   Color:   PetName:`

`1       VW      Black    Zippy`

`2       Ford    Rust     Rusty`

`3       Saab    Black    Mel`

`4       Yugo    Yellow   Cluncker`

`5       BMW     Black    Bimmer`

`6       BMW     Green    Hank`

`7       BMW     Pink     Pinkey`

`Please enter your command: P`

`Enter ID of Car to look up: 6`

`Petname of 6 is Hank.`

`Please enter your command: Q`

`Press any key to continue . . .`

Source Code

您可以在 [`Chapter 21`](21.html) 子目录中找到 AutoLotCUIClient 应用程序。

## 了解数据库事务

让我们通过了解数据库事务的概念来结束对 ADO.NET 连接层的研究。简而言之，事务是一组数据库操作，作为一个整体，要么全部工作，要么全部失败。可以想象，事务对于确保表数据的安全性、有效性和一致性非常重要。

当数据库操作涉及与多个表或多个存储过程(或数据库原子的组合)进行交互时，事务非常重要。典型的交易示例涉及在两个银行账户之间转移货币资金的过程。例如，如果您要将 500 美元从您的储蓄账户转入您的支票账户，则应以交易方式执行以下步骤:

The bank should remove $500 from your savings account.   The bank should add $500 to your checking account.  

如果钱从储蓄账户中取出，但没有转到支票账户(因为银行方面的一些错误),这将是一件非常糟糕的事情，因为那样你将损失 500 美元！但是，如果这些步骤被打包到一个数据库事务中，DBMS 会确保所有相关步骤作为一个单元发生。如果事务的任何部分失败，整个操作将回滚到原始状态。另一方面，如果所有步骤都成功，则提交事务。

Note

您可能在阅读交易文献时熟悉缩写 ACID。这代表了基本事务的四个关键属性:原子性(全有或全无)、一致性(数据在整个事务中保持稳定)、隔离性(事务不会互相干扰)和持久性(事务被保存和记录)。

事实证明。NET 平台以多种方式支持事务。本章将研究您的 ADO.NET 数据提供者的事务对象(在`System.Data.SqlClient`的情况下，是`SqlTransaction`)。的。NET 基本类库还在许多 API 中提供事务支持，包括:

*   `System.EnterpriseServices`:这个名称空间(位于`System.EnterpriseServices.dll`程序集)提供了允许你与 COM+运行时层集成的类型，包括它对分布式事务的支持。
*   `System.Transactions`:这个名称空间(位于`System.Transactions.dll`汇编中)包含允许你为各种服务(例如，ADO.NET、MSMQ 和 COM+)编写自己的事务应用程序和资源管理器的类。
*   windows Communication Foundation:WCF API 提供了一些服务，以方便各种分布式绑定类的事务处理。
*   Windows 工作流基础:WF API 为工作流活动提供事务支持。

除了内置的事务支持之外。NET 基本类库，可以使用数据库管理系统的 SQL 语言。例如，您可以编写一个使用`BEGIN TRANSACTION`、`ROLLBACK`和`COMMIT`语句的存储过程。

### ADO.NET 事务对象的主要成员

虽然事务感知类型存在于整个基本类库中，但是您将关注 ADO.NET 数据提供者中的事务对象，所有这些对象都从`DBTransaction`派生并实现`IDbTransaction`接口。回想一下本章开始时，`IDbTransaction`对少数成员的定义如下:

`public interface IDbTransaction : IDisposable`

`{`

`IDbConnection Connection { get; }`

`IsolationLevel IsolationLevel { get; }`

`void Commit();`

`void Rollback();`

`}`

注意`Connection`属性，它返回对启动当前事务的连接对象的引用(正如您将看到的，您从给定的连接对象中获得一个事务对象)。当您的每个数据库操作成功时，您调用`Commit()`方法。这样做将导致每个挂起的更改都保留在数据存储中。相反，如果出现运行时异常，您可以调用`Rollback()`方法，通知 DMBS 忽略任何未决的更改，保持原始数据不变。

Note

transaction 对象的`IsolationLevel`属性允许您指定一个事务应该如何积极地防范其他并行事务的活动。默认情况下，事务在提交之前是完全隔离的。请参考。NET Framework 4.6 SDK 文档，以了解关于`IsolationLevel`枚举值的完整详细信息。

除了由`IDbTransaction`接口定义的成员之外，`SqlTransaction`类型还定义了一个名为`Save()`的额外成员，它允许您定义保存点。这个概念允许您将失败的事务回滚到指定的点，而不是回滚整个事务。本质上，当您使用`SqlTransaction`对象调用`Save()`时，您可以指定一个友好的字符串名字对象。当您调用`Rollback()`时，您可以指定这个相同的名字作为参数来执行有效的部分回滚。不带参数调用`Rollback()`会导致所有挂起的更改回滚。

### 向汽车人数据库添加信用风险表

现在让我们看看如何使用 ADO.NET 交易。首先，使用 Visual Studio 的服务器资源管理器向`AutoLot`数据库添加一个名为`CreditRisks`的新表，该表与您在本章前面创建的`Customers`表具有相同的列:`CustId`，这是主键；`FirstName`；还有`LastName`。顾名思义，`CreditRisks`是你驱逐那些没有通过信用检查的不受欢迎的客户的地方(见图 [21-15](#Fig15) )。

![A978-1-4842-1332-2_21_Fig15_HTML.jpg](A978-1-4842-1332-2_21_Fig15_HTML.jpg)

图 21-15。

The interconnected Orders, Inventory, and Customers tables

与前面的储蓄到支票的资金转移示例一样，在这个示例中，您将一个有风险的客户从`Customers`表移动到`CreditRisks`表，这应该在事务范围的监视下进行(毕竟，您会希望记住那些没有信誉的客户的名字)。具体来说，您需要确保成功地从`Customers`表中删除当前的信用风险并将它们添加到`CreditRisks`表中，或者这两个数据库操作都不发生。

Note

在生产环境中，您不需要构建一个全新的数据库表来捕获高风险客户；相反，您可以将名为`IsCreditRisk`的布尔列添加到现有的`Customers`表中。但是，这个新表允许您处理一个简单的事务。

### 将交易方法添加到库存

现在让我们看看如何以编程方式处理 ADO.NET 事务。首先打开您之前创建的`AutoLotDAL`代码库项目，并将一个名为`ProcessCreditRisk()`的新公共方法添加到`InventoryDAL`类中，以处理感知到的信用风险。(注意，这个例子避免使用参数化查询，以保持实现简单；但是，您可能希望对生产级方法使用这样的查询。)

`// A new member of the InventoryDAL class.`

`public void ProcessCreditRisk(bool throwEx, int custID)`

`{`

`// First, look up current name based on customer ID.`

`string fName;`

`string lName;`

`var cmdSelect =`

`new SqlCommand($"Select * from Customers where CustId = {custID}",`

`_sqlConnection);`

`using (var dataReader = cmdSelect.ExecuteReader())`

`{`

`if (dataReader.HasRows)`

`{`

`dataReader.Read();`

`fName = (string) dataReader["FirstName"];`

`lName = (string) dataReader["LastName"];`

`}`

`else`

`{`

`return;`

`}`

`}`

`// Create command objects that represent each step of the operation.`

`var cmdRemove =`

`new SqlCommand($"Delete from Customers where CustId = {custID}",`

`_sqlConnection);`

`var cmdInsert =`

`new SqlCommand("Insert Into CreditRisks" +`

`$"(FirstName, LastName) Values(’{fName}’, ’{lName}’)",`

`_sqlConnection);`

`// We will get this from the connection object.`

`SqlTransaction tx = null;`

`try`

`{`

`tx = _sqlConnection.BeginTransaction();`

`// Enlist the commands into this transaction.`

`cmdInsert.Transaction = tx;`

`cmdRemove.Transaction = tx;`

`// Execute the commands.`

`cmdInsert.ExecuteNonQuery();`

`cmdRemove.ExecuteNonQuery();`

`// Simulate error.`

`if (throwEx)`

`{`

`throw new Exception("Sorry!  Database error! Tx failed...");`

`}`

`// Commit it!`

`tx.Commit();`

`}`

`catch (Exception ex)`

`{`

`WriteLine(ex.Message);`

`// Any error will roll back transaction.`

`// Using the new conditional access operator to check for null.`

`tx?.Rollback();`

`}`

`}`

这里，您使用一个传入的`bool`参数来表示当您试图处理违规的客户时是否会抛出一个任意的异常。这允许您模拟会导致数据库事务失败的意外情况。显然，您在这里这样做只是为了说明的目的；真正的数据库事务方法不会允许调用者心血来潮地强迫逻辑失败！

注意，您使用两个`SqlCommand`对象来表示您将开始的事务中的每一步。在根据传入的`custID`参数获得客户的名字和姓氏之后，可以使用`BeginTransaction()`从连接对象中获得一个有效的`SqlTransaction`对象。接下来，也是最重要的，您必须通过将`Transaction`属性分配给刚刚获得的事务对象来登记每个命令对象。如果您没有这样做，`Insert` / `Delete`逻辑将不会在事务上下文中。

在每个命令上调用`ExecuteNonQuery()`之后，当(且仅当)参数`bool`的值为`true`时，抛出异常。在这种情况下，所有挂起的数据库操作都将回滚。如果您没有抛出异常，那么一旦您调用了`Commit()`，这两个步骤都将被提交给数据库表。现在编译您修改过的`AutoLotDAL`项目，确保没有任何错别字。

### 测试您的数据库事务

您可以用一个新选项来更新您以前的`AutoLotCUIClient`应用程序，以调用`ProcessCreditRisk()`方法；但是，您将创建一个名为 AdoNetTransaction 的新控制台应用程序项目来完成此任务。设置对您的`AutoLotDAL.dll`程序集的引用，并导入`AutoLotDAL.ConnectedLayer`、`AutoLotDAL.Models`和`static System.Console`名称空间。

接下来，从服务器资源管理器中右键单击表图标并选择 Show Table Data，打开您的`Customers`表进行数据输入。现在添加以下新客户，他将成为低信用分数的受害者(记下新记录的分配 Id):

*   名字:荷马
*   姓氏:辛普森

最后，更新您的`Main()`方法，如下所示:

`static void Main(string[] args)`

`{`

`WriteLine("***** Simple Transaction Example *****\n");`

`// A simple way to allow the tx to succeed or not.`

`bool throwEx = true;`

`Write("Do you want to throw an exception (Y or N): ");`

`var userAnswer = ReadLine();`

`if (userAnswer?.ToLower() == "n")`

`{`

`throwEx = false;`

`}`

`var dal = new InventoryDAL();`

`dal.OpenConnection(@"Data Source=(local)\SQLEXPRESS2014;Integrated Security=SSPI;" +`

`"Initial Catalog=AutoLot");`

`// Process customer 5 – enter the id for Homer Simpson in the next line.`

`dal.ProcessCreditRisk(throwEx, 5);`

`WriteLine("Check CreditRisk table for results");`

`ReadLine();`

`}`

如果您要运行程序并选择抛出一个异常，您会发现 Homer 并没有从`Customers`表中删除，因为整个事务已经回滚了。但是，如果您没有抛出异常，您会发现客户 ID 5 不再在`Customers`表中，而是被放在了`CreditRisks`表中。

Source Code

你可以在 [`Chapter 21`](21.html) 子目录中找到 AdoNetTransaction 项目。

## 摘要

ADO.NET 是本地的数据访问技术。NET 平台，你可以用三种不同的方式使用它:连接、断开或通过实体框架。在这一章中，您研究了连接层并学习了数据提供者的角色，它本质上是几个抽象基类(在`System.Data.Common`名称空间中)和接口类型(在`System.Data`名称空间中)的具体实现。您还看到了使用 ADO.NET 数据提供者工厂模型构建提供者中立的代码库是可能的。

您还了解了可以使用连接层的连接对象、事务对象、命令对象和数据读取器对象来选择、更新、插入和删除记录。此外，还记得 command 对象支持内部参数集合，您可以使用它为 SQL 查询增加一些类型安全性；事实证明，这些在触发存储过程时也非常有用。