# 22.ADO.NET 第二部:分离的层

上一章让您有机会研究了 ADO.NET 的连接层和基本组件，它们允许您使用数据提供者的连接、命令和数据读取器对象向数据库提交 SQL 语句。在本章中，您将了解 about 的不连通图层。使用 ADO.NET 的这个方面，您可以在调用层内，通过利用众多的`System.Data`名称空间成员(最著名的有`DataSet`、`DataTable`、`DataRow`、`DataColumn`、`DataView`和`DataRelation`)，在内存中对数据库数据进行建模。通过这样做，您可以提供调用层持续连接到外部数据源的假象；实际情况是，调用者正在操作关系数据的本地副本。

Note

正如前一章介绍中提到的，实体框架(EF)正在获得动力，并被越来越多的人采用。我将在下一章介绍英孚，但了解 ADO.NET 如何在其核心工作仍然很重要，因为英孚(和其他。NET 对象关系映射器[ORM])是建立在 ADO.NET 之上的。虽然可以使用 ADO.NET 的这种断开连接的方面，而不必与关系数据库建立文字连接，但是您通常会使用数据提供者的数据适配器对象来获得填充的`DataSet`对象。正如您将看到的，数据适配器对象充当了客户端层和关系数据库之间的桥梁。使用这些对象，您可以获得`DataSet`对象，操作它们的内容，并将修改后的行发送回去进行处理。最终结果是高度可扩展的以数据为中心的。NET 应用。

本章还将使用 Windows Forms GUI 桌面应用的上下文来说明一些数据绑定技术，并研究强类型`DataSet`的作用。您还将使用一个新的名称空间来更新您在第 21 章的[中创建的`AutoLotDAL.dll`数据库，该名称空间使用了 ADO.NET 的非连接层。最后但同样重要的是，您将了解 LINQ 对数据集的作用，它允许您对内存中的数据缓存应用 LINQ 查询。](21.html)

Note

在本书的后面，您将了解到 Windows Presentation Foundation 和 ASP.NET 应用的各种数据绑定技术。

## 理解 ADO.NET 的分离层

正如您在上一章中看到的，使用连接的图层允许您使用主连接、命令和数据读取器对象与数据库进行交互。您可以使用这些类来选择、插入、更新和删除记录(以及调用存储过程或执行其他数据操作[例如，DDL 创建表，DCL 授予权限])。然而，你只看到了 ADO.NET 故事的一部分。回想一下，您可以以断开连接的方式使用 ADO.NET 对象模型。

使用非连接层，可以使用内存中的对象模型对关系数据建模。远远不止是简单地建模一个由行和列组成的表格块，`System.Data`中的类型允许您表示表关系、列约束、主键、视图和其他数据库原语。对数据建模后，可以应用过滤器、提交内存中的查询，并以 XML 和二进制格式持久化(或加载)数据。您可以通过从本地 XML 文件加载数据或在代码中手动构建一个`DataSet`来完成所有这些工作，而无需与 DBMS 建立文字连接(这就是为什么它被称为断开的层)。

Note

在第 23 章中，你将研究 ADO.NET 实体框架，它建立在这里研究的分离层的概念之上。

您可以在不连接到数据库的情况下使用断开连接的类型，但通常仍会使用连接和命令对象。此外，您将利用一个特定的对象，即数据适配器(它扩展了抽象的`DbDataAdapter`类)来获取和更新数据。与连接的图层不同，使用数据适配器获得的数据不使用数据读取器对象进行处理。更确切地说，数据适配器对象使用`DataSet`对象(或者更具体地说，`DataSet`中的`DataTable`对象)在调用者和数据源之间移动数据。`DataSet`类型是任意数量的`DataTable`对象的容器，每个对象包含一个`DataRow`和`DataColumn`对象的集合。

数据提供程序的数据适配器对象自动处理数据库连接。为了提高可伸缩性，数据适配器尽可能在最短的时间内保持连接打开。在调用者接收到`DataSet`对象后，调用层与数据库完全断开，留下远程数据的本地副本。调用者可以自由地插入、删除或更新给定`DataTable`中的行，但是直到调用者显式地将`DataSet`中的`DataTable`传递给数据适配器进行更新时，物理数据库才会更新。简而言之，`DataSet` s 允许客户假装他们总是保持联系；然而，它们实际上是在内存数据库上操作的(见图 [22-1](#Fig1) )。

![A978-1-4842-1332-2_22_Fig1_HTML.gif](img/A978-1-4842-1332-2_22_Fig1_HTML.gif)

图 22-1。

Data adapter objects move DataSets to and from the client tier

假设断开层的核心是`DataSet`类，本章的第一个任务是学习如何手动操作`DataSet`。一旦您能够做到这一点，那么操作从数据适配器对象中检索的`DataSet`的内容就没有问题了。

## 了解数据集的作用

如前所述，`DataSet`是关系数据的内存表示。更具体地说，`DataSet`是一个内部维护三个强类型集合的类类型(见图 [22-2](#Fig2) )。

![A978-1-4842-1332-2_22_Fig2_HTML.jpg](img/A978-1-4842-1332-2_22_Fig2_HTML.jpg)

图 22-2。

The anatomy of a DataSet

`DataSet al`的`Tables`属性允许您访问包含单个`DataTable`的`DataTableCollection`。`DataSet`使用的另一个重要集合是`DataRelationCollection`。假设一个`DataSet`是一个数据库模式的断开版本，您可以用它来以编程方式表示其表之间的父子关系。例如，您可以在两个表之间创建一个关系，以使用`DataRelation`类型对外键约束进行建模。您可以使用`Relations`属性将该对象添加到`DataRelationCollection`中。此时，您可以在搜索数据时在相关表之间导航。在本章的后面你会看到如何做到这一点。

`ExtendedProperties`属性提供对`PropertyCollection`对象的访问，这允许您将任何额外的信息作为名称-值对与`DataSet`相关联。这些信息实际上可以是任何东西，即使它与数据库数据本身没有关系。例如，您可以将您公司的名称与一个`DataSet`相关联，然后它可以作为内存中的元数据。其他扩展属性的例子可能包括时间戳、访问`DataSet`内容时必须提供的加密密码、代表数据刷新率的数字等等。

Note

`DataTable`和`DataColumn`类也支持`ExtendedProperties`属性。

### 数据集的关键属性

在探索太多其他纲领性细节之前，我们先来看看`DataSet`的一些核心成员。表 [22-1](#Tab1) 描述了除`Tables`、`Relations`和`ExtendedProperties`属性之外的一些感兴趣的附加属性。

表 22-1。

Properties of the DataSet

<colgroup><col> <col></colgroup> 
| 财产 | 生命的意义 |
| --- | --- |
| `CaseSensitive` | 指示`DataTable`对象中的字符串比较是否区分大小写。默认值是`false`(默认情况下，字符串比较不区分大小写)。 |
| `DataSetName` | 表示此`DataSet`的友好名称。通常，您将此值建立为构造函数参数。 |
| `EnforceConstraints` | 获取或设置一个值，该值指示在尝试任何更新操作时是否遵循约束规则(默认值为`true`)。 |
| `HasErrors` | 获取一个值，该值指示在`DataSet`的任何`DataTable`的任何行中是否有错误。 |
| `RemotingFormat` | 允许您定义`DataSet`应该如何序列化其内容(默认为二进制或 XML)。 |

### 数据集的关键方法

`DataSet`的方法与上述属性提供的一些功能协同工作。除了与 XML 流交互之外，`DataSet`还提供了一些方法，允许您复制`DataSet`的内容，在内部表之间导航，以及建立一批更新的起点和终点。表 [22-2](#Tab2) 描述了一些核心方法。

表 22-2。

Select Methods of the DataSet

<colgroup><col> <col></colgroup> 
| 方法 | 生命的意义 |
| --- | --- |
| `AcceptChanges()` | 提交自加载或上次调用`AcceptChanges()`以来对此`DataSet`所做的所有更改。 |
| `Clear()` | 通过删除每个`DataTable`中的每一行来完全清除`DataSet`数据。 |
| `Clone()` | 克隆`DataSet`的结构，但不克隆数据，包括所有的`DataTable`，以及所有的关系和任何约束。 |
| `Copy()` | 复制此`DataSet`的结构和数据。 |
| `GetChanges()` | 返回`DataSet`的副本，包含自上次加载或调用`AcceptChanges()`以来对其所做的所有更改。此方法被重载，以便您可以只获取新行、修改的行或删除的行。 |
| `HasChanges()` | 获取一个值，该值指示`DataSet`是否有更改，包括新的、删除的或修改的行。 |
| `Merge()` | 将此`DataSet`与指定的`DataSet`合并。 |
| `ReadXml()` | 允许您根据 XML 模式和从流中读取的数据，定义一个`DataSet`对象的结构，并用数据填充它。 |
| `RejectChanges()` | 回滚自创建此`DataSet`或自上次调用`AcceptChanges()`以来对此`DataSet`所做的所有更改。 |
| `WriteXml()` | 允许你将一个`DataSet`的内容写到一个有效的流中。 |

### 构建数据集

现在，您对`DataSet`的角色有了更好的理解(并且对使用它可以做什么有了一些想法)，创建一个名为 SimpleDataSet 的新控制台应用项目，并导入`System.Data`名称空间。在`Main()`方法中，定义一个新的`DataSet`对象，该对象包含三个扩展属性，分别代表一个时间戳、一个惟一标识符(代表一个`System.Guid`类型)和您公司的名称，如下所示(您还需要添加`using static System.Console;`):

`using static System.Console;`

`static void Main(string[] args)`

`{`

`WriteLine("***** Fun with DataSets *****\n");`

`// Create the DataSet object and add a few properties.`

`var carsInventoryDS = new DataSet("Car Inventory");`

`carsInventoryDS.ExtendedProperties["TimeStamp"] = DateTime.Now;`

`carsInventoryDS.ExtendedProperties["DataSetID"] = Guid.NewGuid();`

`carsInventoryDS.ExtendedProperties["Company"] =`

`"Mikko’s Hot Tub Super Store";`

`FillDataSet(carsInventoryDS);`

`PrintDataSet(carsInventoryDS);`

`ReadLine();`

`}`

Note

GUID(也称为全局唯一标识符)是一个静态唯一的 128 位数字。

在插入任意数量的`DataTable`之前，`DataSet`对象并不十分有趣。因此，下一个任务是检查`DataTable`的内部组成，从`DataColumn`类型开始。

## 使用数据列

`DataColumn`类型表示`DataTable`中的单个列。总的来说，绑定到给定`DataTable`的所有`DataColumn`类型的集合代表了表的模式信息的基础。例如，如果您要为`AutoLot`数据库的`Inventory`表建模(参见[第 21 章](21.html)，您将创建四个`DataColumn`，每列一个(`CarID`、`Make`、`Color`和`PetName`)。在创建了`DataColumn`对象之后，通常会将它们添加到`DataTable`类型的列集合中(使用`Columns`属性)。

根据您的背景，您可能知道可以为数据库表中的给定列分配一组约束(例如，配置为主键、分配默认值或配置为包含只读信息)。此外，表中的每一列都必须映射到基础数据类型。例如，`Inventory`表的模式要求`CarID`列映射到一个整数，而`Make`、`Color`和`PetName`映射到一个字符数组。`DataColumn`类有许多属性，允许您精确地配置这些东西。表 [22-3](#Tab3) 提供了一些核心属性的概要。

表 22-3。

Properties of the DataColumn

<colgroup><col> <col></colgroup> 
| 性能 | 生命的意义 |
| --- | --- |
| `AllowDBNull` | 您使用该属性来指示一行是否可以在该列中指定`null`值。默认值为`true`。 |
| `AutoIncrement AutoIncrementSeed AutoIncrementStep` | 您可以使用这些属性来配置给定列的自动增量行为。当您想要确保给定的`DataColumn`(比如主键)中的唯一值时，这可能会很有帮助。默认情况下，`DataColumn`不支持自动递增行为。 |
| `Caption` | 此属性获取或设置要为此列显示的标题。这允许您定义文本数据库列名的用户友好版本。 |
| `ColumnMapping` | 该属性决定了当使用`DataSet.WriteXml()`方法将`DataSet`保存为 XML 文档时，如何表示`DataColumn`。您可以指定数据列应该作为 XML 元素、XML 属性、简单文本内容写出，或者完全忽略。 |
| `ColumnName` | 该属性获取或设置`Columns`集合中列的名称(意味着它如何在内部由`DataTable`表示)。如果没有明确设置`ColumnName`，缺省值是带有`(n+1)`数字后缀的`Column`(例如`Column1`、`Column2`和`Column3`)。 |
| `DataType` | 该属性定义了存储在列中的数据类型(如`Boolean`、`string`或`float`)。 |
| `DefaultValue` | 当您插入新行时，此属性获取或设置分配给此列的默认值。 |
| `Expression` | 此属性获取或设置用于筛选行、计算列值或创建聚合列的表达式。 |
| `Ordinal` | 该属性获取列在由`DataTable`维护的`Columns`集合中的数字位置。 |
| `ReadOnly` | 一旦向表中添加了一行，此属性确定该列是否为只读。默认为`false`。 |
| `Table` | 这个属性获取包含这个`DataColumn`的`DataTable`。 |
| `Unique` | 此属性获取或设置一个值，该值指示列的每一行中的值是否必须是唯一的，或者是否允许重复值。如果您将一个列指定为主键约束，那么您必须将`Unique`属性设置为`true`。 |

### 构建数据列

为了继续 SimpleDataSet 项目(并说明`DataColumn`的用法)，假设您想要对`Inventory`表的列进行建模。假设`CarID`列将是表的主键，那么您将把这个`DataColumn`对象配置为只读的、惟一的和非空的(使用`ReadOnly`、`Unique`和`AllowDBNull`属性)。接下来，用一个名为`FillDataSet()`的新方法更新`Program`类，您用它来构建四个`DataColumn`对象。注意这个方法将一个`DataSet`对象作为它唯一的参数。

`static void FillDataSet(DataSet ds)`

`{`

`// Create data columns that map to the`

`// "real" columns in the Inventory table`

`// of the AutoLot database.`

`var carIDColumn = new DataColumn("CarID", typeof (int))`

`{`

`Caption = "Car ID",`

`ReadOnly = true,`

`AllowDBNull = false,`

`Unique = true,`

`};`

`var carMakeColumn = new DataColumn("Make", typeof (string));`

`var carColorColumn = new DataColumn("Color", typeof (string));`

`var carPetNameColumn = new DataColumn("PetName", typeof (string))`

`{ Caption = "Pet Name"};`

`}`

注意，当您配置`carIDColumn`对象时，您为`Caption`属性赋值。该属性非常有用，因为它允许您定义一个用于显示目的的字符串值，该字符串值可以不同于文本数据库表的列名(文本数据库表中的列名通常更适合于编程目的[例如，`au_fname` ]而不是用于显示目的[例如，`Author First Name` ])。这里，出于同样的原因，您为`PetName`列设置了标题，因为对最终用户来说，宠物名看起来比宠物名更好。

### 启用自动递增字段

您可以选择配置的`DataColumn`的一个方面是它的自动增量能力。使用自动递增列可以确保在给定的表中添加新行时，根据当前的增加幅度自动分配该列的值。当您希望确保某一列没有重复值(例如主键)时，这很有帮助。

您可以使用`AutoIncrement`、`AutoIncrementSeed`和`AutoIncrementStep`属性来控制这种行为。您使用种子值来标记列的起始值；您可以使用步长值来标识递增时要添加到种子中的数字。考虑以下对`carIDColumn DataColumn`建造的更新:

`static void FillDataSet(DataSet ds)`

`{`

`var carIDColumn = new DataColumn("CarID", typeof (int))`

`{`

`Caption = "Car ID",`

`ReadOnly = true,`

`AllowDBNull = false,`

`Unique = true,`

`AutoIncrement = true,`

`AutoIncrementSeed = 1,`

`AutoIncrementStep = 1`

`};`

`}`

这里，您配置了`carIDColumn`对象，以确保当行被添加到相应的表中时，该列的值会增加`1`。您将种子设置在`1`，因此该列将被编号为`1`、`2`、`3`、`4`，以此类推。

### 向数据表添加 DataColumn 对象

`DataColumn`类型通常不作为独立实体存在；然而，您通常会将它插入到相关的`DataTable`中。例如，创建一个新的`DataTable`对象(稍后将详细介绍)并使用`Columns`属性将每个`DataColumn`对象插入列集合，如下所示:

`static void FillDataSet(DataSet ds):`

`{`

`...`

`// Now add DataColumns to a DataTable.`

`var inventoryTable = new DataTable("Inventory");`

`inventoryTable.Columns.AddRange(new[]`

`{carIDColumn, carMakeColumn, carColorColumn, carPetNameColumn});`

`}`

此时，`DataTable`对象包含四个`DataColumn`对象，表示内存中`Inventory`表的模式。然而，该表目前没有数据，并且该表目前在由`DataSet`维护的表集合之外。您将解决这两个缺点，首先使用`DataRow`对象向表中填充数据。

## 使用数据行

如您所见，`DataColumn`对象的集合代表了`DataTable`的模式。相比之下，`DataRow`对象的集合表示表中的实际数据。因此，如果在`AutoLot`数据库的`Inventory`表中有 20 行，那么可以用 20 个`DataRow`对象来表示这些记录。

表 [22-4](#Tab4) 记录了`DataRow`类型的一些(但不是全部)成员。

表 22-4。

Key Members of the DataRow Type

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `HasErrors GetColumnsInError() GetColumnError() ClearErrors() RowError` | `HasErrors`属性返回一个布尔值，表明`DataRow`中是否有错误。如果是这样，您可以使用`GetColumnsInError()`方法获得有问题的列，使用`GetColumnError()`获得错误描述。类似地，您可以使用`ClearErrors()`方法删除该行的每个错误列表。`RowError`属性允许您为给定的行配置错误的文本描述。 |
| `ItemArray` | 此属性使用对象数组获取或设置此行的所有列值。 |
| `RowState` | 您可以使用这个属性来查明包含`DataRow`的`DataTable`中的`DataRow`的当前状态，使用`RowState`枚举的值(例如，一行可以被标记为新的、已修改的、未更改的或已删除的)。 |
| `Table` | 您使用这个属性来获取对包含这个`DataRow`的`DataTable`的引用。 |
| `AcceptChanges() RejectChanges()` | 这些方法提交或拒绝自上次调用`AcceptChanges()`以来对该行所做的所有更改。 |
| `BeginEdit() EndEdit() CancelEdit()` | 这些方法开始、结束或取消对一个`DataRow`对象的编辑操作。 |
| `Delete()` | 当调用`AcceptChanges()`方法时，该方法标记您想要移除的行。 |
| `IsNull()` | 此方法获取一个值，该值指示指定的列是否包含空值。 |

与`DataRow`一起工作与与`DataColumn`一起工作有点不同；您不能创建此类型的直接实例，因为没有公共构造函数。

`// Error! No public constructor!`

`DataRow r = new DataRow();`

相反，您从给定的`DataTable`中获得一个新的`DataRow`对象。例如，假设您想在`Inventory`表中插入两行。`DataTable.NewRow()`方法允许您获取表中的下一个槽，此时您可以使用类型索引器用新数据填充每一列。这样做时，您可以指定分配给`DataColumn`的字符串名称或者它的(从零开始的)序号位置。

`static void FillDataSet(DataSet ds)`

`{`

`...`

`// Now add some rows to the Inventory Table.`

`DataRow carRow = inventoryTable.NewRow();`

`carRow["Make"] = "BMW";`

`carRow["Color"] = "Black";`

`carRow["PetName"] = "Hamlet";`

`inventoryTable.Rows.Add(carRow);`

`carRow = inventoryTable.NewRow();`

`// Column 0 is the autoincremented ID field,`

`// so start at 1.`

`carRow[1] = "Saab";`

`carRow[2] = "Red";`

`carRow[3] = "Sea Breeze";`

`inventoryTable.Rows.Add(carRow);`

`}`

Note

如果您向`DataRow`的索引器方法传递一个无效的列名或序号位置，您将收到一个运行时异常。

此时，您有一个包含两行的单个`DataTable`。当然，您可以重复这个一般过程来创建许多`DataTable`来定义模式和数据内容。在将`inventoryTable`对象插入到`DataSet`对象之前，您应该检查最重要的`RowState`属性。

### 了解 RowState 属性

当您需要以编程方式确定表中所有行的集合时,`RowState`属性非常有用，这些行是从原始值更改的、新插入的等等。你可以从`DataRowState`枚举中给这个属性赋值，如表 [22-5](#Tab5) 所示。

表 22-5。

Values of the DataRowState Enumeration

<colgroup><col> <col></colgroup> 
| 价值 | 生命的意义 |
| --- | --- |
| `Added` | 该行已被添加到一个`DataRowCollection`中，而`AcceptChanges()`尚未被调用。 |
| `Deleted` | 已经使用`DataRow`的`Delete()`方法将该行标记为删除，并且还没有调用`AcceptChanges()`。 |
| `Detached` | 该行已经创建，但不是任何`DataRowCollection`的一部分。一个`DataRow`在它被创建之后，但是在它被添加到一个集合之前，就处于这种状态。如果它已从集合中移除，它也处于这种状态。 |
| `Modified` | 该行已被修改，`AcceptChanges()`未被调用。 |
| `Unchanged` | 自从上次调用`AcceptChanges()`以来，该行没有改变。 |

当您以编程方式操作给定`DataTable`的行时，`RowState`属性会自动设置。例如，向您的`Program`类添加一个新方法，该方法对一个本地`DataRow`对象进行操作，同时打印出其行状态，如下所示:

`private static void ManipulateDataRowState()`

`{`

`// Create a temp DataTable for testing.`

`var temp = new DataTable("Temp");`

`temp.Columns.Add(new DataColumn("TempColumn", typeof(int)));`

`// RowState = Detached.`

`var row = temp.NewRow();`

`WriteLine($"After calling NewRow(): {row.RowState}");`

`// RowState = Added.`

`temp.Rows.Add(row);`

`WriteLine($"After calling Rows.Add(): {row.RowState}");`

`// RowState = Added.`

`row["TempColumn"] = 10;`

`WriteLine($"After first assignment: {row.RowState}");`

`// RowState = Unchanged.`

`temp.AcceptChanges();`

`WriteLine($"After calling AcceptChanges: {row.RowState}");`

`// RowState = Modified.`

`row["TempColumn"] = 11;`

`WriteLine($"After first assignment: {row.RowState}");`

`// RowState = Deleted.`

`temp.Rows[0].Delete();`

`WriteLine($"After calling Delete: {row.RowState}");`

`}`

Note

记住将`using static System.Console;`添加到这个示例(以及所有其他使用控制台的示例)的代码文件的顶部。

ADO.NET 足够聪明，能够记住当前的事态。考虑到这一点，所属的`DataTable`能够识别哪些行已经被添加、更新或删除。这是`DataSet`的一个关键特性，因为当需要向数据存储发送更新的信息时，只提交修改过的数据。

### 了解 DataRowVersion 属性

除了用`RowState`属性维护行的当前状态之外，`DataRow`对象还使用`DataRowVersion`属性维护它包含的数据的三个可能版本。当第一次构造一个`DataRow`对象时，它只包含数据的一个副本，表示为当前版本。然而，当您以编程方式操作一个`DataRow`对象(使用各种方法调用)时，数据的其他版本就会活跃起来。具体来说，您可以将`DataRowVersion`设置为相关`DataRowVersion`枚举的任意值(见表 [22-6](#Tab6) )。

表 22-6。

Values of the DataRowVersion Enumeration

<colgroup><col> <col></colgroup> 
| 价值 | 生命的意义 |
| --- | --- |
| `Current` | 这表示行的当前值，即使在进行了更改之后。 |
| `Default` | 这是`DataRowState`的默认版本。对于`Added`、`Modified`或`Deleted`的`DataRowState`值，默认版本为`Current`。对于`Detached`的`DataRowState`值，版本为`Proposed`。 |
| `Original` | 这代表第一次插入到`DataRow`中的值或最后一次调用`AcceptChanges()`的值。 |
| `Proposed` | 由于调用了`BeginEdit()`，这是当前正在编辑的行的值。 |

如表 [22-6](#Tab6) 所示，`DataRowVersion`属性的值在很多情况下依赖于`DataRowState`属性的值。如前所述，当您调用`DataRow`(或者，在某些情况下，`DataTable`)对象上的各种方法时，`DataRowVersion`属性将在幕后发生变化。下面是可能影响行的`DataRowVersion`属性值的方法的分类:

*   如果您调用`DataRow.BeginEdit()`方法并更改行的值，那么`Current`和`Proposed`值将变为可用。
*   如果调用`DataRow.CancelEdit()`方法，那么`Proposed`值将被删除。
*   在您调用`DataRow.EndEdit()`之后，`Proposed`值变成了`Current`值。
*   在您调用了`DataRow.AcceptChanges()`方法之后，`Original`值变得与`Current`值相同。当您调用`DataTable.AcceptChanges()`时，会发生相同的转换。
*   在您调用`DataRow.RejectChanges()`之后，`Proposed`值被丢弃，版本变成了`Current`。

是的，这有点复杂，尤其是因为一个`DataRow`在任何给定的时间可能有也可能没有所有的版本(如果您试图获得一个当前没有被跟踪的行版本，您将会收到运行时异常)。不管有多复杂，假设`DataRow`维护三个数据副本，构建一个允许最终用户修改值、改变主意和回滚值或者永久提交值的前端就变得很简单。在本章的剩余部分，你会看到操纵这些方法的各种例子。

## 使用数据表

`DataTable`类型定义了许多成员，其中许多成员在名称和功能上都与`DataSet`的成员相同。表 [22-7](#Tab7) 描述了`Rows`和`Columns`之外的一些`DataTable`型核心成员。

表 22-7。

Key Members of the DataTable Type

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `CaseSensitive` | 指示表中的字符串比较是否区分大小写。默认值为`false`。 |
| `ChildRelations` | 返回此`DataTable`的子关系集合(如果有)。 |
| `Constraints` | 获取由该表维护的约束集合。 |
| `Copy()` | 将给定`DataTable`的模式和数据复制到新实例中的方法。 |
| `DataSet` | 获取包含该表的`DataSet`(如果有)。 |
| `DefaultView` | 获取表的自定义视图，该视图可能包括筛选视图或光标位置。 |
| `ParentRelations` | 获取此`DataTable`的父关系集合。 |
| `PrimaryKey` | 获取或设置作为数据表主键的列数组。 |
| `TableName` | 获取或设置表的名称。这个相同的属性也可能被指定为构造函数参数。 |

继续当前的例子，您可以将`DataTable`的`PrimaryKey`属性设置为`carIDColumn DataColumn`对象。请注意，`PrimaryKey`属性被分配了一个由`DataColumn`对象组成的集合，以解释多列键。然而，在这种情况下，您只需要指定`CarID`列(表中的第一个序号位置)，如下所示:

`static void FillDataSet(DataSet ds)`

`{`

`...`

`// Mark the primary key of this table.`

`inventoryTable.PrimaryKey = new [] { inventoryTable.Columns[0] };`

`}`

### 将数据表插入数据集中

至此，你的`DataTable`对象完成。最后一步是使用`Tables`集合将`DataTable`插入到`carsInventoryDS DataSet`对象中，就像这样:

`static void FillDataSet(DataSet ds)`

`{`

`...`

`// Finally, add our table to the DataSet.`

`ds.Tables.Add(inventoryTable);`

`}`

现在更新您的`Main()`方法来调用`FillDataSet()`，传入您的本地`DataSet`对象作为参数。接下来，将同一个对象传递给一个名为`PrintDataSet()`的新的(尚未编写的)helper 方法，如下所示:

`static void Main(string[] args)`

`{`

`WriteLine("***** Fun with DataSets *****\n");`

`...`

`FillDataSet(carsInventoryDS);`

`PrintDataSet(carsInventoryDS);`

`ReadLine();`

`}`

### 获取数据集中的数据

`PrintDataSet()`方法简单地迭代`DataSet`元数据(使用`ExtendedProperties`集合)和`DataSet`中的每个`DataTable`，使用类型索引器打印出列名和行值。将`System.Collections`的`using`添加到`DictionaryEntry`类型文件的顶部。

`static void PrintDataSet(DataSet ds)`

`{`

`// Print out the DataSet name and any extended properties.`

`WriteLine($"DataSet is named: {ds.DataSetName}");`

`foreach (DictionaryEntry de in ds.ExtendedProperties)`

`{`

`WriteLine($"Key = {de.Key}, Value = {de.Value}");`

`}`

`WriteLine();`

`// Print out each table using rows and columns.`

`foreach (DataTable dt in ds.Tables)`

`{`

`WriteLine($"=> {dt.TableName} Table:");`

`// Print out the column names.`

`for (var curCol = 0; curCol < dt.Columns.Count; curCol++)`

`{`

`Write($"{dt.Columns[curCol].ColumnName}\t");`

`}`

`WriteLine("\n----------------------------------");`

`// Print the DataTable.`

`for (var curRow = 0; curRow < dt.Rows.Count; curRow++)`

`{`

`for (var curCol = 0; curCol < dt.Columns.Count; curCol++)`

`{`

`Write($"{dt.Rows[curRow][curCol]}\t");`

`}`

`WriteLine();`

`}`

`}`

`}`

如果您现在运行您的程序，您将看到以下输出(当然，您的时间戳和 GUID 值会有所不同):

`***** Fun with DataSets *****`

`DataSet is named: Car Inventory`

`Key = TimeStamp, Value = 7/24/2015 6:41:09 AM`

`Key = DataSetID, Value = 11c533ed-d1aa-4c82-96d4-b0f88893ab21`

`Key = Company, Value = Mikko’s Hot Tub Super Store`

`=> Inventory Table:`

`CarID   Make    Color   PetName`

`----------------------------------`

`1       BMW     Black   Hamlet`

`2       Saab    Red     Sea Breeze`

### 使用 DataTableReader 对象处理数据表数据

鉴于您在第 21 章中所做的工作，您应该注意到您使用连接层(如数据读取器对象)和断开层(如`DataSet`对象)处理数据的方式是非常不同的。使用数据读取器通常包括建立一个`while`循环，调用`Read()`方法，并使用索引器提取名称-值对。另一方面，`DataSet`处理通常涉及一系列迭代构造，以钻取到表、行和列中的数据(记住，`DataReader`需要一个开放的数据库连接，以便它可以从实际的数据库中读取数据)。

支持一个名为`CreateDataReader()`的方法。该方法允许您使用类似数据读取器的导航方案在`DataTable`中获取数据(数据读取器现在将从内存`DataTable`中读取数据，而不是从实际的数据库中读取，因此这里不涉及数据库连接)。这种方法的主要好处是，现在您可以使用单一模型来处理数据，而不管您使用 ADO.NET 的哪一层来获取数据。假设您在名为`PrintTable()`的`Program`类中编写了一个新方法，如下所示:

`static void PrintTable(DataTable dt)`

`{`

`// Get the DataTableReader type.`

`DataTableReader dtReader = dt.CreateDataReader();`

`// The DataTableReader works just like the DataReader.`

`while (dtReader.Read())`

`{`

`for (var i = 0; i < dtReader.FieldCount; i++)`

`{`

`Write($"{dtReader.GetValue(i).ToString().Trim()}\t");`

`}`

`WriteLine();`

`}`

`dtReader.Close();`

`}`

请注意，`DataTableReader`的工作方式与您的数据提供者的数据读取器对象相同。当您需要在一个`DataTable`中快速抽取数据，而不需要遍历内部的行和列集合时，一个`DataTableReader`可能是一个理想的选择。现在假设您已经更新了前面的`PrintDataSet()`方法来调用`PrintTable()`，而不是钻取到`Rows`和`Columns`集合。

`static void PrintDataSet(DataSet ds)`

`{`

`// Print out any name and extended properties.`

`WriteLine($"DataSet is named: {ds.DataSetName}");`

`foreach (DictionaryEntry de in ds.ExtendedProperties)`

`{`

`WriteLine($"Key = {de.Key}, Value = {de.Value}");`

`}`

`WriteLine();`

`//Print out each table using data reader`

`foreach (DataTable dt in ds.Tables)`

`{`

`WriteLine($"=> {dt.TableName} Table:");`

`// Print out the column names.`

`for (int curCol = 0; curCol < dt.Columns.Count; curCol++)`

`{`

`Write($"{dt.Columns[curCol].ColumnName.Trim()}\t");`

`}`

`WriteLine("\n----------------------------------");`

`// Call our new helper method.`

`PrintTable(dt);`

`}`

`}`

当您运行应用时，输出与前面显示的相同。唯一的区别是如何在内部访问`DataTable`的内容。

### 将数据表/数据集对象序列化为 XML

`DataSet` s 和`DataTable` s 都支持`WriteXml()`和`ReadXml()`方法。`WriteXml()`允许您将对象的内容作为 XML 文档保存到本地文件(以及任何`System.IO.Stream`派生的类型)。`ReadXml()`允许您从给定的 XML 文档中合成一个`DataSet`(或`DataTable`)的状态。另外，`DataSet` s 和`DataTable` s 都支持`WriteXmlSchema()`和`ReadXmlSchema()`保存或加载`*.xsd`文件。

为了验证这一点，更新您的`Main()`方法来调用下面的 helper 函数(注意，您传递了一个`DataSet`作为唯一的参数):

`static void SaveAndLoadAsXml(DataSet carsInventoryDS)`

`{`

`// Save this DataSet as XML.`

`carsInventoryDS.WriteXml("carsDataSet.xml");`

`carsInventoryDS.WriteXmlSchema("carsDataSet.xsd");`

`// Clear out DataSet.`

`carsInventoryDS.Clear();`

`// Load DataSet from XML file.`

`carsInventoryDS.ReadXml("carsDataSet.xml");`

`}`

如果打开`carsDataSet.xml`文件(可以在项目的`\bin\Debug`文件夹下找到)，您会发现表中的每一列都被编码为一个 XML 元素。

`<?xml version="1.0" standalone="yes"?>`

`<Car_x0020_Inventory>`

`<Inventory>`

`<CarID>1</CarID>`

`<Make>BMW</Make>`

`<Color>Black</Color>`

`<PetName>Hamlet</PetName>`

`</Inventory>`

`<Inventory>`

`<CarID>2</CarID>`

`<Make>Saab</Make>`

`<Color>Red</Color>`

`<PetName>Sea Breeze</PetName>`

`</Inventory>`

`</Car_x0020_Inventory>`

如果您要在 Visual Studio 中双击生成的`*.xsd`文件(也可以在您的`\bin\Debug`文件夹中找到)，您将打开 IDE 的 XML 模式编辑器(参见图 [22-3](#Fig3) )。

![A978-1-4842-1332-2_22_Fig3_HTML.jpg](img/A978-1-4842-1332-2_22_Fig3_HTML.jpg)

图 22-3。

The XSD editor of Visual Studio Note

第 24 章将向您介绍 LINQ 到 XML API，这是在。NET 平台。

### 以二进制格式序列化数据表/数据集对象

也可以将一个`DataSet`(或一个单独的`DataTable`)的内容以紧凑的二进制格式保存。当一个`DataSet`对象需要跨越机器边界时(在分布式应用的情况下)，这尤其有用。XML 数据表示的一个缺点是它的描述性会导致大量的开销。

要以二进制格式保存`DataTable`或`DataSet` s，请将`RemotingFormat`属性设置为`SerializationFormat.Binary`。此时，你可以按预期使用`BinaryFormatter`型(见[第二十章](20.html))。考虑 SimpleDataSet 项目的以下最终方法(不要忘记导入`System.IO`和`System.Runtime.Serialization.Formatters.Binary`名称空间):

`static void SaveAndLoadAsBinary(DataSet carsInventoryDS)`

`{`

`// Set binary serialization flag.`

`carsInventoryDS.RemotingFormat = SerializationFormat.Binary;`

`// Save this DataSet as binary.`

`var fs = new FileStream("BinaryCars.bin", FileMode.Create);`

`var bFormat = new BinaryFormatter();`

`bFormat.Serialize(fs, carsInventoryDS);`

`fs.Close();`

`// Clear out DataSet.`

`carsInventoryDS.Clear();`

`// Load DataSet from binary file.`

`fs = new FileStream("BinaryCars.bin", FileMode.Open);`

`var data = (DataSet)bFormat.Deserialize(fs);`

`}`

如果你从`Main()`调用这个方法，你可以在你的`bin\Debug`文件夹中找到`*.bin`文件。图 [22-4](#Fig4) 显示了`BinaryCars.bin`文件的内容。

![A978-1-4842-1332-2_22_Fig4_HTML.jpg](img/A978-1-4842-1332-2_22_Fig4_HTML.jpg)

图 22-4。

A `DataSet` saved to a binary format Source Code

您可以在 [`Chapter 22`](22.html) 子目录中找到 SimpleDataSet 应用。

## 将 DataTable 对象绑定到 Windows 窗体 GUI

到目前为止，您已经研究了如何使用 ADO.NET 的继承对象模型手动创建、合并和迭代一个`DataSet`对象的内容。虽然理解如何做到这一点非常重要，但是？NET 平台附带了许多 API，这些 API 能够自动将数据绑定到用户界面元素。

例如，最初的 GUI 工具包。NET 的 Windows Forms 提供了一个名为`DataGridView`的控件，该控件包含了只使用几行代码就能显示`DataSet`或`DataTable`对象内容的内置功能。ASP.NET(。NET 的 web 开发 API)和 Windows Presentation Foundation API 也支持数据绑定的概念。在本书的后面，您将学习如何将数据绑定到 ASP.NET 和 WPF GUI 元素；但是，在本章中，您将使用 Windows 窗体，因为它是一个相当简单明了的编程模型。

Note

下一个示例假设您有一些使用 Windows 窗体构建图形用户界面的经验。如果不是这种情况，您可能需要打开解决方案，在阅读完附录 a 后继续或返回到本节。

您的下一个任务是构建一个 Windows 窗体应用，它将在用户界面中显示一个`DataTable`对象的内容。在这个过程中，您还将研究如何过滤和更改表数据。您还将了解到`DataView`对象的作用。

首先创建一个名为 WindowsFormsDataBinding 的新 Windows 窗体项目工作区。使用解决方案浏览器将初始的`Form1.cs`文件重命名为更合适的`MainForm.cs`。使用“属性”窗口将窗体文本更改为 Windows 窗体数据绑定。接下来，使用 Visual Studio 工具箱将位于数据选项卡中的`DataGridView`控件(使用属性窗口的`(Name)`属性重命名为`carInventoryGridView`)拖动到设计器图面上。您可能会注意到，当您第一次在设计器上添加`DataGridView`时，您会激活一个上下文菜单，允许您连接到一个物理数据源。暂时忽略设计器的这一方面，因为您将通过编程方式绑定您的`DataTable`对象。最后，为你的设计者添加一个描述性的`Label`以供参考。图 [22-5](#Fig5) 显示了一种可能的外观和感觉。

![A978-1-4842-1332-2_22_Fig5_HTML.jpg](img/A978-1-4842-1332-2_22_Fig5_HTML.jpg)

图 22-5。

The initial GUI of your Windows Forms application

### 从通用列表中合成数据表

与前面的 SimpleDataSet 示例类似，WindowsFormsDataBinding 应用将构造一个包含一组表示各种数据列和行的`DataColumn`的`DataTable`。然而，这一次，您将使用一个通用的`List<T>`成员变量来填充这些行。首先，在您的项目中插入一个新的 C#类(名为`Car`)，定义如下:

`public class Car`

`{`

`public int Id { get; set; }`

`public string PetName { get; set; }`

`public string Make { get; set; }`

`public string Color { get; set; }`

`}`

在主窗体的默认构造函数中，用一组新的`Car`对象填充一个`List<T>`成员变量(名为`listCars`),如下所示:

`public partial class MainForm : Form`

`{`

`// A collection of Car objects.`

`List<Car> listCars = null;`

`public MainForm()`

`{`

`InitializeComponent();`

`// Fill the list with some cars.`

`listCars = new List<Car>`

`{`

`new Car { Id = 1, PetName = "Chucky", Make = "BMW", Color = "Green" },`

`new Car { Id = 2, PetName = "Tiny", Make = "Yugo", Color = "White" },` `},`

`new Car { Id = 3, PetName = "Ami", Make = "Jeep", Color = "Tan" },`

`new Car { Id = 4, PetName = "Pain Inducer", Make = "Caravan", Color = "Pink" },`

`new Car { Id = 5, PetName = "Fred", Make = "BMW", Color = "Green" },`

`new Car { Id = 6, PetName = "Sidd", Make = "BMW", Color = "Black" },`

`new Car { Id = 7, PetName = "Mel", Make = "Firebird", Color = "Red" },`

`new Car { Id = 8, PetName = "Sarah", Make = "Colt", Color = "Black" },`

`};`

`}`

`}`

接下来，向您的`MainForm`类类型添加一个名为`DataTable`的新成员变量，如下所示:

`public partial class MainForm : Form`

`{`

`// A collection of Car objects.`

`List<Car> listCars = null;`

`// Inventory information.`

`DataTable inventoryTable = new DataTable();`

`...`

`}`

现在向名为`CreateDataTable()`的类添加一个新的助手函数，并在`MainForm`类的默认构造函数中调用这个方法。

`void CreateDataTable()`

`{`

`// Create table schema.`

`var carIDColumn = new DataColumn("Id", typeof(int));`

`var carMakeColumn = new DataColumn("Make", typeof(string));`

`var carColorColumn = new DataColumn("Color", typeof(string));`

`var carPetNameColumn = new DataColumn("PetName", typeof (string))`

`{ Caption = "Pet Name"};`

`inventoryTable.Columns.AddRange(`

`new[] { carIDColumn, carMakeColumn,carColorColumn, carPetNameColumn });`

`// Iterate over the array list to make rows.`

`foreach (var c in listCars)`

`{`

`var newRow = inventoryTable.NewRow();`

`newRow["Id"] = c.Id;`

`newRow["Make"] = c.Make;`

`newRow["Color"] = c.Color;`

`newRow["PetName"] = c.PetName;`

`inventoryTable.Rows.Add(newRow);`

`}`

`// Bind the DataTable to the carInventoryGridView.`

`carInventoryGridView.DataSource = inventoryTable;`

`}`

方法实现首先通过创建四个`DataColumn`对象来创建`DataTable`的模式(为了简单起见，您不需要麻烦自动递增`ID`字段或将其设置为主键)。这样做之后，您可以将它们添加到`DataTable`成员变量的列集合中。使用一个`foreach`迭代结构和原生 ADO.NET 对象模型，将来自`List<Car>`集合的行数据映射到`DataTable`。

但是，请注意，`CreateDataTable()`方法中的最后一个代码语句将`inventoryTable`赋给了`DataGridView`对象的`DataSource`属性。将一个`DataTable`绑定到一个 Windows 窗体`DataGridView`对象只需要设置这个属性。在幕后，这个 GUI 控件在内部读取行和列集合，非常类似于`SimpleDataSet`示例中的`PrintDataSet()`方法。此时，您应该能够运行您的应用并在`DataGridView`控件中看到`DataTable`，如图 [22-6](#Fig6) 所示。

![A978-1-4842-1332-2_22_Fig6_HTML.jpg](img/A978-1-4842-1332-2_22_Fig6_HTML.jpg)

图 22-6。

Binding a DataTable to a Windows Forms DataGridView

### 从数据表中删除行

现在，假设您想更新您的图形界面，以允许用户从内存中删除一行绑定到`DataGridView`的数据。一种方法是调用代表要终止的行的`DataRow`对象的`Delete()`方法。在这种情况下，您指定代表要删除的行的索引(或`DataRow`对象)。为了允许用户指定删除哪一行，向当前设计器添加一个`TextBox`(名为`txtCarToRemove`)和一个`Button`控件(名为`btnRemoveCar`)。图 [22-7](#Fig7) 显示了一个可能的 UI 更新(注意这个例子将两个控件包装在一个`GroupBox`控件中，说明了它们是如何关联的)。

![A978-1-4842-1332-2_22_Fig7_HTML.jpg](img/A978-1-4842-1332-2_22_Fig7_HTML.jpg)

图 22-7。

Updating the UI to enable removal of rows from the underlying DataTable

新的`Button`的`Click`事件处理程序背后的逻辑根据汽车的 ID 从内存`DataTable`中删除用户指定的行。`DataTable`类的`Select()`方法允许您指定一个搜索标准，它是按照普通的 SQL 语法建模的。返回值是匹配搜索标准的一组`DataRow`对象。

`// Remove this row from the DataRowCollection.`

`private void btnRemoveCar_Click (object sender, EventArgs e)`

`{`

`try`

`{`

`// Find the correct row to delete.`

`DataRow[] rowToDelete = inventoryTable.Select($"Id={int.Parse(txtCarToRemove.Text)}");`

`// Delete it!`

`rowToDelete[0].Delete();`

`inventoryTable.AcceptChanges();`

`}`

`catch (Exception ex)`

`{` `{`

`MessageBox.Show(ex.Message);`

`}`

`}`

现在，您应该能够运行您的应用，并指定要从`DataTable`中删除的汽车 ID。当您从`DataTable`中移除`DataRow`对象时，您会注意到网格的 UI 会立即更新；这是因为它被绑定到了`DataTable`对象的状态。

### 基于过滤标准选择行

许多以数据为中心的应用需要查看一小部分`DataTable`数据，这是由某种过滤标准指定的。例如，假设您只想从内存`DataTable`中看到某个汽车品牌(例如，只有宝马)。您已经看到了`DataTable`类的`Select()`方法如何让您找到要删除的行；但是，您也可以使用这种方法获取记录的子集以供显示。

要看到这一点，请再次更新您的 UI，这一次允许用户使用新的`TextBox`(名为`txtMakeToView`)和新的`Button`(名为`btnDisplayMakes`)来指定一个代表他们想要查看的汽车品牌的字符串(见图 [22-8](#Fig8) )。

![A978-1-4842-1332-2_22_Fig8_HTML.jpg](img/A978-1-4842-1332-2_22_Fig8_HTML.jpg)

图 22-8。

Updating the UI to enable row filtering

为了提供不同的选择语义，`Select()`方法已经被重载了很多次。在最基本的层面上，发送给`Select()`的参数是一个包含一些条件操作的字符串。首先，观察新按钮的`Click`事件处理程序的如下逻辑:

`private void btnDisplayMakes_Click(object sender, EventArgs e)`

`{`

`// Build a filter based on user input.`

`string filterStr = $"Make=’{txtMakeToView.Text}’";`

`// Find all rows matching the filter.`

`DataRow[] makes = inventoryTable.Select(filterStr);`

`// Show what we got!`

`if (makes.Length == 0)`

`MessageBox.Show("Sorry, no cars...", "Selection error!");`

`else`

`{`

`string strMake = null;`

`for (var i = 0; i < makes.Length; i++)`

`{`

`strMake += makes[i]["PetName"] + "\n";`

`}`

`// Now show all matches in a message box.`

`MessageBox.Show(strMake,$"We have {txtMakeToView.Text}s named:");`

`}`

`}`

`}`

这里，首先基于相关的`TextBox`中的值构建一个简单的过滤器。如果在过滤器文本框中指定 BMW，它将创建一个相当于`Make = ’BMW’`的过滤器。当你将这个过滤器发送给`Select()`方法时，你会得到一个`DataRow`类型的数组，代表匹配过滤器的每一行(见图 [22-9](#Fig9) )。

![A978-1-4842-1332-2_22_Fig9_HTML.jpg](img/A978-1-4842-1332-2_22_Fig9_HTML.jpg)

图 22-9。

Displaying filtered data

同样，过滤逻辑基于标准的 SQL 语法。例如，假设您想根据宠物名，按字母顺序获取前面的`Select()`调用的结果。就 SQL 而言，这转化为基于`PetName`列的排序。幸运的是，`Select()`方法已经被重载来发送一个排序标准。

`// Sort by PetName.`

`makes = inventoryTable.Select(filterStr, "PetName");`

调用`Select()`，如下所示，如果您想要结果以降序排列:

`// Return results in descending order.`

`makes = inventoryTable.Select(filterStr, "PetName DESC");`

通常，排序字符串包含列名，后跟`ASC`(升序，这是默认设置)或`DESC`(降序)。如有必要，可以用逗号分隔多列。最后，要理解过滤器字符串可以由任意数量的关系操作符组成。例如，假设您想要查找 ID 大于 5 的所有汽车。这个帮助器函数可以让您完成以下任务:

`private void ShowCarsWithIdGreaterThanFive()`

`{`

`// Now show the pet names of all cars with ID greater than 5.`

`DataRow[] properIDs;`

`string``newFilterStr`T2】

`properIDs = inventoryTable.Select(newFilterStr);`

`string strIDs = null;`

`for(int i = 0; i < properIDs.Length; i++)`

`{`

`DataRow temp = properIDs[i];`

`strIDs += $"{temp["PetName"]} is ID {temp["ID"]}\n";`

`}`

`MessageBox.Show(strIDs, "Pet names of cars where ID > 5");`

`}`

### 更新数据表中的行

您应该了解的`DataTable`的最后一个方面是用新值更新现有行的过程。一种方法是首先使用`Select()`方法获得匹配给定过滤标准的行。一旦你得到有问题的`DataRow`(或`DataRow`)后，相应地修改它们。例如，假设您的表单上有一个名为`btnChangeMakes`的新的`Button`，它(当被单击时)在`DataTable`中搜索所有`Make`等于`BMW`的行。一旦确定了这些项目，就将`Make`从`BMW`更改为`Yugo`，如下所示:

`// Find the rows you want to edit with a filter.`

`private void btnChangeMakes_Click(object sender, EventArgs e)`

`{`

`// Make sure user has not lost his or her mind.`

`if (DialogResult.Yes !=`

`MessageBox.Show("Are you sure?? BMWs are much nicer than Yugos!",`

`"Please Confirm!", MessageBoxButtons.YesNo)) return;`

`// Build a filter.`

`string filterStr = "Make=’BMW’";`

`// Find all rows matching the filter.`

`DataRow[] makes = inventoryTable.Select(filterStr);`

`// Change all Beemers to Yugos!`

`for (int i = 0; i < makes.Length; i++)`

`{`

`makes[i]["Make"] = "Yugo";`

`}`

`}`

### 使用数据视图类型

视图对象是一个表(或一组表)的替代表示。例如，您可以使用 Microsoft SQL Server 为您的`Inventory`表创建一个视图，该视图返回一个只包含给定颜色的汽车的新表。在 ADO.NET，`DataView`类型允许您以编程方式从`DataTable`中提取数据子集到一个独立的对象中。

持有同一个表的多个视图的一个很大的优点是，您可以将这些视图绑定到各种 GUI 部件(比如`DataGridView`)。例如，一个`DataGridView`可能被绑定到一个显示`Inventory`中所有汽车的`DataView`，而另一个可能被配置为只显示绿色汽车。

要看到这一点，用一个名为`dataGridYugosView`的额外的`DataGridView`类型和一个描述性的`Label`来更新当前的 UI。接下来，定义一个名为`yugosOnlyView`的`DataView`类型的成员变量。

`public partial class MainForm : Form`

`{`

`// View of the DataTable.`

`DataView yugosOnlyView;`

`...`

`}`

现在创建一个名为`CreateDataView()`的新帮助函数，并在`DataTable`完全构建后立即在表单的默认构造函数中调用该方法，如下所示:

`public MainForm()`

`{`

`...`

`// Make a data table.`

`CreateDataTable();`

`// Make a view.`

`CreateDataView();`

`}`

下面是这个新助手函数的实现。请注意，`DataView`的构造函数已经被传递了`DataTable`，您将使用它来构建自定义的数据行集。

`private void CreateDataView()` `()`

`{`

`// Set the table that is used to construct this view.`

`yugosOnlyView = new DataView(inventoryTable);`

`// Now configure the views using a filter.`

`yugosOnlyView.RowFilter = "Make = ’Yugo’";`

`// Bind to the new grid.`

`dataGridYugosView.DataSource = yugosOnlyView;`

`}`

如您所见，`DataView`类支持一个名为`RowFilter`的属性，该属性包含表示用于提取匹配行的过滤标准的字符串。建立视图后，相应地设置网格的`DataSource`属性。图 [22-10](#Fig10) 显示了运行中的完整的 Windows 窗体数据绑定应用。

![A978-1-4842-1332-2_22_Fig10_HTML.jpg](img/A978-1-4842-1332-2_22_Fig10_HTML.jpg)

图 22-10。

Displaying a unique view of your data Source Code

可以在 [`Chapter 22`](22.html) 子目录中找到 WindowsFormsDataBinding 项目。

## 使用数据适配器

现在您已经理解了手动操作 ADO.NET 的来龙去脉，是时候将注意力转向数据适配器对象这个主题了。数据适配器是一个用`DataTable`对象填充`DataSet`的类；这个类还可以将修改后的`DataTable`发送回数据库进行处理。表 [22-8](#Tab8) 记录了`DbDataAdapter`基类的核心成员，每个数据适配器对象的公共父对象(例如`SqlDataAdapter`和`OdbcDataAdapter`)。

表 22-8。

Core Members of the DbDataAdapter Class

<colgroup><col> <col></colgroup> 
| 成员 | 生命的意义 |
| --- | --- |
| `Fill()` | 执行 SQL SELECT 命令(由`SelectCommand`属性指定)来查询数据库中的数据，并将数据加载到`DataTable`中。 |
| `SelectCommand InsertCommand UpdateCommand DeleteCommand` | 建立当调用`Fill()`和`Update()`方法时将向数据存储发出的 SQL 命令。 |
| `Update()` | 执行 SQL INSERT、UPDATE 和 DELETE 命令(由`InsertCommand`、`UpdateCommand`和`DeleteCommand`属性指定)来保存对数据库的`DataTable`更改。 |

注意，数据适配器定义了四个属性:`SelectCommand`、`InsertCommand`、`UpdateCommand`和`DeleteCommand`。当您为特定的数据提供者(例如，`SqlDataAdapter`)创建数据适配器对象时，您可以传入一个`string`，它表示由`SelectCommand`的命令对象使用的命令文本。

假设四个命令对象中的每一个都已经正确配置，那么您可以调用`Fill()`方法来获得一个`DataSet`(或者一个单独的`DataTable`，如果您愿意的话)。为此，您让数据适配器执行由`SelectCommand`属性指定的 SQL SELECT 语句。

类似地，如果您想将修改后的`DataSet`(或`DataTable`)对象持久化回数据库，您可以调用`Update()`方法，该方法将根据`DataTable`中每一行的状态使用任何剩余的命令对象(稍后您将了解更多)。

使用数据适配器对象的一个最奇怪的方面是，您从来不需要打开或关闭到数据库的连接。相反，数据库的底层连接是代表您进行管理的。但是，您仍然需要为数据适配器提供有效的连接对象或连接字符串(您将使用它们在内部构建连接对象),以便准确地通知数据适配器您想要与哪个数据库进行通信。

Note

数据适配器本质上是不可知的。您可以动态地插入不同的连接对象和命令对象，并从各种数据库中获取数据。例如，一个`DataSet`可以包含从 SQL Server、Oracle 和 MySQL 数据库提供者那里获得的表数据。

### 一个简单的数据适配器示例

下一步是向您在[第 21 章](21.html)中创建的数据访问库组件(`AutoLotDAL.dll`)添加新功能。您将首先创建一个简单的示例，使用 ADO.NET 数据适配器对象用一个表填充一个`DataSet`。

创建一个名为 FillDataSetUsingSqlDataAdapter 的新控制台应用项目，并将`System.Data`、`System.Data.SqlClient`、`and System.Collections`名称空间导入到初始 C#代码文件中。现在如下更新您的`Main()`方法(您可能需要根据您在[第 21 章](21.html)中如何创建`AutoLot`数据库来更改连接字符串):

`static void Main(string[] args)`

`{`

`WriteLine("***** Fun with Data Adapters *****\n");`

`// Hard-coded connection string.`

`string connectionString = "Integrated Security = SSPI;Initial Catalog=AutoLot;" +`

`@"Data Source=(local)\SQLEXPRESS2014";`

`// Caller creates the DataSet object.`

`DataSet ds = new DataSet("AutoLot");`

`// Inform adapter of the Select command text and connection.`

`SqlDataAdapter adapter =`

`new SqlDataAdapter("Select * From Inventory", connectionString);`

`// Fill our DataSet with a new table, named Inventory.`

`adapter.Fill(ds, "Inventory");`

`// Display contents of DataSet.`

`PrintDataSet(ds);`

`ReadLine();`

`}`

请注意，您通过指定一个将映射到 SQL SELECT 语句的字符串来构造数据适配器。您将使用该值在内部构建一个命令对象，稍后您可以使用`SelectCommand`属性获得该对象。

接下来，注意创建一个`DataSet`类型的实例是调用者的工作，它被传递到`Fill()`方法中。或者，您可以将用于设置新的`DataTable`的`TableName`属性的字符串名称作为第二个参数传递给`Fill()`方法(如果您没有指定表名，数据适配器将简单地将表命名为`Table`)。在大多数情况下，您分配给一个`DataTable`的名称将与关系数据库中物理表的名称相同；然而，这不是必需的。

Note

`Fill()`方法返回一个整数，表示 SQL 查询返回的行数。

最后，请注意，您没有在`Main()`方法中的任何地方显式地打开或关闭到数据库的连接。在从`Fill()`方法返回之前，预先编程给定数据适配器的`Fill()`方法来打开然后关闭底层连接。因此，当您将`DataSet`传递给`PrintDataSet()`方法(在本章前面已经实现，并且包含在这里供您参考)时，您是在对断开连接的数据的本地副本进行操作，不会产生获取数据的往返行程。

`static void PrintDataSet(DataSet ds)`

`{`

`// Print out any name and extended properties.`

`WriteLine($"DataSet is named: {ds.DataSetName}");`

`foreach (DictionaryEntry de in ds.ExtendedProperties)`

`{`

`WriteLine($"Key = {de.Key}, Value = {de.Value}");`

`}`

`WriteLine();`

`foreach (DataTable dt in ds.Tables)`

`{`

`WriteLine($"=> {dt.TableName} Table:");`

`// Print out the column names.`

`for (int curCol = 0; curCol < dt.Columns.Count; curCol++)`

`{`

`Write(dt.Columns[curCol].ColumnName + "\t");`

`}`

`WriteLine("\n----------------------------------");`

`// Print the DataTable.`

`for (int curRow = 0; curRow < dt.Rows.Count; curRow++)`

`{`

`for (int curCol = 0; curCol < dt.Columns.Count; curCol++)`

`{`

`Write(dt.Rows[curRow][curCol].ToString().Trim() + "\t");`

`}`

`WriteLine();`

`}`

`}`

`}`

### 将数据库名称映射到友好名称

如前所述，数据库管理员倾向于创建对最终用户不友好的表名和列名(例如，`au_id`、`au_fname`或`au_lname`)。好消息是数据适配器对象维护了一个内部强类型集合(名为`DataTableMappingCollection`)的`System.Data.Common.DataTableMapping`对象。您可以使用数据适配器对象的`TableMappings`属性来访问这个集合。

如果您愿意，您可以操作这个集合来通知一个`DataTable`当被要求打印其内容时应该使用哪个显示名称。例如，假设出于显示目的，您想要将表名`Inventory`映射到`Current Inventory`。例如，假设您想将`CarID`列名显示为`Car ID`(注意多余的空格)，将`PetName`列名显示为`Name of Car`。为此，在调用数据适配器对象的`Fill()`方法之前添加以下代码(确保导入`System.Data.Common`名称空间以获得`DataTableMapping`类型的定义):

`static void Main(string[] args)`

`{`

`...`

`// Now map DB column names to user-friendly names.`

`DataTableMapping tableMapping =`

`adapter.TableMappings.Add("Inventory", "Current Inventory");`

`tableMapping.ColumnMappings.Add("CarId", "Car Id");`

`tableMapping.ColumnMappings.Add("PetName", "Name of Car");`

`dAdapt.Fill(ds, "Inventory");`

`...`

`}`

如果您再次运行这个程序，您会发现`PrintDataSet()`方法现在显示了`DataTable`和`DataRow`对象的友好名称，而不是由数据库模式建立的名称。

`***** Fun with Data Adapters *****`

`DataSet is named:` `AutoLot`

`=> Current Inventory Table:`

`Car ID  Make    Color     Name of Car`

`----------------------------------`

`1       VW      Black     Zippy`

`2       Ford    Rust      Rusty`

`3       Saab    Black     Mel`

`4       Yugo    Yellow    Clunker`

`5       BMW     Black     Bimmer`

`6       BMW     Green` `Hank`

`7       BMW     Pink      Pinkey`

Source Code

您可以在 [`Chapter 22`](22.html) 子目录中找到 FillDataSetUsingSqlDataAdapter 项目。

## 向 AutoLotDAL.dll 添加断开连接的功能

为了说明使用数据适配器将一个`DataTable`中的更改推回数据库进行处理的过程，您现在将更新在[第 21 章](21.html)中创建的`AutoLotDAL.dll`程序集，以包含一个新的名称空间(名为`AutoLotDisconnectedLayer`)。这个名称空间包含一个新类`InventoryDALDC`，它使用一个数据适配器与一个`DataTable`进行交互。您可以继续在 AutoLotDAL 项目中工作。在下载的本章代码中，下一个例子是在 AutoLotDAL(版本二)中。

### 定义初始类类型

使用“项目➤新文件夹”菜单选项添加新文件夹。将该文件夹命名为`DisconnectedLayer`。在这个新文件夹中，使用项目➤添加类菜单选项插入一个名为`InventoryDALDC (for` `D` `is` `C` `onnected)`的新类。接下来，在新代码文件中添加`public to the`类类型。导入`System.Data.SqlClient`名称空间。

与以连接为中心的`InventoryDAL`类型不同，这个新类不需要提供自定义的打开/关闭方法，因为数据适配器会自动处理细节。

首先添加一个定制的构造函数，该构造函数设置一个表示连接字符串的私有`string`变量。此外，定义一个私有的`SqlDataAdapter`成员变量，您可以通过调用一个名为`ConfigureAdapter()`的(尚未创建的)帮助器方法来配置它，该方法带有一个`SqlDataAdapter`输出参数。

`namespace AutoLotDAL2.DisconnectedLayer`

`{`

`public class InventoryDALDC`

`{`

`// Field data.`

`private string _connectionString;`

`private SqlDataAdapter _adapter = null;`

`public InventoryDALDC(string connectionString)`

`{`

`_connectionString = connectionString;`

`// Configure the SqlDataAdapter.`

`ConfigureAdapter(out _adapter);`

`}`

`}`

`}`

### 使用 SqlCommandBuilder 配置数据适配器

当您使用数据适配器来修改`DataSet`中的表时，首先要做的是用有效的命令对象分配`UpdateCommand`、`DeleteCommand`和`InsertCommand`属性(在您这样做之前，这些属性返回`null`引用)。

为`InsertCommand`、`UpdateCommand`和`DeleteCommand`属性手动配置命令对象可能需要大量代码，尤其是在使用参数化查询的情况下。回想一下第 21 章中的内容，参数化查询允许您使用一组参数对象构建 SQL 语句。因此，如果您要走很长的路，您可以实现`ConfigureAdapter()`来手动创建三个新的`SqlCommand`对象，每个对象包含一组`SqlParameter`对象。此时，您可以将每个对象设置为适配器的`UpdateCommand`、`DeleteCommand`和`InsertCommand`属性。

Visual Studio 提供了几个设计器工具来代表您处理这些平凡而乏味的代码。根据您使用的 API，这些设计器略有不同(例如，Windows 窗体、WPF 或 ASP。NET)，但它们的总体功能是相似的。您将在本书中看到使用这些设计器的示例，包括本章后面的一些 Windows 窗体设计器。

此时，您不需要编写大量代码语句来完全配置数据适配器；相反，您可以通过如下方式实现`ConfigureAdapter()`来获得一个巨大的捷径:

`private void ConfigureAdapter(out SqlDataAdapter adapter)`

`{`

`// Create the adapter and set up the SelectCommand.`

`adapter = new SqlDataAdapter("Select * From Inventory", _connectionString);`

`// Obtain the remaining command objects dynamically at runtime`

`// using the SqlCommandBuilder.`

`var builder = new SqlCommandBuilder(adapter);`

`}`

为了简化数据适配器对象的构造，Microsoft 提供的每个 ADO.NET 数据提供程序都提供了一个命令生成器类型。根据初始的`SelectCommand`,`SqlCommandBuilder`自动生成包含在`SqlDataAdapter`的`InsertCommand`、`UpdateCommand`和`DeleteCommand`属性中的值。这里的好处是您不需要手工构建所有的`SqlCommand`和`SqlParameter`类型。

这里有一个明显的问题:命令构建器如何能够动态地构建这些 SQL 命令对象？简单的答案是元数据。当您在运行时调用数据适配器的`Update()`方法时，相关的命令生成器将读取数据库的模式数据，以自动生成底层的插入、删除和更新命令对象。

显然，这样做需要额外的远程数据库往返行程；这意味着如果你在一个应用中多次使用`SqlCommandBuilder`将会影响性能。这里，您通过在构造`InventoryDALDC`对象时调用您的`ConfigureAdapter()`方法来最小化负面影响，并在对象的整个生命周期中保留已配置的`SqlDataAdapter`。

在前面的代码片段中，除了将数据适配器对象作为构造函数参数传入之外，您没有使用 command builder 对象(在本例中为`SqlCommandBuilder`)。虽然这看起来很奇怪，但这是你必须做的事情(至少)。在幕后，这种类型用剩余的命令对象配置数据适配器。

虽然您可能喜欢不劳而获的想法，但是您应该理解命令构建器有一些重要的限制。具体来说，只有满足以下所有条件，命令生成器才能自动生成供数据适配器使用的 SQL 命令:

*   SQL SELECT 命令只与单个表交互(例如，没有连接)。
*   单个表被赋予了一个主键。
*   该表必须有一列或多列表示包含在 SQL SELECT 语句中的主键。

基于您构建`AutoLot`数据库的方式，这些限制不会造成任何问题。但是，在更具工业强度的数据库中，您将需要考虑这种类型是否有用(如果没有，请记住，Visual Studio 将使用各种数据库设计工具自动生成大量所需的代码，您将在后面看到)。

### 实现 GetAllInventory()

既然您的数据适配器已经准备好了，那么您的新类类型的第一个方法将使用`SqlDataAdapter`对象的`Fill()`方法来获取一个代表`AutoLot`数据库的`Inventory`表中所有记录的`DataTable`，就像这样:

`public DataTable GetAllInventory()`

`{`

`DataTable inv = new DataTable("Inventory");`

`_adapter.Fill(inv);`

`return inv;`

`}`

### 实现 UpdateInventory()

`UpdateInventory()`方法很简单，如下所示:

`public void UpdateInventory(DataTable modifiedTable)`

`{`

`_adapter.Update(modifiedTable);`

`}`

这里，数据适配器对象检查传入的`DataTable`的每一行的`RowState`值。基于这个值(例如，`RowState.Added`、`RowState.Deleted`或`RowState.Modified`，正确的命令对象在幕后被利用。

### 设置您的版本号

太好了。至此，数据访问库的第二个版本的逻辑就完成了。不要求您这样做，但是将这个库的版本号设置为 2.0.0.0，只是为了便于管理。如第 14 章中所述，您可以通过双击解决方案浏览器的属性节点，然后单击位于应用选项卡中的汇编信息按钮来更改. NET 汇编的版本。在出现的对话框中，将装配版本的主版本号设置为`2`的值(详见第 14 章中的[)。完成此操作后，重新编译应用以更新程序集清单。](14.html)

Source Code

你可以在 [`Chapter 22`](22.html) 子目录中找到 AutoLotDAL2 项目。

### 测试断开的功能

此时，您可以构建一个前端来测试您的新`InventoryDALDC`类。同样，您将使用 Windows 窗体 API 在图形用户界面上显示数据。创建一个名为 InventoryDALDisconnectedGUI 的新 Windows 窗体应用，使用解决方案资源管理器将初始的`Form1.cs`文件更改为`MainForm.cs`，并将窗体的 Text 属性设置为清单表的简单 GUI 前端。创建项目后，设置对更新后的`AutoLotDAL.dll`程序集的引用(确保选择版本 2.0.0.0！)并导入以下命名空间:

`using AutoLotDAL2.DisconnectedLayer;`

表单的设计由一个单独的`Label`、`DataGridView`(名为`inventoryGrid`)和`Button`控件(名为`btnUpdateInventory`)组成，您可以配置它们来处理`Click`事件。下面是表单的定义:

`public partial class MainForm : Form`

`{`

`InventoryDALDC _dal = null;`

`public MainForm()`

`{`

`InitializeComponent();`

`string cnStr =`

`@"Data Source=(local)\SQLEXPRESS2014;Initial Catalog=AutoLot;" +`

`"Integrated Security=True;Pooling=False";`

`// Create our data access object.`

`_dal = new InventoryDALDC(cnStr);`

`// Fill up our grid!`

`inventoryGrid.DataSource = _dal.GetAllInventory();`

`}`

`private void btnUpdateInventory_Click(object sender, EventArgs e)`

`{`

`// Get modified data from the grid.`

`DataTable changedDT = (DataTable)inventoryGrid.DataSource;`

`try`

`{`

`// Commit our changes.`

`_dal.UpdateInventory(changedDT);`

`inventoryGrid.DataSource = _dal.GetAllInventory();`

`}`

`catch(Exception ex)`

`{`

`MessageBox.Show(ex.Message);`

`}`

`}`

`}`

创建了`InventoryDALDC`对象后，可以将从`GetAllInventory()`返回的`DataTable`绑定到`DataGridView`对象。当用户点击更新按钮时，您从网格中提取修改后的`DataTable`(带有`DataSource`属性)并将其传递到您的`UpdateInventory()`方法中。

就这样！运行该应用后，向网格中添加一组新行，并更新/删除其他几行。假设您单击了`Button`控件，您将看到您的更改已经保存到了`AutoLot`数据库中。由于数据绑定使用 Windows 窗体的方式，您需要在网格上重置数据源，以便更改立即显示出来。正如您将看到的，当您使用 Windows Presentation Foundation(WPF)构建应用时，Observable 模式修复了这种行为。

Source Code

您可以在 [`Chapter 22`](22.html) 子目录中找到更新后的 InventoryDALDisconnectedGUI 项目。

## 多表数据集对象和数据关系

到目前为止，本章的所有例子都是在一个单独的`DataTable`对象上操作的。然而，当一个`DataSet`对象包含许多相互关联的`DataTable`时，断开层的威力就显现出来了。在这种情况下，您可以在`DataSet`的`DataRelation`集合中定义任意数量的`DataRelation`对象，以考虑表的相互依赖性。客户端层可以使用这些对象在表数据之间导航，而不会导致网络往返。

Note

这个例子没有更新`AutoLotDAL.dll`来解释`Customers`和`Orders`表，而是在一个新的 Windows 窗体项目中隔离所有的数据访问逻辑。但是，不建议在生产级应用中混合 UI 和数据逻辑。本章的最后几个例子利用各种数据库设计工具将 UI 逻辑从数据逻辑代码中分离出来。

首先创建一个名为 MultitabledDataSetApp 的新 Windows 窗体应用。GUI 非常简单(注意，我将初始的`Form1.cs`文件名改为`MainForm.cs`，将`text`属性改为`AutoLot Database Manipulator`)。在图 [22-11](#Fig11) 中，您可以看到三个`DataGridView`小部件(`dataGridViewInventory`、`dataGridViewCustomers`和`dataGridViewOrders`)，它们保存从`AutoLot`数据库的`Inventory`、`Customers`和`Orders`表中检索到的数据。此外，最初的`Button`(名为`btnUpdateDatabase`)将网格中输入的所有更改提交给数据库，以便使用数据适配器对象进行处理。

![A978-1-4842-1332-2_22_Fig11_HTML.jpg](img/A978-1-4842-1332-2_22_Fig11_HTML.jpg)

图 22-11。

The initial UI will display data from each table of the AutoLot database

### 准备数据适配器

为了使数据访问代码尽可能简单，`MainForm`将使用 command builder 对象为三个`SqlDataAdapter`中的每一个自动生成 SQL 命令(每个表一个)。下面是对`Form`派生类型的初始更新(不要忘记导入`System.Data.SqlClient`名称空间):

`public partial class MainForm : Form`

`{`

`// Form wide DataSet.`

`private DataSet _autoLotDs = new DataSet("AutoLot");`

`// Make use of command builders to simplify data adapter configuration.`

`private SqlCommandBuilder _sqlCbInventory;`

`private SqlCommandBuilder _sqlCbCustomers;`

`private SqlCommandBuilder _sqlCbOrders;`

`// Our data adapters (for each table).`

`private SqlDataAdapter _invTableAdapter;`

`private SqlDataAdapter _custTableAdapter;`

`private SqlDataAdapter _ordersTableAdapter;`

`// Form wide connection string.`

`private string _connectionString;`

`...`

`}`

构造函数完成创建以数据为中心的成员变量和填充`DataSet`的繁重工作。本例假设您已经创作了一个包含正确连接字符串数据的`App.config`文件(并且您已经引用了`System.Configuration.dll`并导入了`System.Configuration`名称空间)，如下例所示:

`<configuration>`

`<startup>`

`<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6" />`

`</startup>`

`<connectionStrings>`

`<add name ="AutoLotSqlProvider" connectionString =`

`"Data Source=(local)\SQLEXPRESS2014;`

`Integrated Security=SSPI;Initial Catalog=AutoLot"`

`/>`

`</connectionStrings>`

`</configuration>`

还要注意，您包含了对私有助手函数`BuildTableRelationship()`的调用，如下所示:

`public MainForm()`

`{`

`InitializeComponent();`

`// Get connection string.`

`_connectionString =`

`ConfigurationManager.ConnectionStrings["AutoLotSqlProvider"]`

`.ConnectionString;`

`// Create adapters.`

`_invTableAdapter = new SqlDataAdapter(`

`"Select * from Inventory", _connectionString);`

`_custTableAdapter = new SqlDataAdapter(`

`"Select * from Customers", _connectionString);`

`_ordersTableAdapter = new SqlDataAdapter(`

`"Select * from Orders", _connectionString);`

`// Autogenerate commands.`

`_sqlCbInventory = new SqlCommandBuilder(_invTableAdapter);`

`_sqlCbOrders = new SqlCommandBuilder(_ordersTableAdapter);`

`_sqlCbCustomers = new SqlCommandBuilder(_custTableAdapter);`

`// Fill tables in DataSet.`

`_invTableAdapter.Fill(_autoLotDs, "Inventory");`

`_custTableAdapter.Fill(_autoLotDs, "Customers");`

`_ordersTableAdapter.Fill(_autoLotDs, "Orders");`

`// Build relations between tables.`

`BuildTableRelationship();`

`// Bind to` `grids`

`dataGridViewInventory.DataSource = _autoLotDs.Tables["Inventory"];`

`dataGridViewCustomers.DataSource = _autoLotDs.Tables["Customers"];`

`dataGridViewOrders.DataSource = _autoLotDs.Tables["Orders"];`

`}`

### 构建表关系

`BuildTableRelationship()`助手函数完成了将两个`DataRelation`对象添加到`autoLotDS`对象中的繁重工作。回想一下《T4》第 21 章中的内容，即`AutoLot`数据库表达了许多父子关系，您可以用下面的代码来说明:

`private void BuildTableRelationship()`

`{`

`//Create CustomerOrder data relation object.`

`DataRelation dr = new DataRelation("CustomerOrder",`

`_autoLotDs.Tables["Customers"].Columns["CustID"],`

`_autoLotDs.Tables["Orders"].Columns["CustID"]);`

`_autoLotDs.Relations.Add(dr);`

`// Create InventoryOrder data relation object.`

`dr = new DataRelation("InventoryOrder",`

`_autoLotDs.Tables["Inventory"].Columns["CarID"],`

`_autoLotDs.Tables["Orders"].Columns["CarID"]);`

`_autoLotDs.Relations.Add(dr);`

`}`

请注意，当您创建一个`DataRelation`对象时，您用第一个参数建立了一个友好的字符串名字(您将在一分钟内看到这样做的有用性)。您还可以建立用于构建关系本身的密钥。请注意，父表(第二个构造函数参数)被指定在子表(第三个构造函数参数)之前。

### 更新数据库表

现在`DataSet`已经被来自数据源的数据填充，您可以本地操作每个`DataTable`。为此，运行应用并插入、更新或删除三个`DataGridView`中任意一个的值。当您准备好提交数据进行处理时，单击更新按钮。此时，您会发现很容易理解相关的`Click`事件背后的代码。

`private void btnUpdateDatabase_Click(object sender, EventArgs e)`

`{`

`try`

`{`

`_invTableAdapter.Update(_autoLotDs, "Inventory");`

`_custTableAdapter.Update(_autoLotDs, "Customers");`

`_ordersTableAdapter.Update(_autoLotDs, "Orders");`

`}`

`catch (Exception ex)`

`{`

`MessageBox.Show(ex.Message);`

`}`

`}`

现在运行您的应用并执行各种更新。当您重新运行应用时，您应该会发现您的网格中填充了最近的更改。

### 在相关表格之间导航

现在让我们看看`DataRelation`如何允许您以编程方式在相关的表之间移动。扩展您的 UI，使其包含一个新的`Button`(名为`btnGetOrderInfo`)、一个相关的`TextBox`(名为`txtCustID`)和一个描述性的`Label`(您可以将这些控件组合在一个`GroupBox`中，以增加视觉吸引力)。

图 [22-12](#Fig12) 显示了应用的一个可能的用户界面。

![A978-1-4842-1332-2_22_Fig12_HTML.jpg](img/A978-1-4842-1332-2_22_Fig12_HTML.jpg)

图 22-12。

The updated UI allows the user to look up customer order information

这个更新后的 UI 允许用户输入客户的 ID，并检索关于该客户订单的所有相关信息(例如，`name`、`order ID`和`car order`)。这些信息将被格式化成一个`string`类型，最终显示在一个消息框中。考虑新的`Button`的`Click`事件处理程序背后的以下代码:

`private void btnGetOrderInfo_Click(object sender, EventArgs e)`

`{`

`string strOrderInfo = string.Empty;`

`// Get the customer ID in the text box.`

`int custID = int.Parse(txtCustID.Text);`

`// Now based on custID, get the correct row in Customers table.`

`var drsCust = _autoLotDs.Tables["Customers"].Select($"CustID = {custID}");`

`strOrderInfo +=`

`$"Customer {drsCust[0]["CustID"]}: {drsCust[0]["FirstName"].ToString().Trim()} {drsCust[0]["LastName"].ToString().Trim()}\n";`

`// Navigate from customer table to order table.`

`var drsOrder = drsCust[0].GetChildRows(_autoLotDs.Relations["CustomerOrder"]);`

`// Loop through all orders for this customer.`

`foreach (DataRow order in drsOrder)`

`{`

`strOrderInfo += $"----\nOrder Number: {order["OrderID"]}\n";`

`// Get the car referenced by this order.`

`DataRow[] drsInv = order.GetParentRows(_autoLotDs.Relations["InventoryOrder"]);`

`// Get info for (SINGLE) car info for this order.`

`DataRow car = drsInv[0];`

`strOrderInfo += $"Make: {car["Make"]}\n";`

`strOrderInfo += $"Color: {car["Color"]}\n";`

`strOrderInfo += $"Pet Name: {car["PetName"]}\n";`

`}`

`MessageBox.Show(strOrderInfo, "Order Details");`

`}`

图 [22-13](#Fig13) 显示了用值`3`指定客户 ID 时的一个可能输出(根据`AutoLot`数据库表中的数据，您的输出可能会有所不同)。

![A978-1-4842-1332-2_22_Fig13_HTML.jpg](img/A978-1-4842-1332-2_22_Fig13_HTML.jpg)

图 22-13。

Navigating data relations

前面的例子可能会让你相信`DataSet`类的用处。假设`DataSet`与底层数据源完全断开连接，您可以使用内存中的数据副本，并在每个表中导航，以进行任何必要的更新、删除或插入，而不会导致数据库的任何往返。完成此操作后，您可以将更改提交到数据存储进行处理。最终结果是一个可伸缩的和健壮的应用。

Source Code

您可以在 [`Chapter 22`](22.html) 子目录中找到 MultitabledDataSetApp 项目。

## Windows 窗体数据库设计器工具

到目前为止，所有的例子都涉及到大量的工作，因为您必须手工编写所有的数据访问逻辑。虽然您确实将大量代码卸载到. NET 代码库(`AutoLotDAL.dll`)以便在本书后面的章节中重用，但是在与关系数据库交互之前，您仍然必须手动创建数据提供者的各种对象。本章的下一个任务是了解如何使用各种 Windows 窗体数据库设计器工具，这些工具可以为您生成大量的数据访问代码。

使用这些集成工具的一种方法是使用 Windows 窗体`DataGridView`控件支持的设计器。这种方法的问题是数据库设计工具会将所有的数据访问代码直接嵌入到您的 GUI 代码库中！理想情况下，您希望将所有这些设计器生成的代码隔离在一个专用的。NET 代码库，所以您可以轻松地跨多个项目重用您的数据库访问逻辑。

尽管如此，考虑到这种方法在小规模项目和应用原型中确实有一些用处，从如何使用`DataGridView`控件来生成所需的数据访问代码开始研究可能会有所帮助。此后，您将学习如何将相同的设计者生成的代码隔离到第三个版本的`AutoLotDAL.dll`中。

### 可视化设计 DataGridView

`DataGridView`控件有一个相关的向导，可以为您生成数据访问代码。首先创建一个名为 DataGridViewDataDesigner 的新 Windows 窗体应用项目。使用解决方案资源管理器将初始表单重命名为`MainForm.cs`，将`Text`设置为`Windows Forms Data Wizards`，然后向初始表单添加一个`DataGridView`控件的实例(名为`inventoryDataGridView`)。当您选择您的`DataGridView`控件时，一个内联编辑器应该在控件的右侧打开(如果没有，只需单击控件右上角的小“三角形”按钮)。从选择数据源下拉框中，选择添加项目数据源链接(参见图 [22-14](#Fig14) )。

![A978-1-4842-1332-2_22_Fig14_HTML.jpg](img/A978-1-4842-1332-2_22_Fig14_HTML.jpg)

图 22-14。

The DataGridView editor

这将启动数据源配置向导。该工具引导您完成一系列步骤，允许您选择和配置数据源，然后您可以将其绑定到`DataGridView`。向导的第一步要求您确定要与之交互的数据源类型。选择数据库(见图 [22-15](#Fig15) )并点击下一步按钮。

![A978-1-4842-1332-2_22_Fig15_HTML.jpg](img/A978-1-4842-1332-2_22_Fig15_HTML.jpg)

图 22-15。

Selecting the type of data source

下一步(根据您在步骤 1 中的选择略有不同)询问使用什么类型的数据库模型。只有当您将实体框架添加到项目中时，您才会看到数据集数据库模型。选择数据集数据库模型(参见图 [22-16](#Fig16) )。

![A978-1-4842-1332-2_22_Fig16_HTML.jpg](img/A978-1-4842-1332-2_22_Fig16_HTML.jpg)

图 22-16。

Choosing the database model

下一步允许您配置数据库连接。如果当前有一个数据库添加到服务器资源管理器中，您应该会发现它会自动列在下拉列表中。如果不是这样(或者如果您需要连接到以前没有添加到服务器资源管理器中的数据库)，请单击“新建连接”按钮。图 [22-17](#Fig17) 显示了选择`AutoLot`本地实例的结果。

![A978-1-4842-1332-2_22_Fig17_HTML.jpg](img/A978-1-4842-1332-2_22_Fig17_HTML.jpg)

图 22-17。

Choosing the database

在向导的下一步中，将询问您是否要将连接字符串保存在应用配置文件中，如图 [22-18](#Fig18) 所示。选择保存连接字符串，然后单击“下一步”按钮。

![A978-1-4842-1332-2_22_Fig18_HTML.jpg](img/A978-1-4842-1332-2_22_Fig18_HTML.jpg)

图 22-18。

Saving the connection string in the app.config file

在最后一步，您选择将由自动生成的`DataSet`和相关数据适配器负责的数据库对象。虽然您可以选择`AutoLot`数据库的每个数据对象，但是这里您只关心`Inventory`表。鉴于此，将`DataSet`的建议名称改为`InventoryDataSet`(见图 [22-19](#Fig19) )，检查`Inventory`表，并点击完成按钮。

![A978-1-4842-1332-2_22_Fig19_HTML.jpg](img/A978-1-4842-1332-2_22_Fig19_HTML.jpg)

图 22-19。

Selecting the Inventory table

完成此操作后，您将看到可视化设计器在许多方面都得到了更新。最显著的变化是`DataGridView`显示了`Inventory`表的模式，如列标题所示。此外，您将在表单设计器的底部看到三个组件(在称为组件托盘的区域):一个`DataSet`组件、一个`BindingSource`组件和一个`TableAdapter`组件(参见图 [22-20](#Fig20) )。

![A978-1-4842-1332-2_22_Fig20_HTML.jpg](img/A978-1-4842-1332-2_22_Fig20_HTML.jpg)

图 22-20。

Your Windows Forms project, after running the Data Source Configuration Wizard

此时，您可以运行您的应用，您瞧，网格中充满了`Inventory`表的记录！当然，在这种情况下没有魔法可言。IDE 已经为您编写了大量代码，并设置了网格控件来使用它。让我们深入研究一下这些自动生成的代码。

### 生成的 App.config 文件

如果您检查您的解决方案资源管理器，您会发现您的项目现在包含一个`App.config`文件，该文件包含一个`<connectionStrings>`元素，该元素被赋予了一个有点特殊的名称，如下所示:

`<?xml version="1.0" encoding="utf-8" ?>`

`<configuration>`

`<configSections>`

`</configSections>`

`<connectionStrings>`

`<add name="DataGridViewDataDesigner.Properties.Settings.AutoLotConnectionString"`

`connectionString="Data Source=.\SQLEXPRESS2014;Initial Catalog=AutoLot;Integrated Security=True"`

`providerName="System.Data.SqlClient" />`

`</connectionStrings>`

`<startup>`

`<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6" />`

`</startup>`

`</configuration>`

自动生成的数据适配器对象(稍后您将了解更多)使用长值`"DataGridViewDataDesigner.Properties.Settings.AutoLotConnectionString"`。

### 检查强类型数据集

除了配置文件之外，数据向导工具还生成了所谓的强类型数据集。这个术语描述了一个自定义类，它扩展了`DataSet`并公开了许多成员，这些成员允许您使用更直观的对象模型与数据库进行交互。例如，强类型的`DataSet`对象包含直接映射到数据库表名的属性。因此，您可以使用`Inventory`属性直接获取行和列，而不必使用`Tables`属性钻取表的集合。

如果您在项目中插入一个新的类图文件，您会注意到向导已经创建了一个名为`InventoryDataSet`的类。这个类定义了一些成员，其中最重要的是一个名为`Inventory`的属性(见图 [22-21](#Fig21) )。

![A978-1-4842-1332-2_22_Fig21_HTML.jpg](img/A978-1-4842-1332-2_22_Fig21_HTML.jpg)

图 22-21。

The Data Source Configuration Wizard created a strongly typed DataSet

如果您在解决方案资源管理器中双击`InventoryDataSet.xsd`文件，您将加载 Visual Studio 数据集设计器(稍后您将了解有关该设计器的更多详细信息)。如果右键单击该设计器中的任意位置并选择“查看代码”选项，您会注意到下面相当空的分部类定义:

`partial class InventoryDataSet {`

`}`

如果需要，您可以向该分部类定义中添加自定义成员；然而，真正的动作发生在设计者维护的文件`InventoryDataSet.Designer.cs`中。如果您使用解决方案资源管理器打开这个文件，您将会看到`InventoryDataSet`扩展了`DataSet`父类。考虑下面的部分代码，为了清楚起见添加了注释:

`// This is all designer-generated code!`

`public partial class InventoryDataSet : global::System.Data.DataSet`

`{`

`// A member variable of type InventoryDataTable.`

`private InventoryDataTable tableInventory;`

`// Each constructor calls a helper method named InitClass().`

`public InventoryDataSet()`

`{`

`...`

`this.InitClass();`

`...`

`}`

`// InitClass() preps the DataSet and adds the InventoryDataTable`

`// to the Tables collection.`

`private void InitClass()`

`{`

`this.DataSetName = "InventoryDataSet";`

`this.Prefix = "";`

`this.Namespace = "`[`http://tempuri.org/InventoryDataSet.xsd`](http://tempuri.org/InventoryDataSet.xsd)T2】

`this.EnforceConstraints = true;`

`this.SchemaSerializationMode =`

`global::System.Data.SchemaSerializationMode.IncludeSchema;`

`this.tableInventory = new InventoryDataTable();`

`base.Tables.Add(this.tableInventory);`

`}`

`// The read-only Inventory property` `returns`

`// the InventoryDataTable member variable.`

`public InventoryDataTable Inventory`

`{`

`get { return this.tableInventory; }`

`}`

`}`

请注意，您的强类型`DataSet`有一个成员变量是强类型数据表；在这种情况下，该类被命名为`InventoryDataTable`。强类型`DataSet`类的构造函数调用一个名为`InitClass()`的私有初始化方法，该方法将这个强类型`DataTable`的实例添加到`DataSet`的`Tables`集合中。最后但同样重要的是，注意到`Inventory`属性的实现返回了`InventoryDataTable`成员变量。

### 检查强类型数据表

现在返回到类图文件，打开 InventoryDataSet 图标上的嵌套类型节点。这里你会看到名为`InventoryDataTable`的强类型`DataTable`类和名为`InventoryRow`的强类型`DataRow`类。

`InventoryDataTable`类(与您所研究的强类型`DataSet`的成员变量类型相同)定义了一组属性，这些属性基于物理`Inventory`表的列名(`CarIDColumn`、`ColorColumn`、`MakeColumn`和`PetNameColumn`)，以及一个定制索引器和一个`Count`属性来获取当前记录数。

更有趣的是，这个强类型的`DataTable`类定义了一组方法，允许您使用强类型成员在表中插入、定位和删除行(这是手动导航`Rows`和`Columns`索引器的一个有吸引力的替代方法)。例如，`AddInventoryRow()`让你向内存中的表添加一个新的记录行，`FindByCarID()`让你根据表的主键进行查找，`RemoveInventoryRow()`让你从强类型表中删除一行(见图 [22-22](#Fig22) )。

![A978-1-4842-1332-2_22_Fig22_HTML.jpg](img/A978-1-4842-1332-2_22_Fig22_HTML.jpg)

图 22-22。

The strongly typed DataTable is nested in the strongly typed DataSet

### 检查强类型数据行

强类型的`DataRow`类也嵌套在强类型的`DataSet`中，它扩展了`DataRow`类并公开了直接映射到`Inventory`表模式的属性。此外，数据设计器工具创建了一个方法(`IsPetNameNull()`)，该方法将检查该列是否有值(参见图 [22-23](#Fig23) )。

![A978-1-4842-1332-2_22_Fig23_HTML.jpg](img/A978-1-4842-1332-2_22_Fig23_HTML.jpg)

图 22-23。

The strongly typed `DataRow`

### 检查强类型数据适配器

为断开连接的类型进行强类型化是使用数据源配置向导的一个实实在在的好处，因为手动创建这些类会很繁琐(但完全有可能)。这个向导生成了一个定制的数据适配器对象，可以用强类型的方式填充和更新`InventoryDataSet`和`InventoryDataTable`对象。在可视化类设计器上找到`InventoryTableAdapter`，检查图 [22-24](#Fig24) 中生成的成员。

![A978-1-4842-1332-2_22_Fig24_HTML.jpg](img/A978-1-4842-1332-2_22_Fig24_HTML.jpg)

图 22-24。

A customized data adapter that operates on the strongly typed DataSet and DataTable

自动生成的`InventoryTableAdapter`类型维护了一个`SqlCommand`对象的集合(可以使用`CommandCollection`属性来访问它)，每个对象都有一组完全填充的`SqlParameter`对象。此外，这个自定义数据适配器提供了一组属性来提取基础连接、事务和数据适配器对象，还提供了一个属性来获取表示每个命令类型的数组。

### 完成 Windows 窗体应用

如果您检查表单派生类型的`Load`事件处理程序(换句话说，如果您查看`MainForm.cs`的代码并找到`MainForm_Load()`方法)，您会发现自定义表格适配器的`Fill()`方法在启动时被调用，传入由自定义`DataSet`维护的自定义`DataTable`。

`private void MainForm_Load(object sender, EventArgs e)`

`{`

`this.inventoryTableAdapter.Fill(this.inventoryDataSet.Inventory);`

`}`

您可以使用这个自定义数据适配器对象来更新对网格的更改。用单个`Button`控件(名为`btnUpdateInventory`)更新表单的 UI。接下来，处理`Click`事件，并在事件处理程序中编写以下代码:

`private void btnUpdateInventory_Click(object sender, EventArgs e)`

`{`

`try`

`{`

`// Save changes with the Inventory table back to the database.`

`this.inventoryTableAdapter.Update(this.inventoryDataSet.Inventory);`

`}`

`catch(Exception ex)`

`{`

`MessageBox.Show(ex.Message);`

`}`

`// Get fresh copy for grid.`

`this.inventoryTableAdapter.Fill(this.inventoryDataSet.Inventory);`

`}`

再次运行您的应用；添加、删除或更新网格中显示的记录。然后单击更新按钮。当您再次运行该程序时，您会发现您的更改已经存在并得到了解释。

太好了。这个例子显示了`DataGridView`控件设计器是多么有用。它允许您处理强类型数据，并代表您生成大部分必要的数据库逻辑。明显的问题是这段代码与使用它的窗口紧密相连。理想情况下，这种代码属于您的`AutoLotDAL.dll`程序集(或其他一些数据访问库)。然而，您可能想知道如何在类库项目中获得使用`DataGridView`的关联向导生成的代码，因为默认情况下没有表单设计器。

Source Code

您可以在 [`Chapter 22`](22.html) 子目录中找到 DataGridViewDataDesigner 项目。

## 将强类型数据库代码隔离到类库中

幸运的是，您可以从任何类型的项目(基于 UI 的项目或其他项目)中激活 Visual Studio 的数据设计工具，而无需在项目之间复制和粘贴大量代码。您可以通过向`AutoLotDAL.dll`添加更多功能来看到这一点。您可以继续使用现有项目。在下载的本章代码中，下一节的代码位于一个名为 AutoLotDAL3.dll 的独立项目中。

在项目中创建一个名为 DataSets 的新文件夹，并使用项目➤的 Add New Item 菜单选项将一个新的强类型`DataSet`类(名为`AutoLotDataSet.xsd`)插入到新文件夹中(要快速找到`DataSet`项目类型，请选择 New Item 对话框的 Data 部分；参见图 [22-25](#Fig25) 。

![A978-1-4842-1332-2_22_Fig25_HTML.jpg](img/A978-1-4842-1332-2_22_Fig25_HTML.jpg)

图 22-25。

Inserting a new strongly typed DataSet

这将打开一个空白数据集设计器图面。此时，您可以使用服务器资源管理器连接到一个给定的数据库(您应该已经有一个到`AutoLot`的连接),然后将您想要的每个表和存储过程拖放到`DataSet`中的设计图面上。在图 [22-26](#Fig26) 中，你可以看到`AutoLot`的自定义方面被考虑，并且它们的关系被自动实现(这个例子没有在`CreditRisk`表上拖动)。

![A978-1-4842-1332-2_22_Fig26_HTML.jpg](img/A978-1-4842-1332-2_22_Fig26_HTML.jpg)

图 22-26。

Your custom strongly typed types, this time within a Class Library project

### 查看生成的代码

`DataSet`设计器创建了与前面的 Windows 窗体示例中的`DataGridView`向导相同的代码。然而，这一次您考虑了`Inventory`、`Customers`和`Orders`表，以及`GetPetName`存储过程，因此您有了更多生成的类。基本上，您拖到设计器表面上的每个数据库表都为您提供了包含在强类型`DataSet`中的`DataTable`、`DataRow`和数据适配器类。

强类型的`DataSet`、`DataTable`和`DataRow`类将被放入项目的根名称空间(`AutoLotDAL`)。自定义表适配器将被放置在嵌套的名称空间中。您可以通过使用类视图工具最容易地查看所有生成的类型，您可以从 Visual Studio 视图菜单中打开该工具(参见图 [22-27](#Fig27) )。

![A978-1-4842-1332-2_22_Fig27_HTML.jpg](img/A978-1-4842-1332-2_22_Fig27_HTML.jpg)

图 22-27。

The autogenerated strongly typed data of the AutoLot database

为了完整起见，你可能想要使用 Visual Studio 属性编辑器(详见[第 14 章](14.html))来设置`AutoLotDAL.dll`到`3.0.0.0`的最新版本。

Source Code

你可以在 [`Chapter 22`](22.html) 子目录中找到 AutoLotDAL3 项目。

### 用生成的代码选择数据

此时，您可以在任何。需要与`AutoLot`数据库通信的. NET 应用。为了确保您理解基本的机制，创建一个名为 StronglyTypedDataSetConsoleClient 的控制台应用项目。接下来，添加对最新最好版本的`AutoLotDAL3.dll`的引用，并将`AutoLotDAL3.DataSets`、`AutoLotDAL3.DataSets.AutoLotDataSetTableAdapters`和`static System.Console`名称空间导入到初始 C#代码文件中。

这里有一个`Main()`方法，它使用`InventoryTableAdapter`对象来检索`Inventory`表中的所有数据。请注意，您不需要指定连接字符串，因为该信息现在是强类型对象模型的一部分。填写完表格后，使用名为`PrintInventory()`的辅助方法打印结果。注意，您可以使用`Rows`和`Columns`集合操作强类型`DataTable`，就像操作“普通的”`DataTable`一样。

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Strongly Typed DataSets *****\n");`

`// Caller creates the DataSet object.`

`var table = new AutoLotDataSet.InventoryDataTable();`

`// Inform adapter of the Select command text and connection.`

`var adapter = new InventoryTableAdapter();`

`// Fill our DataSet with a new table, named Inventory.`

`adapter.Fill(table);`

`PrintInventory(table);    Console.ReadLine();`

`}`

`static void PrintInventory(AutoLotDataSet.InventoryDataTable dt)`

`{`

`// Print out the column names.`

`for (int curCol = 0; curCol < dt.Columns.Count; curCol++)`

`{`

`Write(dt.Columns[curCol].ColumnName + "\t");`

`}`

`WriteLine("\n----------------------------------");`

`// Print the DataTable.`

`for (int curRow = 0; curRow < dt.Rows.Count; curRow++)`

`{`

`for (int curCol = 0; curCol < dt.Columns.Count; curCol++)`

`{`

`Write(dt.Rows[curRow][curCol] + "\t");`

`}`

`WriteLine();`

`}`

`}`

`}`

### 用生成的代码插入数据

现在假设您想使用这种强类型对象模型插入新记录。下面的 helper 函数向当前的`InventoryDataTable`添加两个新行，然后使用数据适配器更新数据库。您通过配置强类型的`DataRow`来手动添加第一行；您通过传入所需的列数据来添加第二行，这允许在后台自动创建`DataRow`。

`public static void AddRecords(`

`AutoLotDataSet.InventoryDataTable table,`

`InventoryTableAdapter adapter)`

`{`

`try`

`{`

`// Get a new strongly typed row from the table.`

`AutoLotDataSet.InventoryRow newRow = table.NewInventoryRow();`

`// Fill row with some sample data.`

`newRow.Color = "Purple";`

`newRow.Make = "BMW";`

`newRow.PetName = "Saku";`

`// Insert the new row.`

`table.AddInventoryRow(newRow);`

`// Add one more row, using overloaded Add method.`

`table.AddInventoryRow("Yugo", "Green", "Zippy");`

`// Update database.`

`adapter.Update(table);`

`}`

`catch (Exception ex)`

`{`

`WriteLine(ex.Message);`

`}`

`}`

`Main()`方法可以调用这个方法；这样做可以用这些新记录更新数据库表。

`static void Main(string[] args)`

`{`

`...`

`// Add rows, update, and reprint.`

`AddRecords(table, adapter);`

`table.Clear();`

`adapter.Fill(table);`

`PrintInventory(table);`

`Console.ReadLine();`

`}`

### 使用生成的代码删除数据

用这种强类型对象模型删除记录也很简单。强类型`DataTable`的自动生成的`FindBy` `XXXX` `()`方法(其中`XXXX`是主键列的名称)使用主键返回正确的(强类型)`DataRow`。下面是另一个 helper 方法，它删除了您刚刚创建的两条记录:

`private static void RemoveRecords(`

`AutoLotDataSet.InventoryDataTable table, InventoryTableAdapter adapter)`

`{`

`try`

`{`

`AutoLotDataSet.InventoryRow rowToDelete = table.FindByCarId(1);`

`adapter.Delete(rowToDelete.CarId, rowToDelete.Make, rowToDelete.Color,`

`rowToDelete.PetName);`

`rowToDelete = table.FindByCarId(2);`

`adapter.Delete(rowToDelete.CarId, rowToDelete.Make, rowToDelete.Color,`

`rowToDelete.PetName);`

`}`

`catch (Exception ex)`

`{`

`WriteLine(ex.Message);`

`}`

`}`

如果您从您的`Main()`方法调用它并重新打印该表，您应该会发现这两个测试记录不再显示。

Note

如果想让这个例子更加灵活，可以使用`Console`类从用户那里收集数据。

### 使用生成的代码调用存储过程

让我们再看一个使用强类型对象模型的例子。在这种情况下，您创建了一个调用`GetPetName`存储过程的最终方法。当创建用于`AutoLot`数据库的数据适配器时，有一个名为`QueriesTableAdapter`的特殊类，顾名思义，它封装了在关系数据库中调用存储过程的过程。当从`Main()`调用时，最后一个辅助函数显示指定汽车的名称:

`public static void CallStoredProc()`

`{`

`try`

`{`

`var queriesTableAdapter = new QueriesTableAdapter();`

`Write("Enter ID of car to look up: ");`

`string carID = ReadLine() ?? "0";`

`string carName = "";`

`queriesTableAdapter.GetPetName(int.Parse(carID), ref carName);`

`WriteLine($"CarID {carID} has the name of {carName}");`

`}`

`catch(Exception ex)`

`{`

`Console.WriteLine(ex.Message);`

`}`

`}`

至此，您知道了如何使用强类型数据库类型并将它们打包到专用类库中。您可以找到这个对象模型的更多方面，但是如果您感兴趣的话，您应该可以更深入地研究。作为本章的总结，您将学习如何对 ADO.NET`DataSet`对象应用 LINQ 查询。

Source Code

您可以在 [`Chapter 22`](22.html) 子目录中找到 strong typeddatasetconsoleclient 项目。

## 使用 LINQ 到数据集编程

在本章中您已经看到，您可以用三种不同的方式操作`DataSet`中的数据:

*   通过使用`Tables`、`Rows`和`Columns`集合
*   通过使用数据表读取器
*   通过使用强类型数据类

当您使用`DataSet`和`DataTable`类型的各种索引器时，您可以以一种直接但松散类型的方式与包含的数据进行交互。回想一下，这种方法要求您将数据视为表格形式的单元格块，如下例所示:

`static void PrintDataWithIndxers(DataTable dt)`

`{`

`// Print the DataTable.`

`for (int curRow = 0; curRow < dt.Rows.Count; curRow++)`

`{`

`for (int curCol = 0; curCol < dt.Columns.Count; curCol++)`

`{`

`Write(dt.Rows[curRow][curCol + "\t");`

`}`

`WriteLine();`

`}`

`}`

`DataTable`类型的`CreateDataReader()`方法提供了第二种方法，在这种方法中，您可以将`DataSet`中的数据视为一组线性的行，以顺序的方式进行处理。这允许您将连接的数据读取器编程模型应用于断开的`DataSet`。

`static void PrintDataWithDataTableReader(DataTable dt)`

`{`

`// Get the DataTableReader type.`

`DataTableReader dtReader = dt.CreateDataReader();`

`while (dtReader.Read())`

`{`

`for (int i = 0; i < dtReader.FieldCount; i++)`

`{`

`Write($"{dtReader.GetValue(i)}\t");`

`}`

`WriteLine();`

`}`

`dtReader.Close();`

`}`

最后，您可以使用强类型的`DataSet`生成一个代码库，允许您使用映射到关系数据库中的列名的属性与对象中的数据进行交互。使用强类型对象允许您创作如下代码:

`static void AddRowWithTypedDataSet()`

`{`

`InventoryTableAdapter invDA = new InventoryTableAdapter();`

`AutoLotDataSet.InventoryDataTable inv = invDA.GetData();`

`inv.AddInventoryRow("Ford", "Yellow", "Sal");`

`invDA.Update(inv);`

`}`

虽然所有这些方法都有它们的位置，但 LINQ 转数据集 API 提供了另一种使用 LINQ 查询表达式操作`DataSet`数据的选择。

Note

您使用 LINQ 到数据集 API 将 LINQ 查询仅应用于由数据适配器返回的`DataSet`对象，但是这与将 LINQ 查询直接应用于数据库引擎无关。第 23 章将向你介绍 ADO.NET 实体框架，它提供了一种将 SQL 查询表示为 LINQ 查询的方法。

开箱即用，ADO.NET`DataSet`(以及相关类型如`DataTable`和`DataView`)不具备成为 LINQ 查询直接目标的必要基础设施。例如，下面的方法(使用`AutoLotDisconnectedLayer`名称空间中的类型)会导致编译时错误:

`static void LinqOverDataTable()`

`{`

`// Get a DataTable of data.`

`InventoryDALDC dal = new InventoryDALDC(`

`@"Data Source=(local)\SQLEXPRESS2014;Initial Catalog=AutoLot;Integrated Security=True");`

`DataTable data = dal.GetAllInventory();`

`// Apply a LINQ query to the DataSet?`

`var moreData = from c in data where (int)c["CarID"] > 5 select c;`

`}`

如果您要编译`LinqOverDataTable()`方法，编译器会通知您`DataTable`类型提供了一个查询模式实现。与对没有实现`IEnumerable<T>`的对象应用 LINQ 查询的过程类似，ADO.NET 对象必须被转换成兼容的类型。理解如何做到这一点需要检查`System.Data.DataSetExtensions.dll`的类型。

### 数据集扩展库的作用

在所有 Visual Studio 项目中默认引用的`System.Data.DataSetExtensions.dll`程序集，用一些新的类型扩充了`System.Data`命名空间(参见图 [22-28](#Fig28) )。

![A978-1-4842-1332-2_22_Fig28_HTML.jpg](img/A978-1-4842-1332-2_22_Fig28_HTML.jpg)

图 22-28。

The System.Data.DataSetExtensions.dll assembly

目前最有用的两种类型是`DataTableExtensions`和`DataRowExtensions`。这些类通过使用一组扩展方法来扩展`DataTable`和`DataRow`的功能(见[第 12 章](12.html))。另一个关键类是`TypedTableBaseExtensions`，它定义了扩展方法，您可以将这些方法应用到强类型的`DataSet`对象，以使内部的`DataTable`对象能够感知 LINQ。在`System.Data.DataSetExtensions.dll`程序集内的所有剩余成员都是纯粹的基础结构，它们不打算直接在您的代码库中使用。

### 获取 LINQ 兼容的数据表

现在让我们看看如何使用`DataSet`扩展。假设您有一个名为 LinqToDataSetApp 的新 C#控制台应用项目。添加对最新最好版本(`3.0.0.0`)的`AutoLotDAL.dll`程序集的引用，并使用以下逻辑更新您的初始代码文件:

`using System;`

`...`

`// Location of strongly typed data containers.`

`using AutoLotDAL3.DataSets;`

`// Location of strongly typed data adapters.`

`using AutoLotDAL3.DataSets.AutoLotDataSetTableAdapters;`

`using static System.Console;`

`namespace LinqToDataSetApp`

`{`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`WriteLine("***** LINQ over DataSet *****\n");`

`// Get a strongly typed DataTable containing the current Inventory`

`// of the AutoLot database.`

`AutoLotDataSet dal = new AutoLotDataSet();`

`InventoryTableAdapter tableAdapter = new InventoryTableAdapter();`

`AutoLotDataSet.InventoryDataTable data = tableAdapter.GetData();`

`// Invoke the methods that follow here!`

`ReadLine();`

`}`

`}`

`}`

当你想把一个 ADO.NET`DataTable`(包括一个强类型的`DataTable`)转换成一个 LINQ 兼容的对象时，你必须调用由`DataTableExtensions`类型定义的`AsEnumerable()`扩展方法。这将返回一个包含一组`DataRow`的`EnumerableRowCollection`对象

然后，您可以使用基本的`DataRow`语法(例如，索引器语法)使用`EnumerableRowCollection`类型对每一行进行操作。考虑您的`Program`类的以下新方法，它采用强类型`DataTable`，获得数据的可枚举副本，并打印出每个`CarID`值:

`static void PrintAllCarIDs(DataTable data)`

`{`

`// Get enumerable version of DataTable.`

`EnumerableRowCollection enumData = data.AsEnumerable();`

`// Print the car ID values.`

`foreach (DataRow r in enumData)`

`{`

`WriteLine($"Car ID = {r["CarID"]}");`

`}`

`}`

此时，您还没有应用 LINQ 查询；然而，这里的要点是,`enumData`对象现在可以成为 LINQ 查询表达式的目标。再次注意到，`EnumerableRowCollection`包含了一个`DataRow`对象的集合，因为您针对每个子对象应用了一个类型索引器来打印出`CarID`列的值。

在大多数情况下，您不需要声明一个类型为`EnumerableRowCollection`的变量来保存`AsEnumerable()`的返回值。相反，您可以从查询表达式本身调用该方法。这里有一个更有趣的`Program`类的方法，它从`DataTable`中颜色为黑色的所有条目中获得一个`CarID + Makes`的投影(如果在`Inventory`表中没有任何黑色汽车，则根据需要更新这个 LINQ 查询):

`static void ShowRedCars(DataTable data)`

`{`

`// Project a new result set containing`

`// the ID/color for rows where Color = Red.`

`var cars = from car in data.AsEnumerable()`

`where`

`(string)car["Color"] == "Black"`

`select new`

`{`

`ID = (int)car["CarID"],`

`Make = (string)car["Make"]`

`};`

`WriteLine("Here are the red cars we have in stock:");`

`foreach (var item in cars)`

`{`

`WriteLine($"-> CarID = {item.ID} is {item.Make}");`

`}`

`}`

### DataRowExtensions 的作用。字段<t>()扩展方法</t>

当前 LINQ 查询表达式的一个不好的方面是，您使用了大量的转换操作和`DataRow`索引器来收集结果集，如果您试图转换为不兼容的数据类型，这可能会导致运行时异常。要在查询中注入一些强类型，可以使用`DataRow`类型的`Field<T>()`扩展方法。这样做可以提高查询的类型安全性，因为数据类型的兼容性是在编译时检查的。考虑以下更新:

`var cars = from car in data.AsEnumerable()`

`where`

`car.Field<string>("Color") == "Black"`

`select new`

`{`

`ID = car.Field<int>("CarID"),`

`Make = car.Field<string>("Make")`

`};`

在这种情况下，您可以调用`Field<T>()`并指定一个类型参数来表示列的底层数据类型。作为该方法的一个参数，可以传入列名本身。考虑到额外的编译时检查，在处理`EnumerableRowCollection`的角色时，您应该考虑使用`Field<T>()`(而不是`DataRow`索引器)的最佳实践。

除了调用`AsEnumerable()`方法之外，LINQ 查询的整体格式与你在[第 13 章](13.html)中看到的完全相同。鉴于此，没有理由在这里重复各种 LINQ 算子的细节。如果您想查看更多示例，可以在中查找主题“LINQ 到数据集的示例”。NET Framework 4.5 SDK 文档。

### 从 LINQ 查询中合成新的数据表

基于 LINQ 查询的结果，如果您没有使用投影，也可以很容易地填充新的`DataTable`的数据。当您有一个底层类型可以表示为`IEnumerable<T>`的结果集时，您可以对结果调用`CopyToDataTable<T>()`扩展方法，如下例所示:

`static void BuildDataTableFromQuery(DataTable data)`

`{`

`var cars = from car in data.AsEnumerable()`

`where car.Field<int>("CarID") > 5`

`select car;`

`// Use this result set to build a new DataTable.`

`DataTable newTable = cars.CopyToDataTable();`

`// Print the DataTable.`

`for (int curRow = 0; curRow < newTable.Rows.Count; curRow++)`

`{`

`for (int curCol = 0; curCol < newTable.Columns.Count; curCol++)`

`{`

`Write(newTable.Rows[curRow][curCol].ToString().Trim() + "\t");`

`}`

`WriteLine();`

`}`

`}`

Note

还可以通过使用`AsDataView<T>()`扩展方法将 LINQ 查询转换为`DataView`类型。

当您希望将 LINQ 查询的结果用作数据绑定操作的源时，您可能会发现这种技术很有帮助。回想一下，Windows 窗体的`DataGridView`(以及 ASP.NET 或 WPF 网格控件)支持名为`DataSource`的属性。您可以将 LINQ 结果绑定到格网，如下所示:

`// Assume myDataGrid is a GUI-based grid object.`

`myDataGrid.DataSource = (from car in data.AsEnumerable()`

`where car.Field<int>("CarID") >` `5`

`select car).` `CopyToDataTable();`

这就结束了对 ADO.NET 分离层的研究。使用 API 的这一方面，您可以从关系数据库中获取数据，咀嚼数据，然后返回数据进行处理，同时尽可能短时间地保持数据库连接打开。

Source Code

您可以在 [`Chapter 22`](22.html) 子目录中找到 LinqToDataSetApp 示例。

## 摘要

这一章深入研究了 ADO.NET 分离层的细节。如您所见，断开层的核心是`DataSet`。这种类型是任意数量的表和任意数量的可选相互关系、约束和表达式的内存表示。在本地表上建立关系的好处在于，当与远程数据存储断开连接时，您可以通过编程方式在它们之间导航。

在本章中，您还研究了数据适配器类型的作用。使用这种类型(以及相关的`SelectCommand`、`InsertCommand`、`UpdateCommand`和`DeleteCommand`属性)，适配器可以用原始数据存储解决`DataSet`中的变化。您还学习了如何使用强力手动方法导航`DataSet`的对象模型，以及使用强类型对象，这通常是 Visual Studio 的数据集设计器工具生成的。

最后，您看了 LINQ 技术集的一个方面，名为 LINQ 到数据集。这允许您获得一个可查询的`DataSet`副本，它可以接收格式良好的 LINQ 查询。