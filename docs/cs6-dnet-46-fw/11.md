# 11.高级 C#语言功能

在本章中，您将通过研究一些更高级的主题来加深对 C#编程语言的理解。首先，您将学习如何实现和使用索引器方法。这种 C#机制使您能够构建自定义类型，这些自定义类型使用类似数组的语法提供对内部子项的访问。在您学习了如何构建索引器方法之后，您将看到如何重载各种操作符(`+`、`-`、`<`、`>`等等)，以及如何为您的类型创建自定义的显式和隐式转换例程(您将了解为什么您可能想要这样做)。

接下来，您将研究在使用以 LINQ 为中心的 API 时特别有用的主题(尽管您可以在 LINQ 的上下文之外使用它们)，特别是扩展方法和匿名类型。

最后，您将学习如何创建一个“不安全”的代码上下文来直接操作非托管指针。虽然在 C#应用中使用指针确实是一项相当罕见的活动，但在一些涉及复杂互操作性的情况下，理解如何使用指针会很有帮助。

## 了解索引器方法

作为一名程序员，您肯定很熟悉使用索引操作符(`[]`)访问一个简单数组中包含的各个项的过程。这里有一个例子:

`static void Main(string[] args)`

`{`

`// Loop over incoming command-line arguments`

`// using index operator.`

`for(int i = 0; i < args.Length; i++)`

`Console.WriteLine("Args: {0}", args[i]);`

`// Declare an array of local integers.`

`int[] myInts = { 10, 9, 100, 432, 9874};`

`// Use the index operator to access each element.`

`for(int j = 0; j < myInts.Length; j++)`

`Console.WriteLine("Index {0}  = {1} ", j,  myInts[j]);`

`Console.ReadLine();`

`}`

这个代码绝不是一个主要的新闻快报。然而，通过定义索引器方法，C#语言提供了设计自定义类和结构的能力，这些类和结构可以像标准数组一样被索引。当您创建自定义集合类(泛型或非泛型)时，这个特殊的功能最有用。

在研究如何实现自定义索引器之前，让我们先来看一个实例。假设您已经在第 9 章的[中开发的自定义`PersonCollection`类型中添加了对索引器方法的支持(具体来说，就是 IssuesWithNonGenericCollections 项目)。虽然您尚未添加索引器，但请在名为 SimpleIndexer 的新控制台应用项目中观察以下用法:](09.html)

`// Indexers allow you to access items in an array-like fashion.`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Indexers *****\n");`

`PersonCollection myPeople = new PersonCollection();`

`// Add objects with indexer syntax.`

`myPeople[0] = new Person("Homer", "Simpson", 40);`

`myPeople[1] = new Person("Marge", "Simpson", 38);`

`myPeople[2] = new Person("Lisa", "Simpson", 9);`

`myPeople[3] = new Person("Bart", "Simpson", 7);`

`myPeople[4] = new Person("Maggie", "Simpson", 2);`

`// Now obtain and display each item using indexer.`

`for (int i = 0; i < myPeople.Count; i++)`

`{`

`Console.WriteLine("Person number: {0}", i);`

`Console.WriteLine("Name: {0} {1}",`

`myPeople[i].FirstName, myPeople[i].LastName);`

`Console.WriteLine("Age: {0}", myPeople[i].Age);`

`Console.WriteLine();`

`}`

`}`

`}`

如您所见，索引器允许您像操作标准数组一样操作子对象的内部集合。现在来看一个大问题:如何配置`PersonCollection`类(或任何定制类或结构)来支持这个功能？索引器表示为稍加修改的 C#属性定义。最简单的形式是使用`this[]`语法创建一个索引器。下面是`PersonCollection`类所需的更新:

`// Add the indexer to the existing class definition.`

`public class PersonCollection : IEnumerable`

`{`

`private ArrayList arPeople = new ArrayList();`

`// Custom indexer for this class.`

`public Person this[int index]`

`{`

`get { return (Person)arPeople[index]; }`

`set { arPeople.Insert(index, value); }`

`}`

`...`

`}`

除了使用`this`关键字，索引器看起来就像任何其他 C#属性声明。例如，`get`作用域的作用是将正确的对象返回给调用者。这里，您通过将请求委托给`ArrayList`对象的索引器来实现，因为这个类也支持索引器。`set`作用域负责添加新的`Person`对象；这是通过调用`ArrayList`的`Insert()`方法实现的。

索引器是另一种形式的语法糖，因为这种功能也可以使用“普通的”公共方法来实现，比如`AddPerson()`或`GetPerson()`。然而，当您在自定义集合类型上支持索引器方法时，它们可以很好地集成到。NET 基础类库。

虽然创建索引器方法在构建自定义集合时很常见，但请记住泛型类型为您提供了开箱即用的功能。考虑下面的方法，它使用了一个通用的`Person`对象的`List<T>`。注意，你可以简单地直接使用`List<T>`的索引器。这里有一个例子:

`static void UseGenericListOfPeople()`

`{`

`List<Person> myPeople = new List<Person>();`

`myPeople.Add(new Person("Lisa", "Simpson", 9));`

`myPeople.Add(new Person("Bart", "Simpson", 7));`

`// Change first person with indexer.`

`myPeople[0] = new Person("Maggie", "Simpson", 2);`

`// Now obtain and display each item using indexer.`

`for (int i = 0; i < myPeople.Count; i++)`

`{`

`Console.WriteLine("Person number: {0}", i);`

`Console.WriteLine("Name: {0} {1}", myPeople[i].FirstName,`

`myPeople[i].LastName);`

`Console.WriteLine("Age: {0}", myPeople[i].Age);`

`Console.WriteLine();`

`}`

`}`

Source Code

SimpleIndexer 项目位于 [`Chapter 11`](11.html) 子目录中。

### 使用字符串值索引数据

当前的`PersonCollection`类定义了一个索引器，该索引器允许调用者使用数值来标识子项。但是，请理解，这不是索引器方法的要求。假设您更喜欢使用`System.Collections.Generic.Dictionary<TKey, TValue>`而不是`ArrayList`来包含`Person`对象。假设`Dictionary`类型允许使用一个键(比如一个人的名字)访问包含的类型，您可以如下定义一个索引器:

`public class PersonCollection : IEnumerable`

`{`

`private Dictionary<string, Person> listPeople =`

`new Dictionary<string, Person>();`

`// This indexer returns a person based on a string index.`

`public Person this[string name]`

`{`

`get { return (Person)listPeople[name]; }`

`set { listPeople[name] = value; }`

`}`

`public void ClearPeople()`

`{ listPeople.Clear(); }`

`public int Count`

`{ get { return listPeople.Count; } }`

`IEnumerator IEnumerable.GetEnumerator()`

`{ return listPeople.GetEnumerator(); }`

`}`

调用者现在能够与包含的`Person`对象交互，如下所示:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Indexers *****\n");`

`PersonCollection myPeople = new PersonCollection();`

`myPeople["Homer"] = new Person("Homer", "Simpson", 40);`

`myPeople["Marge"] = new Person("Marge", "Simpson", 38);`

`// Get "Homer" and print data.`

`Person homer = myPeople["Homer"];`

`Console.WriteLine(homer.ToString());`

`Console.ReadLine();`

`}`

同样，如果您直接使用泛型`Dictionary<TKey, TValue>`类型，您将获得现成的索引器方法功能，而无需构建一个支持字符串索引器的自定义、非泛型类。尽管如此，请理解任何索引器的数据类型都将基于支持的集合类型如何允许调用方检索子项。

Source Code

StringIndexer 项目位于 [`Chapter 11`](11.html) 子目录下。

### 重载索引器方法

理解索引器方法可能在单个类或结构上重载。因此，如果允许调用方使用数字索引或字符串值访问子项是有意义的，则可以为一个类型定义多个索引器。举例来说，在 ADO.NET(。NET 的本地数据库访问 API)，`DataSet`类支持一个名为`Tables`的属性，它返回给你一个强类型的`DataTableCollection`类型。事实证明，`DataTableCollection`定义了三个索引器来获取和设置`DataTable`对象——一个通过序号位置，另一个通过友好的字符串名字对象和可选的包含名称空间，如下所示:

`public sealed class DataTableCollection : InternalDataCollectionBase`

`{`

`...`

`// Overloaded indexers!`

`public DataTable this[int index] { get; }`

`public DataTable this[string name] { get; }`

`public DataTable this[string name, string tableNamespace] { get; }`

`}`

基类库中的类型支持索引器方法是很常见的。所以请注意，即使您当前的项目不要求您为您的类和结构构建自定义索引器，许多类型已经支持这种语法。

### 多维索引器

您还可以创建一个接受多个参数的索引器方法。假设您有一个在 2D 数组中存储子项的自定义集合。如果是这种情况，您可以按如下方式定义索引器方法:

`public class SomeContainer`

`{`

`private int[,] my2DintArray = new int[10, 10];`

`public int this[int row, int column]`

`{  /* get or set value from 2D array */  }`

`}`

同样，除非您正在构建一个高度风格化的自定义集合类，否则您不太需要构建一个多维索引器。尽管如此，ADO.NET 再次展示了这种构造是多么有用。ADO.NET`DataTable`本质上是行和列的集合，很像一张绘图纸或 Microsoft Excel 电子表格的一般结构。

虽然通常使用相关的“数据适配器”代表您填充`DataTable`对象，但是下面的代码演示了如何手动创建包含三列(每个记录的名字、姓氏和年龄)的内存中的`DataTable`。请注意，一旦您向`DataTable`添加了一行，您如何使用多维索引器来钻取第一行(也是唯一一行)的每一列。(如果您正在跟进，您需要将`System.Data`名称空间导入到您的代码文件中。)

`static void MultiIndexerWithDataTable()`

`{`

`// Make a simple DataTable with 3 columns.`

`DataTable myTable = new DataTable();`

`myTable.Columns.Add(new DataColumn("FirstName"));`

`myTable.Columns.Add(new DataColumn("LastName"));`

`myTable.Columns.Add(new DataColumn("Age"));`

`// Now add a row to the table.`

`myTable.Rows.Add("Mel", "Appleby", 60);`

`// Use multidimension indexer to get details of first row.`

`Console.WriteLine("First Name: {0}", myTable.Rows[0][0]);`

`Console.WriteLine("Last Name: {0}", myTable.Rows[0][1]);`

`Console.WriteLine("Age : {0}", myTable.Rows[0][2]);`

`}`

请注意，您将从第 21 章开始深入研究 ADO.NET，所以如果前面的一些代码看起来不熟悉，不要担心。此示例的要点是索引器方法可以支持多维度，如果使用正确，可以简化您与自定义集合中包含的子对象的交互方式。

### 接口类型的索引器定义

索引器可以在给定的。NET 接口类型，以允许支持类型提供自定义实现。下面是一个简单的接口示例，它定义了使用数字索引器获取字符串对象的协议:

`public interface IStringContainer`

`{`

`string this[int index] { get; set; }`

`}`

使用此接口定义，任何实现此接口的类或结构现在都必须支持读写索引器，该索引器使用数值来操作子项。下面是类的部分实现:

`class SomeClass : IStringContainer`

`{`

`private List<string> myStrings = new List<string>();`

`public string this[int index]`

`{`

`get { return myStrings[index]; }`

`set { myStrings.Insert(index, value); }`

`}`

`}`

这就结束了本章的第一个主要话题。现在让我们来研究一个语言特性，它允许您构建定制的类或结构，这些类或结构对 C#的内部运算符做出独特的响应。接下来，请允许我介绍运算符重载的概念。

## 理解运算符重载

像任何编程语言一样，C#有一组固定的标记，用于对内部类型执行基本操作。例如，您知道可以将`+`运算符应用于两个整数，以产生一个更大的整数。

`// The + operator with ints.`

`int a = 100;`

`int b = 240;`

`int c =``a + b;`T2】

再说一次，这不是什么大新闻，但是你有没有停下来注意过同一个`+`操作符是如何应用于大多数 C#数据类型的？例如，考虑以下代码:

`// + operator with strings.`

`string s1 = "Hello";`

`string s2 = " world!";`

`string s3 =``s1 + s2;`T2】

本质上，`+`操作符基于所提供的数据类型(在本例中是字符串或整数)以特定的方式运行。当`+`运算符应用于数值类型时，结果是操作数的总和。然而，当`+`操作符应用于字符串类型时，结果是字符串连接。

C#语言为您提供了构建定制类和结构的能力，这些定制类和结构也可以唯一地响应同一组基本标记(如`+`操作符)。虽然不是每个可能的 C#操作符都可以重载，但是很多都可以，如表 [11-1](#Tab1) 所示。

表 11-1。

Overloadability of C# Operators

<colgroup><col> <col></colgroup> 
| C#运算符 | 过载能力 |
| --- | --- |
| `+`、`-`、`!`、`∼`、`++`、`--`、`true`、`false` | 这些一元运算符可以重载。 |
| `+`、`-`、`*`、`/`、`%`、`&`、`&#124;`、`^`、`<<`、`>>` | 这些二元运算符可以重载。 |
| `==`、`!=`、`<`、`>`、`<=`、`>=` | 这些比较运算符可以重载。C#要求“like”操作符(即`<`和`>`、`<=`和`>=`、`==`和`!=`)一起重载。 |
| `[]` | `[]`运算符不能重载。然而，正如您在本章前面所看到的，索引器构造提供了相同的功能。 |
| `()` | `()`运算符不能重载。然而，正如您将在本章后面看到的，自定义转换方法提供了相同的功能。 |
| `+=`、`-=`、`*=`、`/=`、`%=`、`&=`、`&#124;=`、`^=`、`<<=`、`>>=` | 速记赋值运算符不能重载；然而，当你重载相关的二元操作符时，你可以免费得到它们。 |

### 重载二元运算符

为了说明重载二元运算符的过程，假设在一个名为 OverloadedOps 的新控制台应用项目中定义了以下简单的`Point`类:

`// Just a simple, everyday C# class.`

`public class Point`

`{`

`public int X {get; set;}`

`public int Y {get; set;}`

`public Point(int xPos, int yPos)`

`{`

`X = xPos;`

`Y = yPos;`

`}`

`public override string ToString()`

`{`

`return string.Format("[{0}, {1}]", this.X, this.Y);`

`}`

`}`

现在，从逻辑上讲，把`Point` s“加”在一起是有意义的。例如，如果你将两个`Point`变量加在一起，你应该得到一个新的`Point`，它是`X`和`Y`值的总和。当然，从另一个中减去一个`Point`也是有帮助的。理想情况下，您希望能够编写以下代码:

`// Adding and subtracting two points?`

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Overloaded Operators *****\n");`

`// Make two points.`

`Point ptOne = new Point(100, 100);`

`Point ptTwo = new Point(40, 40);`

`Console.WriteLine("ptOne = {0}", ptOne);`

`Console.WriteLine("ptTwo = {0}", ptTwo);`

`// Add the points to make a bigger point?`

`Console.WriteLine("ptOne + ptTwo: {0} ", ptOne + ptTwo);`

`// Subtract the points to make a smaller point?`

`Console.WriteLine("ptOne - ptTwo: {0} ", ptOne - ptTwo);`

`Console.ReadLine();`

`}`

然而，就您的`Point`而言，您将会收到编译时错误，因为`Point`类型不知道如何响应`+`或`-`操作符。为了使自定义类型能够唯一地响应内部运算符，C#提供了`operator`关键字，您只能将它与`static`关键字结合使用。当您重载一个二元操作符(比如`+`和`-`)时，您通常会传入两个与定义类类型相同的参数(本例中为`Point`)，如下面的代码更新所示:

`// A more intelligent Point type.`

`public class Point`

`{`

`...`

`// Overloaded operator +.`

`public static Point operator + (Point p1, Point p2)`

`{`

`return new Point(p1.X + p2.X, p1.Y + p2.Y);`

`}`

`// Overloaded operator -.`

`public static Point operator - (Point p1, Point p2)`

`{`

`return new Point(p1.X - p2.X, p1.Y - p2.Y);`

`}`

`}`

操作符`+`背后的逻辑只是基于传入的`Point`参数的字段总和返回一个新的`Point`对象。因此，当您编写`pt1` + `pt2`时，您可以想象下面对静态操作符`+`方法的隐藏调用。

`// Pseudo-code: Point p3 = Point.operator+ (p1, p2)`

`Point p3 = p1 + p2;`

同样，`p1`–`p2`映射到以下内容:

`// Pseudo-code: Point p4 = Point.operator- (p1, p2)`

`Point p4 = p1 - p2;`

有了这个更新，您的程序现在可以编译了，并且您发现您能够添加和减去`Point`对象，如下面的输出所示:

`ptOne = [100, 100]`

`ptTwo = [40, 40]`

`ptOne + ptTwo: [140, 140]`

`ptOne - ptTwo: [60, 60]`

当重载二元运算符时，不需要传入两个相同类型的参数。如果这样做有意义，其中一个论点可以不同。例如，这里有一个重载操作符`+`，它允许调用者获得一个基于数字调整的新的`Point`:

`public class Point`

`{`

`...`

`public static Point operator + (Point p1, int change)`

`{`

`return new Point(p1.X + change, p1.Y + change);`

`}`

`public static Point operator + (int change, Point p1)`

`{`

`return new Point(p1.X + change, p1.Y + change);`

`}`

`}`

请注意，如果您希望参数以任意顺序传递，您需要这两个版本的方法(即，您不能只定义其中一个方法，并期望编译器自动支持另一个)。您现在可以使用这些新版本的运算符`+`，如下所示:

`// Prints [110, 110].`

`Point biggerPoint = ptOne + 10;`

`Console.WriteLine("ptOne + 10 = {0}", biggerPoint);`

`// Prints [120, 120].`

`Console.WriteLine("10 + biggerPoint = {0}", 10 + biggerPoint);`

`Console.WriteLine();`

### +=和–+运算符是什么？

如果您是从 C++背景进入 C#的，您可能会感叹重载速记赋值操作符(`+=`、`-=`等等)的损失。不要绝望。就 C#而言，如果一个类型重载了相关的二元运算符，那么会自动模拟速记赋值运算符。因此，假设`Point`结构已经重载了`+`和`-`操作符，您可以编写如下代码:

`// Overloading binary operators results in a freebie shorthand operator.`

`static void Main(string[] args)`

`{`

`...`

`// Freebie +=`

`Point ptThree = new Point(90, 5);`

`Console.WriteLine("ptThree = {0}", ptThree);`

`Console.WriteLine("ptThree += ptTwo: {0}", ptThree += ptTwo);`

`// Freebie -=`

`Point ptFour = new Point(0, 500);`

`Console.WriteLine("ptFour = {0}", ptFour);`

`Console.WriteLine("ptFour -= ptThree: {0}", ptFour -= ptThree);`

`Console.ReadLine();`

`}`

### 重载一元运算符

C#还允许你重载各种一元运算符，比如`++`和`--`。当重载一元运算符时，还必须将`static`关键字与`operator`关键字一起使用；但是，在这种情况下，您只需传入一个与定义的类/结构类型相同的参数。例如，如果您要用以下重载操作符更新`Point`:

`public class Point`

`{`

`...`

`// Add 1 to the X/Y values for the incoming Point.`

`public static Point operator ++(Point p1)`

`{`

`return new Point(p1.X+1, p1.Y+1);`

`}`

`// Subtract 1 from the X/Y values for the incoming Point.`

`public static Point operator --(Point p1)`

`{`

`return new Point(p1.X-1, p1.Y-1);`

`}`

`}`

您可以像这样递增和递减`Point`的`x`和`y`值:

`static void Main(string[] args)`

`{`

`...`

`// Applying the ++ and -- unary operators to a Point.`

`Point ptFive = new Point(1, 1);`

`Console.WriteLine("++ptFive = {0}", ++ptFive);  // [2, 2]`

`Console.WriteLine("--ptFive = {0}", --ptFive);  // [1, 1]`

`// Apply same operators as postincrement/decrement.`

`Point ptSix = new Point(20, 20);`

`Console.WriteLine("ptSix++ = {0}", ptSix++);  // [20, 20]`

`Console.WriteLine("ptSix-- = {0}", ptSix--);  // [21, 21]`

`Console.ReadLine();`

`}`

请注意，在前面的代码示例中，您以两种不同的方式应用了自定义的`++`和`--`操作符。在 C++中，可以分别重载前/后递增/递减运算符。这在 C#中是不可能的。然而，递增/递减的返回值会被自动“正确”地免费处理(例如，对于重载的`++`操作符，`pt++`将未修改对象的值作为其在表达式中的值，而`++pt`在表达式中使用之前应用了新值)。

### 重载相等运算符

你可能还记得第 6 章中的[，可以覆盖`System.Object.Equals()`来执行引用类型之间基于值的(而不是基于引用的)比较。如果您选择覆盖`Equals()`(以及通常相关的`System.Object.GetHashCode()`方法)，重载等式操作符(`==`和`!=`)是微不足道的。为了说明，下面是更新后的`Point`类型:](06.html)

`// This incarnation of Point also overloads the == and != operators.`

`public class Point`

`{`

`...`

`public override bool Equals(object o)`

`{`

`return o.ToString() == this.ToString();`

`}`

`public override int GetHashCode()`

`{`

`return this.ToString().GetHashCode();`

`}`

`// Now let’s overload the == and != operators.`

`public static bool operator ==(Point p1, Point p2)`

`{`

`return p1.Equals(p2);`

`}`

`public static bool operator !=(Point p1, Point p2)`

`{`

`return !p1.Equals(p2);`

`}`

`}`

注意操作符`==`和操作符`!=`的实现是如何简单地调用被覆盖的`Equals()`方法来完成大部分工作的。考虑到这一点，您现在可以如下练习您的`Point`类:

`// Make use of the overloaded equality operators.`

`static void Main(string[] args)`

`{`

`...`

`Console.WriteLine("ptOne == ptTwo : {0}", ptOne == ptTwo);`

`Console.WriteLine("ptOne != ptTwo : {0}", ptOne != ptTwo);`

`Console.ReadLine();`

`}`

正如您所看到的，使用众所周知的`==`和`!=`操作符来比较两个对象是非常直观的，而不是调用`Object. Equals()`。如果你确实重载了给定类的等式操作符，记住 C#要求如果你覆盖了`==`操作符，你也必须覆盖`!=`操作符(如果你忘记了，编译器会通知你)。

### 重载比较运算符

在第 8 章的[中，你学习了如何实现`IComparable`接口来比较两个相似对象之间的关系。事实上，您还可以为同一个类重载比较操作符(`<`、`>`、`<=`和`>=`)。和等式操作符一样，C#要求如果你重载了`<`，你也必须重载`>`。这同样适用于`<=`和`>=`操作符。如果`Point`类型重载了这些比较操作符，对象用户现在可以比较`Point` s，如下所示:](08.html)

`// Using the overloaded < and > operators.`

`static void Main(string[] args)`

`{`

`...`

`Console.WriteLine("ptOne < ptTwo : {0}", ptOne < ptTwo);`

`Console.WriteLine("ptOne > ptTwo : {0}", ptOne > ptTwo);`

`Console.ReadLine();`

`}`

假设您已经实现了`IComparable`接口(或者更好的是通用等效接口)，重载比较操作符是微不足道的。下面是更新后的类定义:

`// Point is also comparable using the comparison operators.`

`public class Point : IComparable<Point>`

`{`

`...`

`public int CompareTo(Point other)`

`{`

`if (this.X > other.X && this.Y > other.Y)`

`return 1;`

`if (this.X < other.X && this.Y < other.Y)`

`return -1;`

`else`

`return 0;`

`}`

`public static bool operator <(Point p1, Point p2)`

`{ return (p1.CompareTo(p2) < 0); }`

`public static bool operator >(Point p1, Point p2)`

`{ return (p1.CompareTo(p2) > 0); }`

`public static bool operator <=(Point p1, Point p2)`

`{ return (p1.CompareTo(p2) <= 0); }`

`public static bool operator >=(Point p1, Point p2)`

`{ return (p1.CompareTo(p2) >= 0); }`

`}`

### 关于运算符重载的最终想法

正如您所看到的，C#提供了构建类型的能力，这些类型可以唯一地响应各种固有的、众所周知的运算符。现在，在您修改您的所有类以支持这种行为之前，您必须确保您将要重载的操作符在世界范围内具有某种逻辑意义。

例如，假设您重载了`MiniVan`类的乘法运算符。将两个`MiniVan`对象相乘到底意味着什么？不多。事实上，如果队友看到`MiniVan`对象的以下用法，会感到困惑:

`// Huh?! This is far from intuitive...`

`MiniVan newVan = myVan * yourVan;`

重载操作符通常只在构建原子数据类型时有用。文本、点、矩形、分数和六边形是运算符重载的理想选择。人、管理人员、汽车、数据库连接和网页没有。根据经验，如果重载的操作符使用户更难理解类型的功能，就不要这样做。明智地使用这个特性。

Source Code

OverloadedOps 项目位于 [`Chapter 11`](11.html) 子目录下。

## 了解自定义类型转换

现在让我们研究一个与运算符重载密切相关的主题:自定义类型转换。为了给讨论做好准备，让我们快速回顾一下数字数据和相关类类型之间显式和隐式转换的概念。

### 回忆:数字转换

根据固有的数字类型(`sbyte`、`int`、`float`等)。)，当您试图在较小的容器中存储较大的值时，需要进行显式转换，因为这可能会导致数据丢失。基本上，这是你告诉编译器，“别管我，我知道我在做什么。”相反，当您试图将较小的类型放入不会导致数据丢失的目标类型中时，隐式转换会自动发生。

`static void Main()`

`{`

`int a = 123;`

`long b = a;       // Implicit conversion from int to long.`

`int c = (int) b;  // Explicit conversion from long to int.`

`}`

### 回忆:相关类类型之间的转换

如[第 6 章](06.html)所示，类类型可能通过经典继承相关(“is-a”关系)。在这种情况下，C#转换过程允许您上下转换类层次结构。例如，派生类总是可以隐式转换为基类型。但是，如果您想在派生变量中存储基类类型，则必须执行显式转换，如下所示:

`// Two related class types.`

`class Base{}`

`class Derived : Base{}`

`class Program`

`{`

`static void Main(string[] args)`

`{`

`// Implicit cast between derived to base.`

`Base myBaseType;`

`myBaseType = new Derived();`

`// Must explicitly cast to store base reference`

`// in derived type.`

`Derived myDerivedType = (Derived)myBaseType;`

`}`

`}`

这种显式强制转换是可行的，因为`Base`和`Derived`类是通过传统继承联系在一起的。但是，如果在不同的层次结构中有两个需要转换的类类型，并且没有共同的父类(除了`System.Object`)，该怎么办呢？假设它们没有传统的继承关系，典型的造型操作不会提供任何帮助(而且你会得到一个编译错误！).

另一方面，考虑值类型(结构)。假设你有两个。名为`Square`和`Rectangle`的网络结构。鉴于结构不能利用经典继承(因为它们总是密封的)，您没有自然的方法在这些看似相关的类型之间进行转换。

虽然您可以在结构中创建助手方法(如`Rectangle.ToSquare()`)，但 C#允许您构建自定义转换例程，允许您的类型响应`()`转换操作符。因此，如果您正确配置了结构，您将能够使用以下语法在它们之间进行显式转换，如下所示:

`// Convert a Rectangle to a Square!`

`Rectangle rect;`

`rect.Width = 3;`

`rect.Height = 10;`

`Square sq = (Square)rect;`

### 创建自定义转换例程

首先创建一个名为 CustomConversions 的新控制台应用项目。C#提供了两个关键字，`explicit`和`implicit`，您可以使用它们来控制您的类型在尝试转换期间如何响应。假设您有以下结构定义:

`public struct Rectangle`

`{`

`public int Width {get; set;}`

`public int Height {get; set;}`

`public Rectangle(int w, int h) : this()`

`{`

`Width = w; Height = h;`

`}`

`public void Draw()`

`{`

`for (int i = 0; i < Height; i++)`

`{`

`for (int j = 0; j < Width; j++)`

`{`

`Console.Write("*");`

`}`

`Console.WriteLine();`

`}`

`}`

`public override string ToString()`

`{`

`return string.Format("[Width = {0}; Height = {1}]",`

`Width, Height);`

`}`

`}`

`public struct Square`

`{`

`public int Length {get; set;}`

`public Square(int l) : this()`

`{`

`Length = l;`

`}`

`public void Draw()`

`{`

`for (int i = 0; i < Length; i++)`

`{`

`for (int j = 0; j < Length; j++)`

`{`

`Console.Write("*");`

`}`

`Console.WriteLine();`

`}`

`}`

`public override string ToString()`

`{ return string.Format("[Length = {0}]", Length); }`

`// Rectangles can be explicitly converted`

`// into Squares.`

`public static explicit operator Square(Rectangle r)`

`{`

`Square s = new Square();`

`s.Length = r.Height;`

`return s;`

`}`

`}`

Note

你会注意到在`Square`和`Rectangle`构造函数中，我显式链接到默认构造函数。原因是，如果您有一个使用自动属性语法的结构(如您在这里所做的)，则必须显式调用默认构造函数(从所有自定义构造函数中)来初始化私有支持字段(例如，如果该结构有任何附加字段/属性，则该默认构造函数会将这些字段初始化为默认值)。是的，这是 C#的一个古怪的规则，但毕竟这是一个高级主题章节。

注意，`Square`类型的这个迭代定义了一个显式转换操作符。像重载操作符的过程一样，转换例程使用 C# `operator`关键字，结合`explicit`或`implicit`关键字，并且必须被定义为`static`。传入参数是要转换的实体，而运算符类型是要转换的实体。

在这种情况下，假设可以从矩形的高度获得正方形(所有边都等长的几何图案)。因此，您可以自由地将`Rectangle`转换成`Square`，如下所示:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Conversions *****\n");`

`// Make a Rectangle.`

`Rectangle r = new Rectangle(15, 4);`

`Console.WriteLine(r.ToString());`

`r.Draw();`

`Console.WriteLine();`

`// Convert r into a Square,`

`// based on the height of the Rectangle.`

`Square s = (Square)r;`

`Console.WriteLine(s.ToString());`

`s.Draw();`

`Console.ReadLine();`

`}`

您可以在这里看到输出:

`***** Fun with Conversions *****`

`[Width = 15; Height = 4]`

`***************`

`***************`

`***************`

`***************`

`[Length = 4]`

`****`

`****`

`****`

`****`

虽然在同一个作用域内将一个`Rectangle`转换成一个`Square`可能没什么帮助，但是假设你有一个被设计成接受`Square`参数的函数。

`// This method requires a Square type.`

`static void DrawSquare(Square sq)`

`{`

`Console.WriteLine(sq.ToString());`

`sq.Draw();`

`}`

使用对`Square`类型的显式转换操作，您现在可以传入`Rectangle`类型以使用显式强制转换进行处理，如下所示:

`static void Main(string[] args)`

`{`

`...`

`// Convert Rectangle to Square to invoke method.`

`Rectangle rect = new Rectangle(10, 5);`

`DrawSquare((Square)rect);`

`Console.ReadLine();`

`}`

### Square 类型的其他显式转换

既然您已经可以显式地将`Rectangle`转换成`Square`了，那么让我们检查一些额外的显式转换。假设一个正方形在所有边上都是对称的，那么提供一个显式的转换例程，允许调用者从整数类型转换为`Square`(当然，它的边长等于传入的整数)可能会有所帮助。同样，如果你要更新`Square`，使呼叫者可以从`Square`转换成`int`会怎样？下面是调用逻辑:

`static void Main(string[] args)`

`{`

`...`

`// Converting an int to a Square.`

`Square sq2 = (Square)90;`

`Console.WriteLine("sq2 = {0}", sq2);`

`// Converting a Square to an int.`

`int side = (int)sq2;`

`Console.WriteLine("Side length of sq2 = {0}", side);`

`Console.ReadLine();`

`}`

下面是对`Square`类的更新:

`public struct Square`

`{`

`...`

`public static explicit operator Square(int sideLength)`

`{`

`Square newSq = new Square();`

`newSq.Length = sideLength;`

`return newSq;`

`}`

`public static explicit operator int (Square s)`

`{return s.Length;}`

`}`

老实说，将`Square`转换成整数可能不是最直观(或最有用)的操作(毕竟，您可以将这些值传递给构造函数)。然而，它确实指出了关于自定义转换例程的一个重要事实:只要您编写了语法正确的代码，编译器并不关心您转换成什么或转换成什么。

因此，与重载运算符一样，您可以为给定类型创建显式强制转换操作并不意味着您应该这样做。通常，这种技术在您创建时最有帮助。NET 结构类型，因为它们无法参与经典继承(强制转换是免费的)。

### 定义隐式转换例程

到目前为止，您已经创建了各种自定义的显式转换操作。但是，下面的隐式转换呢？

`static void Main(string[] args)`

`{`

`...`

`Square s3 = new Square();`

`s3.Length = 83;`

`// Attempt to make an implicit cast?`

`Rectangle rect2 = s3;`

`Console.ReadLine();`

`}`

假定您没有为`Rectangle`类型提供隐式转换例程，这段代码将不会编译。这里有一个问题:在同一类型上定义显式和隐式转换函数是非法的，如果它们的返回类型或参数集没有区别的话。这似乎是一种限制；然而，第二个问题是，当一个类型定义一个隐式转换例程时，调用者使用显式强制转换语法是合法的！

迷茫？为了弄清楚，让我们使用 C# `implicit`关键字向`Rectangle`结构添加一个隐式转换例程(注意，下面的代码假设产生的`Rectangle`的宽度是通过将`Square`的边乘以 2 来计算的):

`public struct Rectangle`

`{`

`...`

`public static implicit operator Rectangle(Square s)`

`{`

`Rectangle r = new Rectangle();`

`r.Height = s.Length;`

`// Assume the length of the new Rectangle with`

`// (Length x 2).`

`r.Width = s.Length * 2;`

`return r;`

`}`

`}`

通过此更新，您现在可以在类型之间进行转换，如下所示:

`static void Main(string[] args)`

`{`

`...`

`// Implicit cast OK!`

`Square s3 = new Square();`

`s3.Length= 7;`

`Rectangle rect2 = s3;`

`Console.WriteLine("rect2 = {0}", rect2);`

`// Explicit cast syntax still OK!`

`Square s4 = new Square();`

`s4.Length = 3;`

`Rectangle rect3 = (Rectangle)s4;`

`Console.WriteLine("rect3 = {0}", rect3);`

`Console.ReadLine();`

`}`

这就结束了您对自定义转换例程的定义。与重载操作符一样，记住这一点语法只是“普通”成员函数的简写符号，因此它总是可选的。然而，当正确使用时，自定义结构可以更自然地使用，因为它们可以被视为通过继承相关的真正的类类型。

Source Code

CustomConversions 项目位于 [`Chapter 11`](11.html) 子目录中。

## 理解扩展方法

。NET 3.5 引入了扩展方法的概念，它允许您向类或结构添加新的方法或属性，而不用以任何直接的方式修改原始类型。那么，这在哪里会有帮助呢？考虑以下可能性。

首先，假设您有一个生产中的给定类。随着时间的推移，很明显这个类应该支持一些新成员。如果直接修改当前的类定义，就有可能破坏使用它的旧代码库的向后兼容性，因为它们可能没有用最新和最好的类定义编译。确保向后兼容的一种方法是从现有父类创建新的派生类；然而，现在您有两个类需要维护。众所周知，代码维护是软件工程师工作描述中最不光彩的部分。

现在考虑这种情况。假设您有一个结构(或者一个密封的类)并想添加新的成员，这样它在您的系统中的行为就多样化了。由于结构和密封类不能被扩展，你唯一的选择就是将成员添加到类型中，这又一次冒着向后兼容的风险！

使用扩展方法，您可以修改类型，而不需要子类化，也不需要直接修改类型。可以肯定的是，这种技术本质上是一种障眼法。只有在当前项目中引用了扩展方法时，才会为类型提供新功能。

### 定义扩展方法

当你定义扩展方法时，第一个限制是它们必须在一个静态类中定义(见[第 5 章](05.html))，因此，每个扩展方法必须用`static`关键字声明。第二点是所有的扩展方法都是这样标记的，使用`this`关键字作为方法的第一个(也是唯一的一个)参数的修饰符。“this qualified”参数表示被扩展的项目。

为了进行说明，创建一个名为 ExtensionMethods 的新控制台应用项目。现在，假设您正在创作一个名为`MyExtensions`的类，它定义了两个扩展方法。第一种方法允许任何一个`object`使用一个名为`DisplayDefiningAssembly()`的新方法，该方法利用`System.Reflection`名称空间中的类型来显示包含该类型的程序集的名称。

Note

你将在第 15 章中正式检查反射 API。如果您不熟悉这个主题，只需理解反射允许您在运行时发现程序集、类型和类型成员的结构。

第二种扩展方法名为`ReverseDigits()`，允许任何`int`获得其自身的新版本，其中值被逐位反转。例如，如果一个值为 1234 的整数被称为`ReverseDigits()`，那么返回的整数被设置为值 4321。考虑下面的类实现(如果您继续学习，请确保导入`System.Reflection`名称空间):

`static class MyExtensions`

`{`

`// This method allows any object to display the assembly`

`// it is defined in.`

`public static void DisplayDefiningAssembly(this object obj)`

`{`

`Console.WriteLine("{0} lives here: => {1}\n", obj.GetType().Name,`

`Assembly.GetAssembly(obj.GetType()).GetName().Name);`

`}`

`// This method allows any integer to reverse its digits.`

`// For example, 56 would return 65.`

`public static int ReverseDigits(this int i)`

`{`

`// Translate int into a string, and then`

`// get all the characters.`

`char[] digits = i.ToString().ToCharArray();`

`// Now reverse items in the array.`

`Array.Reverse(digits);`

`// Put back into string.`

`string newDigits = new string(digits);`

`// Finally, return the modified string back as an int.`

`return int.Parse(newDigits);`

`}`

`}`

同样，在定义参数类型之前，注意每个扩展方法的第一个参数是如何用关键字`this`限定的。扩展方法的第一个参数总是表示被扩展的类型。鉴于`DisplayDefiningAssembly()`已经被原型化以扩展`System.Object`，每个类型现在都有了这个新成员，因为`Object`是。NET 平台。然而，`ReverseDigits()`已经被原型化，只扩展整数类型；因此，如果整数以外的任何东西试图调用此方法，您将收到一个编译时错误。

Note

理解一个给定的扩展方法可以有多个参数，但是只有第一个参数可以用`this`限定。附加参数将被视为该方法使用的正常输入参数。

### 调用扩展方法

现在已经有了这些扩展方法，考虑下面的`Main()`方法，它将扩展方法应用于基类库中的各种类型:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Extension Methods *****\n");`

`// The int has assumed a new identity!`

`int myInt = 12345678;`

`myInt.DisplayDefiningAssembly();`

`// So has the DataSet!`

`System.Data.DataSet d = new System.Data.DataSet();`

`d.DisplayDefiningAssembly();`

`// And the SoundPlayer!`

`System.Media.SoundPlayer sp = new System.Media.SoundPlayer();`

`sp.DisplayDefiningAssembly();`

`// Use new integer functionality.`

`Console.WriteLine("Value of myInt: {0}", myInt);`

`Console.WriteLine("Reversed digits of myInt: {0}", myInt.ReverseDigits());`

`Console.ReadLine();`

`}`

以下是输出:

`***** Fun with Extension Methods *****`

`Int32 lives here: => mscorlib`

`DataSet lives here: => System.Data`

`SoundPlayer lives here: => System`

`Value of myInt: 12345678`

`Reversed digits of myInt: 87654321`

### 导入扩展方法

当您定义一个包含扩展方法的类时，它无疑将被定义在一个. NET 命名空间中。如果这个名称空间不同于使用扩展方法的名称空间，您将需要使用预期的 C# `using`关键字。当您这样做时，您的代码文件可以访问被扩展类型的所有扩展方法。记住这一点很重要，因为如果不显式导入正确的命名空间，扩展方法就不能用于该 C#代码文件。

实际上，尽管表面上看起来扩展方法本质上是全局的，但实际上它们仅限于定义它们的命名空间或导入它们的命名空间。因此，如果您将`MyExtensions`类包装到名为`MyExtensionMethods`的名称空间中，如下所示:

`namespace MyExtensionMethods`

`{`

`static class MyExtensions`

`{`

`...`

`}`

`}`

项目中的其他名称空间需要显式导入`MyExtensionMethods`名称空间，以获得由您的类定义的扩展方法。

Note

常见的做法是不仅将扩展方法隔离到专用的。NET 命名空间，而是放入专用的类库中。这样，新应用可以通过显式引用正确的库并导入名称空间来“选择”扩展。第 14 章将研究建立和使用定制的细节。NET 类库。

### 扩展方法的智能感知

假设扩展方法不是在被扩展的类型上定义的，那么在检查现有的代码库时，肯定会感到困惑。例如，假设您已经导入了一个名称空间，该名称空间定义了由队友创作的一些扩展方法。在编写代码时，您可能会创建一个扩展类型的变量，应用点运算符，并找到许多不是原始类定义成员的新方法！

谢天谢地，Visual Studio 的 IntelliSense 机制标记了所有扩展方法，如图 [11-1](#Fig1) 所示。

![A978-1-4842-1332-2_11_Fig1_HTML.jpg](img/A978-1-4842-1332-2_11_Fig1_HTML.jpg)

图 11-1。

The IntelliSense of extension methods

任何这样标记的方法都是一个友好的提醒，即该方法是通过扩展方法在原始类定义之外定义的。

Source Code

ExtensionMethods 项目可以在 [`Chapter 11`](11.html) 子目录中找到。

### 扩展实现特定接口的类型

至此，您已经看到了如何通过扩展方法用新的功能来扩展类(并间接地扩展遵循相同语法的结构)。也可以定义一个只能扩展实现正确接口的类或结构的扩展方法。例如，你可以说“如果一个类或结构实现了`IEnumerable<T>`，那么该类型将获得下面的新成员。”当然，有可能要求一个类型支持任何接口，包括您自己的自定义接口。

为了进行说明，创建一个名为 InterfaceExtensions 的新控制台应用项目。这里的目标是向实现`IEnumerable`的任何类型添加一个新方法，这将包括任何数组和许多非泛型集合类(回想一下[第 8 章](08.html)中的泛型`IEnumerable<T>`接口扩展了非泛型`IEnumerable`接口)。将以下扩展类添加到新项目中:

`static class AnnoyingExtensions`

`{`

`public static void PrintDataAndBeep(this System.Collections.IEnumerable iterator)`

`{`

`foreach (var item in iterator)`

`{`

`Console.WriteLine(item);`

`Console.Beep();`

`}`

`}`

`}`

鉴于`PrintDataAndBeep()`方法可以被任何实现`IEnumerable`的类或结构使用，您可以通过下面的`Main()`方法进行测试:

`static void Main( string[] args )`

`{`

`Console.WriteLine("***** Extending Interface Compatible Types *****\n");`

`// System.Array implements IEnumerable!`

`string[] data = { "Wow", "this", "is", "sort", "of", "annoying",`

`"but", "in", "a", "weird", "way", "fun!"};`

`data.PrintDataAndBeep();`

`Console.WriteLine();`

`// List<T> implements IEnumerable!`

`List<int> myInts = new List<int>() {10, 15, 20};`

`myInts.PrintDataAndBeep();`

`Console.ReadLine();`

`}`

这就结束了对 C#扩展方法的研究。请记住，这种特殊的语言特性在您希望扩展某个类型的功能，但又不想创建子类(或者如果该类型是密封的，就不能创建子类)时会非常有用，这是出于多态性的目的。正如您将在本文后面看到的，扩展方法对 LINQ API 起着关键作用。事实上，你会看到在 LINQ API 下，最常见的扩展项之一是一个类或结构实现(惊喜！)通用版的`IEnumerable`。

Source Code

InterfaceExtension 项目可以在 [`Chapter 11`](11.html) 子目录中找到。

## 了解匿名类型

作为面向对象的程序员，您知道定义类来表示您试图建模的给定项目的状态和功能的好处。当然，每当您需要定义一个旨在跨项目重用并通过一组方法、事件、属性和自定义构造函数提供大量功能的类时，创建一个新的 C#类是常见的做法。

然而，也有一些时候，您希望定义一个类，仅仅是为了对一组封装的(或以某种方式相关的)数据点进行建模，而没有任何相关的方法、事件或其他专门的功能。此外，如果这种类型仅由程序中的少数方法使用，该怎么办呢？当你很清楚这个类只在少数地方使用时，定义一个完整的类定义会很麻烦，如下所示。为了强调这一点，下面是当您需要创建一个遵循典型的基于值的语义的“简单”数据类型时，您可能需要做的事情的大致轮廓:

`class SomeClass`

`{`

`// Define a set of private member variables...`

`// Make a property for each member variable...`

`// Override ToString() to account for key member variables...`

`// Override GetHashCode() and Equals() to work with value-based equality...`

`}`

如你所见，事情不一定这么简单。您不仅需要编写大量的代码，还需要在系统中维护另一个类。对于像这样的临时数据，快速创建一个自定义数据类型会很有用。例如，假设您需要构建一个接收一组传入参数的自定义方法。您希望获取这些参数，并使用它们来创建一个新的数据类型，以便在此方法范围内使用。此外，您可能希望使用典型的`ToString()`方法快速打印出这些数据，并且可能使用`System.Object`的其他成员。您可以使用匿名类型语法来做这件事。

### 定义匿名类型

当你定义一个匿名类型时，你可以通过使用`var`关键字(见[第三章](03.html))和对象初始化语法(见[第五章](05.html))来实现。您必须使用`var`关键字，因为编译器会在编译时自动生成一个新的类定义(并且您永远不会在 C#代码中看到这个类的名称)。初始化语法用于告诉编译器为新创建的类型创建私有支持字段和(只读)属性。

举例来说，创建一个名为 AnonymousTypes 的新控制台应用项目。现在，使用传入的参数数据，将下面的方法添加到您的`Program`类中，动态地组成一个新的类型:

`static void BuildAnonType( string make, string color, int currSp )`

`{`

`// Build anon type using incoming args.`

`var car = new { Make = make, Color = color, Speed = currSp };`

`// Note you can now use this type to get the property data!`

`Console.WriteLine("You have a {0} {1} going {2} MPH",`

`car.Color, car.Make, car.Speed);`

`// Anon types have custom implementations of each virtual`

`// method of System.Object. For example:`

`Console.WriteLine("ToString() == {0}", car.ToString());`

`}`

您可以从`Main()`调用这个方法，正如所料。但是，请注意，也可以使用硬编码值创建匿名类型，如下所示:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Anonymous Types *****\n");`

`// Make an anonymous type representing a car.`

`var myCar = new { Color = "Bright Pink", Make = "Saab", CurrentSpeed = 55 };`

`// Now show the color and make.`

`Console.WriteLine("My car is a {0} {1}.", myCar.Color, myCar.Make);`

`// Now call our helper method to build anonymous type via args.`

`BuildAnonType("BMW", "Black", 90);`

`Console.ReadLine();`

`}`

因此，在这一点上，简单地理解一下，匿名类型允许您以很少的开销快速地对数据的“形状”建模。这种技术只不过是一种快速创建新数据类型的方法，它通过属性支持基本的封装，并根据基于值的语义进行操作。为了理解最后一点，让我们看看 C#编译器如何在编译时构建匿名类型，具体来说，它如何覆盖`System.Object`的成员。

### 匿名类型的内部表示

所有匿名类型都是从`System.Object`自动派生的，因此支持这个基类提供的每个成员。鉴于此，您可以对隐式类型化的`myCar`对象调用`ToString()`、`GetHashCode()`、`Equals()`或`GetType()`。假设您的`Program`类定义了以下静态助手函数:

`static void ReflectOverAnonymousType(object obj)`

`{`

`Console.WriteLine("obj is an instance of: {0}", obj.GetType().Name);`

`Console.WriteLine("Base class of {0} is {1}",`

`obj.GetType().Name,`

`obj.GetType().BaseType);`

`Console.WriteLine("obj.ToString() == {0}", obj.ToString());`

`Console.WriteLine("obj.GetHashCode() == {0}", obj.GetHashCode());`

`Console.WriteLine();`

`}`

现在假设您从`Main()`调用该方法，将`myCar`对象作为参数传入，如下所示:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Fun with Anonymous Types *****\n");`

`// Make an anonymous type representing a car.`

`var myCar = new {Color = "Bright Pink", Make = "Saab", CurrentSpeed = 55};`

`// Reflect over what the compiler generated.`

`ReflectOverAnonymousType(myCar);`

`...`

`Console.ReadLine();`

`}`

输出将类似于以下内容:

`***** Fun with Anonymous Types *****`

`obj is an instance of: <>f__AnonymousType0`3`

`Base class of <>f__AnonymousType0`3 is System.Object`

`obj.ToString() = { Color = Bright Pink, Make = Saab, CurrentSpeed = 55 }`

`obj.GetHashCode() = -439083487`

首先，注意，在这个例子中，`myCar`对象的类型是`<>f AnonymousType0`3`(您的名字可能不同)。请记住，分配的类型名称完全由编译器决定，并且不能在 C#代码库中直接访问。

也许最重要的是，注意使用对象初始化语法定义的每个名称-值对都被映射到一个同名的只读属性和一个相应的私有只读支持字段。下面的 C#代码近似于编译器生成的用于表示`myCar`对象的类(同样可以使用`ildasm.exe`进行验证):

`internal sealed class <>f__AnonymousType0<<Color>j__TPar,`

`<Make>j__TPar, <CurrentSpeed>j__TPar>`

`{`

`// Read-only fields.`

`private readonly <Color>j__TPar <Color>i__Field;`

`private readonly <CurrentSpeed>j__TPar <CurrentSpeed>i__Field;`

`private readonly <Make>j__TPar <Make>i__Field;`

`// Default constructor.`

`public <>f__AnonymousType0(<Color>j__TPar Color,`

`<Make>j__TPar Make, <CurrentSpeed>j__TPar CurrentSpeed);`

`// Overridden methods.`

`public override bool Equals(object value);`

`public override int GetHashCode();`

`public override string ToString();`

`// Read-only properties.`

`public <Color>j__TPar Color { get; }`

`public <CurrentSpeed>j__TPar CurrentSpeed { get; }`

`public <Make>j__TPar Make { get; }`

`}`

### ToString()和 GetHashCode()的实现

所有匿名类型都自动从`System.Object`派生而来，并提供有`Equals()`、`GetHashCode()`和`ToString()`的覆盖版本。`ToString()`实现简单地从每个名称-值对构建一个字符串。这里有一个例子:

`public override string ToString()`

`{`

`StringBuilder builder = new StringBuilder();`

`builder.Append("{ Color = ");`

`builder.Append(this.<Color>i__Field);`

`builder.Append(", Make = ");`

`builder.Append(this.<Make>i__Field);`

`builder.Append(", CurrentSpeed = ");`

`builder.Append(this.<CurrentSpeed>i__Field);`

`builder.Append(" }");`

`return builder.ToString();`

`}`

`GetHashCode()`实现使用每个匿名类型的成员变量作为`System.Collections.Generic.EqualityComparer<T>`类型的输入来计算哈希值。使用`GetHashCode()`的这种实现，当(且仅当)两个匿名类型具有相同的属性集并被赋予相同的值时，它们将产生相同的哈希值。给定这个实现，匿名类型非常适合包含在一个`Hashtable`容器中。

### 匿名类型相等的语义

虽然被覆盖的`ToString()`和`GetHashCode()`方法的实现相当简单，但是您可能想知道`Equals()`方法是如何实现的。例如，如果您要定义两个指定相同名称-值对的“匿名汽车”变量，这两个变量会被认为是相等的吗？为了直接看到结果，用下面的新方法更新您的`Program`类型:

`static void EqualityTest()`

`{`

`// Make 2 anonymous classes with identical name/value pairs.`

`var firstCar = new { Color = "Bright Pink", Make = "Saab", CurrentSpeed = 55 };`

`var secondCar = new { Color = "Bright Pink", Make = "Saab", CurrentSpeed = 55 };`

`// Are they considered equal when using Equals()?`

`if (firstCar.Equals(secondCar))`

`Console.WriteLine("Same anonymous object!");`

`else`

`Console.WriteLine("Not the same anonymous object!");`

`// Are they considered equal when using ==?`

`if (firstCar == secondCar)`

`Console.WriteLine("Same anonymous object!");`

`else`

`Console.WriteLine("Not the same anonymous object!");`

`// Are these objects the same underlying type?`

`if (firstCar.GetType().Name == secondCar.GetType().Name)`

`Console.WriteLine("We are both the same type!");`

`else`

`Console.WriteLine("We are different types!");`

`// Show all the details.`

`Console.WriteLine();`

`ReflectOverAnonymousType(firstCar);`

`ReflectOverAnonymousType(secondCar);`

`}`

假设您已经从`Main()`内部调用了这个方法，下面是(有点令人惊讶的)输出:

`My car is a Bright Pink Saab.`

`You have a Black BMW going 90 MPH`

`ToString() == { Make = BMW, Color = Black, Speed = 90 }`

`Same anonymous object!`

`Not the same anonymous object!`

`We are both the same type!`

`obj is an instance of: <>f__AnonymousType0`3`

`Base class of <>f__AnonymousType0`3 is System.Object`

`obj.ToString() == { Color = Bright Pink, Make = Saab, CurrentSpeed = 55 }`

`obj.GetHashCode() == -439083487`

`obj is an instance of: <>f__AnonymousType0`3`

`Base class of <>f__AnonymousType0`3 is System.Object`

`obj.ToString() == { Color = Bright Pink, Make = Saab, CurrentSpeed = 55 }`

`obj.GetHashCode() == -439083487`

当您运行这个测试代码时，您将看到您调用`Equals()`的第一个条件测试返回了`true`，因此，消息“相同的匿名对象！”打印到屏幕上。这是因为编译器生成的`Equals()`方法在测试相等性时使用基于值的语义(例如，检查被比较对象的每个字段的值)。

然而，第二个条件测试使用了 C#等式操作符(`==`)，打印出“不是同一个匿名对象！”乍一看，这似乎有点违反直觉。这个结果是因为匿名类型不接收重载版本的 C#相等运算符(`==`和`!=`)。鉴于此，当您使用 C#相等操作符(而不是`Equals()`方法)测试匿名类型的相等性时，测试的是引用，而不是由对象维护的值。

最后但并非最不重要的是，在最后的条件测试中(检查底层类型名)，您会发现匿名类型是同一个编译器生成的类类型的实例(在本例中为`<>f AnonymousType0`3`)，因为`firstCar`和`secondCar`具有相同的属性(`Color`、`Make`和`CurrentSpeed`)。

这说明了重要但微妙的一点:只有当匿名类型包含匿名类型的唯一名称时，编译器才会生成新的类定义。因此，如果在同一个程序集中声明相同的匿名类型(也就是相同的名称)，编译器只会生成一个匿名类型定义。

### 包含匿名类型的匿名类型

可以创建一个由其他匿名类型组成的匿名类型。例如，假设您想要对一个由时间戳、价格点和购买的汽车组成的采购订单进行建模。下面是一个新的(稍微复杂一点)匿名类型，表示这样一个实体:

`// Make an anonymous type that is composed of another.`

`var purchaseItem = new {`

`TimeBought = DateTime.Now,`

`ItemBought = new {Color = "Red", Make = "Saab", CurrentSpeed = 55},`

`Price = 34.000};`

`ReflectOverAnonymousType(purchaseItem);`

至此，您应该理解了用于定义匿名类型的语法，但是您可能仍然想知道在什么地方(以及什么时候)使用这个新的语言特性。坦率地说，匿名类型声明应该少用，通常只有在利用 LINQ 技术集的时候(见第 12 章)。鉴于匿名类型的诸多限制，您绝不会为了放弃使用强类型类/结构而放弃使用它们，这些限制包括:

*   您不能控制匿名类型的名称。
*   匿名类型总是扩展`System.Object`。
*   匿名类型的字段和属性总是只读的。
*   匿名类型不支持事件、自定义方法、自定义运算符或自定义重写。
*   匿名类型总是隐式密封的。
*   匿名类型总是使用默认构造函数创建的。

但是，当使用 LINQ 技术集编程时，您会发现，在许多情况下，当您想要快速地对实体的整体形状而不是其功能进行建模时，这种语法会很有帮助。

Source Code

AnonymousTypes 项目可以在 [`Chapter 11`](11.html) 子目录中找到。

## 使用指针类型

现在是这一章的最后一个主题，对于大多数人来说，这可能是所有 C#特性中使用最少的。NET 项目。

Note

在下面的例子中，我假设你有一些 C++指针操作的背景知识。如果不是这样，请完全跳过这个话题。对于绝大多数 C#应用来说，使用指针并不是一项常见的任务。

在第 4 章中，你了解到。NET 平台定义了两大类数据:值类型和引用类型。然而，说实话，还有第三类:指针类型。为了使用指针类型，你得到特定的操作符和关键字，允许你绕过 CLR 的内存管理模式，把事情掌握在你自己手中(见表 [11-2](#Tab2) )。

表 11-2。

Pointer-Centric C# Operators and Keywords

<colgroup><col> <col></colgroup> 
| 运算符/关键字 | 生命的意义 |
| --- | --- |
| `*` | 该操作符用于创建指针变量(即表示内存中直接位置的变量)。与 C++中一样，这个操作符也用于指针间接寻址。 |
| `&` | 该操作符用于获取变量在内存中的地址。 |
| `->` | 该运算符用于访问由指针表示的类型的字段(C#点运算符的不安全版本)。 |
| `[]` | 这个操作符(在不安全的上下文中)允许你索引指针变量所指向的槽(如果你是 C++程序员，你会记得指针变量和`[]`操作符之间的相互作用)。 |
| `++`，`--` | 在不安全的上下文中，递增和递减运算符可以应用于指针类型。 |
| `+`，`-` | 在不安全的上下文中，加法和减法运算符可以应用于指针类型。 |
| `==`、`!=`、`<`、`>`、`<=`、`=>` | 在不安全的上下文中，比较和相等运算符可以应用于指针类型。 |
| `stackalloc` | 在不安全的上下文中，`stackalloc`关键字可以用来直接在堆栈上分配 C#数组。 |
| `fixed` | 在不安全的上下文中，`fixed`关键字可以用来临时修复一个变量，以便可以找到它的地址。 |

现在，在深入细节之前，让我再次指出，您很少需要使用指针类型。尽管 C#确实允许您下降到指针操作的级别，但是要理解。NET 运行库完全不知道您的意图。因此，如果你对一个指针管理不当，你就是负责处理后果的人。考虑到这些警告，什么时候需要使用指针类型呢？有两种常见情况:

*   您希望通过在 CLR 管理之外直接操作内存来优化应用的特定部分。
*   您正在调用基于 C 的`.dll`或 COM 服务器的方法，这些方法需要指针类型作为参数。即使在这种情况下，你也可以绕过指针类型，转而使用`System.IntPtr`类型和`System.Runtime.InteropServices.Marshal`类型的成员。

如果您决定利用 C#语言的这一特性，您需要通过使您的项目支持“不安全代码”来告知 C#编译器(`csc.exe`)您的意图要在命令行中这样做，只需提供下面的`/unsafe`标志作为参数:

`csc /unsafe *.cs`

从 Visual Studio 中，您将需要访问项目的属性页，并选中“构建”选项卡上的“允许不安全代码”框(参见图 [11-2](#Fig2) )。若要试验指针类型，请创建一个名为 UnsafeCode 和 enable unsafe code 的新控制台应用项目，并确保启用此设置。

![A978-1-4842-1332-2_11_Fig2_HTML.jpg](img/A978-1-4842-1332-2_11_Fig2_HTML.jpg)

图 11-2。

Enabling unsafe code using Visual Studio

### 不安全的关键字

当您想在 C#中使用指针时，您必须使用`unsafe`关键字明确声明一个“不安全代码”块(任何没有用`unsafe`关键字标记的代码都自动被认为是“安全的”)。例如，下面的`Program`类在 safe `Main()`方法中声明了一个不安全代码的范围:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`unsafe`

`{`

`// Work with pointer types here!`

`}`

`// Can’t work with pointers here!`

`}`

`}`

除了在方法中声明不安全代码的范围之外，您还可以构建“不安全”的结构、类、类型成员和参数下面是几个例子(不需要在当前项目中定义`Node`或`Node2`类型):

`// This entire structure is "unsafe" and can`

`// be used only in an unsafe context.`

`unsafe struct Node`

`{`

`public int Value;`

`public Node* Left;`

`public Node* Right;`

`}`

`// This struct is safe, but the Node2* members`

`// are not. Technically, you may access "Value" from`

`// outside an unsafe context, but not "Left" and "Right".`

`public struct Node2`

`{`

`public int Value;`

`// These can be accessed only in an unsafe context!`

`public unsafe Node2* Left;`

`public unsafe Node2* Right;`

`}`

方法(静态或实例级)也可能被标记为不安全的。例如，假设您知道一个特定的静态方法将使用指针逻辑。为了确保只能从不安全的上下文中调用该方法，可以将该方法定义如下:

`unsafe` `static void SquareIntPointer(int* myIntPointer)`

`{`

`// Square the value just for a test.`

`*myIntPointer *= *myIntPointer;`

`}`

您的方法的配置要求调用者如下调用`SquareIntPointer()`:

`static void Main(string[] args)`

`{`

`unsafe`

`{`

`int myInt = 10;`

`// OK, because we are in an unsafe context.`

`SquareIntPointer(&myInt);`

`Console.WriteLine("myInt: {0}", myInt);`

`}`

`int myInt2 = 5;`

`// Compiler error! Must be in unsafe context!`

`SquareIntPointer(&myInt2);`

`Console.WriteLine("myInt: {0}", myInt2);`

`}`

如果您不想强迫调用者在不安全的上下文中包装调用，您可以用关键字`unsafe`更新`Main()`。在这种情况下，将编译以下代码:

`unsafe static void Main(string[] args)`

`{`

`int myInt2 = 5;`

`SquareIntPointer(&myInt2);`

`Console.WriteLine("myInt: {0}", myInt2);`

`}`

如果您运行这个`Main()`方法，您将看到以下输出:

`myInt: 25`

### 使用*和&运算符

在你建立了一个不安全的上下文之后，你就可以使用`*`操作符构建指向数据类型的指针，并使用`&`操作符获得所指向的地址。与 C 或 C++不同，在 C#中,`*`运算符只应用于基础类型，而不是作为每个指针变量名的前缀。例如，考虑下面的代码，它说明了声明指向整型变量的指针的正确和不正确的方法:

`// No! This is incorrect under C#!`

`int *pi, *pj;`

`// Yes! This is the way of C#.`

`int* pi, pj;`

考虑以下不安全的方法:

`unsafe static void PrintValueAndAddress()`

`{`

`int myInt;`

`// Define an int pointer, and`

`// assign it the address of myInt.`

`int* ptrToMyInt = &myInt;`

`// Assign value of myInt using pointer indirection.`

`*ptrToMyInt = 123;`

`// Print some stats.`

`Console.WriteLine("Value of myInt {0}", myInt);`

`Console.WriteLine("Address of myInt {0:X}", (int)&ptrToMyInt);`

`}`

### 不安全(和安全)的交换函数

当然，仅仅为了赋值而声明指向局部变量的指针(如前一个例子)从来都不是必需的，也不是完全有用的。为了说明不安全代码的一个更实际的例子，假设您想使用指针算法构建一个交换函数。

`unsafe public static void UnsafeSwap(int* i, int* j)`

`{`

`int temp = *i;`

`*i = *j;`

`*j = temp;`

`}`

很 C 的样子，你不觉得吗？但是，鉴于您之前的工作，您应该知道您可以使用 C# `ref`关键字编写以下安全版本的交换算法:

`public static void SafeSwap(ref int i, ref int j)`

`{`

`int temp = i;`

`i = j;`

`j = temp;`

`}`

每个方法的功能都是相同的，因此强调了直接指针操作不是 C#下的强制任务这一点。下面是使用安全`Main()`的调用逻辑，带有不安全的上下文:

`static void Main(string[] args)`

`{`

`Console.WriteLine("***** Calling method with unsafe code *****");`

`// Values for swap.`

`int i = 10, j = 20;`

`// Swap values "safely."`

`Console.WriteLine("\n***** Safe swap *****");`

`Console.WriteLine("Values before safe swap: i = {0}, j = {1}", i, j);`

`SafeSwap(ref i, ref j);`

`Console.WriteLine("Values after safe swap: i = {0}, j = {1}", i, j);`

`// Swap values "unsafely."`

`Console.WriteLine("\n***** Unsafe swap *****");`

`Console.WriteLine("Values before unsafe swap: i = {0}, j = {1}", i, j);`

`unsafe { UnsafeSwap(&i, &j); }`

`Console.WriteLine("Values after unsafe swap: i = {0}, j = {1}", i, j);`

`Console.ReadLine();`

`}`

### 通过指针访问字段(运算符->运算符)

现在假设您已经定义了一个简单、安全的`Point`结构，如下所示:

`struct Point`

`{`

`public int x;`

`public int y;`

`public override string ToString()`

`{`

`return string.Format("({0}, {1})", x, y);`

`}`

`}`

如果你声明一个指向`Point`类型的指针，你将需要使用指针字段访问操作符(由`->`表示)来访问它的公共成员。如表 [11-2](#Tab2) 所示，这是标准(安全)点运算符(`.`的不安全版本。事实上，使用指针间接操作符(`*`)，可以取消引用指针(再次)应用点操作符符号。检查不安全的方法:

`unsafe static void UsePointerToPoint()`

`{`

`// Access members via pointer.`

`Point point;`

`Point* p = &point;`

`p->x = 100;`

`p->y = 200;`

`Console.WriteLine(p->ToString());`

`// Access members via pointer indirection.`

`Point point2;`

`Point* p2 = &point2;`

`(*p2).x = 100;`

`(*p2).y = 200;`

`Console.WriteLine((*p2).ToString());`

`}`

### stackalloc 关键字

在不安全的上下文中，您可能需要声明一个直接从调用堆栈分配内存的局部变量(因此，不受。净垃圾收集)。为此，C#提供了`stackalloc`关键字，它相当于 C 运行时库的`_alloca`函数。这里有一个简单的例子:

`unsafe static void UnsafeStackAlloc()`

`{`

`char* p = stackalloc char[256];`

`for (int k = 0; k < 256; k++)`

`p[k] = (char)k;`

`}`

### 通过 fixed 关键字固定类型

正如您在前面的例子中看到的，在不安全的上下文中分配一块内存可能会通过关键字`stackalloc`变得更容易。由于这种操作的本质，一旦分配方法返回(从堆栈中获取内存)，分配的内存就会被清除。然而，假设一个更复杂的例子。在我们检查`->`操作符的过程中，您创建了一个名为`Point`的值类型。像所有值类型一样，一旦执行范围终止，分配的内存将弹出堆栈。为了便于讨论，假设`Point`被定义为引用类型，如下所示:

`class PointRef // <= Renamed and retyped.`

`{`

`public int x;`

`public int y;`

`public override string ToString()`

`{`

`return string.Format("({0}, {1})", x, y);`

`}`

`}`

如您所知，如果调用者声明了一个类型为`Point`的变量，那么内存将被分配到垃圾收集堆中。紧迫的问题变成了，“如果一个不安全的上下文想要与这个对象(或者堆上的任何对象)交互怎么办？”考虑到垃圾收集可能在任何时候发生，想象一下当访问`Point`的成员时遇到的问题，就在这样一个正在进行堆清理的时间点上。从理论上讲，不安全上下文有可能试图与一个不再可访问的成员进行交互，或者在经历了分代清除之后被重新定位到堆上(这是一个明显的问题)。

为了从不安全的上下文中锁定内存中的引用类型变量，C#提供了`fixed`关键字。`fixed`语句设置一个指向托管类型的指针，并在代码执行期间“固定”该变量。如果没有`fixed`，指向托管变量的指针将没有什么用处，因为垃圾收集可能会不可预测地重新定位变量。(事实上，除了在`fixed`语句中，C#编译器不允许你设置指向托管变量的指针。)

因此，如果您创建了一个`PointRef`对象并希望与其成员交互，您必须编写以下代码(否则会收到一个编译器错误):

`unsafe public static void UseAndPinPoint()`

`{`

`PointRef pt = new PointRef ();`

`pt.x = 5;`

`pt.y = 6;`

`// Pin pt in place so it will not`

`// be moved or GC-ed.`

`fixed (int* p = &pt.x)`

`{`

`// Use int* variable here!`

`}`

`// pt is now unpinned, and ready to be GC-ed once`

`// the method completes.`

`Console.WriteLine ("Point is: {0}", pt);`

`}`

简而言之，`fixed`关键字允许您构建一个锁定内存中引用变量的语句，这样它的地址在语句(或作用域块)的持续时间内保持不变。任何时候在不安全代码的上下文中与引用类型进行交互时，都必须锁定引用。

### sizeof 关键字

最后要考虑的以不安全为中心的 C#关键字是`sizeof`。与 C++中一样，C# `sizeof`关键字用于获取内部数据类型的字节大小，但不是自定义类型，除非在不安全的上下文中。例如，下面的方法不需要声明为“不安全”,因为`sizeof`关键字的所有参数都是内部类型:

`static void UseSizeOfOperator()`

`{`

`Console.WriteLine("The size of short is {0}.",``sizeof`T2】

`Console.WriteLine("The size of int is {0}.",``sizeof`T2】

`Console.WriteLine("The size of long is {0}.",``sizeof`T2】

`}`

但是，如果您想获得自定义的`Point`结构的大小，您需要更新这个方法(注意已经添加了`unsafe`关键字):

`unsafe static void UseSizeOfOperator()`

`{`

`...`

`Console.WriteLine("The size of Point is {0}.", sizeof(Point));`

`}`

Source Code

UnsafeCode 项目可以在[第 11 章](11.html)子目录中找到。

以上介绍了 C#编程语言的一些更高级的特性。为了确保我们都在同一页上，我必须再次说，你的大多数。NET 项目可能永远不需要直接使用这些特性(尤其是指针)。然而，正如你将在后面的章节中看到的，当使用 LINQ API 时，有些主题即使不是必需的，也是非常有用的，尤其是扩展方法和匿名类型。

## 摘要

本章的目的是加深你对 C#编程语言的理解。首先，您研究了各种高级类型构造技术(索引器方法、重载操作符和自定义转换例程)。

接下来，您研究了扩展方法和匿名类型的作用。正如你将在下一章中看到的一些细节，这些特性在使用以 LINQ 为中心的 API 时很有用(尽管你可以在代码中的任何地方使用它们，如果它们有用的话)。回想一下，匿名方法允许您快速地为类型的“形状”建模，而扩展方法允许您为类型添加新的功能，而不需要子类化。

在本章的剩余部分，您研究了一小组鲜为人知的关键字(`sizeof`、`unsafe`等等)，并在此过程中学习了如何使用原始指针类型。正如在整个指针类型研究中所述，绝大多数 C#应用都不需要使用它们。