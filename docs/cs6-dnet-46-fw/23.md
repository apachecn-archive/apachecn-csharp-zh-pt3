# 23.ADO.NET 第三部分:实体框架

前两章研究了基本的 ADO.NET 编程模型——特别是连接层和非连接层。这些方法使得。NET 程序员使用关系数据(以一种相对简单的方式)。然而，微软在 ADO.NET API 中引入了一个新的组件，称为实体框架(简称 EF)。NET 3.5 服务包 1。

Note

虽然这个第一版受到了广泛的批评，但微软的 EF 团队一直在努力发布新版本。Visual Studio 2015 目前(在撰写本文时)发布了 6.1.3 版，与早期版本相比，它包含了许多功能和性能增强。Entity Framework 7 仍处于早期测试阶段(同样，在撰写本文时)。因为 EF 7 有太多的问题，所以我决定把这本书的重点放在 EF 6.x 上。

EF 的首要目标是允许您使用直接映射到应用中业务对象(或域对象)的对象模型与关系数据库中的数据进行交互。例如，您可以对称为实体的强类型对象集合进行操作，而不是将一批数据视为行和列的集合。这些实体本身也是 LINQ 感知的，你可以使用你在第 12 章学到的相同的 LINQ 语法来查询它们。EF 运行时引擎代表您将您的 LINQ 查询翻译成合适的 SQL 查询。

本章将向你介绍使用实体框架的数据访问。您将学习创建一个领域模型，将模型类映射到数据库，以及`DbContext`类的角色。您还将了解导航属性、事务和并发检查。

当你完成这一章时，你将拥有`AutoLotDAL.dll`的最终版本。在本书的后面，当你学习 ASP.NET web forms 和 ASP.NET MVC 时，你会用到这个版本的`AutoLotDAL.dll`。

Note

实体框架的所有版本(包括 EF 6.x)都支持使用实体设计器来创建实体数据模型 XML (EDMX)文件。从版本 4.1 开始，EF 使用一种称为代码优先的技术增加了对普通旧 CLR 对象(POCO)的支持。EF 7 将只支持代码优先范式，放弃所有设计者支持。因此，本章将首先关注代码。

## 理解实体框架的作用

在[第 21 章](21.html)和[第 22 章](22.html)中讨论的 ADO.NET 的连接层和断开层为您提供了一个结构，让您通过连接、命令、数据读取器、数据适配器和`DataSet`对象来选择、插入、更新和删除数据。虽然这一切都很好，但 ADO.NET 的这些方面迫使您以与物理数据库模式紧密耦合的方式处理提取的数据。例如，回想一下，当您使用连接的层时，您通常通过向数据读取器指定列名来迭代每条记录。另一方面，如果您选择使用断开的层，您会发现自己在一个`DataSet`容器中遍历一个`DataTable`对象的行和列集合。

如果您将断开层与强类型的 s/data 适配器结合使用，那么您最终会得到一个提供一些有益好处的编程抽象。首先，强类型的`DataSet`类使用类属性公开了一个表数据。其次，强类型表适配器支持封装底层 SQL 语句构造的方法。回忆下面的`AddRecords()`方法来自[第二十二章](22.html):

`public static void AddRecords(AutoLotDataSet.InventoryDataTable table,`

`InventoryTableAdapter adapter)`

`{`

`// Get a new strongly typed row from the table.`

`AutoLotDataSet.InventoryRow newRow = table.NewInventoryRow();`

`// Fill row with some sample data.`

`newRow.Color = "Purple";`

`newRow.Make = "BMW";`

`newRow.PetName = "Saku";`

`// Insert the new row.`

`table.AddInventoryRow(newRow);`

`// Add one more row, using overloaded Add method.`

`table .AddInventoryRow("Yugo", "Green", "Zippy");`

`// Update database.`

`adapter.Update(table);`

`}`

当您将断开连接的图层与 LINQ 合并到数据集时，情况变得更好。在本例中，您对内存中的数据应用了 LINQ 查询，以获得新的结果集。然后，您可以选择映射到一个独立的对象，比如一个新的`DataTable`、`List<T>`、`Dictionary<K,V>`或一个数据数组，如下所示:

`static void BuildDataTableFromQuery(DataTable data)`

`{`

`var cars = from car in data.AsEnumerable()`

`where car.Field<int>("CarID") > 5 select car;`

`// Use this result set to build a new DataTable.`

`DataTable newTable = cars.CopyToDataTable();`

`// Work with DataTable...`

`}`

虽然 LINQ 到数据集很有用，但您需要记住，LINQ 查询的目标是从数据库返回的数据，而不是数据库引擎本身。这意味着您将所有数据从数据库拖到客户端，然后使用 LINQ 来获取子集或转换数据。理想情况下，您可以构建一个直接发送到数据库引擎进行处理的 LINQ 查询，并获得一些强类型数据作为回报(这正是 ADO.NET 实体框架允许您完成的)。

当您使用 ADO.NET 的连接层或断开层时，您必须始终注意后端数据库的物理结构。您必须知道每个数据表的模式，编写可能复杂的 SQL 查询来与所述数据表交互，等等。这可能会迫使您编写一些相当冗长的 C#代码，因为 C#本身并不直接使用数据库模式语言。

更糟糕的是，物理数据库的构造方式(由友好的 DBA)完全集中在数据库构造上，比如外键、视图和存储过程。友好的 DBA 构建的数据库可能会变得非常复杂，因为 DBA 努力考虑安全性和可伸缩性。这也使您必须编写的与数据存储交互的 C#代码变得复杂。

ADO.NET 实体框架(EF)是一种编程模型，它试图缩小数据库结构和面向对象编程结构之间的差距。使用 EF，您可以与关系数据库进行交互，而不必看一行 SQL 代码(如果您愿意的话)。相反，当您对强类型类应用 LINQ 查询时，EF 运行时会为您生成适当的 SQL 语句。

Note

对实体的 LINQ 是描述对 ADO.NET EF 实体对象应用 LINQ 查询的行为的术语。

另一种可能的方法(不是通过查找一行、更新该行，然后将该行发送回去供一批 SQL 查询处理来更新数据库数据)，您可以简单地更改对象的属性并保存其状态。同样，EF 运行时会自动更新数据库。

就微软而言，ADO.NET 实体框架只是数据访问 API 的另一种方法，并不打算完全取代直接从 C#代码中使用 ADO.NET。然而，一旦您花一些时间使用 EF，您可能会很快发现自己更喜欢这种丰富的对象模型，而不是更原始的 SQL 查询和行/列集合。

然而，很有可能你会发现这三种方法在你的。净项目；在某些情况下，EF 模型可能会使您的代码库变得复杂。例如，如果您想要构建一个只需要与单个数据库表通信的内部应用，您可能更喜欢使用连接层来调用一批相关的存储过程。更大的应用尤其能从 EF 中受益，尤其是如果开发团队能自如地使用 LINQ 的话。与任何新技术一样，您需要确定 ADO.NET EF 如何(以及何时)适合手头的任务。

Note

您可能还记得。NET 3.5 对 SQL 调用了 LINQ。这个 API 在概念上(在编程结构方面)与 ADO.NET EF 非常接近。LINQ 到 SQL 处于维护模式，这意味着它将只接收关键的错误修复。如果您有一个使用 LINQ 到 SQL 的应用，要知道微软的官方政策是在所有软件“寿命结束”后至少十年内支持它们因此，虽然软件卫士不会把它从你的机器上删除，但来自雷德蒙那些好心人的官方说法是，你应该把精力放在 EF 上，而不是 SQL 的 LINQ 上。他们当然是。

### 实体的作用

前面提到的强类型类称为实体。实体是映射到您的业务领域的物理数据库的概念模型。从形式上讲，这种模型被称为实体数据模型(EDM)。EDM 是一组客户端类，通过实体框架约定和配置映射到物理数据库。您应该理解，就命名约定而言，实体不需要直接映射到数据库模式。您可以自由地重构您的实体类以满足您的需求，EF 运行时会将您的唯一名称映射到正确的数据库模式。

Note

在代码优先的世界里，大多数人把 POCO 类称为模型，把这些类的集合称为模型。当用来自数据存储的数据实例化模型类时，它们被称为实体。实际上，这两个术语可以互换使用。

例如，您可能记得您使用图 [23-1](#Fig1) 所示的数据库模式在`AutoLot`数据库中创建了简单的`Inventory`表。

![A978-1-4842-1332-2_23_Fig1_HTML.jpg](img/A978-1-4842-1332-2_23_Fig1_HTML.jpg)

图 23-1。

Structure of the Inventory table of the AutoLot database

如果您要为`AutoLot`数据库的`Inventory`表创建模型(您将马上看到如何这样做)，默认情况下，该类将被称为`Inventory`。但是，您可以将这个类重命名为`Car`，并定义您选择的唯一命名的属性，这些属性将被映射到`Inventory`表的列。这种松散耦合意味着您可以塑造实体，使它们紧密地模拟您的业务领域。图 [23-2](#Fig2) 显示了这样一个实体类。

![A978-1-4842-1332-2_23_Fig2_HTML.jpg](img/A978-1-4842-1332-2_23_Fig2_HTML.jpg)

图 23-2。

The Car model is a client-side reshaping of the Inventory schema Note

在许多情况下，模型类将与相关的数据库表同名。但是，请记住，您总是可以重塑模型以匹配您的业务情况。

您将很快用 EF 构建一个完整的示例。但是，暂时考虑下面的`Program`类，它使用`Car`模型类(和一个名为`AutoLotEntities`的相关上下文类)向`AutoLot`的`Inventory`表添加一个新行。`AutoLotEntities`上下文类源自`DbContext`。该类的工作是代表您与物理数据库进行通信(您将很快了解更多细节)。

`class Program`

`{`

`static void Main(string[] args)`

`{`

`// Connection string automatically read from config file.`

`using (AutoLotEntities context = new AutoLotEntities())`

`{`

`// Add a new record to Inventory table, using our model.`

`context.Cars.Add(new Car() { ColorOfCar = "Black",`

`MakeOfCar = "Pinto",`

`NicknameOfCar = "Pete" });`

`context.SaveChanges();`

`}`

`}`

`}`

由 EF 运行时获取客户端表示的`Inventory`表(这里是一个名为`Car`的类)并将其映射回`Inventory`表的正确列。注意，您看不到任何 SQL INSERT 语句的踪迹。您只需向由上下文对象的恰当命名的`Cars`属性维护的集合中添加一个新的`Car`对象，并保存您的更改。果然，如果您使用 Visual Studio 的服务器资源管理器查看表数据，您将看到一条新记录(参见图 [23-3](#Fig3) )。

![A978-1-4842-1332-2_23_Fig3_HTML.jpg](img/A978-1-4842-1332-2_23_Fig3_HTML.jpg)

图 23-3。

The result of saving the context

在前面的例子中没有魔法。在后台，建立到数据库的连接，生成正确的 SQL 语句，等等。EF 的好处是这些细节是代表你处理的。现在让我们来看看 EF 的核心服务是什么让这一切成为可能。

### 实体框架的构建块

EF API 位于您在前两章已经研究过的现有 ADO.NET 基础设施之上。像任何 ADO.NET 交互一样，实体框架使用 ADO.NET 数据提供者与数据存储进行通信。但是，必须更新数据提供者，以便它在与 EF API 交互之前支持一组新的服务。如您所料，Microsoft SQL Server 数据提供程序已经更新了必要的基础结构，这在使用`System.Data.Entity.dll`程序集时会考虑到。

Note

许多第三方数据库(如 Oracle 和 MySQL)都提供支持 EF 的数据提供者。详情请咨询您的数据库供应商，或登录 [`https://msdn.microsoft.com/en-us/library/dd363565.aspx`](https://msdn.microsoft.com/en-us/library/dd363565.aspx) 查看已知的 ADO.NET 数据提供商列表。EF 建立在 ADO.NET 数据提供者模型的基础上，将与任何有数据提供者的数据源一起工作。

除了向 Microsoft SQL Server 数据提供者添加必要的位之外，`System.Data.Entity.dll`程序集还包含各种名称空间，这些名称空间说明了 EF 服务本身。EF API 的两个关键部分(目前)是`DbContext`类和派生的特定于模型的上下文。

#### DbContext 类的角色

`DbContext`类代表了工作单元和存储库模式的组合，可以用来从数据库中进行查询，并将将要作为单个工作单元写回的更改组合在一起。`DbContext`为子类提供了许多核心服务，包括保存所有更改(这会导致数据库更新)、调整连接字符串、删除对象、调用存储过程以及处理其他基本细节的能力。表 [23-1](#Tab1) 显示了一些更常用的`DbContext`成员。

表 23-1。

Common Members of DbContext

<colgroup><col> <col></colgroup> 
| `DbContext`的成员 | 生命的意义 |
| --- | --- |
| `DbContext` | 派生的上下文类中默认使用的构造函数。string 参数或者是数据库名，或者是存储在`*.config`文件中的连接字符串。 |
| `Entry Entry<TEntity>` | 检索提供对信息的访问和对实体执行操作的能力的`System.Data.Entity.Infrastructure.DbEntityEntry`对象。 |
| `GetValidationErrors` | 验证跟踪的条目并返回一个集合`System.Data.Entity.Validation.DbEntityValidationResults`。 |
| `SaveChanges SaveChangesAsync` | 将在此上下文中所做的所有更改保存到数据库中。返回受影响实体的数量。 |
| `Configuration` | 提供对上下文配置属性的访问。 |
| `Database` | 为基础数据库提供创建/删除/存在检查机制，针对基础数据存储执行存储过程和原始 SQL 语句，并公开事务功能。 |

`DbContext`也实现了`IObjectContextAdapter`，所以`ObjectContext`类中可用的任何功能也是可用的。虽然`DbContext`满足了您的大部分需求，但有两个事件非常有用，您将在本章后面看到。表 [23-2](#Tab2) 列出了事件。

表 23-2。

Events in DbContext

<colgroup><col> <col></colgroup> 
| `DbContext`事件 | 生命的意义 |
| --- | --- |
| `ObjectMaterialized` | 当作为查询或加载操作的一部分从数据存储中创建新的实体对象时激发 |
| `SavingChanges` | 在将更改保存到数据存储区时，但在持久保存数据之前发生 |

#### 派生上下文类的角色

如前所述，`DbContext`类在首先处理 EF 代码时提供核心功能。在您的项目中，您将为您的特定领域创建一个从`DbContext`派生的类。在构造函数中，您需要将该上下文类的连接字符串的名称传递给基类，如下所示:

`public class AutoLotEntities : DbContext`

`{`

`public AutoLotEntities() base("name=AutoLotConnection")`

`{`

`}`

`protected override void Dispose(bool disposing)`

`{`

`}`

`}`

#### DbSet 的作用

要将表添加到您的上下文中，您需要为对象模型中的每个表添加一个`DbSet<T>`。要启用延迟加载，上下文中的属性需要是虚拟的，如下所示:

`public virtual DbSet<CreditRisk> CreditRisks { get; set; }`

`public virtual DbSet<Customer> Customers { get; set; }`

`public virtual DbSet<Inventory> Inventory { get; set; }`

`public virtual DbSet<Order> Orders { get; set; }`

每个`DbSet<T>`为每个集合提供许多核心服务，比如创建、删除和查找所表示的表中的记录。表 [23-3](#Tab3) 描述了`DbSet<T>`类的一些核心成员。

表 23-3。

Common Members of DbSet<T>

<colgroup><col> <col></colgroup> 
| `DbSet<T>`的成员 | 生命的意义 |
| --- | --- |
| `Add AddRange` | 允许您将新对象(或对象范围)插入到集合中。当在`DbContext`上调用`SaveChanges`(或`SaveChangesAsync`)时，它们将被标记为添加的状态并被插入数据库。 |
| `Attach` | 将一个对象与`DbContext`相关联。这通常用于像 ASP.NET/MVC.这样的非连接应用 |
| `Create Create<T>` | 创建指定实体类型的新实例。 |
| `Find FindAsync` | 通过主键查找数据行，并返回表示该行的对象。 |
| `Remove RemoveRange` | 将对象(或对象范围)标记为删除。 |
| `SqlQuery` | 创建一个原始 SQL 查询，该查询将返回该集合中的实体。 |

一旦钻取了对象上下文的正确属性，就可以调用`DbSet<T>`的任何成员。再次考虑本章前几页中显示的示例代码:

`using (AutoLotEntities context = new AutoLotEntities())`

`{`

`// Add a new record to Inventory table, using our entity.`

`context.Cars.Add(new Car() { ColorOfCar = "Black",`

`MakeOfCar = "Pinto",`

`NicknameOfCar = "Pete" });`

`context.SaveChanges();`

`}`

这里，`AutoLotEntities`是-a 派生的`Context`。通过`Cars`属性，您可以访问`DbSet<Car>`变量。您使用这个引用来插入一个新的`Car`实体对象，并告诉`DbContext`保存对数据库的所有更改。

`DbSet<T>`通常是 LINQ 对实体查询的目标；因此，`DbSet<T>`支持你在[第 12 章](12.html)中学到的相同的扩展方法，比如`ForEach()`、`Select()`和`All()`。此外，`DbSet<T>`从它的直接父类`DbQuery<T>`中获得了大量的功能，这是一个表示强类型 LINQ(或实体 SQL)查询的类。

#### 空代码优先模型或数据库中的代码优先

在构建第一个实体框架示例之前，还有一点需要讨论。您可以从头开始构建实体框架数据模型，或者从现有数据库对其进行反向工程(就像您可以使用实体框架设计器一样)。在接下来的小节中，您将研究这两种方法。

#### 交易支持

所有版本的 EF 都将对`SaveChanges/SaveChangesAsync`的每个调用包装在一个事务中。这些自动事务的隔离级别与数据库的默认隔离级别相同(对于 SQL Server 是读提交的)。如果你需要的话，你可以在 EF 中添加更多的事务支持控制。详见 [`https://msdn.microsoft.com/en-us/data/dn456843.aspx`](https://msdn.microsoft.com/en-us/data/dn456843.aspx) 。

Note

尽管本书没有涉及，但是使用来自`DbContext`数据库对象的`ExecuteSqlCommand()`执行 SQL 语句现在被封装在一个隐式事务中。这是 EF 版本 6 中的新功能。

#### 实体状态

`DbContext`自动跟踪其上下文中任何对象的状态。在前面的例子中，在`using`语句中，当在`AutoLotEntities`类上调用`SaveChanges`时，任何对数据的更改都会被跟踪和保存。表 [23-4](#Tab4) 列出了对象状态的可能值。

表 23-4。

Entity State Enumeration Values

<colgroup><col> <col></colgroup> 
| 价值 | 生命的意义 |
| --- | --- |
| `Detached` | 对象存在，但没有被跟踪。实体在创建后和添加到对象上下文之前立即处于这种状态。 |
| `Unchanged` | 该对象自附加到上下文或自上次调用`SaveChanges()`方法后未被修改。 |
| `Added` | 该对象是新的，已经被添加到对象上下文中，并且还没有调用`SaveChanges()`方法。 |
| `Deleted` | 该对象已从对象上下文中删除，但尚未从数据存储中删除。 |
| `Modified` | 对象上的一个标量属性被修改，并且尚未调用`SaveChanges()`方法。 |

如果需要检查对象的状态，请使用以下代码:

`EntityState state = context.Entry(entity).State;`

你通常不需要担心对象的状态。但是，在删除对象的情况下，您可以将对象的状态设置为`EntityState.Deleted`，并保存到数据库的往返行程。您将在本章的后面部分执行此操作。

## 首先从现有数据库中编码

既然您已经对 ADO.NET 实体框架有了更好的理解，并且从较高的层面上了解了它是如何工作的，那么是时候看看您的第一个完整的例子了。您将构建一个简单的控制台应用，首先使用现有数据库中的代码来创建模型类，这些模型类代表您在第 21 章和第 22 章中构建的现有`AutoLot`数据库。您将在控制台应用中编写代码，执行典型的创建、读取、更新和删除(CRUD)操作，然后查看为您构建的所有内容。

### 生成模型

首先创建一个名为`AutoLotConsoleApp`的新控制台应用项目。通过项目➤新文件夹菜单选项将文件夹添加到项目中，并将其命名为 EF。选择新建 EF 文件夹，然后选择项目➤添加新项(一定要突出显示数据节点)，插入一个名为`AutoLotEntities`的新 ADO.NET 实体数据模型项(如图 [23-4](#Fig4) )。

![A978-1-4842-1332-2_23_Fig4_HTML.jpg](img/A978-1-4842-1332-2_23_Fig4_HTML.jpg)

图 23-4。

Inserting a new ADO.NET EDM project item

单击添加按钮启动实体模型数据向导。向导的第一步允许您选择使用实体框架设计器(从现有数据库或通过创建空设计器)或首先使用代码(从现有数据库或通过创建空`DbContext`)来生成 EDM 的选项。选择“首先从数据库中编码”选项并点击下一步按钮(见图 [23-5](#Fig5) )。

![A978-1-4842-1332-2_23_Fig5_HTML.jpg](img/A978-1-4842-1332-2_23_Fig5_HTML.jpg)

图 23-5。

Generating an EDM from an existing database

您可以在向导的第二步中选择数据库。如果您已经连接到 Visual Studio 服务器资源管理器中的一个数据库，您会看到它列在下拉组合框中。如果不是这样，您可以单击“新建连接”按钮。无论哪种方式，选择您的`AutoLot`数据库，然后确保您将连接字符串数据保存在(自动生成的)`App.config`文件中(见图 [23-6](#Fig6) ，将名称改为`AutoLotConnection`。

![A978-1-4842-1332-2_23_Fig6_HTML.jpg](img/A978-1-4842-1332-2_23_Fig6_HTML.jpg)

图 23-6。

Selecting the database used to generate the model

在单击“下一步”按钮之前，花点时间检查一下连接字符串的格式。

`Data source= .\SQLEXPRESS2014;Initial Catalog=AutoLot;Integrated Security=True;MultipleActiveResultSets=true;App=EntityFramework`

这与你在[第 21 章](21.html)和[第 22 章](22.html)中使用的非常相似，只是增加了`App=EntityFramework`名称-值对。`App`是应用名称的缩写，可在解决 SQL Server 问题时使用。

在向导的最后一步，您可以从数据库中选择要用来生成 EDM 的项目。选择所有的应用表，确保您没有选择`sysdiagrams`(如果它存在于您的数据库中)。这个对话框看起来如图 [23-7](#Fig7) 所示。

![A978-1-4842-1332-2_23_Fig7_HTML.jpg](img/A978-1-4842-1332-2_23_Fig7_HTML.jpg)

图 23-7。

Selecting the database items

现在，单击 Finish 按钮生成 EDM 数据。

### 那有什么用？

完成向导后，您将在项目中看到几个新的类:一个用于您在向导中选择的每个表，另一个名为`AutoLotEntities`(与您在向导的第一步中输入的名称相同)。默认情况下，实体的名称将基于原始的数据库对象名称；但是，请记住，概念模型中的实体名称可以是您选择的任何名称。通过使用 special，可以更改实体名称以及实体的属性名称。NET 属性称为数据注释。您将使用数据注释对您的模型进行一些修改。

Note

Fluent API 是配置模型类和属性以将它们映射到数据库的另一种方式。您可以用数据注释做的一切，也可以通过 Fluent API 用代码来做。由于篇幅和时间的限制，我在这一章中只简单提到了 Fluent API，重点介绍了数据注释。

打开`Inventory`类。您首先会注意到一系列修饰类的属性和类中的属性。这些被称为数据注释，它们指导 EF 在生成数据库时如何构建你的表和属性。他们还指导 EF 如何将数据库中的数据映射到您的模型类中。在类级别，`Table`属性指定类映射到哪个表。在属性级别，使用了两个属性。您首先看到的是`Key`属性。这指定了表的主键。使用的另一个属性是`StringLength`，它在为字段生成 DDL 时指定字符串长度。这个属性也用于验证，您将在后面的章节中看到。

Note

还有两个`SuppressMessage`属性。这指示静态分析器(如 FXCop 和新的 Roslyn 代码分析器)关闭构造函数中列出的特定规则。

`[Table("Inventory")]`

`public partial class Inventory`

`{`

`[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2214:DoNotCallOverridableMethodsInConstructors")]`

`public Inventory()`

`{`

`Orders = new HashSet<Order>();`

`}`

`[Key]`

`public int CarId { get; set; }`

`[StringLength(50)]`

`public string Make { get; set; }`

`[StringLength(50)]`

`public string Color { get; set; }`

`[StringLength(50)]`

`public string PetName { get; set; }`

`[System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Usage", "CA2227:CollectionPropertiesShouldBeReadOnly")]`

`public virtual ICollection<Order> Orders { get; set; }`

`}`

您还可以看到，`Inventory`类有一个`Order`对象的集合。这指定了`Inventory`和`Order`之间的一对多关系。在关系的另一端，`Order`类指定了一个`CarId`属性和一个`Car`属性。

`public partial class Order`

`{`

`public int OrderId { get; set; }`

`public int CustId { get; set; }`

`public int CarId { get; set; }`

`public virtual Customer Customer { get; set; }`

`public virtual Inventory Inventory { get; set; }`

`}`

接下来，打开`AutoLotEntities`类。这个类从`DbContext`派生而来，包含您在向导中指定的每个表的`DbSet<TEntity>`属性。它还覆盖了`OnModelCreating()`，使用`FluentAPI`来定义`Customer`和`Orders`以及`Orders`和`Inventory`之间的关系。

`public partial class AutoLotEntities : DbContext`

`{`

`public AutoLotEntities()`

`: base("name=AutoLotConnection")`

`{`

`}`

`public virtual DbSet<CreditRisk> CreditRisks { get; set; }`

`public virtual DbSet<Customer> Customers { get; set; }`

`public virtual DbSet<Inventory> Inventories { get; set; }`

`public virtual DbSet<Order> Orders { get; set; }`

`protected override void OnModelCreating(DbModelBuilder modelBuilder)`

`{`

`modelBuilder.Entity<Customer>()`

`.HasMany(e => e.Orders)`

`.WithRequired(e => e.Customer)`

`.WillCascadeOnDelete(false);`

`modelBuilder.Entity<Inventory>()`

`.HasMany(e => e.Orders)`

`.WithRequired(e => e.Inventory)`

`.WillCascadeOnDelete(false);`

`}`

`}`

最后，打开`App.config`文件。您将看到一个新的`configSection`(名为`entityFramework`)，以及向导生成的连接字符串。您可以忽略其中的大部分内容，但是如果您更改数据库，您可能需要修改的唯一内容就是`AutoLotConnection`连接字符串的连接字符串值(与您在向导中指定的名称相同)。

`<configuration>`

`<configSections>`

`<!-- For more information on Entity Framework configuration, visit`[`http://go.microsoft.com/fwlink/?LinkID=237468`](http://go.microsoft.com/fwlink/?LinkID=237468)T2】

`<section name="entityFramework" type="System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />`

`</configSections>`

`<startup>`

`<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6" />`

`</startup>`

`<entityFramework>`

`<defaultConnectionFactory type="System.Data.Entity.Infrastructure.SqlConnectionFactory, EntityFramework" />`

`<providers>`

`<provider invariantName="System.Data.SqlClient" type="System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer" />`

`</providers>`

`</entityFramework>`

`<connectionStrings>`

`<add name="AutoLotConnection" connectionString="data source=.\SQLEXPRESS2014;initial catalog=AutoLot;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework" providerName="System.Data.SqlClient" />`

`</connectionStrings>`

`</configuration>`

### 更改默认映射

如前一节所述，`[Table("Inventory")]`属性指定类映射到`Inventory`表。有了这个属性，您可以将您的类的名称更改为您想要的任何名称。将类名(和构造函数)改为`Car`。除了`Table`属性，EF 还使用了`Column`属性。通过将`[Column("PetName")]`属性添加到`PetName`属性，您可以将属性的名称更改为`CarNickName`。相关代码应该如下所示:

`[Table("Inventory")]`

`public partial class Car`

`{`

`public Car()`

`{`

`Orders = new HashSet<Order>();`

`}`

`[StringLength(50), Column("PetName")]`

`public string CarNickName { get; set; }`

`//remainder of the class not shown for brevity`

`}`

如果您更改了名称并且没有使用 Visual Studio 重构功能，您的应用将无法编译。如果不能编译，打开`Order`类，将`Inventory`属性的类型和名称改为`Car`。相关代码如下所示:

`public partial class Order`

`{`

`public virtual Car Car { get; set; }`

`//remainder of the class not shown for brevity`

`}`

最后要做的更改是对`AutoLotEntities`类的更改(除非您使用了 Visual Studio 2015 中可用的自动重构)。打开文件，将两个出现的`Inventory`更改为`Car`，将`DbSet<Car>`更改为`Cars`。更新后的代码如下所示:

`public partial class AutoLotEntities : DbContext`

`{`

`public AutoLotEntities()`

`: base("name=AutoLotConnection")`

`{`

`}`

`// Additional code removed for brevity`

`public virtual DbSet<Car> Cars { get; set; }`

`protected override void OnModelCreating(DbModelBuilder modelBuilder)`

`{`

`modelBuilder.Entity<Car>()`

`.HasMany(e => e.Orders)`

`.WithRequired(e => e.Car`

`.WillCascadeOnDelete(false);`

`// Additional code removed for brevity`

`}`

`}`

Note

EF 团队为 Visual Studio 发布了一套强大的工具(恰当地命名为实体框架强大工具)。这些工具允许以各种方式绘制 EDM 和附加功能。在撰写本文时，遗憾的是它们不可用于 Visual Studio 2015。随时关注 [`https://visualstudiogallery.msdn.microsoft.com/72a60b14-1581-4b9b-89f2-846072eff19d/`](https://visualstudiogallery.msdn.microsoft.com/72a60b14-1581-4b9b-89f2-846072eff19d/) 的更新。

### 添加到生成的模型类

所有设计器生成的类都是用关键字`partial`声明的，如果您还记得的话，这个关键字允许您跨多个 C#代码文件实现一个类。这在使用 EF 编程模型时特别有用，因为这意味着您可以向您的实体类添加额外的方法，帮助您更好地对业务领域建模。

例如，您可以覆盖`Car`实体类的`ToString()`方法，用格式良好的`string`返回实体的状态。如果您将它添加到生成的类中，那么每次重新生成模型类时，您都有丢失自定义代码的风险。相反，在名为`CarPartial.cs`的新文件中定义下面的分部类声明。下面列出了新的类:

`public partial class Car`

`{`

`public override string ToString()`

`{`

`// Since the PetName column could be empty, supply`

`// the default name of **No Name**.`

`return $"{this.CarNickName ?? "**No Name**"} is a {this.Color} {this.Make} with ID {this.CarId}.";`

`}`

`}`

## 在代码中使用模型类

现在您已经有了模型类，您可以编写一些代码来与它们以及数据库进行交互。首先向您的`Program`类添加`AutoLotConsoleApp.EF`和`static System.Console`的`using`语句。

### 插入记录

从`Main()`(名为`AddNewRecord()`)添加一个助手方法，这将向`Inventory`表中插入一条新记录。

`private static int AddNewRecord()`

`{`

`// Add record to the Inventory table of the AutoLot`

`// database.`

`using (var context = new AutoLotEntities())`

`{`

`try`

`{`

`// Hard-code data for a new record, for testing.`

`var car = new Car() { Make = "Yugo", Color = "Brown", CarNickName="Brownie"};`

`context.Cars.Add(car);`

`context.SaveChanges();`

`// On a successful save, EF populates the database generated identity field.`

`return car.CarId;`

`}`

`catch(Exception ex)`

`{`

`WriteLine(ex.InnerException.Message);`

`return 0;`

`}`

`}`

`}`

这段代码在`DbSet<Car>`类上使用了`Add()`方法。`Add()`方法获取一个类型为`Car`的对象，并将其添加到`AutoLotEntities`上下文类的`Cars`集合中。通过用`DbSet<Car>`的`Add()`方法插入一个新的`Car`对象，然后在上下文中调用`SaveChanges()`，您已经执行了一次 SQL 插入。当调用`SaveChanges`时，所有挂起的更改(在本例中，只有一个额外的记录)都被保存到数据库中。如果没有错误发生，那么记录被添加，并且用任何数据库生成的值更新`Car`对象，在本例中是`CarId`。

要查看这一点，请像这样更新`Main()`方法:

`static void Main(string[] args)`

`{`

`WriteLine("***** Fun with ADO.NET EF *****\n");`

`int carId = AddNewRecord();`

`WriteLine(carId);`

`ReadLine();`

`}`

控制台的输出实际上是新记录的`CarId`。值得注意的是，虽然您不必做任何特殊的事情来获取数据库生成的 id，但是 EF 会代表您执行一个 SELECT 语句来获取`CarId`值。在大多数应用中，这不是什么大问题，但是如果出现性能或伸缩问题，并且您需要开始调整调用，理解这一点是很重要的。

### 选择记录

有几种方法可以使用 EF 从数据库中获取记录。最简单的方法是迭代`DbSet<Car>`集合。要看到这一点，添加一个名为`PrintAllInventory()`的新方法。为`DbContext`(返回一个`DbSet<Car>`)的`Cars`属性添加一个`foreach`循环，并打印每辆汽车，如下所示:

`private static void PrintAllInventory()`

`{`

`// Select all items from the Inventory table of AutoLot,`

`// and print out the data using our custom ToString()`

`// of the Car entity class.`

`using (var context = new AutoLotEntities())`

`{`

`foreach (Car c in context.Cars)`

`{`

`WriteLine(c);`

`}`

`}`

`}`

要查看这一点，请按如下方式更新您的`Main()`方法:

`class Program`

`{`

`static void Main(string[] args)`

`{`

`WriteLine("***** Fun with ADO.NET EF *****\n");`

`//int carId = AddNewRecord();`

`//WriteLIne(carId);`

`PrintAllInventory();`

`ReadLine();`

`}`

枚举由`Cars`属性公开的每一项都会向底层 ADO.NET 数据提供者隐式提交一个 SQL SELECT 语句。需要注意的是，EF 正在创建一个`DataReader`来从数据库中加载记录，然后将记录从`DataReader`转换成`Car`类型。

#### 使用 SQL 查询

EF 还支持用 SQL 填充`DbSet`(无论是内联还是存储过程)。要对此进行测试，请将`PrintInventory()`方法更新为以下内容:

`private static void PrintAllInventory()`

`{`

`// Select all items from the Inventory table of AutoLot,`

`// and print out the data using our custom ToString()`

`// of the Car entity class.`

`using (var context = new AutoLotEntities())`

`{`

`//foreach (Car c in context.Cars)`

`//{`

`//    WriteLine(c);`

`//}`

`foreach (Car c in context.Cars.SqlQuery("Select CarId,Make,Color,PetName as CarNickName from Inventory where Make=@p0", "BMW"))`

`{`

`WriteLine(c);`

`}`

`}`

`}`

好消息是，这会用跟踪的实体填充列表，这意味着当调用`SaveChanges`时，任何更改或删除都会传播到数据库。坏消息是(正如您从 SQL 文本中看到的)`SqlQuery`不理解您之前所做的映射更改。您不仅必须使用数据库表和字段名，而且任何字段名的更改(例如对`PetName`的更改)都必须从数据库字段名别名到模型属性名。

#### 向 LINQ 询问

当你加入 LINQ 查询时，EF 变得更加强大。考虑对使用 LINQ 从数据库获取记录的`PrintInventory()`方法的更新:

`private static void PrintAllInventory()`

`{`

`// Select all items from the Inventory table of AutoLot,`

`// and print out the data using our custom ToString()`

`// of the Car entity class.`

`using (var context = new AutoLotEntities())`

`{`

`//foreach (Car c in context.Cars)`

`//{`

`//    WriteLine(c);`

`//}`

`//foreach (Car c in context.Cars.SqlQuery("Select CarId,Make,Color,PetName as CarNickName from Inventory where Make=@p0", "BMW"))`

`//{`

`//    WriteLine(c);`

`//}`

`foreach (Car c in context.Cars.Where(c => c.Make == "BMW"))`

`{`

`WriteLine(c);`

`}`

`}`

LINQ 语句被翻译成一个 SQL 查询，该查询创建一个`DataReader`，然后返回一个附加的`Cars`集合。生成的查询如下所示(在您的机器上可能略有不同):

`SELECT`

`[Extent1].[CarId] AS [CarId],`

`[Extent1].[Make] AS [Make],`

`[Extent1].[Color] AS [Color],`

`[Extent1].[PetName] AS [PetName]`

`FROM [dbo].[Inventory] AS [Extent1]`

`WHERE N’BMW’ = [Extent1].[Make]`

鉴于你已经在第 13 章中使用了许多 LINQ 的表达方式，现在再举几个例子就够了。

`private static void FunWithLinqQueries()`

`{`

`using (var context = new AutoLotEntities())`

`{`

`// Get a projection of new data.`

`var colorsMakes = from item in context.Cars select new { item.Color, item.Make };`

`foreach (var item in colorsMakes)`

`{`

`WriteLine(item);`

`}`

`// Get only items where Color == "Black"`

`var blackCars = from item in context.Cars where item.Color == "Black" select item;`

`foreach (var item in blackCars)`

`{`

`WriteLine(item);`

`}`

`}`

`}`

虽然这些查询的语法非常简单，但是请记住，每次对对象上下文应用 LINQ 查询时，您都是在访问数据库！回想一下，当您想要获得一个独立的数据副本(这可能是新 LINQ 查询的目标)时，您想要使用带有`ToList<T>()`、`ToArray<T>()`或`ToDictionary<K,V>()`扩展方法的立即执行。下面是对前面方法的更新，它执行与 SELECT *等效的操作，将实体缓存为数组，并使用对象的 LINQ 操作数组数据:

`using (var context = new AutoLotEntities())`

`{`

`// Get all data from the Inventory table.`

`// Could also write:`

`// var allData = (from item in context.Cars select item).ToArray();`

`var allData = context.Cars.ToArray();`

`// Get a projection of new data.`

`var colorsMakes = from item in allData select new { item.Color, item.Make };`

`foreach (var item in colorsMakes)`

`{`

`WriteLine(item);`

`}`

`// Get only items where Color == “Black”.`

`var blackCars = from item in allData where item.Color== "Black" select item;`

`foreach (var item in blackCars)`

`{`

`WriteLine(item);`

`}`

`}`

要运行这个，将`Main()`方法更新为:

`static void Main(string[] args)`

`{`

`WriteLine("***** Fun with ADO.NET EF *****\n");`

`//int carId = AddNewRecord();`

`//WriteLine(carId);`

`//PrintAllInventory();`

`FunWithLinqQueries();`

`ReadLine();`

`}`

### 导航属性的作用

顾名思义，导航属性允许您在实体框架编程模型中捕获连接操作(无需编写复杂的 SQL 语句)。为了说明这些外键关系，模型中的每个类都包含将类连接在一起的虚拟属性。例如，在`Inventory.cs`类中，`Orders`属性被定义为`virtual ICollection<Order>`。

`public virtual ICollection<Order> Orders { get; set; }`

这告诉 EF 每个`Inventory`数据库记录(对于 C#代码重命名为`Car`类)可以有零到多个`Order`记录。

`Order`模型有零到一的`Inventory` ( `Car`)记录与之相关联。`Order`模型通过另一个`Inventory`类型的`virtual`属性导航回`Inventory`模型。

`public virtual Car Car { get; set; }`

#### 懒惰、急切和显式加载

EF 有三种方式将数据加载到模型中。惰性抓取和急切抓取基于上下文的设置，第三个是显式抓取，由开发人员控制。

##### 惰性装载

修改后的`virtual`允许 EF 延迟加载数据。这意味着 EF 为每个对象加载最少的内容，然后在代码中需要属性时检索额外的细节。例如，如果您有下面的代码，EF 将调用一个查询来获取所有的`Car`，然后对每个`Car`执行另一个查询来获取所有的`Order`:

`using (var context = new AutoLotEntities())`

`{`

`foreach (Car c in context.Cars)`

`{`

`foreach (Order o in c.Orders)`

`{`

`WriteLine(o.OrderId);`

`}`

`}`

`}`

延迟加载防止整个数据库(或者至少比预期的多得多)被加载到内存中。由于`Orders`被绑定到`Cars`并且`Customers`被绑定到`Orders`，如果记录被急切地加载，那么获得所有`Cars`也将获得所有`Orders`和`Customers`(除了那些没有任何订单的客户)。

##### 急切装载

有时您希望加载所有相关记录。例如，如果您完全知道您需要所有的`Orders`和所有的`Cars`，您可以将前面的代码改为:

`using (var context = new AutoLotEntities())`

`{`

`foreach (Car c in context.Cars.Include(c=>c.Orders))`

`{`

`foreach (Order o in c.Orders)`

`{`

`WriteLine(o.OrderId);`

`}`

`}`

`}`

那么初始查询将得到所有的`Cars`和所有的`Orders`。`Include` LINQ 表达式指示 EF 编写一个查询来获取它们，如下所示:

`SELECT`

`[Project1].[CarId] AS [CarId],`

`[Project1].[Make] AS [Make],`

`[Project1].[Color] AS [Color],`

`[Project1].[PetName] AS [PetName],`

`[Project1].[C1] AS [C1],`

`[Project1].[OrderId] AS [OrderId],`

`[Project1].[CustId] AS [CustId],`

`[Project1].[CarId1] AS [CarId1]`

`FROM ( SELECT`

`[Extent1].[CarId] AS [CarId],`

`[Extent1].[Make] AS [Make],`

`[Extent1].[Color] AS [Color],`

`[Extent1].[PetName] AS [PetName],`

`[Extent2].[OrderId] AS [OrderId],`

`[Extent2].[CustId] AS [CustId],`

`[Extent2].[CarId] AS [CarId1],`

`CASE WHEN ([Extent2].[OrderId] IS NULL) THEN CAST(NULL AS int) ELSE 1 END AS [C1]`

`FROM  [dbo].[Inventory] AS [Extent1]`

`LEFT OUTER JOIN [dbo].[Orders] AS [Extent2] ON [Extent1].[CarId] = [Extent2].[CarId]`

`)  AS [Project1]`

`ORDER BY [Project1].[CarId] ASC, [Project1].[C1] ASC`

查询的确切语法并不重要；我展示它是为了演示所有的`Cars`和`Orders`都是在对数据库的一次调用中获得的。

##### 显式加载

显式加载加载由导航属性引用的集合或类。如果延迟加载被禁用，那么您需要立即加载相关对象或者显式加载它们。您可以通过在`DbContext`配置上设置`LazyLoadingEnabled`属性来关闭延迟加载，如下所示:

`context.Configuration.LazyLoadingEnabled = false;`

然后，要获得相关的对象，您必须使用`context`和`Load`的`Collection`(对于集合)或`Property`(对于单个对象)方法。下面的代码显示了如何使用`Collection.Load()`:

`foreach (Car c in context.Cars)`

`{`

`context.Entry(c).Collection(x => x.Orders).Load();`

`foreach (Order o in c.Orders)`

`{`

`WriteLine(o.OrderId);`

`}`

`}`

### 删除记录

当您想从数据库中删除一条记录时，一种方法是在`DbSet<T>`中找到正确的条目，然后调用`Remove`，传入该实例。您可以通过调用`DbSet<T>`上的`Find()`方法并传入您想要删除的汽车的主键来找到正确的记录。将以下方法添加到您的类中:

`private static void RemoveRecord(int carId)`

`{`

`// Find a car to delete by primary key.`

`using (var context = new AutoLotEntities())`

`{`

`// See if we have it.`

`Car carToDelete = context.Cars.Find(carId);`

`if (carToDelete != null)`

`{`

`context.Cars.Remove(carToDelete);`

`context.SaveChanges();`

`}`

`}`

`}`

要运行它，将`Main()`方法更新为(如果您在前面的例子中注释掉了`AddNewRecord()`行，请记住取消注释):

`static void Main(string[] args)`

`{`

`WriteLine("***** Fun with ADO.NET EF *****\n");`

`int carId = AddNewRecord();`

`RemoveRecord(carId);`

`//WriteLine(carId);`

`//PrintAllInventory();`

`//FunWithLinqQueries();`

`ReadLine();`

`}`

Note

在删除记录之前调用`Find()`需要额外的数据库往返。正如您接下来将看到的，设置`EntityState`是删除记录的一种更有效的方式。

#### 使用 EntityState 删除记录

如前所述，您可以使用`EntityState`删除记录，这不需要往返数据库。添加一个名为`RemoveRecordUsingEntityState()`的新方法，如下:

`private static void RemoveRecordUsingEntityState(int carId)`

`{`

`using (var context = new AutoLotEntities())`

`{`

`Car carToDelete = new Car() { CarId = carId };`

`context.Entry(carToDelete).State = EntityState.Deleted;`

`try`

`{`

`context.SaveChanges();`

`}`

`catch (DbUpdateConcurrencyException ex)`

`{`

`WriteLine(ex);`

`}`

`}`

`}`

创建一个新的`Car`对象，将主键设置为要删除的值，将`EntityState`设置为`EntityState.Deleted`，然后调用`SaveChanges()`。您获得了性能(因为您没有对数据库进行额外的调用)，但是您失去了对象存在于数据库中的验证(如果这对您的场景有影响的话)。如果数据库中不存在`CarId`，EF 将在`System.Data.Entity.Infrastructure`名称空间中抛出一个`DbUpdateConcurrencyException`。发生错误的确切实体可以从异常的`Entries`属性中访问，因此您可以确定哪些实体发生了错误。

Note

没有更新的事实不会触发`DbUpdateConcurrencyException`异常。当应该更新或删除的对象总数(基于实体状态)大于实际更新的对象总数时，将引发该异常。出错的对象通过异常的`Entries`属性公开。对于每个条目，您可以访问属性的当前值、原始值和当前数据库值(通过执行另一个查询)。

### 更新记录

更新记录也很简单。找到要更改的对象，在返回的实体上设置新的属性值，并保存更改，如下所示:

`private static void UpdateRecord(int carId)`

`{`

`// Find a car to delete by primary key.`

`using (var context = new AutoLotEntities())`

`{`

`// Grab the car, change it, save!`

`Car carToUpdate = context.Cars.Find(carId);`

`if (carToUpdate != null)`

`{`

`WriteLine(context.Entry(carToUpdate).State);`

`carToUpdate.Color = "Blue";`

`WriteLine(context.Entry(carToUpdate).State);`

`context.SaveChanges();`

`}`

`}`

`}`

## 处理数据库更改

在本节中，您创建了一个从现有数据库开始的 EF 解决方案。例如，当您的组织有专门的 DBA，而您有一个自己无法控制的数据库时，这种方法非常有效。随着数据库的不断变化，您需要做的就是再次运行向导并重新创建您的`AutoLotEntities`类；模型类也将为您重新构建。当然，您很可能需要重构任何使用您的模型的代码。但是，嘿，如果所有的事情都神奇地为你做了，那就一点都不好玩了！

这个最初的例子将有助于您理解使用实体框架的具体细节。

Source Code

您可以在 [`Chapter 23`](23.html) 子目录中找到 AutoLotConsoleApp 示例。

## 自动代码版本 4

在上一节中，您从现有的数据库中创建了 EF 代码。EF 也可以根据你的模型类和派生的`DbContext`类为你创建数据库。除了创建初始数据库之外，EF 还允许您创建迁移来更新您的数据库，以匹配模型更改。

Note

这是`AutoLotDAL.dll`的版本，它将延续到本书的其余部分。

首先，创建一个名为 AutoLotDAL 的新类库项目。删除创建的默认类，并添加两个文件夹，名为`EF`和`Models`。使用 NuGet 将实体框架添加到项目中。右击项目名称，点击管理 NuGet 包(见图 [23-8](#Fig8) )。(您不需要显式地将 EF 添加到前面的示例中，因为向导已经帮您完成了。我喜欢手动添加软件包，这样我就知道安装的是什么版本。)

![A978-1-4842-1332-2_23_Fig8_HTML.jpg](img/A978-1-4842-1332-2_23_Fig8_HTML.jpg)

图 23-8。

Selecting Manage NuGet Packages

NuGet 包管理器加载后，选择实体框架(如图 [23-9](#Fig9) )。

![A978-1-4842-1332-2_23_Fig9_HTML.jpg](img/A978-1-4842-1332-2_23_Fig9_HTML.jpg)

图 23-9。

NuGet Package Manager

接受变更和许可协议，实体框架(撰写本文时的版本 6.1.3)将被安装到您的项目中。

### 实体框架数据注释

我之前简单讨论过数据注释，你看到了正在使用的`Table`、`Column`、`Key`和`StringLength`。您可以使用更多的注释来优化您的模型和添加验证，并且您将在本章和本书的剩余部分使用其中的许多注释。

Note

中有更多可用的数据注释。NET 框架比表 [23-5](#Tab5) 所示。参考。NET 4.6 框架文档了解更多信息。

表 23-5。

Data Annotations Supported by Entity Framework

<colgroup><col> <col></colgroup> 
| 数据注释 | 生命的意义 |
| --- | --- |
| `Key` | 定义模型的主键。如果键属性被命名为`Id`或者将类名与`Id`组合在一起，比如`OrderId`，那么这是不必要的。如果键是复合键，必须添加带有`Order`的`Column`属性，比如`Column[Order=1]`和`Column[Order=2]`。关键字段也是隐式的`[Required]`。 |
| `Required` | 将属性声明为不可为空。 |
| `ForeignKey` | 声明一个用作导航属性的外键的属性。 |
| `StringLength` | 指定字符串属性的最小和最大长度。 |
| `NotMapped` | 声明未映射到数据库字段的属性。 |
| `ConcurrencyCheck` | 当数据库服务器执行更新、插入或删除操作时，标记要在并发检查中使用的字段。 |
| `TimeStamp` | 将类型声明为行版本或时间戳(取决于数据库提供程序)。 |
| `Table Column` | 允许您以不同于在数据库中声明的方式命名模型类和字段。`Table`属性也允许指定模式(只要数据存储支持模式)。 |
| `DatabaseGenerated` | 指定字段是否由数据库生成。这需要`Computed`、`Identity`或`None`中的一个。 |
| `NotMapped` | 指定 EF 需要忽略关于数据库字段的此属性。 |
| `Index` | 指定应该为列创建索引。您可以指定群集、唯一、名称和顺序。 |

Note

除了数据注释，EF 还支持一个流畅的 API 来定义你的表结构和关系。虽然您在前面的部分看到了一个小例子，但是流畅的 API 超出了本章的范围。你可以在这里找到更多关于使用 Fluent API 定义表和列的信息: [`https://msdn.microsoft.com/en-us/data/jj591617`](https://msdn.microsoft.com/en-us/data/jj591617) 。你可以在这里找到更多关于定义关系的信息: [`https://msdn.microsoft.com/en-us/data/jj591620`](https://msdn.microsoft.com/en-us/data/jj591620) 。

### 添加或更新模型类

在本节中，您可以从上一个示例中创建的模型类开始，也可以从头开始，在完成本章的练习时创建新的类。我将从头开始，所以你可以从头到尾跟踪整个过程。

首先向您的项目添加一个名为`Models`的新文件夹，并添加四个类，分别名为`CreditRisk.cs`、`Customer.cs`、`Inventory.cs`和`Order.cs`。

#### 创建库存模型类

打开`Inventory.cs`，将类更改为`public`和`partial`，并将以下属性以及`System.ComponentModel.DataAnnotations`和`System.ComponentModel.DataAnnotations.Schema`的`using`添加到类的顶部:

`public partial class Inventory`

`{`

`public int CarId { get; set; }`

`public string Make { get; set; }`

`public string Color { get; set; }`

`public string PetName { get; set; }`

`}`

##### 使用数据注释配置模型

首先使用`Table`属性指定`Inventory`的表名。默认情况下，EF 使用了表名是复数的惯例，所以默认的表名是`Inventories`。将`Key`属性添加到`CarId`属性，并为每个字符串属性添加`StringLength(50)`。`Key`属性表示该字段是表的主键。`StringLength(50)`设置字符串属性的最大长度。您也可以设置最小长度，尽管最小值仅用于验证，不会像 max 那样影响数据库字段的创建。下面列出了更新后的代码:

`using System.Collections.Generic;`

`using System.ComponentModel.DataAnnotations;`

`using System.ComponentModel.DataAnnotations.Schema;`

`namespace AutoLotDAL.Models`

`{`

`[Table("Inventory")]`

`public partial class Inventory`

`{`

`[Key]`

`public int CarId { get; set; }`

`[StringLength(50)]`

`public string Make { get; set; }`

`[StringLength(50)]`

`public string Color { get; set; }`

`[StringLength(50)]`

`public string PetName { get; set; }`

`}`

`}`

##### 将导航属性添加到清单

如导航属性一节所述，与`Inventory`记录相关的`Orders`通过`ICollection<Order>`访问，如下所示:

`public virtual ICollection<Order> Orders { get; set; } = new HashSet<Order>();`

下面列出了完整的类:

`using System.Collections.Generic;`

`using System.ComponentModel.DataAnnotations;`

`using System.ComponentModel.DataAnnotations.Schema;`

`namespace AutoLotDAL.Models`

`{`

`[Table("Inventory")]`

`public partial class Inventory`

`{`

`[Key]`

`public int CarId { get; set; }`

`[StringLength(50)]`

`public string Make { get; set; }`

`[StringLength(50)]`

`public string Color { get; set; }`

`[StringLength(50)]`

`public string PetName { get; set; }`

`public virtual ICollection<Order> Orders { get; set; } = new HashSet<Order>();`

`}`

`}`

##### 添加 InventoryPartial 类

现在您将添加一个分部类来覆盖`Inventory`类的`ToString()`方法。在`Models`目录下新建一个目录，命名为`Partials`。添加一个名为`InventoryPartial.cs`的新类。打开`InventoryPartial.cs`类，将该类重命名为`Inventory`，并确保名称空间设置为`AutoLotDAL.Models`(不是默认的`AutoLotDAL.Models.Partials`)。添加以下代码:

`public partial class Inventory`

`{`

`public override string ToString()`

`{`

`// Since the PetName column could be empty, supply`

`// the default name of **No Name**.`

`return $"{this.PetName ?? "**No Name**"} is a {this.Color} {this.Make} with ID {this.CarId}.";`

`}`

`}`

接下来，添加一个结合汽车的`Make`和`Color`的计算字段。这是一个不存储在数据库中的字段，当一个对象用数据库中的数据具体化时，它不会被填充，所以您需要将`[NotMapped]`属性添加到属性中。

`[NotMapped]`

`public string MakeColor => $"{Make} + ({Color})";`

#### 创建客户模型类

打开`Customer.cs`类并将`System.ComponentModel.DataAnnotations`和`System.ComponentModel.DataAnnotations.Schema`的`using`添加到类的顶部。这个过程和你输入的`Inventory`类是一样的，所以我在这里只列出代码。需要注意的一点是`FullName`属性，它是经过计算的，因此应用了`NotMapped`属性。以下是该类的完整内容:

`using System.Collections.Generic;`

`using System.ComponentModel.DataAnnotations;`

`using System.ComponentModel.DataAnnotations.Schema;`

`namespace AutoLotDAL.Models`

`{`

`public partial class Customer`

`{`

`[Key]`

`public int CustId { get; set; }`

`[StringLength(50)]`

`public string FirstName { get; set; }`

`[StringLength(50)]`

`public string LastName { get; set; }`

`[NotMapped]`

`public string FullName => FirstName + " " + LastName;`

`public virtual ICollection<Order> Orders { get; set; } = new HashSet<Order>();`

`}`

`}`

#### 创建订单模型类

打开`Order.cs`类并将`System.ComponentModel.DataAnnotations`和`System.ComponentModel.DataAnnotations.Schema`的`using`添加到类的顶部。添加`OrderId`主键字段，然后添加`Customer`和`Car`导航属性。除了导航属性，添加外键字段`CustId`和`CarId`。该类如下所示:

`using System.ComponentModel.DataAnnotations;`

`using System.ComponentModel.DataAnnotations.Schema;`

`namespace AutoLotDAL.Models`

`{`

`public partial class Order`

`{`

`public int OrderId { get; set; }`

`public int CustId { get; set; }`

`public int CarId { get; set; }`

`public virtual Customer Customer { get; set; }`

`public virtual Inventory Car { get; set; }`

`}`

`}`

现在您将把数据注释属性应用到`Order.cs`类。主键`OrderId`，也是表的主键(因此是必需的)，并被设置为一个`Identity`列。您想要向`OrderId`属性添加三个属性。

*   `[Key]`:表示主键
*   `[Required]`:表示该字段不可为空
*   `[DatabaseGenerated(DatabaseGeneratedOption.Identity)]`:表示该字段是一个`Identity`列

正如您在本书前面所回忆的，您可以单独列出所有三个属性，也可以作为逗号分隔的列表一起列出。将它们放在一起，您的`OrderId`属性应该如下所示:

`[Key, Required, DatabaseGenerated(DatabaseGeneratedOption.Identity)]`

`public int OrderId { get; set;}`

默认情况下，支持导航属性的两个值都是必需的，因为类型不可为空。但是，为了可读性，您将显式地将它们标记为 required。

`[Required]`

`public int CustId { get; set; }`

`[Required]`

`public int CarId { get; set; }`

最后，使用注释来指示哪些属性作为两个导航属性的支持字段。

`[ForeignKey("CustId")]`

`public virtual Customer Customer { get; set; }`

`[ForeignKey("CarId")]`

`public virtual Inventory Car { get; set; }`

下面列出了整个类:

`public partial class Order`

`{`

`[Key, Required, DatabaseGenerated(DatabaseGeneratedOption.Identity)]`

`public int OrderId { get; set; }`

`[Required]`

`public int CustId { get; set; }`

`[Required]`

`public int CarId { get; set; }`

`[ForeignKey("CustId")]`

`public virtual Customer Customer { get; set; }`

`[ForeignKey("CarId")]`

`public virtual Inventory Car { get; set; }`

`}`

#### 创建信用风险类别

打开`CreditRisk.cs`类，将`System.ComponentModel.DataAnnotations`的`usings`和`System.ComponentModel.DataAnnotations.Schema`添加到类的顶部。您需要对`CreditRisk.cs`模型类进行的唯一更改是移动到新的名称空间。初始类如下所示:

`using System.ComponentModel.DataAnnotations;`

`using System.ComponentModel.DataAnnotations.Schema;`

`namespace AutoLotDAL.Models`

`{`

`public partial class CreditRisk`

`{`

`public int CustId { get; set; }`

`public string FirstName { get; set; }`

`public string LastName { get; set; }`

`}`

`}`

为`CustId`添加`Key`属性，为`FirstName`和`LastName`添加`StringLength`属性。完整的`Order.cs`类如下所示:

`namespace AutoLotDAL.Models`

`{`

`public partial class CreditRisk`

`{`

`[Key]`

`public int CustId { get; set; }`

`[StringLength(50)]`

`public string FirstName { get; set; }`

`[StringLength(50)]`

`public string LastName { get; set; }`

`}`

`}`

### 添加数据库上下文

这个难题的一个重要部分仍然缺失:从`DbContext`派生的上下文类！幸运的是，这很容易添加。选择`AutoLotDAL`项目中的 EF 文件夹，并选择项目➤添加新项目菜单选项。在左侧栏中选择数据，在主栏中选择 ADO.NET 实体数据模型，输入`AutoLotEntities`作为名称(如图 [23-10](#Fig10) )。

![A978-1-4842-1332-2_23_Fig10_HTML.jpg](img/A978-1-4842-1332-2_23_Fig10_HTML.jpg)

图 23-10。

Adding a context to your project

在实体数据模型向导中，选择空代码优先模型(如图 [23-11](#Fig11) )。

![A978-1-4842-1332-2_23_Fig11_HTML.jpg](img/A978-1-4842-1332-2_23_Fig11_HTML.jpg)

图 23-11。

Selecting the Empty Code First model

一个区别可能变得很明显:向导从不要求您输入连接字符串！空数据库向导中的代码首先假定没有数据库(如图所示)，因此它为您构建了一个新的连接字符串，您将在下一节中对此进行研究。

#### *的更新。配置文件和 EF 连接字符串

打开`App.config`文件，查看 EF 所做的更改。其中大部分你应该很熟悉。两个明显的区别是连接字符串中的`data source`和`initial catalog`属性。

`<connectionStrings>`

`<add name="AutoLotEntities" connectionString="data source=``(LocalDb)\MSSQLLocalDB`T2】

`</connectionStrings>`

`LocalDb`是面向应用开发人员的 SQL Server Express 版本。它使用最少的文件集，不需要开发人员进行任何配置。您可以使用具有唯一名称的`(LocalDb)`，而不是服务器名，比如`(local)\SQLEXPRESS2014`。

目录(数据库名称)是从命名空间加上向导中分配的名称派生出来的。这种情况下是`AutoLotDAL.EF.AutoLotEntities`。

在本章的后面，您将把数据库移动到 SQL Server Express(为了后面章节的方便)，但是现在只需把目录的名称改为`AutoLot`，把连接字符串改为`AutoLotConnection`。

`<add name="AutoLotConnection" connectionString="data source=(LocalDb)\MSSQLLocalDb;initial catalog=AutoLot;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework" providerName="System.Data.SqlClient" />`

#### 更新上下文

派生的`DbContext`类的构造函数将连接字符串的名称传递给基类`DbContext`。打开`AutoLotEntities.cs`，将构造函数中的连接字符串改为`AutoLotConnection`。更新后的代码如下所示:

`public class AutoLotEntities : DbContext`

`{`

`public AutoLotEntities()`

`: base("name=AutoLotConnection")`

`{`

`}`

`}`

为模型(`AutoLotDAL.Models`)添加`using`语句，然后为每个模型类添加一个`DbSet`。相关代码如下所示:

`public virtual DbSet<CreditRisk> CreditRisks { get; set; }`

`public virtual DbSet<Customer> Customers { get; set; }`

`public virtual DbSet<Inventory> Inventory { get; set; }`

`public virtual DbSet<Order> Orders { get; set; }`

### 添加存储库

一种常见的数据访问设计模式是存储库模式。正如 Martin Fowler 所描述的，该模式的核心是在域和数据映射层之间进行协调。虽然对存储库模式的完整解释超出了本书的范围，但是该模式有助于消除重复代码。

Note

您可以在 Martin Fowler 的网站 [`www.martinfowler.com/eaaCatalog/repository.html`](http://www.martinfowler.com/eaaCatalog/repository.html) 上找到关于存储库模式的更多信息。

#### 添加 IRepo 界面

EF 的一个优点是所有的模型和集合都是强类型的。您希望您的存储库类继续这种趋势。首先在名为`Repos`的`AutoLotDAL`项目中添加一个新文件夹。在`Repos`文件夹中添加一个名为`IRepo`的新接口。

该接口将为您的模型公开基本的 CRUD 方法。你将公开同步和异步版本(关于异步版本的更多信息，参见第 19 章)。下面列出了完整的界面:

`interface IRepo<T>`

`{`

`int Add(T entity);`

`Task<int> AddAsync(T entity);`

`int AddRange(IList<T> entities);`

`Task<int> AddRangeAsync(IList<T> entities);`

`int Save(T entity);`

`Task<int> SaveAsync(T entity);`

`int Delete(int id);`

`Task<int> DeleteAsync(int id);`

`int Delete(T entity);`

`Task<int> DeleteAsync(T entity);`

`T GetOne(int? id);`

`Task<T> GetOneAsync(int? id);`

`List<T> GetAll();`

`Task<List<T>> GetAllAsync();`

`List<T> ExecuteQuery(string sql);`

`Task<List<T>> ExecuteQueryAsync(string sql);`

`List<T> ExecuteQuery(string sql,object[] sqlParametersObjects );`

`Task<List<T>> ExecuteQueryAsync(string sql, object[] sqlParametersObjects);`

`}`

最后四个成员允许传入一个字符串 SQL 查询(带有接受 SQL 字符串参数的重载)。执行这些方法会将实体加载(并跟踪)到上下文的`DbSet<T>`中。通常不使用这些方法，因为您可以使用 LINQ 构建强大的查询，这些查询对开发人员隐藏了 SQL 细节，但是这里包含这些方法是为了展示如何在上下文中直接调用 SQL。

Note

对于从大容量系统(比如 web 应用或服务)异步执行数据访问代码的优点和潜在问题，已经有了很多讨论。我将在本书中介绍 EF 的同步和异步机制，并让您来测试您的特定应用。

#### 添加 BaseRepo

接下来，将另一个名为`BaseRepo`的类添加到`Repos`目录中。这个类将实现所有存储库类的公共功能，它们都将继承这些功能。该类将是一个泛型类，因此派生的存储库可以强类型化这些方法。首先为`AutoLotEntities`上下文添加一个受保护的属性，并实例化它。初始类定义如下所示:

`using AutoLotDAL.EF;`

`public abstract class BaseRepo<T> where T:class,new()`

`{`

`public AutoLotEntities Context { get; } = new AutoLotEntities();`

`}`

所有的动作都从上下文的`DbSet<T>`属性开始，所以添加一个名为`DbSet<T>`的表的受保护属性，如下所示:

`using AutoLotDAL.EF;`

`public abstract class BaseRepo<T>:where T:class,new()`

`{`

`public AutoLotEntities Context { get; } = new AutoLotEntities();`

`protected DbSet<T> Table;`

`}`

##### 实现 SaveChanges() Helper 方法

接下来，添加两种保存更改的方法，一种是同步的，另一种是异步的。这些方法仅仅是`DbContext`的`SaveChanges()`和`SaveChangesAsync()`方法的包装器，并且被放在基类中，因此所有派生的库可以共享实现。调用这些方法通常需要大量的代码和错误处理代码，最好只编写一次代码。`DbContext`上的`SaveChanges()`方法的异常处理程序被清除。在生产应用中，您需要相应地处理任何异常。

`internal int SaveChanges()`

`{`

`try`

`{`

`return Context.SaveChanges();`

`}`

`catch (DbUpdateConcurrencyException ex)`

`{`

`//Thrown when there is a concurrency error`

`//for now, just rethrow the exception`

`throw;`

`}`

`catch (DbUpdateException ex)`

`{`

`//Thrown when database update fails`

`//Examine the inner exception(s) for additional`

`//details and affected objects`

`//for now, just rethrow the exception`

`throw;`

`}`

`catch (CommitFailedException ex)`

`{`

`//handle transaction failures here`

`//for now, just rethrow the exception`

`throw;`

`}`

`catch (Exception ex)`

`{`

`//some other exception happened and should be handled`

`throw;`

`}`

`}`

`internal async Task<int> SaveChangesAsync()`

`{`

`try`

`{`

`return await Context.SaveChangesAsync();`

`}`

`catch (DbUpdateConcurrencyException ex)`

`{`

`//Thrown when there is a concurrency error`

`//for now, just rethrow the exception`

`throw;`

`}`

`catch (DbUpdateException ex)`

`{`

`//Thrown when database update fails`

`//Examine the inner exception(s) for additional`

`//details and affected objects`

`//for now, just rethrow the exception`

`throw;`

`}`

`catch (CommitFailedException ex)`

`{`

`//handle transaction failures here`

`//for now, just rethrow the exception`

`throw;`

`}`

`catch (Exception ex)`

`{`

`//some other exception happened and should be handled`

`throw;`

`}`

`}`

Note

从性能角度来看，创建一个新的`DbContext`实例可能是一个开销很大的过程。当您的上下文类的一个新实例被创建时，基类`DbContext`与数据库进行几次通信。这种通信的数量会因多种因素而异，包括模型的复杂性和迁移的数量等等。如果您将在像 WPF 或 WinForms 这样的客户端上使用该类，那么实际上不会创建该类的太多实例。如果这是一个 web 应用(像 ASP.NET web forms 或 ASP.NET MVC)，谨慎的做法可能是让`BaseRepo`成为单例。没有一种绝对的方法，因为每种情况都是不同的，必须根据您的特定应用进行定制。

##### 检索记录

`GetOne()` / `GetOneAsync()`方法包装了`DbSet<T>`的`Find()/FindAsync()`方法。类似地，`GetAll()/GetAllAsync()`方法包装了`ToList()/ToListAsync()`方法。代码如下所示:

`public T GetOne(int? id)  => Table.Find(id);`

`public Task<T> GetOneAsync(int? id)  => Table.FindAsync(id);`

`public List<T> GetAll()  => Table.ToList();`

`public Task<List<T>> GetAllAsync()  => Table.ToListAsync();`

##### 使用 SQL 检索记录

要实现的接口的最后四个方法是 SQL 字符串方法。它们将字符串和参数传递给`DbSet<T>`，如下所示:

`public List<T> ExecuteQuery(string sql)  => Table.SqlQuery(sql).ToList();`

`public Task<List<T>> ExecuteQueryAsync(string sql)`

`=> Table.SqlQuery(sql).ToListAsync();`

`public List<T> ExecuteQuery(string sql, object[] sqlParametersObjects)`

`=> Table.SqlQuery(sql, sqlParametersObjects).ToList();`

`public Task<List<T>> ExecuteQueryAsync(string sql, object[] sqlParametersObjects)`

`=> Table.SqlQuery(sql).ToListAsync();`

Note

对数据存储运行原始 SQL 字符串时应该非常小心，尤其是在字符串接受用户输入的情况下。这样做会使您的应用容易受到 SQL 注入攻击。这本书没有涉及安全性，但是我想指出运行原始 SQL 语句的危险。

##### 添加记录

许多方法可以用泛型在`BaseRepo`中处理。从`Add()`和`AddRange()`方法开始(记住在你的例子中你实现了异步和同步版本；您可能只需要其中一个)。每个`Add()` / `AddRange()`方法都给`DbSet<T>`加一个`T/IList<T>`(由属性`Table`引用)。然后你需要调用`SaveChanges()` / `SaveChangesAsync()`。代码如下所示:

`public int Add(T entity)`

`{`

`Table.Add(entity);`

`return SaveChanges();`

`}`

`public Task<int> AddAsync(T entity)`

`{`

`Table.Add(entity);`

`return SaveChangesAsync();`

`}`

`public int AddRange(IList<T> entities)`

`{`

`Table.AddRange(entities);`

`return SaveChanges();`

`}`

`public Task<int> AddRangeAsync(IList<T> entities)`

`{`

`Table.AddRange(entities);`

`return SaveChangesAsync();`

`}`

您通过实现`IDisposable`接口完成了`BaseRepo`的核心，这有助于确保及时释放任何资源。首先将`IDisposable`接口添加到类中，然后添加以下代码(注意在`Dispose()`方法中调用`Context.Dispose()`):

`public abstract class BaseRepo: IDisposable`

`{`

`protected AutoLotEntities Context { get; } = new AutoLotEntities();`

`//SaveChanges and SaveChangesAsync omitted for brevity`

`bool disposed = false;`

`public void Dispose()`

`{`

`Dispose(true);`

`GC.SuppressFinalize(this);`

`}`

`protected virtual void Dispose(bool disposing)`

`{`

`if (disposed)`

`return;`

`if (disposing)`

`{`

`Context.Dispose();`

`// Free any managed objects here.`

`//`

`}`

`// Free any unmanaged objects here.`

`//`

`disposed = true;`

`}`

`}`

Note

你可以在 [`https://msdn.microsoft.com/en-us/library/system.idisposable(v=vs.110).aspx`](https://msdn.microsoft.com/en-us/library/system.idisposable(v=vs.110).aspx) 找到更多关于实现`IDisposable`的信息。

##### 更新记录

对于`Save()/SaveAsync()`方法，首先将实体的`EntityState`设置为`EntityState.Modified`，然后调用`SaveChanges()/SaveChangesAsync()`。设置状态可以确保上下文将更改传播到服务器。代码如下所示:

`public int Save(T entity)`

`{`

`Context.Entry(entity).State = EntityState.Modified;`

`return SaveChanges();`

`}`

`public Task<int> SaveAsync(T entity)`

`{`

`Context.Entry(entity).State = EntityState.Modified;`

`return SaveChangesAsync();`

`}`

##### 删除记录

您将为`Delete()/DeleteAsync()`方法添加类似的代码。如果调用代码传入一个对象，`BaseRepo`中的泛型方法将状态设置为`EntityState.Deleted`，然后调用`SaveChanges()/SaveChangesAsync()`。代码如下所示:

`public int Delete(T entity)`

`{`

`Context.Entry(entity).State = EntityState.Deleted;`

`return SaveChanges();`

`}`

`public Task<int> DeleteAsync(T entity)`

`{`

`Context.Entry(entity).State = EntityState.Deleted;`

`return SaveChangesAsync();`

`}`

#### 添加库存存储库

向`Repos`目录添加一个新类，并将其命名为`InventoryRepo.cs`。继承`BaseRepo<Inventory>`，实现`IRepo<Inventory>`，将`Table`变量赋给`DbSet<Inventory>`。初始代码应该如下所示:

`public class InventoryRepo : BaseRepo<Inventory>, IRepo<Inventory>`

`{`

`public InventoryRepo()`

`{`

`Table = Context.Inventory;`

`}`

`}`

接下来，您需要实现接口的所有成员。

##### 按 Id 删除记录

当需要通过主键删除一条`Inventory`记录时，需要创建一个`Inventory`类的新实例，将`CarId`赋给`id`参数，然后将状态设置为`EntityState.Deleted`。设置好状态后，调用`SaveChanges/SaveChangesAsync`。代码如下所示:

`public int Delete(int id)`

`{`

`Context.Entry(new Inventory() {CarId=id}).State = EntityState.Deleted;`

`return SaveChanges();`

`}`

`public Task<int> DeleteAsync(int id)`

`{`

`Context.Entry(new Inventory() { CarId = id }).State = EntityState.Deleted;`

`return SaveChangesAsync();`

`}`

#### 添加剩余的存储库

`CustomerRepo`、`OrderRepo`和`CreditRiskRepo`类遵循与`InventoryRepo`类相同的模式。将`InventoryRepo.cs`类复制到`CreditRiskRepo.cs`、`CustomerRepo.cs`和`OrderRepo.cs`，并相应地更新`Delete()`方法、泛型类型和构造函数。这里显示它们是为了完整性:

`public class``OrderRepo`T2】

`{`

`public OrderRepo()`

`{`

`Table = Context.Orders;`

`}`

`public int Delete(int id)`

`{`

`Context.Entry(new Order()`

`{`

`OrderId = id`

`}).State = EntityState.Deleted;`

`return SaveChanges();`

`}`

`public Task<int> DeleteAsync(int id)`

`{`

`Context.Entry(new Order()`

`{`

`OrderId = id`

`}).State = EntityState.Deleted;`

`return SaveChangesAsync();`

`}`

`}`

`public class CustomerRepo:BaseRepo<Customer>,IRepo<Customer>`

`{`

`public CustomerRepo()`

`{`

`Table = Context.Customers;`

`}`

`public int Delete(int id)`

`{`

`Context.Entry(new Customer()`

`{`

`CustId = id`

`}).State = EntityState.Deleted;`

`return SaveChanges();`

`}`

`public Task<int> DeleteAsync(int id)`

`{`

`Context.Entry(new Customer()`

`{`

`CustId = id`

`}).State = EntityState.Deleted;`

`return SaveChangesAsync();`

`}`

`}`

`public class``CreditRiskRepo`T2】

`{`

`public CreditRiskRepo()`

`{`

`Table = Context.CreditRisks;`

`}`

`public int Delete(int id)`

`{`

`Context.Entry(new CreditRisk()`

`{`

`CustId = id`

`}).State = EntityState.Deleted;`

`return SaveChanges();`

`}`

`public Task<int> DeleteAsync(int id)`

`{`

`Context.Entry(new CreditRisk()`

`{`

`CustId = id`

`}).State = EntityState.Deleted;`

`return SaveChangesAsync();`

`}`

`}`

### 正在初始化数据库

EF 的一个强大特性是用数据初始化数据库的能力。这在开发过程中尤其方便，因为该过程可以在每次运行代码之前将数据库恢复到已知状态。这个过程是创建一个继承自`DropCreateDatabaseIfModelChanges<TContext>`或`DropCreateDatabaseAlways<TContext>`的类

首先在 EF 目录下创建一个新类，并将该类命名为`DataInitialize` `r`。继承`DropCreateDatabaseAlways<AutoLotEntities>`并覆盖`Seed()`方法，就像这样:

`using System.Collections.Generic;`

`using System.Data.Entity;`

`using AutoLotDAL.Models;`

`public class DataInitializer : DropCreateDatabaseAlways<AutoLotEntities>`

`{`

`protected override void Seed(AutoLotEntities context)`

`{`

`}`

`}`

`DropCreateDatabaseAlways`类被强类型化为`AutoLotEntities`上下文类，顾名思义，它将在每次执行程序时删除并重新创建数据库。同样，只有当模型发生变化时，`DropCreateDatabaseIfModelChanges<TContext>`类才会删除并重新创建数据库。`Seed()`方法带来了派生上下文的一个实例，您可以用它来填充表。过程很简单:在正确的`DbSet`上调用`Add`，当你添加完记录后，调用`SaveChanges`。下面是一个示例，说明如何使用您在上一章中使用的相同记录植入数据库:

`protected override void Seed(AutoLotEntities context)`

`{`

`var customers = new List<Customer>`

`{`

`new Customer {FirstName = "Dave", LastName = "Brenner"},`

`new Customer {FirstName = "Matt", LastName = "Walton"},`

`new Customer {FirstName = "Steve", LastName = "Hagen"},`

`new Customer {FirstName = "Pat", LastName = "Walton"},`

`new Customer {FirstName = "Bad", LastName = "Customer"},`

`};`

`customers.ForEach(x => context.Customers.Add(x));`

`var cars = new List<Inventory>`

`{`

`new Inventory {Make = "VW", Color = "Black", PetName = "Zippy"},`

`new Inventory {Make = "Ford", Color = "Rust", PetName = "Rusty"},`

`new Inventory {Make = "Saab", Color = "Black", PetName = "Mel"},`

`new Inventory {Make = "Yugo", Color = "Yellow", PetName = "Clunker"},`

`new Inventory {Make = "BMW", Color = "Black", PetName = "Bimmer"},`

`new Inventory {Make = "BMW", Color = "Green", PetName = "Hank"},`

`new Inventory {Make = "BMW", Color = "Pink", PetName = "Pinky"},`

`new Inventory {Make = "Pinto", Color = "Black", PetName = "Pete"},`

`new Inventory {Make = "Yugo", Color = "Brown", PetName = "Brownie"},`

`};`

`cars.ForEach(x => context.Inventory.Add(x));`

`var orders = new List<Order>`

`{`

`new Order {Car = cars[0], Customer = customers[0]},`

`new Order {Car = cars[1], Customer = customers[1]},`

`new Order {Car = cars[2], Customer = customers[2]},`

`new Order {Car = cars[3], Customer = customers[3]},`

`};`

`orders.ForEach(x => context.Orders.Add(x));`

`context.CreditRisks.Add(`

`new CreditRisk`

`{`

`CustId = customers[4].CustId,`

`FirstName = customers[4].FirstName,`

`LastName = customers[4].LastName,`

`});`

`context.SaveChanges();`

`}`

最后一步是设置初始化器，使用下面的代码(您将在下一节中添加):

`Database.SetInitializer(new DataInitializer());`

## 试驾 AutoLotDAL

测试代码类似于您在先前版本的`AutoLotDal.dll`中所做的，但是您将使用`Repository`类，而不是直接根据上下文进行编程。首先向解决方案添加一个名为`AutoLotTestDrive`的新控制台应用项目，并将该项目设置为启动项目。通过 NuGet 将 EF 添加到项目中，并将`App.config`中的`connectionStrings`更新为:

`<connectionStrings>`

`<add name="AutoLotConnection" connectionString="data source=(LocalDb)\MSSQLLocalDb;initial catalog=AutoLot;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework" providerName="System.Data.SqlClient" />`

`</connectionStrings>`

添加对`AutoLotDAL`项目的引用。打开`Program.cs`并将以下代码添加到`Main()`方法中:

`static void Main(string[] args)`

`{`

`Database.SetInitializer(new DataInitializer());`

`WriteLine("***** Fun with ADO.NET EF Code First *****\n");`

`ReadLine();`

`}`

### 打印所有库存记录

要打印所有记录，调用`Inventory` repo 上的`GetAll()`方法，然后遍历返回的列表。这与直接根据上下文编码没有太大区别，但是存储库模式提供了一种一致的方法来访问和操作所有类的数据。

`private static void PrintAllInventory()`

`{`

`using (var repo = new InventoryRepo())`

`{`

`foreach (Inventory c in repo.GetAll())`

`{`

`WriteLine(c);`

`}`

`}`

`}`

### 添加库存记录

添加新记录显示了使用存储库调用 EF 的简单性。在生产系统中，您当然希望添加错误处理，但是添加记录的工作就像在存储库上调用`Add()`或`AddRange()`一样简单。代码如下所示:

`private static void AddNewRecord(Inventory car)`

`{`

`// Add record to the Inventory table of the AutoLot`

`// database.`

`using (var repo = new InventoryRepo())`

`{`

`repo.Add(car);`

`}`

`}`

`private static void AddNewRecords(IList<Inventory> cars)`

`{`

`// Add record to the Inventory table of the AutoLot`

`// database.`

`using (var repo = new InventoryRepo())`

`{`

`repo.AddRange(cars);`

`}`

`}`

为了测试这段代码，将以下代码添加到`Main()`方法中:

`static void Main(string[] args)`

`{`

`Database.SetInitializer(new MyDataInitializer());`

`WriteLine("***** Fun with ADO.NET EF Code First *****\n");`

`var car1 = new Inventory() { Make = "Yugo", Color = "Brown", PetName = "Brownie" };`

`var car2 = new Inventory() { Make = "SmartCar", Color = "Brown", PetName = "Shorty" };`

`AddNewRecord(car1);`

`AddNewRecord(car2);`

`AddNewRecords(new List<Inventory> { car1, car2 });`

`PrintAllInventory();`

`ReadLine();`

`}`

### 编辑记录

保存对记录的更改也同样简单。获取一个`Inventory`对象，进行一些修改，并在`InventoryRepo`类上调用`Save()`。代码如下所示(附带一些额外的代码来输出对象的`EntityState`):

`private static void UpdateRecord(int carId)`

`{`

`using (var repo = new InventoryRepo())`

`{`

`// Grab the car, change it, save!`

`var carToUpdate = repo.GetOne(carId);`

`if (carToUpdate != null)`

`{`

`WriteLine("Before change: " + repo.Context.Entry(carToUpdate).State);`

`carToUpdate.Color = "Blue";`

`WriteLine("After change: " + repo.Context.Entry(carToUpdate).State);`

`repo.Save(carToUpdate);`

`WriteLine("After save: " + repo.Context.Entry(carToUpdate).State);`

`}`

`}`

`}`

为了测试这段代码，将以下代码添加到`Main()`方法中:

`static void Main(string[] args)`

`{`

`Database.SetInitializer(new MyDataInitializer());`

`WriteLine("***** Fun with ADO.NET EF Code First *****\n");`

`var car1 = new Inventory() { Make = "Yugo", Color = "Brown", PetName = "Brownie" };`

`var car2 = new Inventory() { Make = "SmartCar", Color = "Brown", PetName = "Shorty" };`

`AddNewRecord(car1);`

`AddNewRecord(car2);`

`AddNewRecords(new List<Inventory> { car1, car2 });`

`UpdateRecord(car1.CarId);`

`PrintAllInventory();`

`ReadLine();`

`}`

### 使用导航属性

添加一个名为`ShowAllOrders()`的方法。在该方法中，在`OrdersRepo`类周围添加一个`using`语句。对于从`GetAll()`方法返回的每条记录，打印`itm.Customer.FullName`和`itm.Car.PetName`属性。代码如下所示:

`private static void ShowAllOrders()`

`{`

`using (var repo = new OrderRepo())`

`{`

`WriteLine("*********** Pending Orders ***********");`

`foreach (var itm in repo.GetAll())`

`{`

`WriteLine($"->{itm.Customer.FullName} is waiting on {itm.Car.PetName}");`

`}`

`}`

`}`

在`Main()`方法中添加对该方法的调用。当您运行该程序时，您将得到类似于下面的输出(您的里程数将根据数据库中当前的数据而有所不同):

`***** Fun with ADO.NET EF Code First *****`

`*********** Pending Orders ***********`

`-> Dave Brenner is waiting on Bimmer`

`-> Matt Walton  is waiting on Zippy`

`-> Steve Hagen is waiting on Clunker`

`-> Pat Walton is waiting on Pinky`

如果您在运行应用时查看输出窗口，您将会看到有许多对数据库的单独数据库调用:一个调用获取所有订单，另一个调用获取每个单独的`Customer`名称和`Car PetName`。正如本章前面所讨论的，这是由于延迟加载造成的。接下来，您将通过`InventoryRepo`使用急切加载。

要从`Main()`调用这个，添加下面一行:

`ShowAllOrders();`

#### 急切装载

首先为`System.Data.Entity`添加一个`using`语句。接下来，创建一个名为`ShowAllOrdersEagerlyFetched()`的方法。您需要直接针对`AutoLotEntities`进行编码，因为您没有一个`Repo`方法来急切地获取数据。(如果这是你会经常用到的东西，可以加入到`OrderRepo`类中。)新方法如下所示:

`private static void ShowAllOrdersEagerlyFetched()`

`{`

`using (var context = new AutoLotEntities())`

`{`

`WriteLine("*********** Pending Orders ***********");`

`var orders = context.Orders`

`.Include(x => x.Customer)`

`.Include(y => y.Car)`

`.ToList();`

`foreach (var itm in orders)`

`{`

`WriteLine($"->{itm.Customer.FullName} is waiting on {itm.Car.PetName}");`

`}`

`}`

`}`

要从`Main()`调用这个，添加下面一行:

`ShowAllOrdersEagerlyFetched();`

### 多表操作/隐式事务

正如您所记得的，EF 会自动登记所有通过`SaveChanges`调用传播到隐式事务中的变更。复制第 22 章中的[事务示例，将记录从`Customer`表移动到`CreditRisk`表非常简单。到目前为止，您编写的存储库一次只能在一个表上工作，因此您需要直接根据上下文编写代码。](22.html)

首先创建一个名为`MakeCustomerARisk()`的方法。这个方法将从`Customers`表中删除一个客户到`CreditRisk`表中。因为没有一个`Move()`方法，所以你必须把它编码成一个两阶段操作。添加到`CreditRisk`，然后从`Customers`添加到`Delete`。当一个实体存在于一个上下文中时，您必须分离它，然后将它连接到新的上下文。这就是在`Main()`中将`EntityState`设置为`EntityState.Detached`，然后在新的上下文中调用`Attach()`的原因。代码如下所示:

`private static CreditRisk MakeCustomerARisk(Customer customer)`

`{`

`using (var context = new AutoLotEntities())`

`{`

`context.Customers.Attach(customer);`

`context.Customers.Remove(customer);`

`var creditRisk = new CreditRisk()`

`{`

`FirstName = customer.FirstName,`

`LastName = customer.LastName`

`};`

`context.CreditRisks.Add(creditRisk);`

`try`

`{`

`context.SaveChanges();`

`}`

`catch (DbUpdateException ex)`

`{`

`WriteLine(ex);`

`}`

`catch (Exception ex)`

`{`

`WriteLine(ex);`

`}`

`return creditRisk;`

`}`

`}`

为了显示结果，创建一个名为`PrintAllCustomersAndCreditRisks()`的方法。使用现有的存储库类来遍历`Customer`和`CreditRisk`记录。

`private static void PrintAllCustomersAndCreditRisks()`

`{`

`WriteLine("*********** Customers ***********");`

`using (var repo = new CustomerRepo())`

`{`

`foreach (var cust in repo.GetAll())`

`{`

`WriteLine($"->{cust.FirstName} {cust.LastName} is a Customer.");`

`}`

`}`

`WriteLine("*********** Credit Risks ***********");`

`using (var repo = new CreditRiskRepo())`

`{`

`foreach (var risk in repo.GetAll())`

`{`

`WriteLine($"->{risk.FirstName} {risk.LastName} is a Credit Risk!");`

`}`

`}`

`}`

从`Main()`方法调用这些方法，传入一个新的`Customer`对象，如下所示:

`WriteLine("***** Fun with ADO.NET EF Code First *****\n");`

`PrintAllCustomersAndCreditRisks();`

`var customerRepo = new CustomerRepo();`

`var customer = customerRepo.GetOne(4);`

`customerRepo.Context.Entry(customer).State = EntityState.Detached;`

`var risk = MakeCustomerARisk(customer);`

`PrintAllCustomersAndCreditRisks();`

如果其中一个操作(从`Customer`删除或添加到`CreditRisk`)失败，两个操作都将失败。

Source Code

你可以在 [`Chapter 23`](23.html) 子目录中找到`AutoLotTestDrive`的例子。

## 实体框架迁移

您从代码中创建了这个版本的`AutoLotDAL.dll`，然后创建了数据库。每次运行应用时，都会在初始化过程中删除并重新创建数据库。这在开发过程中非常有用，但是一旦你将应用部署到生产环境中，你就不能每次用户运行应用时都删除数据库。如果模型发生变化，您需要保持数据库同步。这就是 EF 迁移发挥作用的地方。在创建您的第一个迁移之前，您将进行一些更改来说明这个问题。从打开`Program.cs`开始，注释掉下面一行:

`Database.SetInitializer(new MyDataInitializer());`

Note

如前所述，无论是在应用每次运行时，还是在模型发生变化时，数据初始化器都会删除并重新创建数据库。如果您不注释掉`SetInitializer`行，那么下一节将不会对您起作用。

### 更新模型

假设企业要求对应用进行一些更改，包括并发检查。为此，您将向所有的表添加一个`Timestamp`属性(您将在下一节学习使用 EF 进行并发检查)。从数据注释列表中回忆起，`Timestamp`属性用于此目的。在 SQL Server 中，`Timestamp`注释映射到`RowVersion`数据类型，这在 C#中由`byte[]`数据类型表示。这是这次您将对`Inventory`、`Customer`和`Order`类进行的唯一更改。您还将向`CreditRisk`添加`Timestamp`属性，但是您将在下一节中对该类进行一些额外的更改。更新后的`Inventory`、`Customer`和`Order`类如下所示。

#### 库存类别

下面是`Inventory`类:

`[Table("Inventory")]`

`public partial class Inventory`

`{`

`[Key]`

`public int CarId { get; set; }`

`[StringLength(50)]`

`public string Make { get; set; }`

`[StringLength(50)]`

`public string Color { get; set; }`

`[StringLength(50)]`

`public string PetName { get; set; }`

`[Timestamp]`

`public byte[] Timestamp { get; set; }`

`public virtual ICollection<Order> Orders { get; set; } = new HashSet<Order>();`

`}`

#### 客户类别

下面是`Customer`类:

`public partial class Customer`

`{`

`[Key]`

`public int CustId { get; set; }`

`[StringLength(50)]`

`public string FirstName { get; set; }`

`[StringLength(50)]`

`public string LastName { get; set; }`

`[Timestamp]`

`public byte[] Timestamp { get; set; }`

`[NotMapped]`

`public string FullName => FirstName + " " + LastName;`

`public virtual ICollection<Order> Orders { get; set; } = new HashSet<Order>();`

`}`

#### 订单类别

下面是`Order`类:

`public partial class Order`

`{`

`[Key, Required, DatabaseGenerated(DatabaseGeneratedOption.Identity)]`

`public int OrderId { get; set; }`

`[Required]`

`public int CustId { get; set; }`

`[Required]`

`public int CarId { get; set; }`

`[Timestamp]`

`public byte[] Timestamp { get; set; }`

`[ForeignKey("CustId")]`

`public virtual Customer Customer { get; set; }`

`[ForeignKey("CarId")]`

`public virtual Inventory Car { get; set; }`

`}`

#### 信用风险等级

除了`Timestamp`属性，您还将使用数据注释在`FirstName`和`LastName`属性上创建一个惟一的索引。由于这是一个复杂的键，您还需要指定索引的名称以及索引中每一列的顺序。在这个例子中，索引名是`IDX_CreditRisk` _ `Name`，索引的列顺序是`LastName`，然后是`FirstName`，并被创建为唯一索引。更新后的代码如下所示:

`public partial class CreditRisk`

`{`

`[Key]`

`public int CustId { get; set; }`

`[StringLength(50)]`

`[Index("IDX_CreditRisk_Name",IsUnique = true,Order=2)]`

`public string FirstName { get; set; }`

`[StringLength(50)]`

`[Index("IDX_CreditRisk_Name", IsUnique = true, Order = 1)]`

`public string LastName { get; set; }`

`[Timestamp]`

`public byte[] Timestamp { get; set; }`

`}`

### 测试应用

注释掉`Program.cs`中`Main()`方法的所有内容，除了对`PrintAllInventory()`的调用(如下面的代码片段)并运行应用。

`static void Main(string[] args)`

`{`

`WriteLine("***** Fun with ADO.NET EF Code First *****\n");`

`PrintAllInventory();`

`ReadLine();`

`}`

您将得到一个带有以下错误消息的`System.InvalidOperationException`:

`The model backing the ’AutoLotEntities’ context has changed since the database was created. Consider using Code First Migrations to update the database (`[`http://go.microsoft.com/fwlink/?LinkId=238269`](http://go.microsoft.com/fwlink/?LinkId=238269)T2】

### 输入 EF 迁移

EF 怎么知道数据库和模型不同步？在 EF 第一次调用数据库之前，它会查找一个名为`__` `MigrationHistory`的表，并将当前 EF 模型的散列与存储在该表中的最新散列进行比较。如果您在服务器资源管理器中打开`AutoLot`数据库，您将看到一条记录。这是 EF 在创建数据库时自动创建的。既然您已经更改了您的模型，那么您需要创建一个新的迁移条目。

Note

当您从一个现有的数据库中创建您的模型时，`__MigrationHistory`表并没有被创建(至少在编写本文的时候)。为什么重要？当您的`DbContext`类被实例化时，在您的定制代码第一次调用数据库之前，EF 检查迁移历史。因为这个表不存在，所以会生成一系列异常。众所周知，异常可能是开销很大的操作，这可能会导致性能问题。即使您从未计划过使用迁移，您也应该启用迁移，如下一节所述。

### 创建基线迁移

首先为您的项目启用迁移。为此，请通过选择查看➤其他 Windows ➤软件包管理器控制台打开软件包管理器控制台(用于管理 NuGet 软件包的命令行工具)。确保默认项目设置为`AutoLotDAL`，输入`enable-migrations`，如图 [23-12](#Fig12) 所示。

![A978-1-4842-1332-2_23_Fig12_HTML.jpg](img/A978-1-4842-1332-2_23_Fig12_HTML.jpg)

图 23-12。

Enabling migrations on AutoLotDAL

这将创建一个包含两个类的`Migrations`文件夹:`Configuration.cs`和`201510060510505_InitialCreate.cs`注意:第二个文件的名称基于日期和 CPU 时间，后跟迁移的名称。这种名称格式使 EF 能够以正确的时间顺序运行迁移(如果存在多个迁移)。由于您在启用迁移时没有指定名称，因此迁移名称默认为`InitialCreate`。

打开`InitialCreate.cs`类。这个类有两个名为`Up()`和`Down()`的方法。`Up()`方法用于将更改应用到数据库，而`Down()`方法用于回滚更改。在您在上一节中做出更改之前，EF 根据您的模型构建了数据库，并用这些表和字段的散列填充了`__MigrationHistory`表。如果您检查`InitialCreate`类，您将看到`Timestamp`字段和`CreditRisk`表中的附加索引没有列出。该文件应该如下所示:

`public partial class InitialCreate : DbMigration`

`{`

`public override void Up()`

`{`

`CreateTable(`

`"dbo.CreditRisks",`

`c => new`

`{`

`CustId = c.Int(nullable: false, identity: true),`

`FirstName = c.String(maxLength: 50),`

`LastName = c.String(maxLength: 50),`

`})`

`.PrimaryKey(t => t.CustId);`

`CreateTable(`

`"dbo.Customers",`

`c => new`

`{`

`CustId = c.Int(nullable: false, identity: true),`

`FirstName = c.String(maxLength: 50),`

`LastName = c.String(maxLength: 50),`

`})`

`.PrimaryKey(t => t.CustId);`

`CreateTable(`

`"dbo.Orders",`

`c => new`

`{`

`OrderId = c.Int(nullable: false, identity: true),`

`CustId = c.Int(nullable: false),`

`CarId = c.Int(nullable: false),`

`})`

`.PrimaryKey(t => t.OrderId)`

`.ForeignKey("dbo.Inventory", t => t.CarId, cascadeDelete: true)`

`.ForeignKey("dbo.Customers", t => t.CustId, cascadeDelete: true)`

`.Index(t => t.CustId)`

`.Index(t => t.CarId);`

`CreateTable(`

`"dbo.Inventory",`

`c => new`

`{`

`CarId = c.Int(nullable: false, identity: true),`

`Make = c.String(maxLength: 50),`

`Color = c.String(maxLength: 50),`

`PetName = c.String(maxLength: 50),`

`})`

`.PrimaryKey(t => t.CarId);`

`}`

`public override void Down()`

`{`

`DropForeignKey("dbo.Orders", "CustId", "dbo.Customers");`

`DropForeignKey("dbo.Orders", "CarId", "dbo.Inventory");`

`DropIndex("dbo.Orders", new[] { "CarId" });`

`DropIndex("dbo.Orders", new[] { "CustId" });`

`DropTable("dbo.Inventory");`

`DropTable("dbo.Orders");`

`DropTable("dbo.Customers");`

`DropTable("dbo.CreditRisks");`

`}`

`}`

`Configuration.cs`类也有一个方法和一些构造器代码。构造函数中的代码指示 EF 禁用自动迁移(这是您将在大多数时间使用的设置，因为您想要控制迁移如何工作)并将`ContextKey`(在基类中)设置为您的派生`DbContext`类的完全限定名。`Seed()`方法使您能够向数据库添加数据，您很快就会用到它。

`internal sealed class Configuration : DbMigrationsConfiguration<AutoLotDAL.EF.AutoLotEntities>`

`{`

`public Configuration()`

`{`

`AutomaticMigrationsEnabled = false;`

`ContextKey = "AutoLotDAL.EF.AutoLotEntities";`

`}`

`protected override void Seed(AutoLotDAL.EF.AutoLotEntities context)`

`{`

`}`

`}`

要创建迁移，请在软件包管理器控制台中键入`add-migration TimeStamps`。`add-migration`指示 EF 获取当前模型的散列，并将其与`__MigrationHistory`表中最近的散列进行比较。第二个参数是迁移的名称，可以是任何名称，但应该对您有意义。执行该命令(图 [23-13](#Fig13) )在`Migrations`文件夹下创建一个名为`<timestamp>_TimeStamps.cs`的新文件。

![A978-1-4842-1332-2_23_Fig13_HTML.jpg](img/A978-1-4842-1332-2_23_Fig13_HTML.jpg)

图 23-13。

Creating the initial migration

打开新文件(我的名为`201510062307304_TimeStamps.cs`)并检查内容。同样，它有一个应用更改的`Up()`方法和一个回滚更改的`Down()`方法。此处列出了该文件:

`public partial class TimeStamps : DbMigration`

`{`

`public override void Up()`

`{`

`AddColumn("dbo.CreditRisks", "Timestamp",`

`c => c.Binary(nullable: false, fixedLength: true, timestamp: true, storeType: "rowversion"));`

`AddColumn("dbo.Customers", "Timestamp",`

`c => c.Binary(nullable: false, fixedLength: true, timestamp: true, storeType: "rowversion"));`

`AddColumn("dbo.Orders", "Timestamp",`

`c => c.Binary(nullable: false, fixedLength: true, timestamp: true, storeType: "rowversion"));`

`AddColumn("dbo.Inventory", "Timestamp",`

`c => c.Binary(nullable: false, fixedLength: true, timestamp: true, storeType: "rowversion"));`

`CreateIndex("dbo.CreditRisks", new[] { "LastName", "FirstName" },`

`unique: true, name: "IDX_CreditRisk_Name");`

`}`

`public override void Down()`

`{`

`DropIndex("dbo.CreditRisks", "IDX_CreditRisk_Name");`

`DropColumn("dbo.Inventory", "Timestamp");`

`DropColumn("dbo.Orders", "Timestamp");`

`DropColumn("dbo.Customers", "Timestamp");`

`DropColumn("dbo.CreditRisks", "Timestamp");`

`}`

`}`

最后一项任务是更新数据库。在包管理器控制台中键入`update-database`,您将得到一条消息，说明已经应用了迁移。打开服务器资源管理器，并刷新“表”节点。您将看到`__MigrationHistory`表。如果您选择在表格上显示表格数据，您将看到类似于图 [23-14](#Fig14) 的内容。

![A978-1-4842-1332-2_23_Fig14_HTML.jpg](img/A978-1-4842-1332-2_23_Fig14_HTML.jpg)

图 23-14。

The contents of the __MigrationHistory table

### 为数据库设定种子

`Configure.cs`中的`Seed()`方法利用了`DbSet`类中的`AddOrUpdate()`方法。`AddOrUpdate() method`有两个参数；第一个是 lambda，表示要更新的唯一字段，第二个是要在数据库中添加(或更新)的记录。基本语法如下:

`context.Customers.AddOrUpdate(c=> c.CustId,`

`new Customer {CustId = 1, FirstName="Foo",LastName="Bar"});`

在这个例子中，您没有通过主键进行检查，因为它是一个标识。您需要检查以确保`FirstName`和`LastName`的组合是唯一的。要使用复杂标识符，需要创建一个匿名对象来标识字段，而不是像下面这样创建一个单一属性:

`context.Customers.AddOrUpdate(c=> new {c.FirstName,c.LastName},`

`new Customer { FirstName="Foo",LastName="Bar"});`

将代码从`DataInitialize`类复制到`Seed()`方法中。将`Add()`呼叫改为`AddOrUpdate()`，如下图所示:

`protected override void Seed(AutoLotDAL.EF.AutoLotEntities context)`

`{`

`var customers = new List<Customer>`

`{`

`new Customer {FirstName = "Dave", LastName = "Brenner"},`

`new Customer {FirstName = "Matt", LastName = "Walton"},`

`new Customer {FirstName = "Steve", LastName = "Hagen"},`

`new Customer {FirstName = "Pat", LastName = "Walton"},`

`new Customer {FirstName = "Bad", LastName = "Customer"},`

`};`

`customers.ForEach(x =>`

`context.Customers.AddOrUpdate(c=> new { c.FirstName,c.LastName},x));`

`var cars = new List<Inventory>`

`{`

`new Inventory {Make = "VW", Color = "Black", PetName = "Zippy"},`

`new Inventory {Make = "Ford", Color = "Rust", PetName = "Rusty"},`

`new Inventory {Make = "Saab", Color = "Black", PetName = "Mel"},`

`new Inventory {Make = "Yugo", Color = "Yellow", PetName = "Clunker"},`

`new Inventory {Make = "BMW", Color = "Black", PetName = "Bimmer"},`

`new Inventory {Make = "BMW", Color = "Green", PetName = "Hank"},`

`new Inventory {Make = "BMW", Color = "Pink", PetName = "Pinky"},`

`new Inventory {Make = "Pinto", Color = "Black", PetName = "Pete"},`

`new Inventory {Make = "Yugo", Color = "Brown", PetName = "Brownie"},`

`};`

`cars.ForEach(x =>`

`context.Inventory.AddOrUpdate(i => new { i.Make, i.Color, i.PetName }, x));`

`var orders = new List<Order>`

`{`

`new Order {Car = cars[0], Customer = customers[0]},`

`new Order {Car = cars[1], Customer = customers[1]},`

`new Order {Car = cars[2], Customer = customers[2]},`

`new Order {Car = cars[3], Customer = customers[3]},`

`};`

`orders.ForEach(x =>`

`context.Orders.AddOrUpdate(o => new { o.CarId, o.CustId }, x));`

`context.CreditRisks.AddOrUpdate(c => new { c.FirstName, c.LastName },`

`new CreditRisk`

`{`

`CustId = customers[4].CustId,`

`FirstName = customers[4].FirstName,`

`LastName = customers[4].LastName,`

`});`

`}`

每当您从软件包管理器控制台运行`update-database`时，`Seed()`方法就会运行。要播种数据库，打开软件包管理器控制台，键入`update-database`，然后按回车键。

## 重新审视交易测试

现在您已经有了基于客户姓氏和名字的`CreditRisk`表的惟一索引，更新`MakeACustomerRisk()`方法来添加新记录两次。由于调用`SaveChanges()`时创建的隐式事务，不仅客户不会被添加到`CreditRisk`表中(无论何时)，而且客户也不会从`Customer`表中删除。在对`SaveChanges()`的调用周围添加一个`try-catch`块来捕捉`DbUpdateException`。在`catch`块中，将异常写入控制台。当您运行应用时，您会看到实际上并没有对数据库进行更改，并且异常详细信息被写入控制台窗口。更新后的代码如下所示:

`private static CreditRisk MakeCustomerARisk(Customer customer)`

`{`

`using (var context = new AutoLotEntities())`

`{`

`context.Customers.Attach(customer);`

`context.Customers.Remove(customer);`

`var creditRisk = new CreditRisk()`

`{`

`FirstName = customer.FirstName,`

`LastName = customer.LastName`

`};`

`context.CreditRisks.Add(creditRisk);`

`var creditRiskDupe = new CreditRisk()`

`{`

`FirstName = customer.FirstName,`

`LastName = customer.LastName`

`};`

`context.CreditRisks.Add(creditRiskDupe);`

`try`

`{`

`context.SaveChanges();`

`}`

`catch (DbUpdateException ex)`

`{`

`WriteLine(ex);`

`}`

`return creditRisk;`

`}`

`}`

## 并发

多用户应用中的一个常见问题是并发问题。如果您的应用不检查并发问题，当两个用户更新同一条记录时，最后一个用户获胜。这对于您的应用来说可能非常好，但如果不是这样，EF 和 SQL Server 提供了一种检查并发冲突的方便机制。

在上一节中，当您将时间戳属性添加到您的模型类中时，它改变了 EF 构建和运行更新或删除数据库中数据的查询的方式。删除调用不再只是寻找主键(`CarId`)，而是寻找`Timestamp`。例如，生成的 SQL 如下所示:

`Execute NonQuery "DELETE [dbo].[Inventory] WHERE (([CarId] = @0) AND ([Timestamp] = @1))"`

EF 自动添加时间戳作为 delete 上的`WHERE`子句的一部分。这可以防止一个用户(或进程)践踏另一个用户(或进程)的更改。如果 delete 调用没有使用最新版本的记录，则不会更新任何内容，并且会引发一个`DbUpdateConcurrencyException`。

### 更正存储库

repos 中的`Delete(int id)`和`DeleteAsync(int id)`方法现在每次被调用都会失败，因为`Timestamp`没有被传入。首先更正`IRepo<T>`接口中的方法定义，以接受一个时间戳值。更新后的代码如下所示:

`int Delete(int id, byte[] timeStamp);`

`Task<int> DeleteAsync(int id, byte[] timeStamp);`

现在更新所有的存储库，以利用新的方法签名。这里显示了来自`InventoryRepo`类的相关代码(其余的存储库遵循相同的模式，更新的代码可以在示例下载中找到):

`public int Delete(int id, byte[] timeStamp)`

`{`

`Context.Entry(new Inventory()`

`{`

`CarId=id,`

`Timestamp = timeStamp`

`}).State = EntityState.Deleted;`

`return SaveChanges();`

`}`

`public Task<int> DeleteAsync(int id, byte[] timeStamp)`

`{`

`Context.Entry(new Inventory()`

`{`

`CarId = id,`

`Timestamp = timeStamp`

`}).State = EntityState.Deleted;`

`return SaveChangesAsync();`

`}`

### 测试并发性

下面的代码演示了对`Inventory`记录的并发检查。它复制了更新同一记录的两个不同的用户。当用户从数据库中获取记录时，时间戳是相同的。当一个用户更新他们的记录时，时间戳由 SQL Server 更新，但是第二个用户没有刷新他们的对象，因此时间戳值仍然是原始值。当用户试图保存记录时，时间戳不匹配，`SaveChanges`调用不更新任何记录，并抛出异常。更新后的代码如下所示:

`private static void UpdateRecordWithConcurrency)`

`{`

`var car = new Inventory()`

`{ Make = "Yugo", Color = "Brown", PetName = "Brownie" };`

`AddNewRecord(car);`

`var repo1 = new InventoryRepo();`

`var car1 = repo1.GetOne(car.CarId);`

`car1.PetName = "Updated";`

`var repo2 = new InventoryRepo();`

`var car2 = repo2.GetOne(car.CarId);`

`car2.Make = "Nissan";`

`repo1.Save(car1);`

`try`

`{`

`repo2.Save(car2);`

`}`

`catch (DbUpdateConcurrencyException ex)`

`{`

`WriteLine(ex);`

`}`

`RemoveRecordById(car1.CarId, car1.Timestamp);`

`}`

这些代码所做的就是暴露问题。当并发错误发生时，您仍然需要决定做什么。这将取决于您的具体业务需求。

## 拦截

本章的最后一个主题涉及 EF 拦截。正如您在前面的示例中所看到的那样，许多“魔术”都是在幕后发生的，目的是让数据从数据存储移动到对象模型中，反之亦然。拦截是在进程的不同阶段运行代码的过程。

### IDbCommandInterceptor 接口

这一切都从下面列出的`IDbCommandInterceptor`接口开始:

`public interface IDbCommandInterceptor : IDbInterceptor`

`{`

`void NonQueryExecuted(DbCommand command,`

`DbCommandInterceptionContext<int> interceptionContext);`

`void NonQueryExecuting(DbCommand command,`

`DbCommandInterceptionContext<int> interceptionContext);`

`void ReaderExecuted(DbCommand command,`

`DbCommandInterceptionContext<DbDataReader> interceptionContext);`

`void ReaderExecuting(DbCommand command,`

`DbCommandInterceptionContext<DbDataReader> interceptionContext);`

`void ScalarExecuted(DbCommand command,`

`DbCommandInterceptionContext<object> interceptionContext);`

`void ScalarExecuting(DbCommand command,`

`DbCommandInterceptionContext<object> interceptionContext);`

`}`

正如您可能从名称中推断的那样，这个接口包含 EF 在特定事件之前和之后调用的方法。例如，`ReaderExecuting()`方法在读取器执行之前被调用，而`ReaderExecuted()`在读取器执行之后被调用。对于本例，您将在这些方法中的每一个中简单地写入控制台。在生产系统中，逻辑将更适合您的需求。

### 向 AutoLotDAL 添加拦截

向 AutoLotDAL 项目添加一个名为`Interception`的新文件夹，并向文件夹名`ConsoleWriterInterceptor`添加一个新类。把类公开，加`System.Data.Entity.Infrastructure.Interception`为`using`，继承`IDbCommandInterceptor`。实现缺少的成员后，您的代码应该如下所示:

`public class ConsoleWriterInterceptor : IDbCommandInterceptor`

`{`

`public void NonQueryExecuting(DbCommand command,`

`DbCommandInterceptionContext<int> interceptionContext)`

`{`

`}`

`public void NonQueryExecuted(DbCommand command,`

`DbCommandInterceptionContext<int> interceptionContext)`

`{`

`}`

`public void ReaderExecuting(DbCommand command,`

`DbCommandInterceptionContext<DbDataReader> interceptionContext)`

`{`

`}`

`public void ReaderExecuted(DbCommand command,`

`DbCommandInterceptionContext<DbDataReader> interceptionContext)`

`{`

`}`

`public void ScalarExecuting(DbCommand command,`

`DbCommandInterceptionContext<object> interceptionContext)`

`{`

`}`

`public void ScalarExecuted(DbCommand command,`

`DbCommandInterceptionContext<object> interceptionContext)`

`{`

`}`

`}`

为了保持示例简单，您只需向控制台写入调用是否异步以及命令的文本。为`static System.Console`添加一个`using`，并添加一个名为`WriteInfo()`的私有方法，该方法采用一个`bool`和一个`string`。代码如下所示:

`private void WriteInfo(bool isAsync, string commandText)`

`{`

`WriteLine($"IsAsync: {isAsync}, Command Text: {commandText}");`

`}`

在接口的每个方法中，添加对`WriteInfo()`方法的调用，如下所示:

`WriteInfo(interceptionContext.IsAsync,command.CommandText);`

### 注册拦截器

拦截器可以通过代码或在应用配置文件中注册。在代码中注册它们可以将它们与配置文件的更改隔离开来，从而确保它们总是被注册。如果您需要更多的灵活性，配置文件可能是更好的选择。对于这个例子，您将在代码中注册拦截器。

打开`AutoLotEntities.cs`类并添加以下`using`:

`using System.Data.Entity.Infrastructure;`

`using System.Data.Entity.Infrastructure.Interception;`

接下来，在构造函数中，添加以下代码行:

`DbInterception.Add(new ConsoleWriterInterceptor());`

执行本章前面的一个测试方法，您将看到写入控制台的记录器的附加输出。这是一个简单的例子，但是说明了拦截器类的能力。

Note

`DbCommandInterceptionContext<T>`包含了比你在这里探索的更多的东西。请参考。NET Framework 4.6 SDK 文档以了解更多信息。

### 添加数据库记录器拦截器

如果您想做的只是简单的日志记录，EF 现在附带了一个内置的日志记录拦截器。要添加这个功能，首先打开`AutoLotEntities.cs`类并注释掉控制台日志记录器。添加一个类型为`DatabaseLogger`的静态只读成员(在`System.Data.Entity.Infrastructure.Interception`名称空间中)。构造函数接受两个参数；第一个是日志文件的文件名，第二个是可选的，指示是否应该将日志追加到后面(默认值为 false)。在构造函数中，调用拦截器上的`StartLogging()`，并将实例添加到拦截器列表中。更新后的代码如下所示:

`static readonly DatabaseLogger DatabaseLogger =`

`new DatabaseLogger("sqllog.txt", true);`

`public AutoLotEntities() : base("name=AutoLotConnection")`

`{`

`//DbInterception.Add(new ConsoleWriterInterceptor());`

`DatabaseLogger.StartLogging();`

`DbInterception.Add(DatabaseLogger);`

`}`

最后一个变化是利用`IDisposable`模式的`DbContext`实现来停止日志记录并移除拦截器。代码如下所示:

`protected override void Dispose(bool disposing)`

`{`

`DbInterception.Remove(DatabaseLogger);`

`DatabaseLogger.StopLogging();`

`base.Dispose(disposing);`

`}`

## 对象具体化和保存更改事件

`ObjectContext`类包含两个事件，`ObjectMaterialized`和`SavingChanges`。这些事件可以避免您创建拦截器——只要它们满足您的需求！当从数据存储中重构一个对象时，触发`ObjectMaterialized`事件，当对象的数据即将传播到数据存储时，就在上下文中调用`SaveChanges()`方法之后，发生`SavingChanges`事件。

### 访问对象上下文

正如您所记得的，上下文是从`DbContext`类中派生出来的。幸运的是，它还扩展了`IObjectContextAdapter`接口。要到达`ObjectContext`，你需要将`AutoLotEntities`施放到`IObjectContextAdapter`。您可以在构造函数中这样做:

`public AutoLotEntities(): base("name=AutoLotConnection")`

`{`

`//Interceptor code`

`var context = (this as IObjectContextAdapter).ObjectContext;`

`context.ObjectMaterialized += OnObjectMaterialized;`

`context.SavingChanges += OnSavingChanges;`

`}`

`private void OnSavingChanges(object sender, EventArgs eventArgs)`

`{`

`}`

`private void OnObjectMaterialized(object sender,`

`System.Data.Entity.Core.Objects.ObjectMaterializedEventArgs e)`

`{`

`}`

### 物化对象

`ObjectMaterialized`事件的参数提供了对被重组实体的访问。虽然在本章中你不会用到这个事件，但在第 30 章中你会用到它。现在，只要说在 EF 填充了模型类的属性之后，在上下文将它提供给调用代码之前，这个事件立即触发就足够了。

### 保存更改

如上所述，`SavingChanges`事件在`SaveChanges()`方法被调用之后(在`DbContext`上)但在数据库被更新之前触发。通过访问传递给事件处理程序的`ObjectContext`，可以通过`DbContext`上的`ObjectStateEntry`属性访问事务中的所有实体。表 [23-6](#Tab6) 显示了一些关键属性。

表 23-6。

Key Members of ObjectStateEntry

<colgroup><col> <col></colgroup> 
| DbContext 成员 | 生命的意义 |
| --- | --- |
| `CurrentValues` | 实体属性的当前值 |
| `OriginalValues` | 实体属性的原始值 |
| `Entity` | 由`ObjectStateEntry`对象表示的实体 |
| `State` | 实体的当前状态(例如，修改、添加、删除) |

`ObjectStateEntry`还公开了一组可以在实体上使用的方法。其中一些在表 [23-7](#Tab7) 中列出。

表 23-7。

Key Methods of ObjectStateEntry

<colgroup><col> <col></colgroup> 
| DbContext 成员 | 生命的意义 |
| --- | --- |
| `AcceptChanges` | 接受当前值作为原始值 |
| `ApplyCurrentValues` | 设置当前值以匹配所提供对象的值 |
| `ApplyOriginalValues` | 设置原始值以匹配所提供对象的值 |
| `ChangeState` | 更新实体的状态 |
| `GetModifiedProperties` | 返回所有已更改属性的名称 |
| `IsPropertyChanges` | 检查特定属性的更改 |
| `RejectPropertyChanges` | 实体的当前状态(例如，修改、添加、删除) |

这允许您编写代码，如果车辆的颜色是红色，就拒绝对其进行任何更改，如下所示:

`private void OnSavingChanges(object sender, EventArgs eventArgs)`

`{`

`//Sender is of type ObjectContext.  Can get current and original values, and`

`//cancel/modify the save operation as desired.`

`var context = sender as ObjectContext;`

`if (context == null) return;`

`foreach (ObjectStateEntry item in`

`context.ObjectStateManager.GetObjectStateEntries(`

`EntityState.Modified | EntityState.Added))`

`{`

`//Do something important here`

`if ((item.Entity as Inventory)!=null)`

`{`

`var entity = (Inventory) item.Entity;`

`if (entity.Color == "Red")`

`{`

`item.RejectPropertyChanges(nameof(entity.Color));`

`}`

`}`

`}`

`}`

Source Code

您可以在 [`Chapter 23`](23.html) 子目录中找到更新后的自动标注示例。

## 部署到 SQL Server

最后一步，将数据库部署到 SQL Server Express。这就像更改连接字符串并执行`update-database`一样简单！在`AutoLotDAL`中打开`App.config`文件，并更新连接字符串以指向 SQL Server Express。注意:我还更改了默认目录的名称，因为我在 SQL Express 中已经有了一个`AutoLot`数据库。确切的字符串将取决于您安装 SQL Server 的方式，但它应该类似于以下内容:

`<connectionStrings>`

`<add name="AutoLotConnection" connectionString="data source=.\SQLEXPRESS2014;initial catalog=AutoLot2;integrated security=True;MultipleActiveResultSets=True;App=EntityFramework" providerName="System.Data.SqlClient" />`

`</connectionStrings>`

当您运行更新数据库时，您将看到更新被应用(如图 [23-15](#Fig15) )。

![A978-1-4842-1332-2_23_Fig15_HTML.jpg](img/A978-1-4842-1332-2_23_Fig15_HTML.jpg)

图 23-15。

Deploying to SQL Server Express Source Code

如果迁移无法执行，程序包管理器控制台可能会将控制台应用用作目标。您可以指定以下内容来纠正这种情况:Update-Database-project name AutoLotDAL-startup project name AutoLotDAL

## 摘要

在过去的三章中，您浏览了使用 ADO.NET 进行数据操作的三种方法，特别是连接层、非连接层和实体框架。每种方法都有优点，许多应用可能会用到每种方法的各个方面。现在可以肯定的是，您仅仅触及了 ADO.NET 技术集内所有主题的表面。要更深入地研究本书中介绍的任何主题(以及检查大量相关项目)，我建议参考。NET Framework 4.6 SDK 文档。

本章通过研究实体框架的作用，总结了使用 ADO.NET 对数据库编程的正式研究。EF 允许您根据与您的业务领域紧密相关的概念模型进行编程。虽然您可以以自己选择的任何方式重塑您的实体，但是 EF 运行时确保被更改的数据被映射到正确的物理表数据。

在这个过程中，您了解了数据注释，这是描述领域模型和数据库模型之间映射的一种方式。您了解了 EF 如何处理交易；创建、保存和删除数据；以及实体状态如何适应。

然后，您使用数据库迁移来保持对模型的更改与数据库同步，检查并发错误，并添加日志记录和拦截。最后，你在试驾`AutoLotDAL.dll`的时候走过了很多不同的例子。